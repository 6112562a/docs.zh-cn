---
title: 标识每个微服务的域模型边界
description: 探索将大型应用程序划分为微服务以实现可靠体系结构的本质。
ms.date: 09/20/2018
ms.openlocfilehash: 9c433066dd8e93dbb09b15e58c9c85617775723d
ms.sourcegitcommit: 8a0fe8a2227af612f8b8941bdb8b19d6268748e7
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 10/03/2019
ms.locfileid: "71834419"
---
# <a name="identify-domain-model-boundaries-for-each-microservice"></a><span data-ttu-id="8ab00-103">标识每个微服务的域模型边界</span><span class="sxs-lookup"><span data-stu-id="8ab00-103">Identify domain-model boundaries for each microservice</span></span>

<span data-ttu-id="8ab00-104">在为每个微服务标识模型边界和大小时，虽然应尽可能倾向小型微服务，但目标并不是尽可能达到最细粒度分离。</span><span class="sxs-lookup"><span data-stu-id="8ab00-104">The goal when identifying model boundaries and size for each microservice isn't to get to the most granular separation possible, although you should tend toward small microservices if possible.</span></span> <span data-ttu-id="8ab00-105">相反，目标应在域知识指导下实现最有意义的分离。</span><span class="sxs-lookup"><span data-stu-id="8ab00-105">Instead, your goal should be to get to the most meaningful separation guided by your domain knowledge.</span></span> <span data-ttu-id="8ab00-106">重点不在于大小，而在于业务功能。</span><span class="sxs-lookup"><span data-stu-id="8ab00-106">The emphasis isn't on the size, but instead on business capabilities.</span></span> <span data-ttu-id="8ab00-107">此外，如果基于大量依赖关系的应用程序的某一特定区域需要清除内聚，这也表明需要单个微服务。</span><span class="sxs-lookup"><span data-stu-id="8ab00-107">In addition, if there's clear cohesion needed for a certain area of the application based on a high number of dependencies, that indicates the need for a single microservice, too.</span></span> <span data-ttu-id="8ab00-108">内聚是一种标识如何将微服务分离或组合的方法。</span><span class="sxs-lookup"><span data-stu-id="8ab00-108">Cohesion is a way to identify how to break apart or group together microservices.</span></span> <span data-ttu-id="8ab00-109">最终，当获得关于域的详细知识时，应以迭代方式调整微服务的大小。</span><span class="sxs-lookup"><span data-stu-id="8ab00-109">Ultimately, while you gain more knowledge about the domain, you should adapt the size of your microservice, iteratively.</span></span> <span data-ttu-id="8ab00-110">查找适当的大小不是一个单步过程。</span><span class="sxs-lookup"><span data-stu-id="8ab00-110">Finding the right size isn't a one-shot process.</span></span>

<span data-ttu-id="8ab00-111">[Sam Newman](https://samnewman.io/) 是一位公认的微服务促进者以及[《构建微服务》](https://samnewman.io/books/building_microservices/)一书的作者，他强调应该按照前面介绍的界定的上下文 (BC) 模式（域驱动设计的一部分）来设计微服务。</span><span class="sxs-lookup"><span data-stu-id="8ab00-111">[Sam Newman](https://samnewman.io/), a recognized promoter of microservices and author of the book [Building Microservices](https://samnewman.io/books/building_microservices/), highlights that you should design your microservices based on the Bounded Context (BC) pattern (part of domain-driven design), as introduced earlier.</span></span> <span data-ttu-id="8ab00-112">有时，BC 可以由几个物理服务组成，但反之则不然。</span><span class="sxs-lookup"><span data-stu-id="8ab00-112">Sometimes, a BC could be composed of several physical services, but not vice versa.</span></span>

<span data-ttu-id="8ab00-113">具有特定域实体的域模型应用于具体的 BC 或微服务中。</span><span class="sxs-lookup"><span data-stu-id="8ab00-113">A domain model with specific domain entities applies within a concrete BC or microservice.</span></span> <span data-ttu-id="8ab00-114">BC 划分了域模型的适用性，并使开发人员团队成员对哪些必须具有内聚和哪些可以独立开发有了清晰和共同的理解。</span><span class="sxs-lookup"><span data-stu-id="8ab00-114">A BC delimits the applicability of a domain model and gives developer team members a clear and shared understanding of what must be cohesive and what can be developed independently.</span></span> <span data-ttu-id="8ab00-115">这些都是微服务的相同目标。</span><span class="sxs-lookup"><span data-stu-id="8ab00-115">These are the same goals for microservices.</span></span>

<span data-ttu-id="8ab00-116">另一个通知设计选择的工具是[康威定律](https://en.wikipedia.org/wiki/Conway%27s_law)，它规定应用程序应反映生成它的组织的社交边界。</span><span class="sxs-lookup"><span data-stu-id="8ab00-116">Another tool that informs your design choice is [Conway's law](https://en.wikipedia.org/wiki/Conway%27s_law), which states that an application will reflect the social boundaries of the organization that produced it.</span></span> <span data-ttu-id="8ab00-117">但有时恰恰相反 — 公司的组织是由软件组成的。</span><span class="sxs-lookup"><span data-stu-id="8ab00-117">But sometimes the opposite is true -the company's organization is formed by the software.</span></span> <span data-ttu-id="8ab00-118">可能需要方向吸取康威定律，按照想要公司进行组织的方式生成边界，倾向于业务流程咨询。</span><span class="sxs-lookup"><span data-stu-id="8ab00-118">You might need to reverse Conway's law and build the boundaries the way you want the company to be organized, leaning toward business process consulting.</span></span>

<span data-ttu-id="8ab00-119">若要标识有界上下文，可以使用称为[上下文映射模式](https://www.infoq.com/articles/ddd-contextmapping)的 DDD 模式。</span><span class="sxs-lookup"><span data-stu-id="8ab00-119">To identify bounded contexts, you can use a DDD pattern called the [Context Mapping pattern](https://www.infoq.com/articles/ddd-contextmapping).</span></span> <span data-ttu-id="8ab00-120">通过上下文映射，标识应用程序中的各种上下文及其边界。</span><span class="sxs-lookup"><span data-stu-id="8ab00-120">With Context Mapping, you identify the various contexts in the application and their boundaries.</span></span> <span data-ttu-id="8ab00-121">例如，对于每个小型子系统来说，有一个不同的上下文和边界是很常见的。</span><span class="sxs-lookup"><span data-stu-id="8ab00-121">It's common to have a different context and boundary for each small subsystem, for instance.</span></span> <span data-ttu-id="8ab00-122">上下文映射是一种定义和明确域之间的这些边界的方法。</span><span class="sxs-lookup"><span data-stu-id="8ab00-122">The Context Map is a way to define and make explicit those boundaries between domains.</span></span> <span data-ttu-id="8ab00-123">BC 具有自治性，它包含单个域的详细信息（比如域实体）并定义了与其他 BC 的集成契约。</span><span class="sxs-lookup"><span data-stu-id="8ab00-123">A BC is autonomous and includes the details of a single domain -details like the domain entities- and defines integration contracts with other BCs.</span></span> <span data-ttu-id="8ab00-124">这类似于微服务的定义：具有自治性，实现特定的域功能，并且必须提供接口。</span><span class="sxs-lookup"><span data-stu-id="8ab00-124">This is similar to the definition of a microservice: it's autonomous, it implements certain domain capability, and it must provide interfaces.</span></span> <span data-ttu-id="8ab00-125">因此上下文映射和界定的上下文模式是标识微服务的域模型边界的好方法。</span><span class="sxs-lookup"><span data-stu-id="8ab00-125">This is why Context Mapping and the Bounded Context pattern are good approaches for identifying the domain model boundaries of your microservices.</span></span>

<span data-ttu-id="8ab00-126">在设计大型应用程序时，将看到其域模型可能存在碎片，例如，目录域中的域专家将在目录和清单域中命名实体，该行为不同于传送域专家的操作。</span><span class="sxs-lookup"><span data-stu-id="8ab00-126">When designing a large application, you'll see how its domain model can be fragmented - a domain expert from the catalog domain will name entities differently in the catalog and inventory domains than a shipping domain expert, for instance.</span></span> <span data-ttu-id="8ab00-127">或者，对于想要存储客户的每个细节的 CRM 专家，用户域实体的大小和属性数目可能与只需要部分客户数据的订购域专家要求不同。</span><span class="sxs-lookup"><span data-stu-id="8ab00-127">Or the user domain entity might be different in size and number of attributes when dealing with a CRM expert who wants to store every detail about the customer than for an ordering domain expert who just needs partial data about the customer.</span></span> <span data-ttu-id="8ab00-128">很难在与大型应用程序相关的所有域中消除所有域术语的歧义。</span><span class="sxs-lookup"><span data-stu-id="8ab00-128">It's very hard to disambiguate all domain terms across all the domains related to a large application.</span></span> <span data-ttu-id="8ab00-129">但最重要的是不应尝试统一术语。</span><span class="sxs-lookup"><span data-stu-id="8ab00-129">But the most important thing is that you shouldn't try to unify the terms.</span></span> <span data-ttu-id="8ab00-130">而是接受每个域所带来的差异和丰富性。</span><span class="sxs-lookup"><span data-stu-id="8ab00-130">Instead, accept the differences and richness provided by each domain.</span></span> <span data-ttu-id="8ab00-131">如果尝试为整个应用程序创建一个统一的数据库，那么尝试统一词汇会很繁琐，而且对任何多个域专家来说都是不正确的。</span><span class="sxs-lookup"><span data-stu-id="8ab00-131">If you try to have a unified database for the whole application, attempts at a unified vocabulary will be awkward and won't sound right to any of the multiple domain experts.</span></span> <span data-ttu-id="8ab00-132">因此，BC（作为微服务实现）将帮助阐明在哪里可以使用特定域术语，以及在哪里需要拆分系统，并使用不同的域创建其他 BC。</span><span class="sxs-lookup"><span data-stu-id="8ab00-132">Therefore, BCs (implemented as microservices) will help you to clarify where you can use certain domain terms and where you'll need to split the system and create additional BCs with different domains.</span></span>

<span data-ttu-id="8ab00-133">如果域模型之间的强关系很少，那么每个 BC 和域模型的边界和大小正确，并且在执行典型的应用程序操作时通常不需要合并来自多个域模型的信息。</span><span class="sxs-lookup"><span data-stu-id="8ab00-133">You'll know that you got the right boundaries and sizes of each BC and domain model if you have few strong relationships between domain models, and you do not usually need to merge information from multiple domain models when performing typical application operations.</span></span>

<span data-ttu-id="8ab00-134">对于每个微服务的域模型应该有多大这个问题，最佳答案是：它应该有一个尽可能独立的自治 BC，这样就可以工作而不必不断切换到其他上下文（其他微服务的模型）。</span><span class="sxs-lookup"><span data-stu-id="8ab00-134">Perhaps the best answer to the question of how large a domain model for each microservice should be is the following: it should have an autonomous BC, as isolated as possible, that enables you to work without having to constantly switch to other contexts (other microservice's models).</span></span> <span data-ttu-id="8ab00-135">在图 4-10 中可以看到多个微服务（多个 BC）如何生成自己的模型，以及如何定义其实体，具体取决于应用程序中每个标识域的特定要求。</span><span class="sxs-lookup"><span data-stu-id="8ab00-135">In Figure 4-10, you can see how multiple microservices (multiple BCs) each has their own model and how their entities can be defined, depending on the specific requirements for each of the identified domains in your application.</span></span>

![显示多个模型边界中的实体的示意图。](./media/identify-microservice-domain-model-boundaries/identify-entities-microservice-model-boundries.png)

<span data-ttu-id="8ab00-137">**图 4-10**。</span><span class="sxs-lookup"><span data-stu-id="8ab00-137">**Figure 4-10**.</span></span> <span data-ttu-id="8ab00-138">标识实体和微服务模型边界</span><span class="sxs-lookup"><span data-stu-id="8ab00-138">Identifying entities and microservice model boundaries</span></span>

<span data-ttu-id="8ab00-139">图 4-10 演示了与联机会议管理系统相关的示例方案。</span><span class="sxs-lookup"><span data-stu-id="8ab00-139">Figure 4-10 illustrates a sample scenario related to an online conference management system.</span></span> <span data-ttu-id="8ab00-140">相同实体会显示为“Users”、“Buyers”、“Payers”和“Customers”，具体取决于有界上下文。</span><span class="sxs-lookup"><span data-stu-id="8ab00-140">The same entity appears as "Users", "Buyers", "Payers", and "Customers" depending on the bounded context.</span></span> <span data-ttu-id="8ab00-141">已经根据域专家定义的域确定了几个可作为微服务实现的 BC。</span><span class="sxs-lookup"><span data-stu-id="8ab00-141">You've identified several BCs that could be implemented as microservices, based on domains that domain experts defined for you.</span></span> <span data-ttu-id="8ab00-142">如你所见，有些实体只存在于单个微服务模型中，比如付款微服务中的付款。</span><span class="sxs-lookup"><span data-stu-id="8ab00-142">As you can see, there are entities that are present just in a single microservice model, like Payments in the Payment microservice.</span></span> <span data-ttu-id="8ab00-143">这些将易于实现。</span><span class="sxs-lookup"><span data-stu-id="8ab00-143">Those will be easy to implement.</span></span>

<span data-ttu-id="8ab00-144">但是，也可能有一些实体具有不同的形状，但在来自多个微服务的多个域模型中共享相同标识。</span><span class="sxs-lookup"><span data-stu-id="8ab00-144">However, you might also have entities that have a different shape but share the same identity across the multiple domain models from the multiple microservices.</span></span> <span data-ttu-id="8ab00-145">例如，在会议管理微服务中标识用户实体。</span><span class="sxs-lookup"><span data-stu-id="8ab00-145">For example, the User entity is identified in the Conferences Management microservice.</span></span> <span data-ttu-id="8ab00-146">具有相同标识的相同用户在订购微服务中名为“购买者”或在付款微服务中名为“付款者”，甚至在客户服务微服务中名为“客户”。</span><span class="sxs-lookup"><span data-stu-id="8ab00-146">That same user, with the same identity, is the one named Buyers in the Ordering microservice, or the one named Payer in the Payment microservice, and even the one named Customer in the Customer Service microservice.</span></span> <span data-ttu-id="8ab00-147">这是因为，具体取决于每个域专家使用的[通用语言](https://martinfowler.com/bliki/UbiquitousLanguage.html)，用户可能有不同的视角，甚至具有不同的属性。</span><span class="sxs-lookup"><span data-stu-id="8ab00-147">This is because, depending on the [ubiquitous language](https://martinfowler.com/bliki/UbiquitousLanguage.html) that each domain expert is using, a user might have a different perspective even with different attributes.</span></span> <span data-ttu-id="8ab00-148">名为“会议管理”的微服务模型中的用户实体可能具有其大部分个人数据属性。</span><span class="sxs-lookup"><span data-stu-id="8ab00-148">The user entity in the microservice model named Conferences Management might have most of its personal data attributes.</span></span> <span data-ttu-id="8ab00-149">但是，在微服务支付中以“付款者”形式或者在微服务客户服务中以“客户”形式的相同用户可能不需要相同的属性列表。</span><span class="sxs-lookup"><span data-stu-id="8ab00-149">However, that same user in the shape of Payer in the microservice Payment or in the shape of Customer in the microservice Customer Service might not need the same list of attributes.</span></span>

<span data-ttu-id="8ab00-150">图 4-11 说明了类似的方法。</span><span class="sxs-lookup"><span data-stu-id="8ab00-150">A similar approach is illustrated in Figure 4-11.</span></span>

![显示如何将数据模型分解为多个域模型的示意图。](./media/identify-microservice-domain-model-boundaries/decompose-traditional-data-models.png)

<span data-ttu-id="8ab00-152">**图 4-11**。</span><span class="sxs-lookup"><span data-stu-id="8ab00-152">**Figure 4-11**.</span></span> <span data-ttu-id="8ab00-153">将传统数据模型分解为多个域模型</span><span class="sxs-lookup"><span data-stu-id="8ab00-153">Decomposing traditional data models into multiple domain models</span></span>

<span data-ttu-id="8ab00-154">在有界上下文之间分解传统数据模型时，可以使不同实体共享相同标识（购买者也是用户），在每个有界上下文中具有不同特性。</span><span class="sxs-lookup"><span data-stu-id="8ab00-154">When decomposing a traditional data model between bounded contexts, you can have different entities that share the same identity (a buyer is also a user) with different attributes in each bounded context.</span></span> <span data-ttu-id="8ab00-155">可以看到用户是如何作为用户实体出现在会议管理微服务模型中的，并且在定价微服务中也以购买者实体的形式出现，当用户实际上是购买者时，具有备用属性或用户详细信息。</span><span class="sxs-lookup"><span data-stu-id="8ab00-155">You can see how the user is present in the Conferences Management microservice model as the User entity and is also present in the form of the Buyer entity in the Pricing microservice, with alternate attributes or details about the user when it's actually a buyer.</span></span> <span data-ttu-id="8ab00-156">每个微服务或 BC 可能不需要与用户实体相关的所有数据，而只是其中的一部分，具体取决于要解决的问题或上下文。</span><span class="sxs-lookup"><span data-stu-id="8ab00-156">Each microservice or BC might not need all the data related to a User entity, just part of it, depending on the problem to solve or the context.</span></span> <span data-ttu-id="8ab00-157">例如，在定价微服务模型中，不需要用户的地址或名称，只需 ID（作为标识）和状态，这将影响在为每个购买者的席位定价时的折扣。</span><span class="sxs-lookup"><span data-stu-id="8ab00-157">For instance, in the Pricing microservice model, you do not need the address or the name of the user, just the ID (as identity) and Status, which will have an impact on discounts when pricing the seats per buyer.</span></span>

<span data-ttu-id="8ab00-158">在每个域模型中，席位实体的名称都相同，但属性不同。</span><span class="sxs-lookup"><span data-stu-id="8ab00-158">The Seat entity has the same name but different attributes in each domain model.</span></span> <span data-ttu-id="8ab00-159">然而，席位共享具有相同 ID 的标识，就像用户和购买者一样。</span><span class="sxs-lookup"><span data-stu-id="8ab00-159">However, Seat shares identity based on the same ID, as happens with User and Buyer.</span></span>

<span data-ttu-id="8ab00-160">基本上，在多个服务（域）中存在用户的共享概念，都共享该用户的标识。</span><span class="sxs-lookup"><span data-stu-id="8ab00-160">Basically, there's a shared concept of a user that exists in multiple services (domains), which all share the identity of that user.</span></span> <span data-ttu-id="8ab00-161">但在每个域模型中，可能存在有关该用户实体的其他或不同的详细信息。</span><span class="sxs-lookup"><span data-stu-id="8ab00-161">But in each domain model there might be additional or different details about the user entity.</span></span> <span data-ttu-id="8ab00-162">因此，需要有一种方法将用户实体从一个域（微服务）映射到另一个域。</span><span class="sxs-lookup"><span data-stu-id="8ab00-162">Therefore, there needs to be a way to map a user entity from one domain (microservice) to another.</span></span>

<span data-ttu-id="8ab00-163">不与相同的属性数目跨域共享相同的用户实体有几个好处。</span><span class="sxs-lookup"><span data-stu-id="8ab00-163">There are several benefits to not sharing the same user entity with the same number of attributes across domains.</span></span> <span data-ttu-id="8ab00-164">一个好处是减少重复项，以便微服务模型没有不需要的任何数据。</span><span class="sxs-lookup"><span data-stu-id="8ab00-164">One benefit is to reduce duplication, so that microservice models do not have any data that they do not need.</span></span> <span data-ttu-id="8ab00-165">另一个好处是拥有一个主微服务，它拥有每个实体的特定类型的数据，以便对该类型数据的更新和查询只能由该微服务驱动。</span><span class="sxs-lookup"><span data-stu-id="8ab00-165">Another benefit is having a master microservice that owns a certain type of data per entity so that updates and queries for that type of data are driven only by that microservice.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="8ab00-166">[上一页](distributed-data-management.md)
>[下一页](direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md)</span><span class="sxs-lookup"><span data-stu-id="8ab00-166">[Previous](distributed-data-management.md)
[Next](direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md)</span></span>
