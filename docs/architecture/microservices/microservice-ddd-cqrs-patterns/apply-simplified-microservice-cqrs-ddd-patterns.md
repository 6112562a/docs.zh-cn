---
title: 在微服务中应用简化的 CQRS 和 DDD 模式
description: 适用于容器化 .NET 应用程序的 .NET 微服务体系结构 | 了解 CQRS 与 DDD 模式之间的整体关系。
ms.date: 10/08/2018
ms.openlocfilehash: f42b553fd30fdffdc6e325b11740fe9162aab7c8
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/14/2020
ms.locfileid: "71834307"
---
# <a name="apply-simplified-cqrs-and-ddd-patterns-in-a-microservice"></a><span data-ttu-id="87946-103">在微服务中应用简化后的 CQRS 和 DDD 模式</span><span class="sxs-lookup"><span data-stu-id="87946-103">Apply simplified CQRS and DDD patterns in a microservice</span></span>

<span data-ttu-id="87946-104">CQRS 是一种分离数据读取与写入模型的体系结构模式。</span><span class="sxs-lookup"><span data-stu-id="87946-104">CQRS is an architectural pattern that separates the models for reading and writing data.</span></span> <span data-ttu-id="87946-105">相关术语[命令查询分离 (CQS)](https://martinfowler.com/bliki/CommandQuerySeparation.html)最初由 Bertrand Meyer 在其《面向对象软件构造》一书中定义  。</span><span class="sxs-lookup"><span data-stu-id="87946-105">The related term [Command Query Separation (CQS)](https://martinfowler.com/bliki/CommandQuerySeparation.html) was originally defined by Bertrand Meyer in his book *Object Oriented Software Construction*.</span></span> <span data-ttu-id="87946-106">基本思想是可以将系统操作划分为两个界限明显的类别：</span><span class="sxs-lookup"><span data-stu-id="87946-106">The basic idea is that you can divide a system’s operations into two sharply separated categories:</span></span>

- <span data-ttu-id="87946-107">查询。</span><span class="sxs-lookup"><span data-stu-id="87946-107">Queries.</span></span> <span data-ttu-id="87946-108">这些查询返回结果，不改变系统的状态，且没有副作用。</span><span class="sxs-lookup"><span data-stu-id="87946-108">These return a result and do not change the state of the system, and they are free of side effects.</span></span>

- <span data-ttu-id="87946-109">命令。</span><span class="sxs-lookup"><span data-stu-id="87946-109">Commands.</span></span> <span data-ttu-id="87946-110">这些命令会更改系统状态。</span><span class="sxs-lookup"><span data-stu-id="87946-110">These change the state of a system.</span></span>

<span data-ttu-id="87946-111">CQS 是一个简单的概念 - 说明同一对象中的方法是查询还是命令。</span><span class="sxs-lookup"><span data-stu-id="87946-111">CQS is a simple concept—it is about methods within the same object being either queries or commands.</span></span> <span data-ttu-id="87946-112">每种方法要么返回状态，要么更改状态，不会二者兼具。</span><span class="sxs-lookup"><span data-stu-id="87946-112">Each method either returns state or mutates state, but not both.</span></span> <span data-ttu-id="87946-113">即使是单个存储库模式对象也符合 CQS。</span><span class="sxs-lookup"><span data-stu-id="87946-113">Even a single repository pattern object can comply with CQS.</span></span> <span data-ttu-id="87946-114">CQS 被视为 CQRS 的基本原则。</span><span class="sxs-lookup"><span data-stu-id="87946-114">CQS can be considered a foundational principle for CQRS.</span></span>

<span data-ttu-id="87946-115">[命令和查询职责分离 (CQRS)](https://martinfowler.com/bliki/CQRS.html) 由 Greg Young 提出并由 Udi Dahan 等人大力推广。</span><span class="sxs-lookup"><span data-stu-id="87946-115">[Command and Query Responsibility Segregation (CQRS)](https://martinfowler.com/bliki/CQRS.html) was introduced by Greg Young and strongly promoted by Udi Dahan and others.</span></span> <span data-ttu-id="87946-116">它基于 CQS 原则，只是更为详细。</span><span class="sxs-lookup"><span data-stu-id="87946-116">It is based on the CQS principle, although it is more detailed.</span></span> <span data-ttu-id="87946-117">它可以视为基于命令和事件的模式，另外在异步消息方面可选。</span><span class="sxs-lookup"><span data-stu-id="87946-117">It can be considered a pattern based on commands and events plus optionally on asynchronous messages.</span></span> <span data-ttu-id="87946-118">在很多情况下，CQRS 涉及到更高级的方案，比如另外构建一个用于读取（查询）而非写入（更新）的物理数据库。</span><span class="sxs-lookup"><span data-stu-id="87946-118">In many cases, CQRS is related to more advanced scenarios, like having a different physical database for reads (queries) than for writes (updates).</span></span> <span data-ttu-id="87946-119">此外，更先进的 CQRS 系统会为更新数据库实现[事件源 (ES)](https://martinfowler.com/eaaDev/EventSourcing.html)，因此只能将事件存储在域模型中，而不能存储当前状态数据。</span><span class="sxs-lookup"><span data-stu-id="87946-119">Moreover, a more evolved CQRS system might implement [Event-Sourcing (ES)](https://martinfowler.com/eaaDev/EventSourcing.html) for your updates database, so you would only store events in the domain model instead of storing the current-state data.</span></span> <span data-ttu-id="87946-120">但是，这不是本指南中使用的方法；我们正使用最简单的 CQRS 方法，只是将查询从命令中分离出来。</span><span class="sxs-lookup"><span data-stu-id="87946-120">However, this is not the approach used in this guide; we are using the simplest CQRS approach, which consists of just separating the queries from the commands.</span></span>

<span data-ttu-id="87946-121">CQRS 的分离操作通过将查询操作分到一层中而将命令分到另一层中来实现。</span><span class="sxs-lookup"><span data-stu-id="87946-121">The separation aspect of CQRS is achieved by grouping query operations in one layer and commands in another layer.</span></span> <span data-ttu-id="87946-122">每一层都有自己的数据模型（注意，我们说的是模型，不一定是其他数据库），并且使用自己的模式和技术组合来构建。</span><span class="sxs-lookup"><span data-stu-id="87946-122">Each layer has its own data model (note that we say model, not necessarily a different database) and is built using its own combination of patterns and technologies.</span></span> <span data-ttu-id="87946-123">更重要的是，这两层可以共处于同一层级或同一个微服务中，如本指南中使用的示例（订购微服务）。</span><span class="sxs-lookup"><span data-stu-id="87946-123">More importantly, the two layers can be within the same tier or microservice, as in the example (ordering microservice) used for this guide.</span></span> <span data-ttu-id="87946-124">也可以在不同的微服务或进程上实现，以便彼此毫不影响地分别进行优化和横向扩展。</span><span class="sxs-lookup"><span data-stu-id="87946-124">Or they could be implemented on different microservices or processes so they can be optimized and scaled out separately without affecting one another.</span></span>

<span data-ttu-id="87946-125">CQRS 表示有两个对象用于读/写操作，而在其他上下文中有一个对象。</span><span class="sxs-lookup"><span data-stu-id="87946-125">CQRS means having two objects for a read/write operation where in other contexts there is one.</span></span> <span data-ttu-id="87946-126">可以添加一个非规范化读取数据库，如要了解这些数据库，请参阅更高级的 CQRS 文献。</span><span class="sxs-lookup"><span data-stu-id="87946-126">There are reasons to have a denormalized reads database, which you can learn about in more advanced CQRS literature.</span></span> <span data-ttu-id="87946-127">但是我们在这里没有使用这种方法，因为在此处，我们的目标是更灵活地查询，而不是使用 DDD 模式的约束（如聚合）限制查询。</span><span class="sxs-lookup"><span data-stu-id="87946-127">But we are not using that approach here, where the goal is to have more flexibility in the queries instead of limiting the queries with constraints from DDD patterns like aggregates.</span></span>

<span data-ttu-id="87946-128">这种服务的一个例子就是 eShopOnContainers 引用应用程序的订购微服务。</span><span class="sxs-lookup"><span data-stu-id="87946-128">An example of this kind of service is the ordering microservice from the eShopOnContainers reference application.</span></span> <span data-ttu-id="87946-129">该服务基于简化的 CQRS 方法实现微服务。</span><span class="sxs-lookup"><span data-stu-id="87946-129">This service implements a microservice based on a simplified CQRS approach.</span></span> <span data-ttu-id="87946-130">使用单个数据源或数据库、两个逻辑模型和事务域的 DDD 模式，如图 7-2 所示。</span><span class="sxs-lookup"><span data-stu-id="87946-130">It uses a single data source or database, but two logical models plus DDD patterns for the transactional domain, as shown in Figure 7-2.</span></span>

![显示高级别的简化 CQRS 和 DDD 微服务的示意图。](./media/apply-simplified-microservice-cqrs-ddd-patterns/simplified-cqrs-ddd-microservice.png)

<span data-ttu-id="87946-132">**图 7-2**。</span><span class="sxs-lookup"><span data-stu-id="87946-132">**Figure 7-2**.</span></span> <span data-ttu-id="87946-133">基于简化 CQRS 和 DDD 的微服务</span><span class="sxs-lookup"><span data-stu-id="87946-133">Simplified CQRS- and DDD-based microservice</span></span>

<span data-ttu-id="87946-134">逻辑“订购”微服务包括其订购数据库，该数据库可以（但无需）为相同 Docker 主机。</span><span class="sxs-lookup"><span data-stu-id="87946-134">The Logical "Ordering" Microservice includes its Ordering database, which can be, but doesn't have to be, the same Docker host.</span></span> <span data-ttu-id="87946-135">若该数据库位于同一 Docker 主机，则更利于开发，但不利于生产。</span><span class="sxs-lookup"><span data-stu-id="87946-135">Having the database in the same Docker host is good for development, but not for production.</span></span>

<span data-ttu-id="87946-136">应用程序层可以是 Web API 本身。</span><span class="sxs-lookup"><span data-stu-id="87946-136">The application layer can be the Web API itself.</span></span> <span data-ttu-id="87946-137">此处的重要设计是微服务已经从 CQRS 模式之后的命令、域模型和事务中将查询和 ViewModel（特别为客户端应用程序创建的数据模型）拆分开了。</span><span class="sxs-lookup"><span data-stu-id="87946-137">The important design aspect here is that the microservice has split the queries and ViewModels (data models especially created for the client applications) from the commands, domain model, and transactions following the CQRS pattern.</span></span> <span data-ttu-id="87946-138">这种方法使查询独立于 DDD 模式的限制和约束，这些模式只对事务和更新有意义，如后面的章节所述。</span><span class="sxs-lookup"><span data-stu-id="87946-138">This approach keeps the queries independent from restrictions and constraints coming from DDD patterns that only make sense for transactions and updates, as explained in later sections.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="87946-139">其他资源</span><span class="sxs-lookup"><span data-stu-id="87946-139">Additional resources</span></span>

- <span data-ttu-id="87946-140">**Greg Young.在事件源系统中进行版本控制**（免费阅读联机电子书）</span><span class="sxs-lookup"><span data-stu-id="87946-140">**Greg Young. Versioning in an Event Sourced System** (Free to read online e-book) </span></span>\
   <https://leanpub.com/esversioning/read>

>[!div class="step-by-step"]
><span data-ttu-id="87946-141">[上一页](index.md)
>[下一页](eshoponcontainers-cqrs-ddd-microservice.md)</span><span class="sxs-lookup"><span data-stu-id="87946-141">[Previous](index.md)
[Next](eshoponcontainers-cqrs-ddd-microservice.md)</span></span>
