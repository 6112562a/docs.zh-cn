---
title: 附录-适用于 WCF 开发人员的 gRPC
description: 在新式微服务体系结构中讨论分布式事务及其实现。
ms.date: 09/02/2019
ms.openlocfilehash: 061aef016fd0e4303e1bbcbf0e73cec2b0c54f74
ms.sourcegitcommit: f348c84443380a1959294cdf12babcb804cfa987
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/12/2019
ms.locfileid: "73968219"
---
# <a name="appendix-a---transactions"></a><span data-ttu-id="184aa-103">附录 A-事务</span><span class="sxs-lookup"><span data-stu-id="184aa-103">Appendix A - Transactions</span></span>

<span data-ttu-id="184aa-104">Windows Communication Foundation （WCF）支持的分布式事务，允许跨多个服务执行原子操作。</span><span class="sxs-lookup"><span data-stu-id="184aa-104">Windows Communication Foundation (WCF) supported distributed transactions, allowing atomic operations to be performed across multiple services.</span></span> <span data-ttu-id="184aa-105">此功能基于[Microsoft 分布式事务处理协调器](https://docs.microsoft.com/previous-versions/windows/desktop/ms684146(v=vs.85))。</span><span class="sxs-lookup"><span data-stu-id="184aa-105">This functionality was based on the [Microsoft Distributed Transaction Coordinator](https://docs.microsoft.com/previous-versions/windows/desktop/ms684146(v=vs.85)).</span></span>

<span data-ttu-id="184aa-106">在新式微服务的环境中，这种类型的自动分布式事务处理是不可能的。</span><span class="sxs-lookup"><span data-stu-id="184aa-106">In the modern microservices landscape, this type of automated distributed transaction processing isn't possible.</span></span> <span data-ttu-id="184aa-107">在播放时，有太多不同的技术，其中包括关系数据库、NoSQL 数据存储区和消息系统，而不是提到可在单个环境中使用的操作系统、编程语言和框架的组合。</span><span class="sxs-lookup"><span data-stu-id="184aa-107">There are too many different technologies at play, including relational databases, NoSQL data stores, and messaging systems, not to mention the mix of operating systems, programming languages and frameworks that may be used in a single environment.</span></span>

<span data-ttu-id="184aa-108">WCF 分布式事务是称为[两阶段提交（2pc）](https://en.wikipedia.org/wiki/Two-phase_commit_protocol)的实现。</span><span class="sxs-lookup"><span data-stu-id="184aa-108">The WCF distributed transaction is an implementation of what is known as a [two-phase commit (2PC)](https://en.wikipedia.org/wiki/Two-phase_commit_protocol).</span></span> <span data-ttu-id="184aa-109">可以通过协调跨服务的消息、在每个服务中创建打开的事务，并根据成功或失败发送 "提交" 或 "回滚" 消息，手动实现2PC 事务。</span><span class="sxs-lookup"><span data-stu-id="184aa-109">It's possible to implement 2PC transactions manually by coordinating messages across services, creating open transactions within each service and sending "commit" or "rollback" messages depending upon success or failure.</span></span> <span data-ttu-id="184aa-110">但是，随着系统的发展，管理2PC 所涉及的复杂性可能会呈指数级增长，而开放事务会持有可能对性能产生负面影响的数据库锁，更糟的是导致跨服务死锁。</span><span class="sxs-lookup"><span data-stu-id="184aa-110">However, the complexity that is involved in managing 2PC can increase exponentially as systems evolve, and open transactions hold database locks that can negatively impact performance or, worse, cause cross-service deadlocks.</span></span>

<span data-ttu-id="184aa-111">如果可能，最好避免分布式事务。</span><span class="sxs-lookup"><span data-stu-id="184aa-111">If possible, it's best to avoid distributed transactions altogether.</span></span> <span data-ttu-id="184aa-112">如果数据的两个项都需要进行原子更新，请考虑使用同一服务对它们进行处理，并使用单个请求或消息将这些原子更改应用到该服务。</span><span class="sxs-lookup"><span data-stu-id="184aa-112">If two items of data are so linked as to require atomic updates, consider handling them both with the same service, and applying those atomic changes using a single request or message to that service.</span></span>

<span data-ttu-id="184aa-113">如果无法做到这一点，一种替代方法是使用[Saga 模式](https://microservices.io/patterns/data/saga.html)。</span><span class="sxs-lookup"><span data-stu-id="184aa-113">If that isn't possible, then one alternative is to use the [Saga pattern](https://microservices.io/patterns/data/saga.html).</span></span> <span data-ttu-id="184aa-114">在 saga 中，更新按顺序进行处理;每个更新成功后，将触发下一个更新。</span><span class="sxs-lookup"><span data-stu-id="184aa-114">In a saga, updates are processing sequentially; as each update succeeds the next one is triggered.</span></span> <span data-ttu-id="184aa-115">这些触发器可以从服务传播到服务，或由 saga 协调器或 "orchestrator" 管理。</span><span class="sxs-lookup"><span data-stu-id="184aa-115">These triggers can be propagated from service to service, or managed by a saga coordinator or "orchestrator".</span></span> <span data-ttu-id="184aa-116">如果在此过程中的任何时间点更新失败，则已完成其更新的服务会应用特定的逻辑来反转它们。</span><span class="sxs-lookup"><span data-stu-id="184aa-116">If an update fails at any point during the process, the services that have already completed their updates apply specific logic to reverse them.</span></span>

<span data-ttu-id="184aa-117">另一种方法是使用域驱动设计（DDD）和命令/查询责任分离（CQRS），如[.Net 微服务电子书](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/)中所述。</span><span class="sxs-lookup"><span data-stu-id="184aa-117">Another option is to use Domain Driven Design (DDD) and Command/Query Responsibility Segregation (CQRS), as described in the [.NET Microservices e-book](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/).</span></span> <span data-ttu-id="184aa-118">特别是，使用域事件或[事件来源](https://martinfowler.com/eaaDev/EventSourcing.html)有助于确保在&mdash;不会立即&mdash;应用时更新更新。</span><span class="sxs-lookup"><span data-stu-id="184aa-118">In particular, using domain events or [event sourcing](https://martinfowler.com/eaaDev/EventSourcing.html) can help to ensure that updates are consistently&mdash;if not immediately&mdash;applied.</span></span>

>[!div class="step-by-step"]
>[<span data-ttu-id="184aa-119">上一部分</span><span class="sxs-lookup"><span data-stu-id="184aa-119">Previous</span></span>](application-performance-management.md)
