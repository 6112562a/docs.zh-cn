---
title: 附录-适用于 WCF 开发人员的 gRPC
description: 在新式微服务体系结构中讨论分布式事务及其实现。
ms.date: 09/02/2019
ms.openlocfilehash: 9931681727f921e007c2f80852ad0e69cd7288de
ms.sourcegitcommit: 5fb5b6520b06d7f5e6131ec2ad854da302a28f2e
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 12/03/2019
ms.locfileid: "74711473"
---
# <a name="appendix-a---transactions"></a><span data-ttu-id="2f8cd-103">附录 A-事务</span><span class="sxs-lookup"><span data-stu-id="2f8cd-103">Appendix A - Transactions</span></span>

<span data-ttu-id="2f8cd-104">Windows Communication Foundation （WCF）支持分布式事务，使你能够跨多个服务执行原子操作。</span><span class="sxs-lookup"><span data-stu-id="2f8cd-104">Windows Communication Foundation (WCF) supports distributed transactions, allowing you to perform atomic operations across multiple services.</span></span> <span data-ttu-id="2f8cd-105">此功能基于[Microsoft 分布式事务处理协调器](https://docs.microsoft.com/previous-versions/windows/desktop/ms684146(v=vs.85))。</span><span class="sxs-lookup"><span data-stu-id="2f8cd-105">This functionality is based on the [Microsoft Distributed Transaction Coordinator](https://docs.microsoft.com/previous-versions/windows/desktop/ms684146(v=vs.85)).</span></span>

<span data-ttu-id="2f8cd-106">在较新的微服务环境中，这种类型的自动分布式事务处理是不可能的。</span><span class="sxs-lookup"><span data-stu-id="2f8cd-106">In the newer microservices landscape, this type of automated distributed transaction processing isn't possible.</span></span> <span data-ttu-id="2f8cd-107">涉及到许多不同的技术，其中包括关系数据库、NoSQL 数据存储和消息传送系统。</span><span class="sxs-lookup"><span data-stu-id="2f8cd-107">There are too many different technologies involved, including relational databases, NoSQL data stores, and messaging systems.</span></span> <span data-ttu-id="2f8cd-108">在单一环境中，可能还会混合使用多种操作系统、编程语言和框架。</span><span class="sxs-lookup"><span data-stu-id="2f8cd-108">There might also be a mix of operating systems, programming languages, and frameworks in use in a single environment.</span></span>

<span data-ttu-id="2f8cd-109">WCF 分布式事务是称为[两阶段提交（2pc）](https://en.wikipedia.org/wiki/Two-phase_commit_protocol)的实现。</span><span class="sxs-lookup"><span data-stu-id="2f8cd-109">WCF distributed transaction is an implementation of what is known as a [two-phase commit (2PC)](https://en.wikipedia.org/wiki/Two-phase_commit_protocol).</span></span> <span data-ttu-id="2f8cd-110">你可以通过协调跨服务的消息、在每个服务中创建打开的事务以及发送提交或回滚消息（具体取决于成功或失败）来手动实现2PC 事务。</span><span class="sxs-lookup"><span data-stu-id="2f8cd-110">You can implement 2PC transactions manually by coordinating messages across services, creating open transactions within each service, and sending commit or rollback messages, depending upon success or failure.</span></span> <span data-ttu-id="2f8cd-111">但是，随着系统的发展，管理2PC 所涉及的复杂性可能会呈指数级增长。</span><span class="sxs-lookup"><span data-stu-id="2f8cd-111">However, the complexity involved in managing 2PC can increase exponentially as systems evolve.</span></span> <span data-ttu-id="2f8cd-112">打开事务保存可能对性能产生负面影响的数据库锁，更糟的是导致跨服务死锁。</span><span class="sxs-lookup"><span data-stu-id="2f8cd-112">Open transactions hold database locks that can negatively affect performance, or, worse, cause cross-service deadlocks.</span></span>

<span data-ttu-id="2f8cd-113">如果可能，最好避免分布式事务。</span><span class="sxs-lookup"><span data-stu-id="2f8cd-113">If possible, it's best to avoid distributed transactions altogether.</span></span> <span data-ttu-id="2f8cd-114">如果数据的两个项都需要进行原子更新，请考虑将它们处理为同一个服务。</span><span class="sxs-lookup"><span data-stu-id="2f8cd-114">If two items of data are so linked as to require atomic updates, consider handling them both with the same service.</span></span> <span data-ttu-id="2f8cd-115">使用单个请求或消息向该服务应用这些原子更改。</span><span class="sxs-lookup"><span data-stu-id="2f8cd-115">Apply those atomic changes by using a single request or message to that service.</span></span>

<span data-ttu-id="2f8cd-116">如果无法做到这一点，一种替代方法是使用[Saga 模式](https://microservices.io/patterns/data/saga.html)。</span><span class="sxs-lookup"><span data-stu-id="2f8cd-116">If that isn't possible, then one alternative is to use the [Saga pattern](https://microservices.io/patterns/data/saga.html).</span></span> <span data-ttu-id="2f8cd-117">在 saga 中，更新按顺序处理;每个更新成功后，将触发下一个更新。</span><span class="sxs-lookup"><span data-stu-id="2f8cd-117">In a saga, updates are processed sequentially; as each update succeeds, the next one is triggered.</span></span> <span data-ttu-id="2f8cd-118">这些触发器可以从服务传播到服务，或由 saga 协调器或 orchestrator 进行管理。</span><span class="sxs-lookup"><span data-stu-id="2f8cd-118">These triggers can be propagated from service to service, or managed by a saga coordinator or orchestrator.</span></span> <span data-ttu-id="2f8cd-119">如果在此过程中的任何时间点更新失败，则已完成其更新的服务会应用特定的逻辑来反转它们。</span><span class="sxs-lookup"><span data-stu-id="2f8cd-119">If an update fails at any point during the process, the services that have already completed their updates apply specific logic to reverse them.</span></span>

<span data-ttu-id="2f8cd-120">另一种方法是使用域驱动设计（DDD）和命令/查询责任分离（CQRS），如[.Net 微服务电子书](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/)中所述。</span><span class="sxs-lookup"><span data-stu-id="2f8cd-120">Another option is to use Domain Driven Design (DDD) and Command/Query Responsibility Segregation (CQRS), as described in the [.NET Microservices e-book](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/).</span></span> <span data-ttu-id="2f8cd-121">特别是，使用域事件或[事件来源](https://martinfowler.com/eaaDev/EventSourcing.html)有助于确保更新的一致性（如果不能立即应用）。</span><span class="sxs-lookup"><span data-stu-id="2f8cd-121">In particular, using domain events or [event sourcing](https://martinfowler.com/eaaDev/EventSourcing.html) can help to ensure that updates are consistently, if not immediately, applied.</span></span>

>[!div class="step-by-step"]
>[<span data-ttu-id="2f8cd-122">上一部分</span><span class="sxs-lookup"><span data-stu-id="2f8cd-122">Previous</span></span>](application-performance-management.md)
