---
title: 应用程序性能管理-适用于 WCF 开发人员的 gRPC
description: ASP.NET Core gRPC 应用程序的日志记录、指标和跟踪。
author: markrendle
ms.date: 09/02/2019
ms.openlocfilehash: 6ba67fd069e7efc232f912e50c0e283facb79e9c
ms.sourcegitcommit: 337bdc5a463875daf2cc6883e5a2da97d56f5000
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 10/24/2019
ms.locfileid: "73841683"
---
# <a name="application-performance-management"></a><span data-ttu-id="32b4f-103">应用程序性能管理</span><span class="sxs-lookup"><span data-stu-id="32b4f-103">Application Performance Management</span></span>

<span data-ttu-id="32b4f-104">在 Kubernetes 等新式生产环境中，能够监视应用程序以确保它们以最佳状态运行非常重要。</span><span class="sxs-lookup"><span data-stu-id="32b4f-104">In modern production environments like Kubernetes, it's very important to be able to monitor applications to ensure they're running optimally.</span></span> <span data-ttu-id="32b4f-105">类似于日志记录和指标的问题从未太重要。</span><span class="sxs-lookup"><span data-stu-id="32b4f-105">Concerns like logging and metrics have never been more important.</span></span> <span data-ttu-id="32b4f-106">ASP.NET Core （包括 gRPC）对生成和管理日志消息和指标数据以及*跟踪*数据具有一流支持。</span><span class="sxs-lookup"><span data-stu-id="32b4f-106">ASP.NET Core, including gRPC, has first-class support for producing and managing log messages and metrics data, as well as *tracing* data.</span></span> <span data-ttu-id="32b4f-107">本部分将更详细地探讨这些方面。</span><span class="sxs-lookup"><span data-stu-id="32b4f-107">This section will explore these areas in more details.</span></span>

## <a name="logging-vs-metrics"></a><span data-ttu-id="32b4f-108">日志记录 vs 指标</span><span class="sxs-lookup"><span data-stu-id="32b4f-108">Logging vs Metrics</span></span>

<span data-ttu-id="32b4f-109">在查看实现细节之前，必须了解日志记录和指标之间的差异。</span><span class="sxs-lookup"><span data-stu-id="32b4f-109">Before looking at the implementation details, it's necessary to understand the difference between logging and metrics.</span></span>

<span data-ttu-id="32b4f-110">日志记录与文本消息相关，这些文本消息记录了有关系统中所发生内容的详细信息。</span><span class="sxs-lookup"><span data-stu-id="32b4f-110">Logging is concerned with text messages that record detailed information about things that have happened in the system.</span></span> <span data-ttu-id="32b4f-111">日志消息可能包含异常数据，如堆栈跟踪或提供消息上下文的结构化数据。</span><span class="sxs-lookup"><span data-stu-id="32b4f-111">Log messages may include exception data like stack traces, or structured data that provides context about the message.</span></span> <span data-ttu-id="32b4f-112">日志记录输出通常写入到可搜索的文本存储。</span><span class="sxs-lookup"><span data-stu-id="32b4f-112">Logging output is commonly written to a searchable text store.</span></span>

<span data-ttu-id="32b4f-113">度量值是指设计为使用面板中的图表和图形进行聚合并显示的数字数据，它提供了应用程序整体运行状况和性能的视图。</span><span class="sxs-lookup"><span data-stu-id="32b4f-113">Metrics refers to numeric data that is designed to be aggregated and presented using charts and graphs in a dashboard that provides a view of the overall health and performance of an application.</span></span> <span data-ttu-id="32b4f-114">指标数据还可用于在超过阈值时触发自动警报。</span><span class="sxs-lookup"><span data-stu-id="32b4f-114">Metrics data can also be used to trigger automated alerts when a threshold is exceeded.</span></span> <span data-ttu-id="32b4f-115">以下列表显示了指标数据的一些示例：</span><span class="sxs-lookup"><span data-stu-id="32b4f-115">The following list shows some examples of metrics data:</span></span>

- <span data-ttu-id="32b4f-116">处理请求所用的时间。</span><span class="sxs-lookup"><span data-stu-id="32b4f-116">Time taken to process requests.</span></span>
- <span data-ttu-id="32b4f-117">服务实例每秒处理的请求数。</span><span class="sxs-lookup"><span data-stu-id="32b4f-117">The number of requests per second being handled by an instance of a service.</span></span>
- <span data-ttu-id="32b4f-118">实例上失败的请求数。</span><span class="sxs-lookup"><span data-stu-id="32b4f-118">The number of failed requests on an instance.</span></span>

## <a name="logging-in-aspnet-core-grpc"></a><span data-ttu-id="32b4f-119">ASP.NET Core gRPC 中的日志记录</span><span class="sxs-lookup"><span data-stu-id="32b4f-119">Logging in ASP.NET Core gRPC</span></span>

<span data-ttu-id="32b4f-120">ASP.NET Core 提供对日志记录的内置支持，采用的形式为：[记录](https://www.nuget.org/packages/Microsoft.Extensions.Logging)NuGet 包。</span><span class="sxs-lookup"><span data-stu-id="32b4f-120">ASP.NET Core provides built-in support for logging, in the form of the [Microsoft.Extensions.Logging](https://www.nuget.org/packages/Microsoft.Extensions.Logging) NuGet package.</span></span> <span data-ttu-id="32b4f-121">此库的核心部分随 Web SDK 一起提供，因此不需要手动安装它。</span><span class="sxs-lookup"><span data-stu-id="32b4f-121">The core parts of this library are included with the Web SDK, so there's no need to install it manually.</span></span> <span data-ttu-id="32b4f-122">默认情况下，日志消息会写入标准输出（"控制台"）和任何附加的调试器。</span><span class="sxs-lookup"><span data-stu-id="32b4f-122">By default, log messages are written to the standard output (the "console") and to any attached debugger.</span></span> <span data-ttu-id="32b4f-123">若要将日志写入永久性外部数据存储，你可能需要导入[可选的日志记录接收器包](https://docs.microsoft.com/aspnet/core/fundamentals/logging/?view=aspnetcore-3.0#third-party-logging-providers)。</span><span class="sxs-lookup"><span data-stu-id="32b4f-123">To write logs to persistent external data stores, you may need to import [optional logging sink packages](https://docs.microsoft.com/aspnet/core/fundamentals/logging/?view=aspnetcore-3.0#third-party-logging-providers).</span></span>

<span data-ttu-id="32b4f-124">ASP.NET Core gRPC 框架将详细的诊断日志记录消息写入此日志记录框架，以便可以将其与应用程序的消息一起进行处理/存储。</span><span class="sxs-lookup"><span data-stu-id="32b4f-124">The ASP.NET Core gRPC framework writes detailed diagnostic logging messages to this logging framework so they can be processed/stored along with your application's own messages.</span></span>

### <a name="produce-log-messages"></a><span data-ttu-id="32b4f-125">生成日志消息</span><span class="sxs-lookup"><span data-stu-id="32b4f-125">Produce log messages</span></span>

<span data-ttu-id="32b4f-126">日志记录扩展会自动注册 ASP.NET Core 的依赖项注入系统，因此，你可以将记录器指定为 gRPC 服务类型上的构造函数参数。</span><span class="sxs-lookup"><span data-stu-id="32b4f-126">The logging extension is automatically registered with ASP.NET Core's dependency injection system, so you can specify loggers as a constructor parameter on gRPC service types.</span></span>

```csharp
public class StockData : Stocks.StocksBase
{
    private readonly ILogger<StockData> _logger;

    public StockData(ILogger<StockData> logger)
    {
        _logger = logger;
    }
}
```

<span data-ttu-id="32b4f-127">与请求、异常等有关的许多日志消息由 ASP.NET Core 和 gRPC 框架组件提供。</span><span class="sxs-lookup"><span data-stu-id="32b4f-127">Many log messages around requests, exceptions, and so on, are provided by the ASP.NET Core and gRPC framework components.</span></span> <span data-ttu-id="32b4f-128">添加自己的日志消息，提供有关应用程序逻辑的详细信息和上下文，而不是更低级别的问题。</span><span class="sxs-lookup"><span data-stu-id="32b4f-128">Add your own log messages to provide detail and context about application logic rather than lower-level concerns.</span></span>

<span data-ttu-id="32b4f-129">有关编写日志消息和可用日志记录接收器和目标的详细信息，请参阅[在 .Net Core 中进行日志记录和 ASP.NET Core](https://docs.microsoft.com/aspnet/core/fundamentals/logging/?view=aspnetcore-3.0)一文。</span><span class="sxs-lookup"><span data-stu-id="32b4f-129">For more information about writing log messages and available logging sinks and targets, see the [Logging in .NET Core and ASP.NET Core](https://docs.microsoft.com/aspnet/core/fundamentals/logging/?view=aspnetcore-3.0) article.</span></span>

## <a name="metrics-in-aspnet-core-grpc"></a><span data-ttu-id="32b4f-130">ASP.NET Core gRPC 中的指标</span><span class="sxs-lookup"><span data-stu-id="32b4f-130">Metrics in ASP.NET Core gRPC</span></span>

<span data-ttu-id="32b4f-131">.NET Core 运行时提供一组用于发出和观察指标的组件，其中包括诸如 <xref:System.Diagnostics.Tracing.EventSource> 和 <xref:System.Diagnostics.Tracing.EventCounter> 类的 Api。</span><span class="sxs-lookup"><span data-stu-id="32b4f-131">The .NET Core runtime provides a set of components for emitting and observing metrics that includes APIs such as the <xref:System.Diagnostics.Tracing.EventSource> and <xref:System.Diagnostics.Tracing.EventCounter> classes.</span></span> <span data-ttu-id="32b4f-132">这些 Api 可用于发出基本数值数据，外部进程可使用这些数据，如[dotnet 全局工具](https://github.com/dotnet/diagnostics/blob/master/documentation/dotnet-counters-instructions.md)或 Windows 事件跟踪。</span><span class="sxs-lookup"><span data-stu-id="32b4f-132">These APIs can be used to emit basic numeric data that can be consumed by external processes like the [dotnet-counters global tool](https://github.com/dotnet/diagnostics/blob/master/documentation/dotnet-counters-instructions.md), or Event Tracing for Windows.</span></span> <span data-ttu-id="32b4f-133">有关在自己的代码中使用 `EventCounter` 的详细信息，请参阅[EventCounter 简介](https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.Tracing/documentation/EventCounterTutorial.md)教程。</span><span class="sxs-lookup"><span data-stu-id="32b4f-133">For more information about using `EventCounter` in your own code, see the [EventCounter Introduction](https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.Tracing/documentation/EventCounterTutorial.md) tutorial.</span></span>

<span data-ttu-id="32b4f-134">对于更高级的度量值，以及将指标数据写入更广泛的数据存储，有一个称为 "[应用指标](https://www.app-metrics.io)" 的优秀开源项目。</span><span class="sxs-lookup"><span data-stu-id="32b4f-134">For more advanced metrics and for writing metric data to a wider range of data stores, there's an excellent open-source project called [App Metrics](https://www.app-metrics.io).</span></span> <span data-ttu-id="32b4f-135">此库套件提供了一组广泛的类型来检测你的代码。</span><span class="sxs-lookup"><span data-stu-id="32b4f-135">This suite of libraries provides an extensive set of types to instrument your code.</span></span> <span data-ttu-id="32b4f-136">它还提供了用于将指标写入不同类型目标的包，这些目标包括时间序列数据库，如 Prometheus 和 InfluxDB、 [Azure 应用程序 Insights](https://docs.microsoft.com/azure/azure-monitor/app/app-insights-overview)等。</span><span class="sxs-lookup"><span data-stu-id="32b4f-136">It also offers packages to write metrics to different kinds of targets that include time-series databases, such as Prometheus and InfluxDB, [Azure Application Insights](https://docs.microsoft.com/azure/azure-monitor/app/app-insights-overview), and more.</span></span> <span data-ttu-id="32b4f-137">[AspNetCore](https://www.nuget.org/packages/App.Metrics.AspNetCore.Mvc/) NuGet 包甚至添加了一组综合的基本指标，这些指标是通过与 ASP.NET Core 框架的集成自动生成的，而网站提供了用于使用[Grafana](https://grafana.com/)可视化平台显示这些指标的[模板](https://www.app-metrics.io/samples/grafana/)。</span><span class="sxs-lookup"><span data-stu-id="32b4f-137">The [App.Metrics.AspNetCore.Mvc](https://www.nuget.org/packages/App.Metrics.AspNetCore.Mvc/) NuGet package even adds a comprehensive set of basic metrics that are automatically generated via integration with the ASP.NET Core framework, and the web site provides [templates](https://www.app-metrics.io/samples/grafana/) for displaying those metrics with the [Grafana](https://grafana.com/) visualization platform.</span></span>

<span data-ttu-id="32b4f-138">有关应用指标的详细信息和文档，请参阅[app-metrics.io](https://app-metrics.io)网站。</span><span class="sxs-lookup"><span data-stu-id="32b4f-138">For more information and documentation about App Metrics, see the [app-metrics.io](https://app-metrics.io) website.</span></span>

### <a name="produce-metrics"></a><span data-ttu-id="32b4f-139">生成指标</span><span class="sxs-lookup"><span data-stu-id="32b4f-139">Produce metrics</span></span>

<span data-ttu-id="32b4f-140">大多数指标平台支持5种基本类型的指标，如下表所示：</span><span class="sxs-lookup"><span data-stu-id="32b4f-140">Most metrics platforms support five basic types of metric, outlined in the following table:</span></span>

| <span data-ttu-id="32b4f-141">度量值类型</span><span class="sxs-lookup"><span data-stu-id="32b4f-141">Metric type</span></span> | <span data-ttu-id="32b4f-142">描述</span><span class="sxs-lookup"><span data-stu-id="32b4f-142">Description</span></span> |
| ----------- | ----------- |
| <span data-ttu-id="32b4f-143">计数器</span><span class="sxs-lookup"><span data-stu-id="32b4f-143">Counter</span></span>     | <span data-ttu-id="32b4f-144">跟踪发生某些情况（如请求、错误等）的频率。</span><span class="sxs-lookup"><span data-stu-id="32b4f-144">Tracks how often something happens, such as requests, errors, and so on.</span></span> |
| <span data-ttu-id="32b4f-145">衡量</span><span class="sxs-lookup"><span data-stu-id="32b4f-145">Gauge</span></span>       | <span data-ttu-id="32b4f-146">记录随时间变化的单个值，如活动连接。</span><span class="sxs-lookup"><span data-stu-id="32b4f-146">Records a single value that changes over time, such as active connections.</span></span> |
| <span data-ttu-id="32b4f-147">而言</span><span class="sxs-lookup"><span data-stu-id="32b4f-147">Histogram</span></span>   | <span data-ttu-id="32b4f-148">度量跨任意限制的值的分布。</span><span class="sxs-lookup"><span data-stu-id="32b4f-148">Measures a distribution of values across arbitrary limits.</span></span> <span data-ttu-id="32b4f-149">例如，直方图可以跟踪数据集的大小，计算包含多少 < 10 个记录，多少11-100 和101-1000，以及 > 1000 条记录。</span><span class="sxs-lookup"><span data-stu-id="32b4f-149">For example, a histogram could track data set size, counting how many contained <10 records, how many 11-100 and 101-1000, and >1000 records.</span></span> |
| <span data-ttu-id="32b4f-150">进度表</span><span class="sxs-lookup"><span data-stu-id="32b4f-150">Meter</span></span>       | <span data-ttu-id="32b4f-151">度量事件在不同时间范围内的发生速率。</span><span class="sxs-lookup"><span data-stu-id="32b4f-151">Measures the rate at which an event occurs in various time spans.</span></span> |
| <span data-ttu-id="32b4f-152">计时器</span><span class="sxs-lookup"><span data-stu-id="32b4f-152">Timer</span></span>       | <span data-ttu-id="32b4f-153">跟踪事件的持续时间以及事件发生的速率（以直方图形式存储）。</span><span class="sxs-lookup"><span data-stu-id="32b4f-153">Tracks the duration of events and the rate at which it occurs, stored as a histogram.</span></span> |

<span data-ttu-id="32b4f-154">使用*应用指标*，可通过依赖关系注入获取 `IMetrics` 接口，并用于记录 gRPC 服务的任何指标。</span><span class="sxs-lookup"><span data-stu-id="32b4f-154">Using *App Metrics*, an `IMetrics` interface can be obtained via dependency injection and used to record any of these metrics for a gRPC service.</span></span> <span data-ttu-id="32b4f-155">下面的示例演示如何计算一段时间内发出的 `Get` 请求数：</span><span class="sxs-lookup"><span data-stu-id="32b4f-155">The following example shows how to count the number of `Get` requests made over time:</span></span>

```csharp
public class StockData : Stocks.StocksBase
{
    private static readonly CounterOptions GetRequestCounter = new CounterOptions
    {
        Name = "StockData_Get_Requests",
        MeasurementUnit = Unit.Calls
    };

    private readonly IStockRepository _repository;
    private readonly IMetrics _metrics;

    public StockData(IStockRepository repository, IMetrics metrics)
    {
        _repository = repository;
        _metrics = metrics;
    }

    public override async Task<GetResponse> Get(GetRequest request, ServerCallContext context)
    {
        _metrics.Measure.Counter.Increment(GetRequestCounter);

        // Serve request...
    }
}
```

### <a name="store-and-visualize-metrics-data"></a><span data-ttu-id="32b4f-156">存储和可视化指标数据</span><span class="sxs-lookup"><span data-stu-id="32b4f-156">Store and visualize metrics data</span></span>

<span data-ttu-id="32b4f-157">存储度量值数据的最佳方式是在时序*数据库*中，这是一个专用的数据存储，用于记录用时间戳标记的数值数据系列。</span><span class="sxs-lookup"><span data-stu-id="32b4f-157">The best way to store metrics data is in a *time-series database*, a specialized data store designed to record numerical data series marked with timestamps.</span></span> <span data-ttu-id="32b4f-158">这些数据库最常见的是[Prometheus](https://prometheus.io/)和[InfluxDB](https://www.influxdata.com/products/influxdb-overview/)。</span><span class="sxs-lookup"><span data-stu-id="32b4f-158">The most popular of these databases are [Prometheus](https://prometheus.io/) and [InfluxDB](https://www.influxdata.com/products/influxdb-overview/).</span></span> <span data-ttu-id="32b4f-159">Microsoft Azure 还通过[Azure Monitor](https://docs.microsoft.com/azure/azure-monitor/overview)服务提供专用的度量值存储。</span><span class="sxs-lookup"><span data-stu-id="32b4f-159">Microsoft Azure also provides dedicated metrics storage through the [Azure Monitor](https://docs.microsoft.com/azure/azure-monitor/overview) service.</span></span>

<span data-ttu-id="32b4f-160">用于可视化度量数据的当前走向解决方案是[Grafana](https://grafana.com)，可与各种存储提供程序（包括 Azure Monitor、InfluxDB 和 Prometheus）配合使用。</span><span class="sxs-lookup"><span data-stu-id="32b4f-160">The current go-to solution for visualizing metrics data is [Grafana](https://grafana.com), which works with a wide range of storage providers including Azure Monitor, InfluxDB and Prometheus.</span></span> <span data-ttu-id="32b4f-161">下图显示了一个示例 Grafana 仪表板，该仪表板显示运行 StockData 示例的 Linkerd service 网格中的指标：</span><span class="sxs-lookup"><span data-stu-id="32b4f-161">The following image shows an example Grafana dashboard that displays metrics from the Linkerd service mesh running the StockData sample:</span></span>

![Grafana 仪表板](media/application-performance-management/grafana-screenshot.png)

### <a name="metrics-based-alerting"></a><span data-ttu-id="32b4f-163">基于指标的警报</span><span class="sxs-lookup"><span data-stu-id="32b4f-163">Metrics-based alerting</span></span>

<span data-ttu-id="32b4f-164">度量值数据的数值性质意味着它非常适合用于驱动警报系统，并在某个值超出某些定义的容差时通知开发人员或支持工程师。</span><span class="sxs-lookup"><span data-stu-id="32b4f-164">The numerical nature of metrics data means that it's ideally suited to drive alerting systems, notifying developers or support engineers when a value falls outside of some defined tolerance.</span></span> <span data-ttu-id="32b4f-165">已提到的平台都通过各种选项（包括电子邮件、短信或仪表板中的可视化效果）提供警报支持。</span><span class="sxs-lookup"><span data-stu-id="32b4f-165">The platforms already mentioned all provide support for alerting via a range of options, including emails, text messages, or in-dashboard visualizations.</span></span>

## <a name="distributed-tracing"></a><span data-ttu-id="32b4f-166">分布式跟踪</span><span class="sxs-lookup"><span data-stu-id="32b4f-166">Distributed tracing</span></span>

<span data-ttu-id="32b4f-167">*分布式跟踪*是一种相对较新的监视开发，它怀疑于不断使用微服务和分布式体系结构。</span><span class="sxs-lookup"><span data-stu-id="32b4f-167">*Distributed tracing* is a relatively recent development in monitoring, which has arisen from the increasing use of microservices and distributed architectures.</span></span> <span data-ttu-id="32b4f-168">来自客户端浏览器、应用程序或设备的单个请求可能分为多个步骤和子请求，并涉及到跨网络使用许多服务。</span><span class="sxs-lookup"><span data-stu-id="32b4f-168">A single request from a client browser, application, or device may be broken down into many steps and sub-requests, and involve the use of many services across a network.</span></span> <span data-ttu-id="32b4f-169">这使得难以将日志消息和指标与触发它们的特定请求关联起来。</span><span class="sxs-lookup"><span data-stu-id="32b4f-169">This makes it difficult to correlate log messages and metrics with the specific request that triggered them.</span></span> <span data-ttu-id="32b4f-170">分布式跟踪将标识符应用于允许日志和指标与特定操作相关联的请求。</span><span class="sxs-lookup"><span data-stu-id="32b4f-170">Distributed tracing applies identifiers to requests that allow logs and metrics to be correlated with a particular operation.</span></span> <span data-ttu-id="32b4f-171">这类似于[WCF 的端到端跟踪](https://docs.microsoft.com/dotnet/framework/wcf/diagnostics/tracing/end-to-end-tracing)，但应用于多个平台。</span><span class="sxs-lookup"><span data-stu-id="32b4f-171">This is similar to [WCF's end-to-end tracing](https://docs.microsoft.com/dotnet/framework/wcf/diagnostics/tracing/end-to-end-tracing), but applied across multiple platforms.</span></span>

<span data-ttu-id="32b4f-172">尽管它仍是一个 nascent 的技术领域，但分布式跟踪在受欢迎程度上迅速增长，现在正在经历标准化过程。</span><span class="sxs-lookup"><span data-stu-id="32b4f-172">Although it's still a nascent technology area, distributed tracing has grown quickly in popularity and is now going through a standardization process.</span></span> <span data-ttu-id="32b4f-173">云本机计算基础创建了[开放跟踪标准](https://opentracing.io)，尝试为使用后端（如[JAEGER](https://www.jaegertracing.io/)和[弹性 APM](https://www.elastic.co/products/apm)）提供与供应商无关的库。</span><span class="sxs-lookup"><span data-stu-id="32b4f-173">The Cloud Native Computing Foundation created the [the Open Tracing standard](https://opentracing.io), attempting to provide vendor-neutral libraries for working with backends like [Jaeger](https://www.jaegertracing.io/) and [Elastic APM](https://www.elastic.co/products/apm).</span></span> <span data-ttu-id="32b4f-174">同时，Google 创建了[OpenCensus 项目](https://opencensus.io/)来处理相同的一组问题。</span><span class="sxs-lookup"><span data-stu-id="32b4f-174">At the same time, Google created the [OpenCensus project](https://opencensus.io/) to address the same set of problems.</span></span> <span data-ttu-id="32b4f-175">这两个项目现在正在合并到一个新项目[OpenTelemetry](https://opentelemetry.io)中，该项目旨在成为未来的行业标准。</span><span class="sxs-lookup"><span data-stu-id="32b4f-175">These two projects are now being merged into a new project, [OpenTelemetry](https://opentelemetry.io), which aims to be the future industry standard.</span></span>

### <a name="how-distributed-tracing-works"></a><span data-ttu-id="32b4f-176">分布式跟踪的工作原理</span><span class="sxs-lookup"><span data-stu-id="32b4f-176">How distributed tracing works</span></span>

<span data-ttu-id="32b4f-177">分布式跟踪基于*跨越*的概念：已命名的计时操作，这些操作是单个*跟踪*的一部分，这可能涉及在系统的多个节点上进行处理。</span><span class="sxs-lookup"><span data-stu-id="32b4f-177">Distributed tracing is based on the concept of *Spans*: named, timed operations that are part of a single *Trace*, which may involve processing on multiple nodes of a system.</span></span> <span data-ttu-id="32b4f-178">当启动新操作时，将使用唯一标识符创建跟踪。</span><span class="sxs-lookup"><span data-stu-id="32b4f-178">When a new operation is initiated, a trace is created with a unique identifier.</span></span> <span data-ttu-id="32b4f-179">对于每个子操作，会使用其自己的标识符和跟踪标识符来创建一个跨度。</span><span class="sxs-lookup"><span data-stu-id="32b4f-179">For each sub-operation, a span is created with its own identifier and trace identifier.</span></span> <span data-ttu-id="32b4f-180">当请求在系统中传递时，各组件可以创建包括其*父*范围的标识符的*子*范围。</span><span class="sxs-lookup"><span data-stu-id="32b4f-180">As the request passes around the system, various components can create *child* spans that include the identifier of their *parent*.</span></span> <span data-ttu-id="32b4f-181">一个范围包含一个*上下文*，其中包含跟踪和范围标识符，以及键/值对（称为*行李*）形式的有用数据。</span><span class="sxs-lookup"><span data-stu-id="32b4f-181">A span has a *context*, which contains the trace and span identifiers, as well as useful data in the form of key/value pairs (called *baggage*).</span></span>

### <a name="distributed-tracing-with-diagnosticsource"></a><span data-ttu-id="32b4f-182">用 DiagnosticSource 进行分布式跟踪</span><span class="sxs-lookup"><span data-stu-id="32b4f-182">Distributed tracing with DiagnosticSource</span></span>

<span data-ttu-id="32b4f-183">.NET Core 有一个内部模块，该模块适用于分布式跟踪和跨越： [DiagnosticSource](https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.DiagnosticSource/src/DiagnosticSourceUsersGuide.md#diagnosticsource-users-guide)。</span><span class="sxs-lookup"><span data-stu-id="32b4f-183">.NET Core has an internal module that maps well to distributed traces and spans: [DiagnosticSource](https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.DiagnosticSource/src/DiagnosticSourceUsersGuide.md#diagnosticsource-users-guide).</span></span> <span data-ttu-id="32b4f-184">除了提供一种在一个进程内生成和使用诊断的简单方法，`DiagnosticSource` 模块具有活动的概念，该*活动*实际上是分布式跟踪的实现或跟踪内的跨度。</span><span class="sxs-lookup"><span data-stu-id="32b4f-184">As well as providing a simple way to produce and consume diagnostics within a process, the `DiagnosticSource` module has the concept of an *Activity*, which is effectively an implementation of a distributed trace, or a span within a trace.</span></span> <span data-ttu-id="32b4f-185">模块的内部机制负责父子活动（包括分配标识符）。</span><span class="sxs-lookup"><span data-stu-id="32b4f-185">The internals of the module take care of parent/child activities, including allocating identifiers.</span></span> <span data-ttu-id="32b4f-186">有关使用 `Activity` 类型的详细信息，请参阅[GitHub 上的活动用户指南](https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.DiagnosticSource/src/ActivityUserGuide.md#activity-user-guide)</span><span class="sxs-lookup"><span data-stu-id="32b4f-186">For more information about using the `Activity` type, see the [Activity User Guide on GitHub](https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.DiagnosticSource/src/ActivityUserGuide.md#activity-user-guide)</span></span>

<span data-ttu-id="32b4f-187">由于 DiagnosticSource 是核心框架的一部分，因此它受多个核心组件（包括 <xref:System.Net.Http.HttpClient>、Entity Framework Core 和 ASP.NET Core）的支持，包括 gRPC 框架中的显式支持。</span><span class="sxs-lookup"><span data-stu-id="32b4f-187">Because DiagnosticSource is a part of the core framework, it's supported by several core components, including <xref:System.Net.Http.HttpClient>, Entity Framework Core and ASP.NET Core, including explicit support in the gRPC framework.</span></span> <span data-ttu-id="32b4f-188">当 ASP.NET Core 收到请求时，它将检查与[W3C 跟踪上下文](https://www.w3.org/TR/trace-context)标准匹配的一对 HTTP 标头。</span><span class="sxs-lookup"><span data-stu-id="32b4f-188">When ASP.NET Core receives a request, it  checks for a pair of HTTP headers matching the [W3C Trace Context](https://www.w3.org/TR/trace-context) standard.</span></span> <span data-ttu-id="32b4f-189">如果找到了标头，则使用标识值和标头中的上下文启动活动。</span><span class="sxs-lookup"><span data-stu-id="32b4f-189">If the headers are found, an Activity is started using the identity values and context from the headers.</span></span> <span data-ttu-id="32b4f-190">如果未找到任何标头，则会启动一个活动，其中生成的标识值与标准格式匹配。</span><span class="sxs-lookup"><span data-stu-id="32b4f-190">If no headers are found, an Activity is started with generated identity values that match the standard format.</span></span> <span data-ttu-id="32b4f-191">在此活动的生存期内，由框架或应用程序代码生成的任何诊断，都可以用 trace 和 span 标识符进行标记。</span><span class="sxs-lookup"><span data-stu-id="32b4f-191">Any diagnostics generated by the framework or by application code during the lifetime of this Activity can be tagged with the trace and span identifiers.</span></span> <span data-ttu-id="32b4f-192">`HttpClient` 支持通过检查每个请求的当前活动并自动将跟踪标头添加到传出请求，进一步扩展了此功能。</span><span class="sxs-lookup"><span data-stu-id="32b4f-192">The `HttpClient` support extends this further by checking for a current Activity on every request and automatically adding the trace headers to the outgoing request.</span></span>

<span data-ttu-id="32b4f-193">ASP.NET Core gRPC 客户端和服务器库包括对 DiagnosticSource 和活动的显式支持，并将创建活动并自动应用和使用标头信息。</span><span class="sxs-lookup"><span data-stu-id="32b4f-193">The ASP.NET Core gRPC client and server libraries include explicit support for DiagnosticSource and Activity, and will create activities and apply and use header information automatically.</span></span>

> [!NOTE]
> <span data-ttu-id="32b4f-194">仅当*侦听器*使用诊断信息时，才会发生这种情况。</span><span class="sxs-lookup"><span data-stu-id="32b4f-194">All of this only happens if a *listener* is consuming the diagnostic information.</span></span> <span data-ttu-id="32b4f-195">如果没有侦听器，则不会写入任何诊断，也不会创建任何活动。</span><span class="sxs-lookup"><span data-stu-id="32b4f-195">If there's no listener, no diagnostics are written and no activities are created.</span></span>

### <a name="add-your-own-diagnosticsources-and-activities"></a><span data-ttu-id="32b4f-196">添加自己的 DiagnosticSources 和活动</span><span class="sxs-lookup"><span data-stu-id="32b4f-196">Add your own DiagnosticSources and Activities</span></span>

<span data-ttu-id="32b4f-197">尽管 ASP.NET Core 会自动生成良好的数据量（包括 gRPC）以及 Entity Framework Core 和 `HttpClient`，但你可能希望在应用程序代码中添加自己的诊断或创建显式范围。</span><span class="sxs-lookup"><span data-stu-id="32b4f-197">Although a good quantity of data is automatically generated by ASP.NET Core, including gRPC, as well as Entity Framework Core and `HttpClient`, you may wish to add your own diagnostics or create explicit spans within your application code.</span></span> <span data-ttu-id="32b4f-198">有关如何实现自己的诊断的详细信息，请参阅[DiagnosticSource 用户指南](https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.DiagnosticSource/src/DiagnosticSourceUsersGuide.md#instrumenting-with-diagnosticsourcediagnosticlistener)和[活动用户指南](https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.DiagnosticSource/src/ActivityUserGuide.md#activity-usage)。</span><span class="sxs-lookup"><span data-stu-id="32b4f-198">Refer to the [DiagnosticSource User Guide](https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.DiagnosticSource/src/DiagnosticSourceUsersGuide.md#instrumenting-with-diagnosticsourcediagnosticlistener) and [Activity User Guide](https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.DiagnosticSource/src/ActivityUserGuide.md#activity-usage) for details on how to implement your own diagnostics.</span></span>

### <a name="store-distributed-trace-data"></a><span data-ttu-id="32b4f-199">存储分布式跟踪数据</span><span class="sxs-lookup"><span data-stu-id="32b4f-199">Store distributed trace data</span></span>

<span data-ttu-id="32b4f-200">撰写 OpenTelemetry 项目时仍处于早期阶段，并且只有 alpha 质量的包可用于 .NET 应用程序。</span><span class="sxs-lookup"><span data-stu-id="32b4f-200">At the time of writing the OpenTelemetry project is still in the early stages, and only alpha-quality packages are available for .NET applications.</span></span> <span data-ttu-id="32b4f-201">OpenTracing 项目提供更成熟的库，但它们会在将来被 OpenTelemetry 库取代。</span><span class="sxs-lookup"><span data-stu-id="32b4f-201">The OpenTracing project offers more mature libraries, but these will be superseded by the OpenTelemetry libraries in the future.</span></span>

<span data-ttu-id="32b4f-202">下面介绍了 OpenTracing API。</span><span class="sxs-lookup"><span data-stu-id="32b4f-202">The OpenTracing API is described below.</span></span> <span data-ttu-id="32b4f-203">如果希望在应用程序中使用较新的 OpenTelemetry API，请参阅[GitHub 上的 OpenTelemetry .NET SDK 存储库](https://github.com/open-telemetry/opentelemetry-dotnet)。</span><span class="sxs-lookup"><span data-stu-id="32b4f-203">If you would prefer to use the newer OpenTelemetry API in your application, refer to the [OpenTelemetry .NET SDK repository on GitHub](https://github.com/open-telemetry/opentelemetry-dotnet).</span></span>

#### <a name="use-the-opentracing-package-to-store-distributed-trace-data"></a><span data-ttu-id="32b4f-204">使用 OpenTracing 包存储分布式跟踪数据</span><span class="sxs-lookup"><span data-stu-id="32b4f-204">Use the OpenTracing package to store distributed trace data</span></span>

<span data-ttu-id="32b4f-205">支持所有 OpenTracing 相容后端的[OpenTracing NuGet 包](https://www.nuget.org/packages/OpenTracing/)（可独立于 `DiagnosticSource`）使用。</span><span class="sxs-lookup"><span data-stu-id="32b4f-205">The [an OpenTracing NuGet package](https://www.nuget.org/packages/OpenTracing/) that supports all OpenTracing-compliant back-ends (which can be used independently of `DiagnosticSource`).</span></span> <span data-ttu-id="32b4f-206">还有一个来自 OpenTracing API 贡献项目的其他包[OpenTracing. Contrib NetCore](https://www.nuget.org/packages/OpenTracing.Contrib.NetCore/)，它添加一个 `DiagnosticSource` 侦听器，并自动将事件和活动写入后端。</span><span class="sxs-lookup"><span data-stu-id="32b4f-206">There's an additional package from the OpenTracing API Contributions project, [OpenTracing.Contrib.NetCore](https://www.nuget.org/packages/OpenTracing.Contrib.NetCore/), which adds a `DiagnosticSource` listener and writes events and activities to a back-end automatically.</span></span> <span data-ttu-id="32b4f-207">启用此包非常简单，只是从 NuGet 安装它并将其作为服务添加到 `Startup` 类中。</span><span class="sxs-lookup"><span data-stu-id="32b4f-207">Enabling this package is as simple as installing it from NuGet and adding it as a service in your `Startup` class.</span></span>

```csharp
public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        services.AddOpenTracing();
    }
}
```

<span data-ttu-id="32b4f-208">OpenTracing 包是抽象层，因此它需要特定于后端的实现。</span><span class="sxs-lookup"><span data-stu-id="32b4f-208">The OpenTracing package is an abstraction layer and as such it requires a back-end-specific implementation.</span></span> <span data-ttu-id="32b4f-209">OpenTracing API 实现适用于以下开源后端。</span><span class="sxs-lookup"><span data-stu-id="32b4f-209">OpenTracing API implementations are available for the following open source back-ends.</span></span>

| <span data-ttu-id="32b4f-210">“属性”</span><span class="sxs-lookup"><span data-stu-id="32b4f-210">Name</span></span> | <span data-ttu-id="32b4f-211">Package</span><span class="sxs-lookup"><span data-stu-id="32b4f-211">Package</span></span> | <span data-ttu-id="32b4f-212">网站</span><span class="sxs-lookup"><span data-stu-id="32b4f-212">Web site</span></span> |
| ---- | ------- | -------- |
| <span data-ttu-id="32b4f-213">Jaeger</span><span class="sxs-lookup"><span data-stu-id="32b4f-213">Jaeger</span></span> | [<span data-ttu-id="32b4f-214">Jaeger</span><span class="sxs-lookup"><span data-stu-id="32b4f-214">Jaeger</span></span>](https://www.nuget.org/packages/Jaeger/) | [<span data-ttu-id="32b4f-215">jaegertracing.io</span><span class="sxs-lookup"><span data-stu-id="32b4f-215">jaegertracing.io</span></span>](https://jaegertracing.io) |
| <span data-ttu-id="32b4f-216">弹性 APM</span><span class="sxs-lookup"><span data-stu-id="32b4f-216">Elastic APM</span></span> | [<span data-ttu-id="32b4f-217">NetCoreAll</span><span class="sxs-lookup"><span data-stu-id="32b4f-217">Elastic.Apm.NetCoreAll</span></span>](https://www.nuget.org/packages/Elastic.Apm.NetCoreAll/) | [<span data-ttu-id="32b4f-218">elastic.co/products/apm</span><span class="sxs-lookup"><span data-stu-id="32b4f-218">elastic.co/products/apm</span></span>](https://www.elastic.co/products/apm) |

<span data-ttu-id="32b4f-219">有关适用于 .net 的 OpenTracing API 的详细信息，请参阅 GitHub 上的[OpenTracing C# ](https://github.com/opentracing/opentracing-csharp)和[OpenTracing C#Contrib/.NET Core](https://github.com/opentracing-contrib/csharp-netcore)存储库。</span><span class="sxs-lookup"><span data-stu-id="32b4f-219">For more information on the OpenTracing API for .NET, see the [OpenTracing for C#](https://github.com/opentracing/opentracing-csharp) and the [OpenTracing Contrib C#/.NET Core](https://github.com/opentracing-contrib/csharp-netcore) repositories on GitHub.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="32b4f-220">[上一页](load-balancing.md)
>[下一页](appendix.md)</span><span class="sxs-lookup"><span data-stu-id="32b4f-220">[Previous](load-balancing.md)
[Next](appendix.md)</span></span>
