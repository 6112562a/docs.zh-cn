---
title: 无服务器体系结构注意事项-无服务器应用
description: 了解构建无服务器应用程序（从状态管理和持久存储到规模、日志记录、跟踪和诊断）的挑战。
author: JEREMYLIKNESS
ms.author: jeliknes
ms.date: 06/26/2018
ms.openlocfilehash: c856683cf6910be98661e634246cd003b93a6d76
ms.sourcegitcommit: 4f4a32a5c16a75724920fa9627c59985c41e173c
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 10/17/2019
ms.locfileid: "72522428"
---
# <a name="serverless-architecture-considerations"></a>无服务器体系结构注意事项

采用无服务器体系结构不会带来某些挑战。 本部分探讨一些更常见的注意事项。 所有这些挑战都包含解决方案。 与所有结构选择一样，只应仔细考虑优缺点，才能进行无服务器决策。 根据应用程序的需要，你可能决定无服务器实现对于某些组件来说不是正确的解决方案。

## <a name="managing-state"></a>管理状态

与微服务一样，无服务器函数默认情况下是无状态的。 避免状态使无服务器是暂时的，可进行横向扩展，并在没有中心故障点的情况下提供复原能力。 在某些情况下，业务流程需要状态。 如果你的过程需要状态，则有两个选择。 可以采用非服务器以外的模型，或与提供状态的单独服务进行交互。 添加状态可能会使解决方案复杂化，并使其难以扩展，并可能会产生单一故障点。 仔细考虑函数是否确实需要状态。 如果答案为 "是"，则确定是否仍有必要用无服务器实现它。

有几种解决方案可以采用状态，而不会危及无服务器的优势。 一些更常见的解决方案包括：

- 使用临时数据存储或分布式缓存，如 Redis
- 将状态存储在数据库中，如 SQL 或 CosmosDB
- 通过工作流引擎（如持久函数）处理状态

关键在于，您应该知道在您打算用无服务器实现的进程内是否需要进行任何状态管理。

## <a name="long-running-processes"></a>长时间运行的进程

无服务器的许多优点依赖于进程是暂时的。 短时间运行时间使无服务器提供程序能够更轻松地将资源作为函数结束并跨主机共享函数。 大多数云提供程序会将函数运行的总时间限制为10分钟左右。 如果你的过程可能需要更长时间，则可以考虑使用其他实现。

有一些例外和解决方案。 一种解决方法是将进程分解为单独花费更少运行时间的小组件。 如果由于依赖关系而导致进程长时间运行，则还可以考虑使用持久性函数等解决方案的异步工作流。 持久函数在等待外部进程完成时暂停并维护进程的状态。 异步处理可减少实际进程的运行时间。

## <a name="startup-time"></a>启动时间

无服务器实现的一个潜在问题是启动时间。 为了节省资源，许多无服务器提供程序都可以 "按需" 创建基础结构。 如果在一段时间后触发了无服务器函数，则可能需要创建或重新启动该函数的宿主资源。 在某些情况下，冷启动可能会导致几秒钟的延迟。 启动时间因提供程序和服务级别而异。 如果最大程度地减少应用的成功，则可以使用几种方法来解决启动时间。

- 某些提供商允许用户为保证基础结构为 "始终可用" 的服务级别付费。
- 实现 keep-alive 机制（对终结点进行 ping 操作，使其保持 "唤醒" 状态）。
- 使用具有容器化函数方法的业务流程（如 Kubernetes）（主机已在运行，因此加速新实例的速度非常快）。

## <a name="database-updates-and-migrations"></a>数据库更新和迁移

无服务器代码的优点是可以在不重新部署整个应用程序的情况下发布新功能。 当涉及到关系数据库时，此优势可能会成为一个缺点。 更改数据库架构很难与无服务器更新同步。 如果出现问题，必须回滚这些更改，则会导致更多挑战。 数据完整性是微服务和无服务器函数的最佳实践之一是它们拥有自己的数据。 可以将更改作为计算和数据的单个单元部署。 事实是，许多旧系统的功能是必须与无服务器体系结构协调的大型后端数据库。

解决架构版本控制的一种常用方法是从不修改现有属性和列，而是添加新信息。 例如，请考虑将待办事项列表的 "已完成" 标志移动到 "完成日期"。 数据库更改不会删除旧字段，而是：

1. 添加新的 "完成日期" 字段。
1. 将 "已完成" 布尔字段转换为计算函数，该函数计算完成日期是否晚于当前日期。
1. 添加一个触发器，以便在完成的布尔值设置为 true 时将完成日期设置为当前日期。

更改顺序确保旧代码继续 "按原样" 运行，而更新的无服务器函数可以利用新的字段。

有关无服务器体系结构中数据的详细信息，请参阅[分布式数据管理的挑战和解决方案](../microservices/architect-microservice-container-applications/distributed-data-management.md)。

## <a name="scaling"></a>缩放

这是一个常见的误解，无服务器表示 "无服务器"。 事实上，这是 "服务器更少"。 事实证明，实现基础结构很重要，因为它需要扩展。 大多数无服务器平台提供一组控件来处理事件密度增加时基础结构应如何缩放。 您可以从各种选项中进行选择，但您的策略可能因函数而异。 而且，函数通常在相关主机下运行，因此同一主机上的函数具有相同的缩放选项。 因此，有必要对哪些函数根据规模要求一起托管和制定战略。

规则通常指定如何根据不同参数增加（增加主机资源）和向外扩展（增加主机实例的数目）。 刻度的触发器可能包括计划、请求速率、CPU 使用率和内存使用情况。 更高的性能通常会获得更高的成本。 如果请求速率突然增加，则基于消耗的基于消耗的方法可能不会迅速扩展。 在支付前面的 "保险成本" 与 "即用即付" 的平衡之间权衡了平衡，因为需求突然增加，导致响应速度变慢。

## <a name="monitoring-tracing-and-logging"></a>监视、跟踪和日志记录

DevOps 的一个经常被忽略的方面是在部署应用程序后对其进行监视。 具有监视无服务器函数的策略非常重要。 最大的挑战通常是关联的，或者在用户将多个函数作为同一交互的一部分调用时进行识别。 大多数无服务器平台允许可以导入第三方工具的控制台日志记录。 还提供了一些选项，可用于自动收集遥测数据、生成和跟踪相关性 Id 以及监视特定操作，以提供详细的见解。 Azure 提供用于监视和分析的高级[Application Insights 平台](https://docs.microsoft.com/azure/azure-functions/functions-monitoring)。

## <a name="inter-service-dependencies"></a>服务间依赖关系

无服务器体系结构可能包含依赖于其他函数的函数。 事实上，无服务器体系结构中存在多个服务作为交互或分布式事务的一部分进行调用的情况并不常见。 为了避免强耦合，建议服务不会直接相互引用。 当服务的终结点需要更改时，直接引用可能会导致主要重构。 建议的解决方案是提供服务发现机制（如注册表），该机制为请求类型提供适当的终结点。 另一种解决方案是利用消息服务（如队列或主题）在服务之间进行通信。

## <a name="managing-failure-and-providing-resiliency"></a>管理故障和提供复原

还必须考虑*断路器模式*：如果由于某种原因，服务继续失败，不建议重复调用该服务。 相反，将调用替代服务或返回一条消息，直到重新建立了依赖服务的运行状况。 无服务器体系结构需要考虑解析和管理服务间依赖项的策略。

若要继续断路器模式，服务需要具备容错能力和复原能力。 容错是指即使在遇到意外的异常或遇到无效状态之后，应用程序也能继续运行。 容错通常是代码本身的一项功能，以及如何编写它来处理异常。 复原指的是应用程序从故障中恢复的能力。 复原通常由无服务器平台管理。 当现有的无服务器函数实例发生故障时，该平台应能启动一个新的无服务器函数实例。 平台还应该具有足够的智能，以便在每个新实例都出现故障时停止旋转新的实例。

有关详细信息，请参阅[实现断路器模式](../microservices/implement-resilient-applications/implement-circuit-breaker-pattern.md)。

## <a name="versioning-and-greenblue-deployments"></a>版本控制和绿色/蓝色部署

无服务器的主要好处是，无需重新部署整个应用程序即可升级特定功能。 要使升级成功，必须将函数版本化，以便调用它们的服务将路由到正确版本的代码。 部署新版本的策略也很重要。 常见的方法是使用 "绿色/蓝色部署"。 绿色部署是当前函数。 将新的 "blue" 版本部署到生产和测试。 测试通过时，将交换绿色和蓝色版本，使新版本生效。 如果遇到任何问题，可以交换回来。 支持版本控制和绿色/蓝色部署需要编写函数以适应版本更改，并使用无服务器平台来处理部署。 一种可能的方法是使用 " [Azure 无服务器平台](azure-functions.md#proxies)" 一章中所述的代理。

>[!div class="step-by-step"]
>[上一页](serverless-architecture.md)
>[下一页](serverless-design-examples.md)
