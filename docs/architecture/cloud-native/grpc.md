---
title: gRPC
description: 了解 gRPC 及其在云原生应用程序中的角色，以及它与 HTTP RESTful 通信有何不同。
author: robvet
ms.date: 03/31/2020
ms.openlocfilehash: 28a07ad5ec105d3fc5b65e4cf0ac0cd85eb16627
ms.sourcegitcommit: 79b0dd8bfc63f33a02137121dd23475887ecefda
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/01/2020
ms.locfileid: "80524207"
---
# <a name="grpc"></a><span data-ttu-id="16116-103">gRPC</span><span class="sxs-lookup"><span data-stu-id="16116-103">gRPC</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="16116-104">到目前为止，在这本书中，我们专注于[基于REST](https://docs.microsoft.com/azure/architecture/best-practices/api-design)的沟通。</span><span class="sxs-lookup"><span data-stu-id="16116-104">So far in this book, we've focused on [REST-based](https://docs.microsoft.com/azure/architecture/best-practices/api-design) communication.</span></span> <span data-ttu-id="16116-105">我们已经看到 REST 是一种灵活的体系结构风格，它根据实体资源定义基于 CRUD 的操作。</span><span class="sxs-lookup"><span data-stu-id="16116-105">We've seen that REST is a flexible architectural style that defines CRUD-based operations against entity resources.</span></span> <span data-ttu-id="16116-106">客户端使用请求/响应通信模型跨 HTTP 与资源进行交互。</span><span class="sxs-lookup"><span data-stu-id="16116-106">Clients interact with resources across HTTP with a request/response communication model.</span></span> <span data-ttu-id="16116-107">虽然 REST 得到了广泛实施，但一种较新的通信技术 gRPC 在整个云原生社区中获得了巨大的发展势头。</span><span class="sxs-lookup"><span data-stu-id="16116-107">While REST is widely implemented, a newer communication technology, gRPC, has gained tremendous momentum across the cloud-native community.</span></span>

## <a name="what-is-grpc"></a><span data-ttu-id="16116-108">什么是 gRPC？</span><span class="sxs-lookup"><span data-stu-id="16116-108">What is gRPC?</span></span>

<span data-ttu-id="16116-109">gRPC 是一个现代的高性能框架，它发展古老的[远程过程调用 （RPC）](https://en.wikipedia.org/wiki/Remote_procedure_call)协议。</span><span class="sxs-lookup"><span data-stu-id="16116-109">gRPC is a modern, high-performance framework that evolves the age-old [remote procedure call (RPC)](https://en.wikipedia.org/wiki/Remote_procedure_call) protocol.</span></span> <span data-ttu-id="16116-110">在应用程序级别，gRPC 简化了客户端和后端服务之间的消息传递。</span><span class="sxs-lookup"><span data-stu-id="16116-110">At the application level, gRPC streamlines messaging between clients and back-end services.</span></span> <span data-ttu-id="16116-111">gRPC 源自 Google，是云[原生产品云原生计算基础 （CNCF）](https://www.cncf.io/)生态系统的一部分。</span><span class="sxs-lookup"><span data-stu-id="16116-111">Originating from Google, gRPC is open source and part of the  [Cloud Native Computing Foundation (CNCF)](https://www.cncf.io/) ecosystem of cloud-native offerings.</span></span> <span data-ttu-id="16116-112">CNCF认为gRPC是一个[孵化项目](https://github.com/cncf/toc/blob/master/process/graduation_criteria.adoc)。</span><span class="sxs-lookup"><span data-stu-id="16116-112">CNCF considers gRPC an [incubating project](https://github.com/cncf/toc/blob/master/process/graduation_criteria.adoc).</span></span> <span data-ttu-id="16116-113">孵化意味着最终用户在生产应用程序中使用该技术，并且项目具有大量贡献者。</span><span class="sxs-lookup"><span data-stu-id="16116-113">Incubating means end users are using the technology in production applications, and the project has a healthy number of contributors.</span></span>

<span data-ttu-id="16116-114">典型的 gRPC 客户端应用将公开实现业务操作的本地进程内函数。</span><span class="sxs-lookup"><span data-stu-id="16116-114">A typical gRPC client app will expose a local, in-process function that implements a business operation.</span></span> <span data-ttu-id="16116-115">在封面下，该本地函数调用远程计算机上的另一个函数。</span><span class="sxs-lookup"><span data-stu-id="16116-115">Under the covers, that local function invokes another function on a remote machine.</span></span> <span data-ttu-id="16116-116">看似本地呼叫的内容实质上变成了对远程服务的透明进程外调用。</span><span class="sxs-lookup"><span data-stu-id="16116-116">What appears to be a local call essentially becomes a transparent out-of-process call to a remote service.</span></span> <span data-ttu-id="16116-117">RPC 管道抽象了计算机之间的点对点网络通信、序列化和执行。</span><span class="sxs-lookup"><span data-stu-id="16116-117">The RPC plumbing abstracts the point-to-point networking communication, serialization, and execution between computers.</span></span>

<span data-ttu-id="16116-118">在云原生应用程序中，开发人员通常跨编程语言、框架和技术工作。</span><span class="sxs-lookup"><span data-stu-id="16116-118">In cloud-native applications, developers often work across programming languages, frameworks, and technologies.</span></span> <span data-ttu-id="16116-119">这种*互操作性*使消息协定和跨平台通信所需的管道复杂化。</span><span class="sxs-lookup"><span data-stu-id="16116-119">This *interoperability* complicates message contracts and the plumbing required for cross-platform communication.</span></span>  <span data-ttu-id="16116-120">gRPC 提供了一个"统一的水平层"，用于抽象这些关注点。</span><span class="sxs-lookup"><span data-stu-id="16116-120">gRPC provides a "uniform horizontal layer" that abstracts these concerns.</span></span> <span data-ttu-id="16116-121">开发人员在其本机平台中的代码侧重于业务功能，而 gRPC 处理通信管道。</span><span class="sxs-lookup"><span data-stu-id="16116-121">Developers code in their native platform focused on business functionality, while gRPC handles communication plumbing.</span></span>

<span data-ttu-id="16116-122">gRPC 在最流行的开发堆栈中提供全面支持，包括 Java、JavaScript、C#、Go、Swift 和 NodeJS。</span><span class="sxs-lookup"><span data-stu-id="16116-122">gRPC offers comprehensive support across most popular development stacks, including Java, JavaScript, C#, Go, Swift, and NodeJS.</span></span>

## <a name="grpc-benefits"></a><span data-ttu-id="16116-123">gRPC 优势</span><span class="sxs-lookup"><span data-stu-id="16116-123">gRPC Benefits</span></span>

<span data-ttu-id="16116-124">gRPC 使用 HTTP/2 进行传输协议。</span><span class="sxs-lookup"><span data-stu-id="16116-124">gRPC uses HTTP/2 for its transport protocol.</span></span> <span data-ttu-id="16116-125">虽然 HTTP/2 与 HTTP 1.1 兼容，但具有许多高级功能：</span><span class="sxs-lookup"><span data-stu-id="16116-125">While compatible with HTTP 1.1, HTTP/2 features many advanced capabilities:</span></span>

- <span data-ttu-id="16116-126">用于数据传输的二进制协议 - 与 HTTP 1.1 不同，HTTP 1.1 以明文形式发送数据。</span><span class="sxs-lookup"><span data-stu-id="16116-126">A binary protocol for data transport - unlike HTTP 1.1, which sends data as clear text.</span></span>
- <span data-ttu-id="16116-127">跨行支持通过同一连接发送多个并行请求 - HTTP 1.1 将处理限制为一次一个请求/响应消息。</span><span class="sxs-lookup"><span data-stu-id="16116-127">Multiplexing support for sending multiple parallel requests over the same connection - HTTP 1.1 limits processing to one request/response message at a time.</span></span>
- <span data-ttu-id="16116-128">双向全双工通信，用于同时发送客户端请求和服务器响应。</span><span class="sxs-lookup"><span data-stu-id="16116-128">Bidirectional full-duplex communication for sending both client requests and server responses simultaneously.</span></span>
- <span data-ttu-id="16116-129">内置流式处理，支持对异步流大型数据集的请求和响应。</span><span class="sxs-lookup"><span data-stu-id="16116-129">Built-in streaming enabling requests and responses to asynchronously stream large data sets.</span></span>

<span data-ttu-id="16116-130">gRPC 重量轻，性能高。</span><span class="sxs-lookup"><span data-stu-id="16116-130">gRPC is lightweight and highly performant.</span></span> <span data-ttu-id="16116-131">与 JSON 序列化相比，其速度可能高达 8 倍，消息小 60-80%。</span><span class="sxs-lookup"><span data-stu-id="16116-131">It can be up to 8x faster than JSON serialization with messages 60-80% smaller.</span></span> <span data-ttu-id="16116-132">用微软[视窗通信基金会（WCF）](https://docs.microsoft.com/dotnet/framework/wcf/whats-wcf)的话说，gRPC性能超过了高度优化的[NetTCP绑定](https://docs.microsoft.com/dotnet/api/system.servicemodel.nettcpbinding?view=netframework-4.8)的速度和效率。</span><span class="sxs-lookup"><span data-stu-id="16116-132">In Microsoft [Windows Communication Foundation (WCF)](https://docs.microsoft.com/dotnet/framework/wcf/whats-wcf) parlance, gRPC performance exceeds the speed and efficiency of the highly optimized [NetTCP bindings](https://docs.microsoft.com/dotnet/api/system.servicemodel.nettcpbinding?view=netframework-4.8).</span></span> <span data-ttu-id="16116-133">与支持微软堆栈的 NetTCP 不同，gRPC 是跨平台的。</span><span class="sxs-lookup"><span data-stu-id="16116-133">Unlike NetTCP, which favors the Microsoft stack, gRPC is cross-platform.</span></span>

## <a name="protocol-buffers"></a><span data-ttu-id="16116-134">协议缓冲区</span><span class="sxs-lookup"><span data-stu-id="16116-134">Protocol Buffers</span></span>

<span data-ttu-id="16116-135">gRPC 采用一种称为[协议缓冲区的](https://developers.google.com/protocol-buffers/docs/overview)开源技术。</span><span class="sxs-lookup"><span data-stu-id="16116-135">gRPC embraces an open-source technology called [Protocol Buffers](https://developers.google.com/protocol-buffers/docs/overview).</span></span> <span data-ttu-id="16116-136">它们为序列化服务相互发送的结构化消息提供了高效且平台中立的序列化格式。</span><span class="sxs-lookup"><span data-stu-id="16116-136">They provide a highly efficient and platform-neutral serialization format for serializing structured messages that services send to each other.</span></span> <span data-ttu-id="16116-137">使用跨平台接口定义语言 （IDL），开发人员为每个微服务定义服务协定。</span><span class="sxs-lookup"><span data-stu-id="16116-137">Using a cross-platform Interface Definition Language (IDL), developers define a service contract for each microservice.</span></span> <span data-ttu-id="16116-138">协定作为基于`.proto`文本的文件实现，描述每个服务的方法、输入和输出。</span><span class="sxs-lookup"><span data-stu-id="16116-138">The contract, implemented as a text-based `.proto` file, describes the methods, inputs, and outputs for each service.</span></span> <span data-ttu-id="16116-139">相同的合同文件可用于在不同开发平台上构建的 gRPC 客户端和服务。</span><span class="sxs-lookup"><span data-stu-id="16116-139">The same contract file can be used for gRPC clients and services built on different development platforms.</span></span>

<span data-ttu-id="16116-140">使用 proto 文件 Protobuf 编译器`protoc`，为您的目标平台生成客户端和服务代码。</span><span class="sxs-lookup"><span data-stu-id="16116-140">Using the proto file, the Protobuf compiler, `protoc`, generates both client and service code for your target platform.</span></span> <span data-ttu-id="16116-141">该代码包括以下组件：</span><span class="sxs-lookup"><span data-stu-id="16116-141">The code includes the following components:</span></span>

- <span data-ttu-id="16116-142">由客户端和服务共享的强类型对象，表示消息的服务操作和数据元素。</span><span class="sxs-lookup"><span data-stu-id="16116-142">Strongly-typed objects, shared by the client and service, that represent the service operations and data elements for a message.</span></span>
- <span data-ttu-id="16116-143">具有远程 gRPC 服务可以继承和扩展所需的网络管道的强类型基类。</span><span class="sxs-lookup"><span data-stu-id="16116-143">A strongly-typed base class with the required network plumbing that the remote gRPC service can inherit and extend.</span></span>
- <span data-ttu-id="16116-144">包含调用远程 gRPC 服务所需的管道的客户端存根。</span><span class="sxs-lookup"><span data-stu-id="16116-144">A client stub that contains the required plumbing to invoke the remote gRPC service.</span></span>

<span data-ttu-id="16116-145">在运行时，每条消息都序列化为标准 Protobuf 表示形式，并在客户端和远程服务之间交换。</span><span class="sxs-lookup"><span data-stu-id="16116-145">At runtime, each message is serialized as a standard Protobuf representation and exchanged between the client and remote service.</span></span> <span data-ttu-id="16116-146">与 JSON 或 XML 不同，Protobuf 消息被序列化为编译的二进制字节。</span><span class="sxs-lookup"><span data-stu-id="16116-146">Unlike JSON or XML, Protobuf messages are serialized as compiled binary bytes.</span></span>

<span data-ttu-id="16116-147">该书名为[gRPC，适用于 WCF 开发人员](https://docs.microsoft.com/dotnet/architecture/grpc-for-wcf-developers/)，可从 Microsoft 体系结构网站获得，提供 gRPC 和协议缓冲区的深入覆盖。</span><span class="sxs-lookup"><span data-stu-id="16116-147">The book, [gRPC for WCF Developers](https://docs.microsoft.com/dotnet/architecture/grpc-for-wcf-developers/), available from the Microsoft Architecture site, provides in-depth coverage of gRPC and Protocol Buffers.</span></span>

## <a name="grpc-support-in-net"></a><span data-ttu-id="16116-148">gRPC 支持 .NET</span><span class="sxs-lookup"><span data-stu-id="16116-148">gRPC support in .NET</span></span>

<span data-ttu-id="16116-149">gRPC 集成到 .NET 核心 3.0 SDK 或更高版本中。</span><span class="sxs-lookup"><span data-stu-id="16116-149">gRPC is integrated into .NET Core 3.0 SDK or later.</span></span> <span data-ttu-id="16116-150">以下工具支持它：</span><span class="sxs-lookup"><span data-stu-id="16116-150">The following tools support it:</span></span>

- <span data-ttu-id="16116-151">Visual Studio 2019，版本 16.3 或更高版本，安装了 Web 开发工作负载。</span><span class="sxs-lookup"><span data-stu-id="16116-151">Visual Studio 2019, version 16.3 or later, with the web development workload installed.</span></span>
- <span data-ttu-id="16116-152">Visual Studio Code</span><span class="sxs-lookup"><span data-stu-id="16116-152">Visual Studio Code</span></span>
- <span data-ttu-id="16116-153">点网 CLI</span><span class="sxs-lookup"><span data-stu-id="16116-153">the dotnet CLI</span></span>

<span data-ttu-id="16116-154">SDK 包括用于端点路由、内置 IoC 和日志记录的工具。</span><span class="sxs-lookup"><span data-stu-id="16116-154">The SDK includes tooling for endpoint routing, built-in IoC, and logging.</span></span> <span data-ttu-id="16116-155">开源 Kestrel Web 服务器支持 HTTP/2 连接。</span><span class="sxs-lookup"><span data-stu-id="16116-155">The open-source Kestrel web server supports HTTP/2 connections.</span></span> <span data-ttu-id="16116-156">图 4-20 显示了 Visual Studio 2019 模板，该模板为 gRPC 服务的脚架式骨架项目提供了支架。</span><span class="sxs-lookup"><span data-stu-id="16116-156">Figure 4-20 shows a Visual Studio 2019 template that scaffolds a skeleton project for a gRPC service.</span></span> <span data-ttu-id="16116-157">请注意 .NET Core 如何完全支持 Windows、Linux 和 macOS。</span><span class="sxs-lookup"><span data-stu-id="16116-157">Note how .NET Core fully supports Windows, Linux, and macOS.</span></span>

![gRPC 支持视觉工作室 2019](./media/visual-studio-2019-grpc-template.png)

<span data-ttu-id="16116-159">图 4-20\*\*\*\*。</span><span class="sxs-lookup"><span data-stu-id="16116-159">**Figure 4-20**.</span></span> <span data-ttu-id="16116-160">gRPC 支持视觉工作室 2019</span><span class="sxs-lookup"><span data-stu-id="16116-160">gRPC support in Visual Studio 2019</span></span>
  
<span data-ttu-id="16116-161">图 4-21 显示了从 Visual Studio 2019 中包含的内置基架生成的骨架 gRPC 服务。</span><span class="sxs-lookup"><span data-stu-id="16116-161">Figure 4-21 shows the skeleton gRPC service generated from the built-in scaffolding included in Visual Studio 2019.</span></span>  

![gRPC 项目在视觉工作室 2019](./media/grpc-project.png  )

<span data-ttu-id="16116-163">图 4-21\*\*\*\*。</span><span class="sxs-lookup"><span data-stu-id="16116-163">**Figure 4-21**.</span></span> <span data-ttu-id="16116-164">gRPC 项目在视觉工作室 2019</span><span class="sxs-lookup"><span data-stu-id="16116-164">gRPC project in Visual Studio 2019</span></span>

<span data-ttu-id="16116-165">在上图中，请注意原型描述文件和服务代码。</span><span class="sxs-lookup"><span data-stu-id="16116-165">In the previous figure, note the proto description file and service code.</span></span> <span data-ttu-id="16116-166">正如您稍后看到的，Visual Studio 会在启动类和基础项目文件中生成其他配置。</span><span class="sxs-lookup"><span data-stu-id="16116-166">As you'll see shortly, Visual Studio generates additional configuration in both the Startup class and underlying project file.</span></span>

## <a name="grpc-usage"></a><span data-ttu-id="16116-167">gRPC 使用情况</span><span class="sxs-lookup"><span data-stu-id="16116-167">gRPC usage</span></span>

<span data-ttu-id="16116-168">以下方案有利于 gRPC：</span><span class="sxs-lookup"><span data-stu-id="16116-168">Favor gRPC for the following scenarios:</span></span>

- <span data-ttu-id="16116-169">同步后端微服务到微服务通信，需要立即响应才能继续处理。</span><span class="sxs-lookup"><span data-stu-id="16116-169">Synchronous backend microservice-to-microservice communication where an immediate response is required to continue processing.</span></span>
- <span data-ttu-id="16116-170">需要支持混合编程平台的多面体环境。</span><span class="sxs-lookup"><span data-stu-id="16116-170">Polyglot environments that need to support mixed programming platforms.</span></span>
- <span data-ttu-id="16116-171">低延迟和高吞吐量通信，其中性能至关重要。</span><span class="sxs-lookup"><span data-stu-id="16116-171">Low latency and high throughput communication where performance is critical.</span></span>
- <span data-ttu-id="16116-172">点对点实时通信 - gRPC 无需轮询即可实时推送消息，并且对双向流流具有出色的支持。</span><span class="sxs-lookup"><span data-stu-id="16116-172">Point-to-point real-time communication - gRPC can push messages in real time without polling and has excellent support for bi-directional streaming.</span></span>
- <span data-ttu-id="16116-173">网络受限环境 – 二进制 gRPC 消息始终小于等效的基于文本的 JSON 消息。</span><span class="sxs-lookup"><span data-stu-id="16116-173">Network constrained environments – binary gRPC messages are always smaller than an equivalent text-based JSON message.</span></span>

<span data-ttu-id="16116-174">在撰写本文时，gRPC 主要用于后端服务。</span><span class="sxs-lookup"><span data-stu-id="16116-174">At the time, of this writing, gRPC is primarily used with backend services.</span></span> <span data-ttu-id="16116-175">大多数现代浏览器无法提供支持前端 gRPC 客户端所需的 HTTP/2 控制级别。</span><span class="sxs-lookup"><span data-stu-id="16116-175">Most modern browsers can't provide the level of HTTP/2 control required to support a front-end gRPC client.</span></span> <span data-ttu-id="16116-176">也就是说，有一[个早期计划](https://devblogs.microsoft.com/aspnet/grpc-web-experiment/)，支持 gRPC 通信从基于浏览器的应用程序构建与 JavaScript 或 Blazor WebAssembly 技术。</span><span class="sxs-lookup"><span data-stu-id="16116-176">That said, there's an [early initiative](https://devblogs.microsoft.com/aspnet/grpc-web-experiment/) that enables gRPC communication from browser-based apps built with JavaScript or Blazor WebAssembly technologies.</span></span> <span data-ttu-id="16116-177">[gRPC-Web 表示 .NET，](https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md)支持ASP.NET核心 gRPC 应用，以支持浏览器应用中的 gRPC 功能：</span><span class="sxs-lookup"><span data-stu-id="16116-177">The  [gRPC-Web for .NET](https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md) enables an ASP.NET Core gRPC app to support gRPC features in browser apps:</span></span>

- <span data-ttu-id="16116-178">强类型代码生成的客户端</span><span class="sxs-lookup"><span data-stu-id="16116-178">Strongly-typed code-generated clients</span></span>
- <span data-ttu-id="16116-179">紧凑型 Protobuf 消息</span><span class="sxs-lookup"><span data-stu-id="16116-179">Compact Protobuf messages</span></span>
- <span data-ttu-id="16116-180">服务器流式处理</span><span class="sxs-lookup"><span data-stu-id="16116-180">Server streaming</span></span>

## <a name="grpc-implementation"></a><span data-ttu-id="16116-181">gRPC 实现</span><span class="sxs-lookup"><span data-stu-id="16116-181">gRPC implementation</span></span>

<span data-ttu-id="16116-182">微软的微服务参考体系结构[，即容器上的eShop，](https://github.com/dotnet-architecture/eShopOnContainers)展示了如何在 .NET Core 应用程序中实现 gRPC 服务。</span><span class="sxs-lookup"><span data-stu-id="16116-182">The microservice reference architecture, [eShop on Containers](https://github.com/dotnet-architecture/eShopOnContainers), from Microsoft, shows how to implement gRPC services in .NET Core applications.</span></span> <span data-ttu-id="16116-183">图 4-22 显示了后端体系结构。</span><span class="sxs-lookup"><span data-stu-id="16116-183">Figure 4-22 presents the back-end architecture.</span></span>

![容器上 eShop 的后端体系结构](./media/eshop-with-aggregators.png)

<span data-ttu-id="16116-185">**图 4-22**。</span><span class="sxs-lookup"><span data-stu-id="16116-185">**Figure 4-22**.</span></span> <span data-ttu-id="16116-186">容器上 eShop 的后端体系结构</span><span class="sxs-lookup"><span data-stu-id="16116-186">Backend architecture for eShop on Containers</span></span>

<span data-ttu-id="16116-187">在上图中，请注意 eShop 如何通过公开多个 API 网关来拥抱[前端模式](https://docs.microsoft.com/azure/architecture/patterns/backends-for-frontends)（BFF） 的后端。</span><span class="sxs-lookup"><span data-stu-id="16116-187">In the previous figure, note how eShop embraces the [Backend for Frontends pattern](https://docs.microsoft.com/azure/architecture/patterns/backends-for-frontends) (BFF) by exposing multiple API gateways.</span></span> <span data-ttu-id="16116-188">本章前面讨论了 BFF 模式。</span><span class="sxs-lookup"><span data-stu-id="16116-188">We discussed the BFF pattern earlier in this chapter.</span></span> <span data-ttu-id="16116-189">密切关注位于 Web 购物 API 网关和后端购物微服务之间的聚合器微服务（灰色）。</span><span class="sxs-lookup"><span data-stu-id="16116-189">Pay close attention to the Aggregator microservice (in gray) that sits between the Web-Shopping API Gateway and backend Shopping microservices.</span></span> <span data-ttu-id="16116-190">聚合器接收来自客户端的单个请求，将其调度到各种微服务，聚合结果，并将它们发送回请求客户端。</span><span class="sxs-lookup"><span data-stu-id="16116-190">The Aggregator receives a single request from a client, dispatches it to various microservices, aggregates the results, and sends them back to the requesting client.</span></span> <span data-ttu-id="16116-191">此类操作通常需要同步通信才能立即产生响应。</span><span class="sxs-lookup"><span data-stu-id="16116-191">Such operations typically require synchronous communication as to produce an immediate response.</span></span> <span data-ttu-id="16116-192">在 eShop 中，聚合器的后端调用使用 gRPC 执行，如图 4-23 所示。</span><span class="sxs-lookup"><span data-stu-id="16116-192">In eShop, backend calls from the Aggregator are performed using gRPC as shown in Figure 4-23.</span></span>

![gRPC 在容器上的 eShop 中](./media/grpc-implementation.png)

<span data-ttu-id="16116-194">图 4-23\*\*\*\*。</span><span class="sxs-lookup"><span data-stu-id="16116-194">**Figure 4-23**.</span></span> <span data-ttu-id="16116-195">gRPC 在容器上的 eShop 中</span><span class="sxs-lookup"><span data-stu-id="16116-195">gRPC in eShop on Containers</span></span>

<span data-ttu-id="16116-196">gRPC 通信需要客户端和服务器组件。</span><span class="sxs-lookup"><span data-stu-id="16116-196">gRPC communication requires both client and server components.</span></span> <span data-ttu-id="16116-197">在上图中，请注意购物聚合器如何实现 gRPC 客户端。</span><span class="sxs-lookup"><span data-stu-id="16116-197">In the previous figure, note how the Shopping Aggregator implements a gRPC client.</span></span> <span data-ttu-id="16116-198">客户端对后端微服务进行同步 gRPC 调用（红色），每个微服务都实现 gRPC 服务器。</span><span class="sxs-lookup"><span data-stu-id="16116-198">The client makes synchronous gRPC calls (in red) to backend microservices, each of which implement a gRPC server.</span></span> <span data-ttu-id="16116-199">客户端和服务器都利用了 .NET Core 3.0 SDK 的内置 gRPC 管道。</span><span class="sxs-lookup"><span data-stu-id="16116-199">Both the client and server take advantage of the built-in gRPC plumbing from the .NET Core 3.0 SDK.</span></span> <span data-ttu-id="16116-200">客户端*存根*提供调用远程 gRPC 调用的管道。</span><span class="sxs-lookup"><span data-stu-id="16116-200">Client-side *stubs* provide the plumbing to invoke remote gRPC calls.</span></span> <span data-ttu-id="16116-201">服务器端组件提供自定义服务类可以继承和使用 gRPC 管道。</span><span class="sxs-lookup"><span data-stu-id="16116-201">Server-side components provide gRPC plumbing that custom service classes can inherit and consume.</span></span>

<span data-ttu-id="16116-202">公开 RESTful API 和 gRPC 通信的微服务需要多个终结点来管理流量。</span><span class="sxs-lookup"><span data-stu-id="16116-202">Microservices that expose both a RESTful API and gRPC communication require multiple endpoints to manage traffic.</span></span> <span data-ttu-id="16116-203">您将打开一个终结点，用于侦听呼叫的 HTTP 流量，为 gRPC 调用打开另一个终结点。</span><span class="sxs-lookup"><span data-stu-id="16116-203">You would open an endpoint that listens for HTTP traffic for the RESTful calls and another for gRPC calls.</span></span> <span data-ttu-id="16116-204">gRPC 终结点必须配置为 gRPC 通信所需的 HTTP/2 协议。</span><span class="sxs-lookup"><span data-stu-id="16116-204">The gRPC endpoint must be configured for the HTTP/2 protocol that is required for gRPC communication.</span></span>

<span data-ttu-id="16116-205">尽管我们努力使微服务与异步通信模式分离，但某些操作需要直接调用。</span><span class="sxs-lookup"><span data-stu-id="16116-205">While we strive to decouple microservices with asynchronous communication patterns, some operations require direct calls.</span></span> <span data-ttu-id="16116-206">gRPC 应该是微服务之间直接同步通信的主要选择。</span><span class="sxs-lookup"><span data-stu-id="16116-206">gRPC should be the primary choice for direct synchronous communication between microservices.</span></span> <span data-ttu-id="16116-207">基于 HTTP/2 和协议缓冲区的高性能通信协议使其成为一个完美的选择。</span><span class="sxs-lookup"><span data-stu-id="16116-207">Its high-performance communication protocol, based on HTTP/2 and protocol buffers, make it a perfect choice.</span></span>

## <a name="looking-ahead"></a><span data-ttu-id="16116-208">展望未来</span><span class="sxs-lookup"><span data-stu-id="16116-208">Looking ahead</span></span>

<span data-ttu-id="16116-209">展望未来，gRPC 将继续为云本机系统赢得牵引力。</span><span class="sxs-lookup"><span data-stu-id="16116-209">Looking ahead, gRPC will continue to gain traction for cloud-native systems.</span></span> <span data-ttu-id="16116-210">性能优势和易于开发是引人注目的。</span><span class="sxs-lookup"><span data-stu-id="16116-210">The performance benefits and ease of development are compelling.</span></span> <span data-ttu-id="16116-211">但是，REST 可能会出现很长时间。</span><span class="sxs-lookup"><span data-stu-id="16116-211">However, REST will likely be around for a long time.</span></span> <span data-ttu-id="16116-212">它擅长公开公开的 API 和向后兼容性原因。</span><span class="sxs-lookup"><span data-stu-id="16116-212">It excels for publicly exposed APIs and for backward compatibility reasons.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="16116-213">[上一个](service-to-service-communication.md)
>[下一个](service-mesh-communication-infrastructure.md)</span><span class="sxs-lookup"><span data-stu-id="16116-213">[Previous](service-to-service-communication.md)
[Next](service-mesh-communication-infrastructure.md)</span></span>
