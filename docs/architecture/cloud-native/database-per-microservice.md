---
title: 每个微服务的数据库
description: 对比单片和云原生应用程序中的数据存储。
author: robvet
ms.date: 01/22/2020
ms.openlocfilehash: c0c5611fa866d70f155e4bdad2eee1181b13c065
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/12/2020
ms.locfileid: "79141440"
---
# <a name="database-per-microservice"></a><span data-ttu-id="85b9b-103">每个微服务的数据库</span><span class="sxs-lookup"><span data-stu-id="85b9b-103">Database-per-microservice</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="85b9b-104">正如我们在本书中所看到的，云原生方法改变了设计、部署和管理应用程序的方式。</span><span class="sxs-lookup"><span data-stu-id="85b9b-104">As we've seen throughout this book, a cloud-native approach changes the way you design, deploy, and manage applications.</span></span> <span data-ttu-id="85b9b-105">它还会更改管理和存储数据的方式。</span><span class="sxs-lookup"><span data-stu-id="85b9b-105">It also changes the way you manage and store data.</span></span>

<span data-ttu-id="85b9b-106">图 5-1 对比了差异。</span><span class="sxs-lookup"><span data-stu-id="85b9b-106">Figure 5-1 contrasts the differences.</span></span>

![云原生应用程序中的数据存储](./media/distributed-data.png)

<span data-ttu-id="85b9b-108">**图5-1**.</span><span class="sxs-lookup"><span data-stu-id="85b9b-108">**Figure 5-1**.</span></span> <span data-ttu-id="85b9b-109">云原生应用程序中的数据管理</span><span class="sxs-lookup"><span data-stu-id="85b9b-109">Data management in cloud-native applications</span></span>

<span data-ttu-id="85b9b-110">有经验的开发人员将很容易识别图 5-1 左侧的体系结构。</span><span class="sxs-lookup"><span data-stu-id="85b9b-110">Experienced developers will easily recognize the architecture on the left-side of figure 5-1.</span></span> <span data-ttu-id="85b9b-111">在此*单片应用程序中*，业务服务组件在共享服务层中组合在一起，共享来自单个关系数据库的数据。</span><span class="sxs-lookup"><span data-stu-id="85b9b-111">In this *monolithic application*, business service components collocate together in a shared services tier, sharing data from a single relational database.</span></span>

<span data-ttu-id="85b9b-112">在许多方面，单个数据库使数据管理变得简单。</span><span class="sxs-lookup"><span data-stu-id="85b9b-112">In many ways, a single database keeps data management simple.</span></span> <span data-ttu-id="85b9b-113">跨多个表查询数据非常简单。</span><span class="sxs-lookup"><span data-stu-id="85b9b-113">Querying data across multiple tables is straightforward.</span></span> <span data-ttu-id="85b9b-114">对数据所做的更改一起更新，或者它们全部回滚。</span><span class="sxs-lookup"><span data-stu-id="85b9b-114">Changes to data update together or they all rollback.</span></span> <span data-ttu-id="85b9b-115">[ACID 交易](https://docs.microsoft.com/windows/desktop/cossdk/acid-properties)保证强和即时的一致性。</span><span class="sxs-lookup"><span data-stu-id="85b9b-115">[ACID transactions](https://docs.microsoft.com/windows/desktop/cossdk/acid-properties) guarantee strong and immediate consistency.</span></span>

<span data-ttu-id="85b9b-116">为云原生设计，我们采取了不同的方法。</span><span class="sxs-lookup"><span data-stu-id="85b9b-116">Designing for cloud-native, we take a different approach.</span></span> <span data-ttu-id="85b9b-117">在图 5-1 的右侧，请注意业务功能如何隔离到小型的独立微服务中。</span><span class="sxs-lookup"><span data-stu-id="85b9b-117">On the right-side of Figure 5-1, note how business functionality segregates into small, independent microservices.</span></span> <span data-ttu-id="85b9b-118">每个微服务封装特定的业务功能及其自己的数据。</span><span class="sxs-lookup"><span data-stu-id="85b9b-118">Each microservice encapsulates a specific business capability and its own data.</span></span> <span data-ttu-id="85b9b-119">单片数据库分解为具有许多较小数据库的分布式数据模型，每个数据库都与微服务对齐。</span><span class="sxs-lookup"><span data-stu-id="85b9b-119">The monolithic database decomposes into a distributed data model with many smaller databases, each aligning with a microservice.</span></span> <span data-ttu-id="85b9b-120">当烟雾清除时，我们出现了一个设计，它公开*了每个微服务的数据库*。</span><span class="sxs-lookup"><span data-stu-id="85b9b-120">When the smoke clears, we emerge with a design that exposes a *database per microservice*.</span></span>

## <a name="why"></a><span data-ttu-id="85b9b-121">为什么？</span><span class="sxs-lookup"><span data-stu-id="85b9b-121">Why?</span></span>

<span data-ttu-id="85b9b-122">每个微服务的此数据库提供了许多好处，尤其是对于必须快速发展并支持大规模扩展的系统。</span><span class="sxs-lookup"><span data-stu-id="85b9b-122">This database per microservice provides many benefits, especially for systems that must evolve rapidly and support massive scale.</span></span> <span data-ttu-id="85b9b-123">使用此模型...</span><span class="sxs-lookup"><span data-stu-id="85b9b-123">With this model...</span></span>

- <span data-ttu-id="85b9b-124">域数据封装在服务中</span><span class="sxs-lookup"><span data-stu-id="85b9b-124">Domain data is encapsulated within the service</span></span>
- <span data-ttu-id="85b9b-125">数据架构可以在不影响其他服务的情况下发展</span><span class="sxs-lookup"><span data-stu-id="85b9b-125">Data schema can evolve without directly impacting other services</span></span>
- <span data-ttu-id="85b9b-126">每个数据存储可以独立扩展</span><span class="sxs-lookup"><span data-stu-id="85b9b-126">Each data store can independently scale</span></span>
- <span data-ttu-id="85b9b-127">一个服务中的数据存储故障不会直接影响其他服务</span><span class="sxs-lookup"><span data-stu-id="85b9b-127">A data store failure in one service won't directly impact other services</span></span>

<span data-ttu-id="85b9b-128">隔离数据还使每个微服务能够实现最适合其工作负载、存储需求和读/写模式的数据存储类型。</span><span class="sxs-lookup"><span data-stu-id="85b9b-128">Segregating data also enables each microservice to implement the data store type that is best optimized for its workload, storage needs, and read/write patterns.</span></span> <span data-ttu-id="85b9b-129">选项包括关系、文档、键值，甚至基于图形的数据存储。</span><span class="sxs-lookup"><span data-stu-id="85b9b-129">Choices include relational, document, key-value, and even graph-based data stores.</span></span>

<span data-ttu-id="85b9b-130">图 5-2 介绍了云本机系统中多面体持久性的原则。</span><span class="sxs-lookup"><span data-stu-id="85b9b-130">Figure 5-2 presents the principle of polyglot persistence in a cloud-native system.</span></span>

![多格洛特数据持久性](./media/polyglot-data-persistence.png)

<span data-ttu-id="85b9b-132">**图5-2**.</span><span class="sxs-lookup"><span data-stu-id="85b9b-132">**Figure 5-2**.</span></span> <span data-ttu-id="85b9b-133">多格洛特数据持久性</span><span class="sxs-lookup"><span data-stu-id="85b9b-133">Polyglot data persistence</span></span>

<span data-ttu-id="85b9b-134">请注意，在上图中，每个微服务如何支持不同类型的数据存储。</span><span class="sxs-lookup"><span data-stu-id="85b9b-134">Note in the previous figure how each microservice supports a different type of data store.</span></span>

- <span data-ttu-id="85b9b-135">产品目录微服务使用关系数据库来容纳其基础数据的丰富关系结构。</span><span class="sxs-lookup"><span data-stu-id="85b9b-135">The product catalog microservice consumes a relational database to accommodate the rich relational structure of its underlying data.</span></span>
- <span data-ttu-id="85b9b-136">购物车微服务使用支持其简单、键值数据存储的分布式缓存。</span><span class="sxs-lookup"><span data-stu-id="85b9b-136">The shopping cart microservice consumes a distributed cache that supports its simple, key-value data store.</span></span>
- <span data-ttu-id="85b9b-137">订购微服务既使用 NoSql 文档数据库进行写入操作，也使用高度非规范化的密钥/值存储，以适应大量读取操作。</span><span class="sxs-lookup"><span data-stu-id="85b9b-137">The ordering microservice consumes both a NoSql document database for write operations along with a highly denormalized key/value store to accommodate high-volumes of read operations.</span></span>
  
<span data-ttu-id="85b9b-138">虽然关系数据库与具有复杂数据的微服务仍然相关，但 NoSQL 数据库已获得相当普及。</span><span class="sxs-lookup"><span data-stu-id="85b9b-138">While relational databases remain relevant for microservices with complex data, NoSQL databases have gained considerable popularity.</span></span> <span data-ttu-id="85b9b-139">它们提供大规模和高可用性。</span><span class="sxs-lookup"><span data-stu-id="85b9b-139">They provide massive scale and high availability.</span></span> <span data-ttu-id="85b9b-140">其无架构特性允许开发人员摆脱类型化数据类和 ORM 的体系结构，使更改变得昂贵且耗时。</span><span class="sxs-lookup"><span data-stu-id="85b9b-140">Their schemaless nature allows developers to move away from an architecture of typed data classes and ORMs that make change expensive and time-consuming.</span></span> <span data-ttu-id="85b9b-141">本章后面我们将介绍 NoSQL 数据库。</span><span class="sxs-lookup"><span data-stu-id="85b9b-141">We cover NoSQL databases later in this chapter.</span></span>

 <span data-ttu-id="85b9b-142">虽然将数据封装到单独的微服务中可以提高敏捷性、性能和可扩展性，但它也带来了许多挑战。</span><span class="sxs-lookup"><span data-stu-id="85b9b-142">While encapsulating  data into separate microservices can increase agility, performance, and scalability, it also presents many challenges.</span></span> <span data-ttu-id="85b9b-143">在下一节中，我们将讨论这些挑战以及帮助克服这些挑战的模式和实践。</span><span class="sxs-lookup"><span data-stu-id="85b9b-143">In the next section, we discuss these challenges along with patterns and practices to help overcome them.</span></span>  

## <a name="cross-service-queries"></a><span data-ttu-id="85b9b-144">跨服务查询</span><span class="sxs-lookup"><span data-stu-id="85b9b-144">Cross-service queries</span></span>

<span data-ttu-id="85b9b-145">虽然微服务是独立的，并且侧重于特定的功能功能，如库存、发货或订购，但它们通常需要与其他微服务集成。</span><span class="sxs-lookup"><span data-stu-id="85b9b-145">While microservices are independent and focus on specific functional capabilities, like inventory, shipping, or ordering, they frequently require integration with other microservices.</span></span> <span data-ttu-id="85b9b-146">通常，集成涉及一个微服务*查询*另一个微服务的数据。</span><span class="sxs-lookup"><span data-stu-id="85b9b-146">Often the integration involves one microservice *querying* another for data.</span></span> <span data-ttu-id="85b9b-147">图 5-3 显示了方案。</span><span class="sxs-lookup"><span data-stu-id="85b9b-147">Figure 5-3 shows the scenario.</span></span>

![跨微服务查询](./media/cross-service-query.png)

<span data-ttu-id="85b9b-149">**图5-3**.</span><span class="sxs-lookup"><span data-stu-id="85b9b-149">**Figure 5-3**.</span></span> <span data-ttu-id="85b9b-150">跨微服务查询</span><span class="sxs-lookup"><span data-stu-id="85b9b-150">Querying across microservices</span></span>

<span data-ttu-id="85b9b-151">在上图中，我们看到一个购物篮微服务，将商品添加到用户的购物篮中。</span><span class="sxs-lookup"><span data-stu-id="85b9b-151">In the preceding figure, we see a shopping basket microservice that adds an item to a user's shopping basket.</span></span> <span data-ttu-id="85b9b-152">虽然此微服务的数据存储包含购物篮和行项目数据，但它不维护产品或定价数据。</span><span class="sxs-lookup"><span data-stu-id="85b9b-152">While the data store for this microservice contains basket and line item data, it doesn't maintain product or pricing data.</span></span> <span data-ttu-id="85b9b-153">相反，这些数据项归目录所有，并定价微服务。</span><span class="sxs-lookup"><span data-stu-id="85b9b-153">Instead, those data items are owned by the catalog and pricing microservices.</span></span> <span data-ttu-id="85b9b-154">这带来了一个问题。</span><span class="sxs-lookup"><span data-stu-id="85b9b-154">This presents a problem.</span></span> <span data-ttu-id="85b9b-155">购物篮微服务如何在用户没有产品或定价数据的情况下将产品添加到用户的购物篮中？</span><span class="sxs-lookup"><span data-stu-id="85b9b-155">How can the shopping basket microservice add a product to the user's shopping basket when it doesn't have product nor pricing data in its database?</span></span>

<span data-ttu-id="85b9b-156">第 4 章中讨论的一个选项是从购物篮[直接调用目录](service-to-service-communication.md#queries)和定价微服务。</span><span class="sxs-lookup"><span data-stu-id="85b9b-156">One option discussed in Chapter 4 is a [direct HTTP call](service-to-service-communication.md#queries) from the shopping basket to the catalog and pricing microservices.</span></span> <span data-ttu-id="85b9b-157">但是，在第 4 章中，我们说过同步 HTTP 将*微服务调用在*一起，从而降低了它们的自主性并降低了它们的体系结构优势。</span><span class="sxs-lookup"><span data-stu-id="85b9b-157">However, in chapter 4, we said synchronous HTTP calls *couple* microservices together, reducing their autonomy and diminishing their architectural benefits.</span></span>

<span data-ttu-id="85b9b-158">我们还可以实现请求-答复模式，为每个服务分别提供入站和出站队列。</span><span class="sxs-lookup"><span data-stu-id="85b9b-158">We could also implement a request-reply pattern with separate inbound and outbound queues for each service.</span></span> <span data-ttu-id="85b9b-159">但是，此模式很复杂，需要管道来关联请求和响应消息。</span><span class="sxs-lookup"><span data-stu-id="85b9b-159">However, this pattern is complicated and requires plumbing to correlate request and response messages.</span></span>
<span data-ttu-id="85b9b-160">虽然它确实分离后端微服务呼叫，但呼叫服务仍必须同步等待呼叫完成。</span><span class="sxs-lookup"><span data-stu-id="85b9b-160">While it does decouple the backend microservice calls, the calling service must still synchronously wait for the call to complete.</span></span> <span data-ttu-id="85b9b-161">网络拥塞、瞬态故障或超载微服务，可能导致长时间运行甚至失败的操作。</span><span class="sxs-lookup"><span data-stu-id="85b9b-161">Network congestion, transient faults, or an overloaded microservice and can result in long-running and even failed operations.</span></span>

<span data-ttu-id="85b9b-162">相反，一个被广泛接受的删除跨服务依赖项的模式是[具体化视图模式](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)，如图 5-4 所示。</span><span class="sxs-lookup"><span data-stu-id="85b9b-162">Instead, a widely accepted pattern for removing cross-service dependencies is the [Materialized View Pattern](https://docs.microsoft.com/azure/architecture/patterns/materialized-view), shown in Figure 5-4.</span></span>

![具体化视图模式](./media/materialized-view-pattern.png)

<span data-ttu-id="85b9b-164">**图5-4**。</span><span class="sxs-lookup"><span data-stu-id="85b9b-164">**Figure 5-4**.</span></span> <span data-ttu-id="85b9b-165">具体化视图模式</span><span class="sxs-lookup"><span data-stu-id="85b9b-165">Materialized View Pattern</span></span>

<span data-ttu-id="85b9b-166">使用此模式，您将本地数据表（称为*读取模型*）放在购物篮服务中。</span><span class="sxs-lookup"><span data-stu-id="85b9b-166">With this pattern, you place a local data table (known as a *read model*) in the shopping basket service.</span></span> <span data-ttu-id="85b9b-167">此表包含产品和定价微服务所需的数据的非规范化副本。</span><span class="sxs-lookup"><span data-stu-id="85b9b-167">This table contains a denormalized copy of the data needed from the product and pricing microservices.</span></span> <span data-ttu-id="85b9b-168">将数据直接复制到购物篮微服务中，无需昂贵的跨服务呼叫。</span><span class="sxs-lookup"><span data-stu-id="85b9b-168">Copying the data directly into the shopping basket microservice eliminates the need for expensive cross-service calls.</span></span> <span data-ttu-id="85b9b-169">使用服务本地数据，可以提高服务的响应时间和可靠性。</span><span class="sxs-lookup"><span data-stu-id="85b9b-169">With the data local to the service, you improve the service's response time and reliability.</span></span> <span data-ttu-id="85b9b-170">此外，拥有自己的数据副本使购物篮服务更具弹性。</span><span class="sxs-lookup"><span data-stu-id="85b9b-170">Additionally, having its own copy of the data makes the shopping basket service more resilient.</span></span> <span data-ttu-id="85b9b-171">如果目录服务不可用，它不会直接影响购物篮服务。</span><span class="sxs-lookup"><span data-stu-id="85b9b-171">If the catalog service should become unavailable, it wouldn't directly impact the shopping basket service.</span></span> <span data-ttu-id="85b9b-172">购物篮可以继续使用自己商店的数据进行操作。</span><span class="sxs-lookup"><span data-stu-id="85b9b-172">The shopping basket can continue operating with the data from its own store.</span></span>

<span data-ttu-id="85b9b-173">这种方法的问题在于，您现在系统中有重复的数据。</span><span class="sxs-lookup"><span data-stu-id="85b9b-173">The catch with this approach is that you now have duplicate data in your system.</span></span> <span data-ttu-id="85b9b-174">但是，*在*云本机系统中战略性地复制数据是一种既定做法，不被视为反模式或不良做法。</span><span class="sxs-lookup"><span data-stu-id="85b9b-174">However, *strategically* duplicating data in cloud-native systems is an established practice and not considered an anti-pattern, or bad practice.</span></span> <span data-ttu-id="85b9b-175">请记住，*只有一个服务*可以拥有数据集并有权拥有数据集。</span><span class="sxs-lookup"><span data-stu-id="85b9b-175">Keep in mind that *one and only one service* can own a data set and have authority over it.</span></span> <span data-ttu-id="85b9b-176">更新记录系统时，您需要同步读取模型。</span><span class="sxs-lookup"><span data-stu-id="85b9b-176">You'll need to synchronize the read models when the system of record is updated.</span></span> <span data-ttu-id="85b9b-177">同步通常通过具有[发布/订阅模式](service-to-service-communication.md#events)的异步消息实现，如图 5.4 所示。</span><span class="sxs-lookup"><span data-stu-id="85b9b-177">Synchronization is typically implemented via asynchronous messaging with a [publish/subscribe pattern](service-to-service-communication.md#events), as shown in Figure 5.4.</span></span>

## <a name="distributed-transactions"></a><span data-ttu-id="85b9b-178">分布式事务</span><span class="sxs-lookup"><span data-stu-id="85b9b-178">Distributed transactions</span></span>

<span data-ttu-id="85b9b-179">虽然跨微服务查询数据很困难，但跨多个微服务实现事务甚至更为复杂。</span><span class="sxs-lookup"><span data-stu-id="85b9b-179">While querying data across microservices is difficult, implementing a transaction across several microservices is even more complex.</span></span> <span data-ttu-id="85b9b-180">在不同微服务中保持独立数据源的数据一致性的内在挑战怎么强调也不为过。</span><span class="sxs-lookup"><span data-stu-id="85b9b-180">The inherent challenge of maintaining data consistency across independent data sources in different microservices can't be understated.</span></span> <span data-ttu-id="85b9b-181">云原生应用程序中缺少分布式事务意味着您必须以编程方式管理分布式事务。</span><span class="sxs-lookup"><span data-stu-id="85b9b-181">The lack of distributed transactions in cloud-native applications means that you must manage distributed transactions programmatically.</span></span> <span data-ttu-id="85b9b-182">你从一个*即时一致性*的世界走向最终一*致性*的世界。</span><span class="sxs-lookup"><span data-stu-id="85b9b-182">You move from a world of *immediate consistency* to that of *eventual consistency*.</span></span>

<span data-ttu-id="85b9b-183">图 5-5 显示了问题。</span><span class="sxs-lookup"><span data-stu-id="85b9b-183">Figure 5-5 shows the problem.</span></span>

![saga 模式中的事务](./media/saga-transaction-operation.png)

<span data-ttu-id="85b9b-185">**图5-5**.</span><span class="sxs-lookup"><span data-stu-id="85b9b-185">**Figure 5-5**.</span></span> <span data-ttu-id="85b9b-186">跨微服务实现事务</span><span class="sxs-lookup"><span data-stu-id="85b9b-186">Implementing a transaction across microservices</span></span>

<span data-ttu-id="85b9b-187">在上图中，五个独立的微服务参与创建订单的分布式事务。</span><span class="sxs-lookup"><span data-stu-id="85b9b-187">In the preceding figure, five independent microservices participate in a distributed transaction that creates an order.</span></span> <span data-ttu-id="85b9b-188">每个微服务维护自己的数据存储，并为其存储实现本地事务。</span><span class="sxs-lookup"><span data-stu-id="85b9b-188">Each microservice maintains its own data store and implements a local transaction for its store.</span></span> <span data-ttu-id="85b9b-189">要创建订单，*每个*微服务的本地事务必须成功，或者*所有*事务都必须中止和回滚该操作。</span><span class="sxs-lookup"><span data-stu-id="85b9b-189">To create the order, the local transaction for *each* individual microservice must succeed, or *all* must abort and roll back the operation.</span></span> <span data-ttu-id="85b9b-190">虽然每个微服务都提供内置事务支持，但不支持跨所有五个服务的分布式事务来保持数据一致性。</span><span class="sxs-lookup"><span data-stu-id="85b9b-190">While built-in transactional support is available inside each of the microservices, there's no support for a distributed transaction that would span across all five services to keep data consistent.</span></span>

<span data-ttu-id="85b9b-191">相反，您必须*以编程方式*构造此分布式事务。</span><span class="sxs-lookup"><span data-stu-id="85b9b-191">Instead, you must construct this distributed transaction *programmatically*.</span></span>

<span data-ttu-id="85b9b-192">添加分布式事务支持的流行模式是 Saga 模式。</span><span class="sxs-lookup"><span data-stu-id="85b9b-192">A popular pattern for adding distributed transactional support is the Saga pattern.</span></span> <span data-ttu-id="85b9b-193">它通过将本地事务分组到一起以编程和按顺序调用每个事务来实现。</span><span class="sxs-lookup"><span data-stu-id="85b9b-193">It's implemented by grouping local transactions together programmatically and sequentially invoking each one.</span></span> <span data-ttu-id="85b9b-194">如果任何本地事务失败，Saga 将中止该操作并调用一组[补偿事务](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction)。</span><span class="sxs-lookup"><span data-stu-id="85b9b-194">If any of the local transactions fail, the Saga aborts the operation and invokes a set of [compensating transactions](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction).</span></span> <span data-ttu-id="85b9b-195">补偿事务撤消了上述本地事务所做的更改，并还原了数据一致性。</span><span class="sxs-lookup"><span data-stu-id="85b9b-195">The compensating transactions undo the changes made by the preceding local transactions and restore data consistency.</span></span> <span data-ttu-id="85b9b-196">图 5-6 显示了 Saga 模式的失败事务。</span><span class="sxs-lookup"><span data-stu-id="85b9b-196">Figure 5-6 shows a failed transaction with the Saga pattern.</span></span>

![回滚在传奇模式](./media/saga-rollback-operation.png)

<span data-ttu-id="85b9b-198">**图5-6**.</span><span class="sxs-lookup"><span data-stu-id="85b9b-198">**Figure 5-6**.</span></span> <span data-ttu-id="85b9b-199">回滚事务</span><span class="sxs-lookup"><span data-stu-id="85b9b-199">Rolling back a transaction</span></span>

<span data-ttu-id="85b9b-200">在上图中，"*更新清单"* 操作在"清单"微服务中失败。</span><span class="sxs-lookup"><span data-stu-id="85b9b-200">In the previous figure, the *Update Inventory* operation has failed in the Inventory microservice.</span></span> <span data-ttu-id="85b9b-201">Saga 调用一组补偿事务（红色）来调整库存计数、取消付款和订单，并将每个微服务的数据返回到一致状态。</span><span class="sxs-lookup"><span data-stu-id="85b9b-201">The Saga invokes a set of compensating transactions (in red) to adjust the inventory counts, cancel the payment and the order, and return the data for each microservice back to a consistent state.</span></span>

<span data-ttu-id="85b9b-202">Saga 模式通常编排为一系列相关事件，或作为一组相关命令编排。</span><span class="sxs-lookup"><span data-stu-id="85b9b-202">Saga patterns are typically choreographed as a series of related events, or orchestrated as a set of related commands.</span></span> <span data-ttu-id="85b9b-203">在第 4 章中，我们讨论了作为协调的 saga 实现基础的服务聚合器模式。</span><span class="sxs-lookup"><span data-stu-id="85b9b-203">In Chapter 4, we discussed the service aggregator pattern that would be the foundation for an orchestrated saga implementation.</span></span> <span data-ttu-id="85b9b-204">我们还讨论了与 Azure 服务总线和 Azure 事件网格主题一起发生的事件，这些主题将成为精心编排的 saga 实现的基础。</span><span class="sxs-lookup"><span data-stu-id="85b9b-204">We also discussed eventing along with Azure Service Bus and Azure Event Grid topics that would be a foundation for a choreographed saga implementation.</span></span>

## <a name="high-volume-data"></a><span data-ttu-id="85b9b-205">大容量数据</span><span class="sxs-lookup"><span data-stu-id="85b9b-205">High volume data</span></span>

<span data-ttu-id="85b9b-206">大型云原生应用程序通常支持大容量数据要求。</span><span class="sxs-lookup"><span data-stu-id="85b9b-206">Large cloud-native applications often support high-volume data requirements.</span></span> <span data-ttu-id="85b9b-207">在这些情况下，传统的数据存储技术可能会导致瓶颈。</span><span class="sxs-lookup"><span data-stu-id="85b9b-207">In these scenarios, traditional data storage techniques can cause bottlenecks.</span></span> <span data-ttu-id="85b9b-208">对于大规模部署的复杂系统，命令和查询责任分离 （CQRS） 和事件源都可能提高应用程序性能。</span><span class="sxs-lookup"><span data-stu-id="85b9b-208">For complex systems that deploy on a large scale, both Command and Query Responsibility Segregation (CQRS) and Event Sourcing may improve application performance.</span></span>  

### <a name="cqrs"></a><span data-ttu-id="85b9b-209">CQRS</span><span class="sxs-lookup"><span data-stu-id="85b9b-209">CQRS</span></span>

<span data-ttu-id="85b9b-210">[CQRS](https://docs.microsoft.com/azure/architecture/patterns/cqrs)是一种体系结构模式，可帮助最大限度地提高性能、可扩展性和安全性。</span><span class="sxs-lookup"><span data-stu-id="85b9b-210">[CQRS](https://docs.microsoft.com/azure/architecture/patterns/cqrs), is an architectural pattern that can help maximize performance, scalability, and security.</span></span> <span data-ttu-id="85b9b-211">该模式将读取数据的操作与写入数据的工序分开。</span><span class="sxs-lookup"><span data-stu-id="85b9b-211">The pattern separates operations that read data from those operations that write data.</span></span>

<span data-ttu-id="85b9b-212">对于正常方案，相同的实体模型和数据存储库*对象用于读取*和写入操作。</span><span class="sxs-lookup"><span data-stu-id="85b9b-212">For normal scenarios, the same entity model and data repository object are used for *both* read and write operations.</span></span>

<span data-ttu-id="85b9b-213">但是，高容量数据方案可以从用于读取和写入的单独模型和数据表中获益。</span><span class="sxs-lookup"><span data-stu-id="85b9b-213">However, a high volume data scenario can benefit from separate models and data tables for reads and writes.</span></span> <span data-ttu-id="85b9b-214">为了提高性能，读取操作可以查询数据的高度非规范化表示形式，以避免昂贵的重复表联接和表锁。</span><span class="sxs-lookup"><span data-stu-id="85b9b-214">To improve performance, the read operation could query against a highly denormalized representation of the data to avoid expensive repetitive table joins and table locks.</span></span> <span data-ttu-id="85b9b-215">*写入*操作（称为*命令*）将针对数据完全规范化表示形式进行更新，以确保一致性。</span><span class="sxs-lookup"><span data-stu-id="85b9b-215">The *write* operation, known as a *command*, would update against a fully normalized representation of the data that would guarantee consistency.</span></span> <span data-ttu-id="85b9b-216">然后，您需要实现一个机制，使两个表示保持同步。通常，每当修改写入表时，它都会发布一个事件，将修改复制到读取表。</span><span class="sxs-lookup"><span data-stu-id="85b9b-216">You then need to implement a mechanism to keep both representations in sync. Typically, whenever the write table is modified, it publishes an event that replicates the modification to the read table.</span></span>

<span data-ttu-id="85b9b-217">图 5-7 显示了 CQRS 模式的实现。</span><span class="sxs-lookup"><span data-stu-id="85b9b-217">Figure 5-7 shows an implementation of the CQRS pattern.</span></span>

![命令和查询责任分离](./media/cqrs-implementation.png)

<span data-ttu-id="85b9b-219">**图5-7**.</span><span class="sxs-lookup"><span data-stu-id="85b9b-219">**Figure 5-7**.</span></span> <span data-ttu-id="85b9b-220">CQRS 实现</span><span class="sxs-lookup"><span data-stu-id="85b9b-220">CQRS implementation</span></span>

<span data-ttu-id="85b9b-221">在上图中，实现了单独的命令和查询模型。</span><span class="sxs-lookup"><span data-stu-id="85b9b-221">In the previous figure, separate command and query models are implemented.</span></span> <span data-ttu-id="85b9b-222">每个数据写入操作都保存到写入存储，然后传播到读取存储。</span><span class="sxs-lookup"><span data-stu-id="85b9b-222">Each data write operation is saved to the write store and then propagated to the read store.</span></span> <span data-ttu-id="85b9b-223">密切关注数据传播过程在[最终一致性](http://www.cloudcomputingpatterns.org/eventual_consistency/)原则下如何运作。</span><span class="sxs-lookup"><span data-stu-id="85b9b-223">Pay close attention to how the data propagation process operates on the principle of [eventual consistency](http://www.cloudcomputingpatterns.org/eventual_consistency/).</span></span> <span data-ttu-id="85b9b-224">读取模型最终与写入模型同步，但过程可能有一些延迟。</span><span class="sxs-lookup"><span data-stu-id="85b9b-224">The read model eventually synchronizes with the write model, but there may be some lag in the process.</span></span> <span data-ttu-id="85b9b-225">我们将在下一节中讨论最终的一致性。</span><span class="sxs-lookup"><span data-stu-id="85b9b-225">We discuss eventual consistency in the next section.</span></span>

<span data-ttu-id="85b9b-226">这种分离使读取和写入能够独立缩放。</span><span class="sxs-lookup"><span data-stu-id="85b9b-226">This separation enables reads and writes to scale independently.</span></span> <span data-ttu-id="85b9b-227">读取操作使用针对查询优化的架构，而写入使用针对更新优化的架构。</span><span class="sxs-lookup"><span data-stu-id="85b9b-227">Read operations use a schema optimized for queries, while the writes use a schema optimized for updates.</span></span> <span data-ttu-id="85b9b-228">读取查询与非规范化数据有关，而复杂的业务逻辑可以应用于写入模型。</span><span class="sxs-lookup"><span data-stu-id="85b9b-228">Read queries go against denormalized data, while complex business logic can be applied to the write model.</span></span> <span data-ttu-id="85b9b-229">同样，与公开读取操作相比，您可能对写入操作施加更严格的安全性。</span><span class="sxs-lookup"><span data-stu-id="85b9b-229">As well, you might impose tighter security on write operations than those exposing reads.</span></span>

<span data-ttu-id="85b9b-230">实现 CQRS 可以提高云原生服务的应用程序性能。</span><span class="sxs-lookup"><span data-stu-id="85b9b-230">Implementing CQRS can improve application performance for cloud-native services.</span></span> <span data-ttu-id="85b9b-231">但是，它确实会导致更复杂的设计。</span><span class="sxs-lookup"><span data-stu-id="85b9b-231">However, it does result in a more complex design.</span></span> <span data-ttu-id="85b9b-232">谨慎和战略性地将此原则应用于云原生应用程序中将从中获益的部分。</span><span class="sxs-lookup"><span data-stu-id="85b9b-232">Apply this principle carefully and strategically to those sections of your cloud-native application that will benefit from it.</span></span> <span data-ttu-id="85b9b-233">有关 CQRS 的更多信息，请参阅 Microsoft 书[.NET 微服务：容器化 .NET 应用程序的体系结构](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/apply-simplified-microservice-cqrs-ddd-patterns)。</span><span class="sxs-lookup"><span data-stu-id="85b9b-233">For more on CQRS, see the Microsoft book [.NET Microservices: Architecture for Containerized .NET Applications](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/apply-simplified-microservice-cqrs-ddd-patterns).</span></span>

### <a name="event-sourcing"></a><span data-ttu-id="85b9b-234">活动采购</span><span class="sxs-lookup"><span data-stu-id="85b9b-234">Event sourcing</span></span>

<span data-ttu-id="85b9b-235">优化大容量数据场景的另一种方法涉及[事件源](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing)。</span><span class="sxs-lookup"><span data-stu-id="85b9b-235">Another approach to optimizing high volume data scenarios involves [Event Sourcing](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing).</span></span>

<span data-ttu-id="85b9b-236">系统通常存储数据实体的当前状态。</span><span class="sxs-lookup"><span data-stu-id="85b9b-236">A system typically stores the current state of a data entity.</span></span> <span data-ttu-id="85b9b-237">例如，如果用户更改了电话号码，则客户记录将更新为新号码。</span><span class="sxs-lookup"><span data-stu-id="85b9b-237">If a user changes their phone number, for example, the customer record is updated with the new number.</span></span> <span data-ttu-id="85b9b-238">我们始终知道数据实体的当前状态，但每个更新都覆盖以前的状态。</span><span class="sxs-lookup"><span data-stu-id="85b9b-238">We always know the current state of a data entity, but each update overwrites the previous state.</span></span>

<span data-ttu-id="85b9b-239">在大多数情况下，此模型工作正常。</span><span class="sxs-lookup"><span data-stu-id="85b9b-239">In most cases, this model works fine.</span></span> <span data-ttu-id="85b9b-240">但是，在高容量系统中，事务锁定和频繁更新操作造成的开销可能会影响数据库性能、响应能力和限制可伸缩性。</span><span class="sxs-lookup"><span data-stu-id="85b9b-240">In high volume systems, however, overhead from transactional locking and frequent update operations can impact database performance, responsiveness, and limit scalability.</span></span>

<span data-ttu-id="85b9b-241">事件源采用不同的方法来捕获数据。</span><span class="sxs-lookup"><span data-stu-id="85b9b-241">Event Sourcing takes a different approach to capturing data.</span></span> <span data-ttu-id="85b9b-242">影响数据的每个操作都会保存到事件存储。</span><span class="sxs-lookup"><span data-stu-id="85b9b-242">Each operation that affects data is persisted to an event store.</span></span> <span data-ttu-id="85b9b-243">我们不是更新数据记录的状态，而是将每个更改追加到过去事件的顺序列表 - 类似于会计的分类帐。</span><span class="sxs-lookup"><span data-stu-id="85b9b-243">Instead of updating the state of a data record, we append each change to a sequential list of past events - similar to an accountant's ledger.</span></span> <span data-ttu-id="85b9b-244">事件存储成为数据的记录系统。</span><span class="sxs-lookup"><span data-stu-id="85b9b-244">The Event Store becomes the system of record for the data.</span></span> <span data-ttu-id="85b9b-245">它用于在微服务的边界上下文中传播各种具体化视图。</span><span class="sxs-lookup"><span data-stu-id="85b9b-245">It's used to propagate various materialized views within the bounded context of a microservice.</span></span> <span data-ttu-id="85b9b-246">图 5.8 显示了图案。</span><span class="sxs-lookup"><span data-stu-id="85b9b-246">Figure 5.8 shows the pattern.</span></span>

![事件溯源](./media/event-sourcing.png)

<span data-ttu-id="85b9b-248">**图5-8**。</span><span class="sxs-lookup"><span data-stu-id="85b9b-248">**Figure 5-8**.</span></span> <span data-ttu-id="85b9b-249">事件溯源</span><span class="sxs-lookup"><span data-stu-id="85b9b-249">Event Sourcing</span></span>

<span data-ttu-id="85b9b-250">在上图中，请注意如何将用户购物车的每个条目（蓝色）追加到基础事件存储中。</span><span class="sxs-lookup"><span data-stu-id="85b9b-250">In the previous figure, note how each entry (in blue) for a user's shopping cart is appended to an underlying event store.</span></span> <span data-ttu-id="85b9b-251">在相邻的具体化视图中，系统通过重播与每个购物车关联的所有事件来预测当前状态。</span><span class="sxs-lookup"><span data-stu-id="85b9b-251">In the adjoining materialized view, the system projects the current state by replaying all the events associated with each shopping cart.</span></span> <span data-ttu-id="85b9b-252">然后，此视图或读取模型将暴露回 UI。</span><span class="sxs-lookup"><span data-stu-id="85b9b-252">This view, or read model, is then exposed back to the UI.</span></span> <span data-ttu-id="85b9b-253">事件也可以与外部系统和应用程序集成，也可以查询以确定实体的当前状态。</span><span class="sxs-lookup"><span data-stu-id="85b9b-253">Events can also be integrated with external systems and applications or queried to determine the current state of an entity.</span></span> <span data-ttu-id="85b9b-254">使用此方法，您可以维护历史记录。</span><span class="sxs-lookup"><span data-stu-id="85b9b-254">With this approach, you maintain history.</span></span> <span data-ttu-id="85b9b-255">您不仅了解实体的当前状态，还了解如何达到此状态。</span><span class="sxs-lookup"><span data-stu-id="85b9b-255">You know not only the current state of an entity, but also how you reached this state.</span></span>

<span data-ttu-id="85b9b-256">机械上讲，事件源简化了写入模型。</span><span class="sxs-lookup"><span data-stu-id="85b9b-256">Mechanically speaking, event sourcing simplifies the write model.</span></span> <span data-ttu-id="85b9b-257">没有更新或删除。</span><span class="sxs-lookup"><span data-stu-id="85b9b-257">There are no updates or deletes.</span></span> <span data-ttu-id="85b9b-258">将每个数据条目追加为不可变事件可最大限度地减少与关系数据库关联的争用、锁定和并发冲突。</span><span class="sxs-lookup"><span data-stu-id="85b9b-258">Appending each data entry as an immutable event minimizes contention, locking, and concurrency conflicts associated with relational databases.</span></span> <span data-ttu-id="85b9b-259">使用具体化视图模式构建读取模型使您能够将视图与写入模型分离，并选择最佳数据存储以优化应用程序 UI 的需求。</span><span class="sxs-lookup"><span data-stu-id="85b9b-259">Building read models with the materialized view pattern enables you to decouple the view from the write model and choose the best data store to optimize the needs of your application UI.</span></span>

<span data-ttu-id="85b9b-260">对于此模式，请考虑直接支持事件源的数据存储。</span><span class="sxs-lookup"><span data-stu-id="85b9b-260">For this pattern, consider a data store that directly supports event sourcing.</span></span> <span data-ttu-id="85b9b-261">Azure 宇宙 DB、蒙戈 DB、卡桑德拉、库 DB 和 RavenDB 都是不错的候选者。</span><span class="sxs-lookup"><span data-stu-id="85b9b-261">Azure Cosmos DB, MongoDB, Cassandra, CouchDB, and RavenDB are good candidates.</span></span>

<span data-ttu-id="85b9b-262">与所有模式和技术一样，在需要时战略性地实施。</span><span class="sxs-lookup"><span data-stu-id="85b9b-262">As with all patterns and technologies, implement strategically and when needed.</span></span> <span data-ttu-id="85b9b-263">虽然事件源可以提供更高的性能和可扩展性，但它以牺牲复杂性和学习曲线为代价。</span><span class="sxs-lookup"><span data-stu-id="85b9b-263">While event sourcing can provide increased performance and scalability, it comes at the expense of complexity and a learning curve.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="85b9b-264">[上一个](service-mesh-communication-infrastructure.md)
>[下一个](relational-vs-nosql-data.md)</span><span class="sxs-lookup"><span data-stu-id="85b9b-264">[Previous](service-mesh-communication-infrastructure.md)
[Next](relational-vs-nosql-data.md)</span></span>
