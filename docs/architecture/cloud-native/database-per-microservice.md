---
title: 每个微服务的数据库
description: 对比单片和云原生应用程序中的数据存储。
author: robvet
ms.date: 01/22/2020
ms.openlocfilehash: c0c5611fa866d70f155e4bdad2eee1181b13c065
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/12/2020
ms.locfileid: "79141440"
---
# <a name="database-per-microservice"></a>每个微服务的数据库

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

正如我们在本书中所看到的，云原生方法改变了设计、部署和管理应用程序的方式。 它还会更改管理和存储数据的方式。

图 5-1 对比了差异。

![云原生应用程序中的数据存储](./media/distributed-data.png)

**图5-1**. 云原生应用程序中的数据管理

有经验的开发人员将很容易识别图 5-1 左侧的体系结构。 在此*单片应用程序中*，业务服务组件在共享服务层中组合在一起，共享来自单个关系数据库的数据。

在许多方面，单个数据库使数据管理变得简单。 跨多个表查询数据非常简单。 对数据所做的更改一起更新，或者它们全部回滚。 [ACID 交易](https://docs.microsoft.com/windows/desktop/cossdk/acid-properties)保证强和即时的一致性。

为云原生设计，我们采取了不同的方法。 在图 5-1 的右侧，请注意业务功能如何隔离到小型的独立微服务中。 每个微服务封装特定的业务功能及其自己的数据。 单片数据库分解为具有许多较小数据库的分布式数据模型，每个数据库都与微服务对齐。 当烟雾清除时，我们出现了一个设计，它公开*了每个微服务的数据库*。

## <a name="why"></a>为什么？

每个微服务的此数据库提供了许多好处，尤其是对于必须快速发展并支持大规模扩展的系统。 使用此模型...

- 域数据封装在服务中
- 数据架构可以在不影响其他服务的情况下发展
- 每个数据存储可以独立扩展
- 一个服务中的数据存储故障不会直接影响其他服务

隔离数据还使每个微服务能够实现最适合其工作负载、存储需求和读/写模式的数据存储类型。 选项包括关系、文档、键值，甚至基于图形的数据存储。

图 5-2 介绍了云本机系统中多面体持久性的原则。

![多格洛特数据持久性](./media/polyglot-data-persistence.png)

**图5-2**. 多格洛特数据持久性

请注意，在上图中，每个微服务如何支持不同类型的数据存储。

- 产品目录微服务使用关系数据库来容纳其基础数据的丰富关系结构。
- 购物车微服务使用支持其简单、键值数据存储的分布式缓存。
- 订购微服务既使用 NoSql 文档数据库进行写入操作，也使用高度非规范化的密钥/值存储，以适应大量读取操作。
  
虽然关系数据库与具有复杂数据的微服务仍然相关，但 NoSQL 数据库已获得相当普及。 它们提供大规模和高可用性。 其无架构特性允许开发人员摆脱类型化数据类和 ORM 的体系结构，使更改变得昂贵且耗时。 本章后面我们将介绍 NoSQL 数据库。

 虽然将数据封装到单独的微服务中可以提高敏捷性、性能和可扩展性，但它也带来了许多挑战。 在下一节中，我们将讨论这些挑战以及帮助克服这些挑战的模式和实践。  

## <a name="cross-service-queries"></a>跨服务查询

虽然微服务是独立的，并且侧重于特定的功能功能，如库存、发货或订购，但它们通常需要与其他微服务集成。 通常，集成涉及一个微服务*查询*另一个微服务的数据。 图 5-3 显示了方案。

![跨微服务查询](./media/cross-service-query.png)

**图5-3**. 跨微服务查询

在上图中，我们看到一个购物篮微服务，将商品添加到用户的购物篮中。 虽然此微服务的数据存储包含购物篮和行项目数据，但它不维护产品或定价数据。 相反，这些数据项归目录所有，并定价微服务。 这带来了一个问题。 购物篮微服务如何在用户没有产品或定价数据的情况下将产品添加到用户的购物篮中？

第 4 章中讨论的一个选项是从购物篮[直接调用目录](service-to-service-communication.md#queries)和定价微服务。 但是，在第 4 章中，我们说过同步 HTTP 将*微服务调用在*一起，从而降低了它们的自主性并降低了它们的体系结构优势。

我们还可以实现请求-答复模式，为每个服务分别提供入站和出站队列。 但是，此模式很复杂，需要管道来关联请求和响应消息。
虽然它确实分离后端微服务呼叫，但呼叫服务仍必须同步等待呼叫完成。 网络拥塞、瞬态故障或超载微服务，可能导致长时间运行甚至失败的操作。

相反，一个被广泛接受的删除跨服务依赖项的模式是[具体化视图模式](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)，如图 5-4 所示。

![具体化视图模式](./media/materialized-view-pattern.png)

**图5-4**。 具体化视图模式

使用此模式，您将本地数据表（称为*读取模型*）放在购物篮服务中。 此表包含产品和定价微服务所需的数据的非规范化副本。 将数据直接复制到购物篮微服务中，无需昂贵的跨服务呼叫。 使用服务本地数据，可以提高服务的响应时间和可靠性。 此外，拥有自己的数据副本使购物篮服务更具弹性。 如果目录服务不可用，它不会直接影响购物篮服务。 购物篮可以继续使用自己商店的数据进行操作。

这种方法的问题在于，您现在系统中有重复的数据。 但是，*在*云本机系统中战略性地复制数据是一种既定做法，不被视为反模式或不良做法。 请记住，*只有一个服务*可以拥有数据集并有权拥有数据集。 更新记录系统时，您需要同步读取模型。 同步通常通过具有[发布/订阅模式](service-to-service-communication.md#events)的异步消息实现，如图 5.4 所示。

## <a name="distributed-transactions"></a>分布式事务

虽然跨微服务查询数据很困难，但跨多个微服务实现事务甚至更为复杂。 在不同微服务中保持独立数据源的数据一致性的内在挑战怎么强调也不为过。 云原生应用程序中缺少分布式事务意味着您必须以编程方式管理分布式事务。 你从一个*即时一致性*的世界走向最终一*致性*的世界。

图 5-5 显示了问题。

![saga 模式中的事务](./media/saga-transaction-operation.png)

**图5-5**. 跨微服务实现事务

在上图中，五个独立的微服务参与创建订单的分布式事务。 每个微服务维护自己的数据存储，并为其存储实现本地事务。 要创建订单，*每个*微服务的本地事务必须成功，或者*所有*事务都必须中止和回滚该操作。 虽然每个微服务都提供内置事务支持，但不支持跨所有五个服务的分布式事务来保持数据一致性。

相反，您必须*以编程方式*构造此分布式事务。

添加分布式事务支持的流行模式是 Saga 模式。 它通过将本地事务分组到一起以编程和按顺序调用每个事务来实现。 如果任何本地事务失败，Saga 将中止该操作并调用一组[补偿事务](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction)。 补偿事务撤消了上述本地事务所做的更改，并还原了数据一致性。 图 5-6 显示了 Saga 模式的失败事务。

![回滚在传奇模式](./media/saga-rollback-operation.png)

**图5-6**. 回滚事务

在上图中，"*更新清单"* 操作在"清单"微服务中失败。 Saga 调用一组补偿事务（红色）来调整库存计数、取消付款和订单，并将每个微服务的数据返回到一致状态。

Saga 模式通常编排为一系列相关事件，或作为一组相关命令编排。 在第 4 章中，我们讨论了作为协调的 saga 实现基础的服务聚合器模式。 我们还讨论了与 Azure 服务总线和 Azure 事件网格主题一起发生的事件，这些主题将成为精心编排的 saga 实现的基础。

## <a name="high-volume-data"></a>大容量数据

大型云原生应用程序通常支持大容量数据要求。 在这些情况下，传统的数据存储技术可能会导致瓶颈。 对于大规模部署的复杂系统，命令和查询责任分离 （CQRS） 和事件源都可能提高应用程序性能。  

### <a name="cqrs"></a>CQRS

[CQRS](https://docs.microsoft.com/azure/architecture/patterns/cqrs)是一种体系结构模式，可帮助最大限度地提高性能、可扩展性和安全性。 该模式将读取数据的操作与写入数据的工序分开。

对于正常方案，相同的实体模型和数据存储库*对象用于读取*和写入操作。

但是，高容量数据方案可以从用于读取和写入的单独模型和数据表中获益。 为了提高性能，读取操作可以查询数据的高度非规范化表示形式，以避免昂贵的重复表联接和表锁。 *写入*操作（称为*命令*）将针对数据完全规范化表示形式进行更新，以确保一致性。 然后，您需要实现一个机制，使两个表示保持同步。通常，每当修改写入表时，它都会发布一个事件，将修改复制到读取表。

图 5-7 显示了 CQRS 模式的实现。

![命令和查询责任分离](./media/cqrs-implementation.png)

**图5-7**. CQRS 实现

在上图中，实现了单独的命令和查询模型。 每个数据写入操作都保存到写入存储，然后传播到读取存储。 密切关注数据传播过程在[最终一致性](http://www.cloudcomputingpatterns.org/eventual_consistency/)原则下如何运作。 读取模型最终与写入模型同步，但过程可能有一些延迟。 我们将在下一节中讨论最终的一致性。

这种分离使读取和写入能够独立缩放。 读取操作使用针对查询优化的架构，而写入使用针对更新优化的架构。 读取查询与非规范化数据有关，而复杂的业务逻辑可以应用于写入模型。 同样，与公开读取操作相比，您可能对写入操作施加更严格的安全性。

实现 CQRS 可以提高云原生服务的应用程序性能。 但是，它确实会导致更复杂的设计。 谨慎和战略性地将此原则应用于云原生应用程序中将从中获益的部分。 有关 CQRS 的更多信息，请参阅 Microsoft 书[.NET 微服务：容器化 .NET 应用程序的体系结构](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/apply-simplified-microservice-cqrs-ddd-patterns)。

### <a name="event-sourcing"></a>活动采购

优化大容量数据场景的另一种方法涉及[事件源](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing)。

系统通常存储数据实体的当前状态。 例如，如果用户更改了电话号码，则客户记录将更新为新号码。 我们始终知道数据实体的当前状态，但每个更新都覆盖以前的状态。

在大多数情况下，此模型工作正常。 但是，在高容量系统中，事务锁定和频繁更新操作造成的开销可能会影响数据库性能、响应能力和限制可伸缩性。

事件源采用不同的方法来捕获数据。 影响数据的每个操作都会保存到事件存储。 我们不是更新数据记录的状态，而是将每个更改追加到过去事件的顺序列表 - 类似于会计的分类帐。 事件存储成为数据的记录系统。 它用于在微服务的边界上下文中传播各种具体化视图。 图 5.8 显示了图案。

![事件溯源](./media/event-sourcing.png)

**图5-8**。 事件溯源

在上图中，请注意如何将用户购物车的每个条目（蓝色）追加到基础事件存储中。 在相邻的具体化视图中，系统通过重播与每个购物车关联的所有事件来预测当前状态。 然后，此视图或读取模型将暴露回 UI。 事件也可以与外部系统和应用程序集成，也可以查询以确定实体的当前状态。 使用此方法，您可以维护历史记录。 您不仅了解实体的当前状态，还了解如何达到此状态。

机械上讲，事件源简化了写入模型。 没有更新或删除。 将每个数据条目追加为不可变事件可最大限度地减少与关系数据库关联的争用、锁定和并发冲突。 使用具体化视图模式构建读取模型使您能够将视图与写入模型分离，并选择最佳数据存储以优化应用程序 UI 的需求。

对于此模式，请考虑直接支持事件源的数据存储。 Azure 宇宙 DB、蒙戈 DB、卡桑德拉、库 DB 和 RavenDB 都是不错的候选者。

与所有模式和技术一样，在需要时战略性地实施。 虽然事件源可以提供更高的性能和可扩展性，但它以牺牲复杂性和学习曲线为代价。

>[!div class="step-by-step"]
>[上一个](service-mesh-communication-infrastructure.md)
>[下一个](relational-vs-nosql-data.md)
