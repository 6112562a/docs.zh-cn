---
title: 定义云本机
description: 了解为云原生系统提供基岩的基础支柱
author: robvet
ms.date: 08/20/2019
ms.openlocfilehash: 756a2565bd77fcef19a5f15579987836ff0e75a4
ms.sourcegitcommit: e3cbf26d67f7e9286c7108a2752804050762d02d
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/09/2020
ms.locfileid: "80989085"
---
# <a name="defining-cloud-native"></a><span data-ttu-id="0cf4d-103">定义云本机</span><span class="sxs-lookup"><span data-stu-id="0cf4d-103">Defining cloud native</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="0cf4d-104">停止你正在做的事情，给十位同事发短信。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-104">Stop what you're doing and text ten of your colleagues.</span></span> <span data-ttu-id="0cf4d-105">请他们定义术语"云原生"。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-105">Ask them to define the term "Cloud Native".</span></span> <span data-ttu-id="0cf4d-106">很有可能你会得到八个不同的答案。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-106">Good chance you'll get eight different answers.</span></span>

<span data-ttu-id="0cf4d-107">云原生就是改变我们构建关键业务系统的方式。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-107">Cloud native is all about changing the way we think about constructing critical business systems.</span></span>

<span data-ttu-id="0cf4d-108">云原生系统旨在适应快速变化、大规模和弹性。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-108">Cloud-native systems are designed to embrace rapid change, large scale, and resilience.</span></span>

<span data-ttu-id="0cf4d-109">云原生计算基金会提供了一[个官方的定义](https://github.com/cncf/foundation/blob/master/charter.md)：</span><span class="sxs-lookup"><span data-stu-id="0cf4d-109">The Cloud Native Computing Foundation provides an [official definition](https://github.com/cncf/foundation/blob/master/charter.md):</span></span>

> <span data-ttu-id="0cf4d-110">*云原生技术使组织能够在公共、私有和混合云等现代动态环境中构建和运行可扩展的应用程序。容器、服务同理、微服务、不可变基础结构和声明性 API 就是此方法的例证。*</span><span class="sxs-lookup"><span data-stu-id="0cf4d-110">*Cloud-native technologies empower organizations to build and run scalable applications in modern, dynamic environments such as public, private, and hybrid clouds. Containers, service meshes, microservices, immutable infrastructure, and declarative APIs exemplify this approach.*</span></span>

> <span data-ttu-id="0cf4d-111">*这些技术支持具有弹性、可管理和可观测的松散耦合系统。结合强大的自动化，它们使工程师能够以最少的辛劳频繁、可预见地进行高影响更改。*</span><span class="sxs-lookup"><span data-stu-id="0cf4d-111">*These techniques enable loosely coupled systems that are resilient, manageable, and observable. Combined with robust automation, they allow engineers to make high-impact changes frequently and predictably with minimal toil.*</span></span>

<span data-ttu-id="0cf4d-112">随着用户要求越来越高，应用程序变得越来越复杂。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-112">Applications have become increasingly complex with users demanding more and more.</span></span> <span data-ttu-id="0cf4d-113">用户期望快速响应、创新功能和零停机时间。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-113">Users expect rapid responsiveness, innovative features, and zero downtime.</span></span> <span data-ttu-id="0cf4d-114">性能问题、反复出现的错误和无法快速移动不再为所接受。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-114">Performance problems, recurring errors, and the inability to move fast are no longer acceptable.</span></span> <span data-ttu-id="0cf4d-115">他们很容易转移到你的竞争对手。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-115">They'll easily move to your competitor.</span></span>

<span data-ttu-id="0cf4d-116">云原生是很多关于*速度和\*\*敏捷*性。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-116">Cloud native is much about *speed* and *agility*.</span></span> <span data-ttu-id="0cf4d-117">业务系统正在从支持业务能力演变为战略转型、加快业务速度和增长的武器。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-117">Business systems are evolving from enabling business capabilities to weapons of strategic transformation, accelerating business velocity and growth.</span></span> <span data-ttu-id="0cf4d-118">立即将创意推向市场势在必行。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-118">It's imperative to get ideas to market immediately.</span></span>

<span data-ttu-id="0cf4d-119">以下是一些已经实施了这些技术的公司。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-119">Here are some companies who have implemented these techniques.</span></span> <span data-ttu-id="0cf4d-120">考虑他们实现的速度、敏捷性和可扩展性。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-120">Think about the speed, agility, and scalability they've achieved.</span></span>

| <span data-ttu-id="0cf4d-121">Company</span><span class="sxs-lookup"><span data-stu-id="0cf4d-121">Company</span></span> | <span data-ttu-id="0cf4d-122">体验</span><span class="sxs-lookup"><span data-stu-id="0cf4d-122">Experience</span></span> |
| :-------- | :-------- |
| [<span data-ttu-id="0cf4d-123">Netflix</span><span class="sxs-lookup"><span data-stu-id="0cf4d-123">Netflix</span></span>](https://www.infoq.com/news/2013/06/netflix/) | <span data-ttu-id="0cf4d-124">有 600 多种生产服务。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-124">Has 600+ services in production.</span></span> <span data-ttu-id="0cf4d-125">每天部署一百次。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-125">Deploys a hundred times per day.</span></span> |
| [<span data-ttu-id="0cf4d-126">超级</span><span class="sxs-lookup"><span data-stu-id="0cf4d-126">Uber</span></span>](https://eng.uber.com/micro-deploy/) | <span data-ttu-id="0cf4d-127">生产中存储了 1，000 多个服务。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-127">Has 1,000+ services stored in production.</span></span> <span data-ttu-id="0cf4d-128">每周部署几千个生成。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-128">Deploys several thousand builds each week.</span></span> |
| [<span data-ttu-id="0cf4d-129">微信</span><span class="sxs-lookup"><span data-stu-id="0cf4d-129">WeChat</span></span>](https://www.cs.columbia.edu/~ruigu/papers/socc18-final100.pdf) | <span data-ttu-id="0cf4d-130">有 300 多种生产服务。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-130">Has 300+ services in production.</span></span> <span data-ttu-id="0cf4d-131">每天进行近 1，000 次更改。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-131">Makes almost 1,000 changes per day.</span></span> |

<span data-ttu-id="0cf4d-132">正如您所看到的，Netflix、优步和微信公开了由数百个独立的微服务组成的系统。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-132">As you can see, Netflix, Uber, and WeChat expose systems that consist of hundreds of independent microservices.</span></span> <span data-ttu-id="0cf4d-133">这种建筑风格使他们能够快速响应市场条件。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-133">This architectural style enables them to rapidly respond to market conditions.</span></span> <span data-ttu-id="0cf4d-134">他们可以即时更新实时复杂应用程序的小区域，并根据需要单独缩放这些区域。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-134">They can instantaneously update small areas of a live, complex application, and individually scale those areas as needed.</span></span>

<span data-ttu-id="0cf4d-135">云原生的速度和敏捷性来自许多因素。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-135">The speed and agility of cloud native come about from a number of factors.</span></span> <span data-ttu-id="0cf4d-136">首先是云基础架构。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-136">Foremost is cloud infrastructure.</span></span> <span data-ttu-id="0cf4d-137">图 1-3 所示的另外五个基柱也为云原生系统提供了基岩。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-137">Five additional foundational pillars shown in Figure 1-3 also provide the bedrock for cloud-native systems.</span></span>

![云原生基础支柱](./media/cloud-native-foundational-pillars.png)

<span data-ttu-id="0cf4d-139">**图1-3**。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-139">**Figure 1-3**.</span></span> <span data-ttu-id="0cf4d-140">云原生基础支柱</span><span class="sxs-lookup"><span data-stu-id="0cf4d-140">Cloud-native foundational pillars</span></span>

<span data-ttu-id="0cf4d-141">让我们花一些时间来更好地了解每个支柱的重要性。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-141">Let's take some time to better understand the significance of each pillar.</span></span>

## <a name="the-cloud"></a><span data-ttu-id="0cf4d-142">云...</span><span class="sxs-lookup"><span data-stu-id="0cf4d-142">The cloud…</span></span>

<span data-ttu-id="0cf4d-143">云原生系统充分利用了云服务模型。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-143">Cloud-native systems take full advantage of the cloud service model.</span></span>

<span data-ttu-id="0cf4d-144">这些系统旨在在动态虚拟化的云环境中蓬勃发展，广泛使用[平台即服务 （PaaS）](https://azure.microsoft.com/overview/what-is-paas/)计算基础架构和托管服务。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-144">Designed to thrive in a dynamic, virtualized cloud environment, these systems make extensive use of [Platform as a Service (PaaS)](https://azure.microsoft.com/overview/what-is-paas/) compute infrastructure and managed services.</span></span> <span data-ttu-id="0cf4d-145">他们将底层基础架构视为*一次性*基础结构 - 在几分钟内预配，并通过自动化按需调整规模、缩放、移动或销毁。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-145">They treat the underlying infrastructure as *disposable* - provisioned in minutes and resized, scaled, moved, or destroyed on demand – via automation.</span></span>

<span data-ttu-id="0cf4d-146">考虑广泛接受的DevOps概念[宠物与牛](https://medium.com/@Joachim8675309/devops-concepts-pets-vs-cattle-2380b5aab313)。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-146">Consider the widely accepted DevOps concept of [Pets vs. Cattle](https://medium.com/@Joachim8675309/devops-concepts-pets-vs-cattle-2380b5aab313).</span></span> <span data-ttu-id="0cf4d-147">在传统的数据中心中，服务器被视为*宠物*：物理机器，被赋予一个有意义的名称，并受到关注。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-147">In a traditional data center, servers are treated as *Pets*: a physical machine, given a meaningful name, and cared for.</span></span> <span data-ttu-id="0cf4d-148">通过向同一计算机添加更多资源（向上扩展）进行扩展。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-148">You scale by adding more resources to the same machine (scaling up).</span></span> <span data-ttu-id="0cf4d-149">如果服务器生病，您将将其护理回运行状况。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-149">If the server becomes sick, you nurse it back to health.</span></span> <span data-ttu-id="0cf4d-150">如果服务器不可用，每个人都会注意到。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-150">Should the server become unavailable, everyone notices.</span></span>

<span data-ttu-id="0cf4d-151">*牛*服务模式不同。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-151">The *Cattle* service model is different.</span></span> <span data-ttu-id="0cf4d-152">将每个实例预配为虚拟机或容器。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-152">You provision each instance as a virtual machine or container.</span></span> <span data-ttu-id="0cf4d-153">它们相同，并分配了系统标识符，如服务-01、服务-02等。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-153">They're identical and assigned a system identifier such as Service-01, Service-02, and so on.</span></span> <span data-ttu-id="0cf4d-154">您可以通过创建更多（向外扩展）进行扩展。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-154">You scale by creating more of them (scaling out).</span></span> <span data-ttu-id="0cf4d-155">当一个人变得不可用时，没有人会注意到。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-155">When one becomes unavailable, nobody notices.</span></span>

<span data-ttu-id="0cf4d-156">牛模式拥抱*了不变的基础设施*。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-156">The cattle model embraces *immutable infrastructure*.</span></span> <span data-ttu-id="0cf4d-157">服务器未修复或修改。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-157">Servers aren't repaired or modified.</span></span> <span data-ttu-id="0cf4d-158">如果一个失败或需要更新，它将被销毁，并预配了新的更新 - 所有这些都通过自动化完成。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-158">If one fails or requires updating, it's destroyed and a new one is provisioned – all done via automation.</span></span>

<span data-ttu-id="0cf4d-159">云原生系统采用牛服务模式。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-159">Cloud-native systems embrace the Cattle service model.</span></span> <span data-ttu-id="0cf4d-160">它们继续随着基础结构的扩展或运行而运行，而不考虑运行的机器。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-160">They continue to run as the infrastructure scales in or out with no regard to the machines upon which they're running.</span></span>

<span data-ttu-id="0cf4d-161">Azure 云平台支持这种类型的高弹性基础架构，具有自动缩放、自我修复和监视功能。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-161">The Azure cloud platform supports this type of highly elastic infrastructure with automatic scaling, self-healing, and monitoring capabilities.</span></span>

## <a name="modern-design"></a><span data-ttu-id="0cf4d-162">现代设计</span><span class="sxs-lookup"><span data-stu-id="0cf4d-162">Modern design</span></span>

<span data-ttu-id="0cf4d-163">您将如何设计云原生应用？</span><span class="sxs-lookup"><span data-stu-id="0cf4d-163">How would you design a cloud-native app?</span></span> <span data-ttu-id="0cf4d-164">您的体系结构是什么样子的？</span><span class="sxs-lookup"><span data-stu-id="0cf4d-164">What would your architecture look like?</span></span> <span data-ttu-id="0cf4d-165">您会遵循哪些原则、模式和最佳实践？</span><span class="sxs-lookup"><span data-stu-id="0cf4d-165">To what principles, patterns, and best practices would you adhere?</span></span> <span data-ttu-id="0cf4d-166">哪些基础设施和运营问题很重要？</span><span class="sxs-lookup"><span data-stu-id="0cf4d-166">What infrastructure and operational concerns would be important?</span></span>

### <a name="the-twelve-factor-application"></a><span data-ttu-id="0cf4d-167">十二因子应用</span><span class="sxs-lookup"><span data-stu-id="0cf4d-167">The Twelve-Factor Application</span></span>

<span data-ttu-id="0cf4d-168">构建基于云的应用程序是一种被广泛接受的方法是[十二因子应用程序](https://12factor.net/)。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-168">A widely accepted methodology for constructing cloud-based applications is the [Twelve-Factor Application](https://12factor.net/).</span></span> <span data-ttu-id="0cf4d-169">它描述了开发人员遵循的一组原则和实践，以构建针对现代云环境优化的应用程序。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-169">It describes a set of principles and practices that developers follow to construct applications optimized for modern cloud environments.</span></span> <span data-ttu-id="0cf4d-170">特别注意跨环境的可移植性和声明性自动化。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-170">Special attention is given to portability across environments and declarative automation.</span></span>

<span data-ttu-id="0cf4d-171">虽然适用于任何基于 Web 的应用程序，但许多从业者认为它是构建云原生应用的坚实基础。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-171">While applicable to any web-based application, many practitioners consider it as a solid foundation for building cloud-native apps.</span></span> <span data-ttu-id="0cf4d-172">基于这些原则构建的系统可以快速部署和扩展，并添加功能以快速响应市场变化。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-172">Systems built upon these principles can deploy and scale rapidly and add features to react quickly to market changes.</span></span>

<span data-ttu-id="0cf4d-173">下表重点介绍了十二因子方法：</span><span class="sxs-lookup"><span data-stu-id="0cf4d-173">The following table highlights the Twelve-Factor methodology:</span></span>

|    |  <span data-ttu-id="0cf4d-174">因素</span><span class="sxs-lookup"><span data-stu-id="0cf4d-174">Factor</span></span> | <span data-ttu-id="0cf4d-175">说明</span><span class="sxs-lookup"><span data-stu-id="0cf4d-175">Explanation</span></span>  |
| :-------- | :-------- | :-------- |
| <span data-ttu-id="0cf4d-176">1</span><span class="sxs-lookup"><span data-stu-id="0cf4d-176">1</span></span> | <span data-ttu-id="0cf4d-177">代码库</span><span class="sxs-lookup"><span data-stu-id="0cf4d-177">Code Base</span></span> | <span data-ttu-id="0cf4d-178">每个微服务的单一代码库，存储在其自己的存储库中。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-178">A single code base for each microservice, stored in its own repository.</span></span> <span data-ttu-id="0cf4d-179">通过版本控制进行跟踪，它可以部署到多个环境（QA、暂存、生产）。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-179">Tracked with version control, it can deploy to multiple environments (QA, Staging, Production).</span></span> |
| <span data-ttu-id="0cf4d-180">2</span><span class="sxs-lookup"><span data-stu-id="0cf4d-180">2</span></span> | <span data-ttu-id="0cf4d-181">依赖项</span><span class="sxs-lookup"><span data-stu-id="0cf4d-181">Dependencies</span></span> | <span data-ttu-id="0cf4d-182">每个微服务隔离和打包自己的依赖项，在不影响整个系统的情况下接受更改。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-182">Each microservice isolates and packages its own dependencies, embracing changes without impacting the entire system.</span></span> |
| <span data-ttu-id="0cf4d-183">3</span><span class="sxs-lookup"><span data-stu-id="0cf4d-183">3</span></span> | <span data-ttu-id="0cf4d-184">配置</span><span class="sxs-lookup"><span data-stu-id="0cf4d-184">Configurations</span></span>  | <span data-ttu-id="0cf4d-185">配置信息从微服务中移出，并通过代码外部的配置管理工具进行外部化。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-185">Configuration information is moved out of the microservice and externalized through a configuration management tool outside of the code.</span></span> <span data-ttu-id="0cf4d-186">相同的部署可以在应用正确配置的环境中传播。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-186">The same deployment can propagate across environments with the correct configuration applied.</span></span>  |
| <span data-ttu-id="0cf4d-187">4</span><span class="sxs-lookup"><span data-stu-id="0cf4d-187">4</span></span> | <span data-ttu-id="0cf4d-188">支持服务</span><span class="sxs-lookup"><span data-stu-id="0cf4d-188">Backing Services</span></span> | <span data-ttu-id="0cf4d-189">辅助资源（数据存储、缓存、消息代理）应通过可寻址 URL 公开。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-189">Ancillary resources (data stores, caches, message brokers) should be exposed via an addressable URL.</span></span> <span data-ttu-id="0cf4d-190">这样做会将资源与应用程序分离，使其可互换。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-190">Doing so decouples the resource from the application, enabling it to be interchangeable.</span></span>  |
| <span data-ttu-id="0cf4d-191">5</span><span class="sxs-lookup"><span data-stu-id="0cf4d-191">5</span></span> | <span data-ttu-id="0cf4d-192">生成、发布、运行</span><span class="sxs-lookup"><span data-stu-id="0cf4d-192">Build, Release, Run</span></span> | <span data-ttu-id="0cf4d-193">每个版本都必须在生成、发布和运行阶段强制实施严格的分离。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-193">Each release must enforce a strict separation across the build, release, and run stages.</span></span> <span data-ttu-id="0cf4d-194">每个应标记一个唯一的 ID，并支持回滚的能力。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-194">Each should be tagged with a unique ID and support the ability to roll back.</span></span> <span data-ttu-id="0cf4d-195">现代 CI/CD 系统有助于实现这一原则。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-195">Modern CI/CD systems help fulfill this principle.</span></span> |
| <span data-ttu-id="0cf4d-196">6</span><span class="sxs-lookup"><span data-stu-id="0cf4d-196">6</span></span> | <span data-ttu-id="0cf4d-197">进程</span><span class="sxs-lookup"><span data-stu-id="0cf4d-197">Processes</span></span> | <span data-ttu-id="0cf4d-198">每个微服务都应在自己的进程中执行，与其他正在运行的服务隔离。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-198">Each microservice should execute in its own process,  isolated from other running services.</span></span> <span data-ttu-id="0cf4d-199">将所需状态外部化到备份服务（如分布式缓存或数据存储）。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-199">Externalize required state to a backing service such as a distributed cache or data store.</span></span> |
| <span data-ttu-id="0cf4d-200">7</span><span class="sxs-lookup"><span data-stu-id="0cf4d-200">7</span></span> | <span data-ttu-id="0cf4d-201">端口绑定</span><span class="sxs-lookup"><span data-stu-id="0cf4d-201">Port Binding</span></span> | <span data-ttu-id="0cf4d-202">每个微服务都应自包含其接口和功能，并在其自己的端口上公开。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-202">Each microservice should be self-contained with its interfaces and functionality exposed on its own port.</span></span> <span data-ttu-id="0cf4d-203">这样做会与其他微服务隔离。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-203">Doing so provides isolation from other microservices.</span></span> |
| <span data-ttu-id="0cf4d-204">8</span><span class="sxs-lookup"><span data-stu-id="0cf4d-204">8</span></span> | <span data-ttu-id="0cf4d-205">并发</span><span class="sxs-lookup"><span data-stu-id="0cf4d-205">Concurrency</span></span> | <span data-ttu-id="0cf4d-206">服务将扩展在大量小型相同进程（副本）上，而不是在最强大的计算机上扩展单个大型实例。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-206">Services scale out across a large number of small identical processes (copies) as opposed to scaling-up a single large instance on the most powerful machine available.</span></span> |
| <span data-ttu-id="0cf4d-207">9</span><span class="sxs-lookup"><span data-stu-id="0cf4d-207">9</span></span> | <span data-ttu-id="0cf4d-208">可处置性</span><span class="sxs-lookup"><span data-stu-id="0cf4d-208">Disposability</span></span> | <span data-ttu-id="0cf4d-209">服务实例应该是一次性的，有利于快速启动来增加可伸缩性机会和正常关机，使系统处于正确的状态。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-209">Service instances should be disposable, favoring fast startups to increase scalability opportunities and graceful shutdowns to leave the system in a correct state.</span></span> <span data-ttu-id="0cf4d-210">Docker 容器以及协调器本身就满足了此要求。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-210">Docker containers along with an orchestrator inherently satisfy this requirement.</span></span> |
| <span data-ttu-id="0cf4d-211">10</span><span class="sxs-lookup"><span data-stu-id="0cf4d-211">10</span></span> | <span data-ttu-id="0cf4d-212">开发/升序奇偶校验</span><span class="sxs-lookup"><span data-stu-id="0cf4d-212">Dev/Prod Parity</span></span> | <span data-ttu-id="0cf4d-213">使整个应用程序生命周期中的环境尽可能相似，避免昂贵的快捷方式。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-213">Keep environments across the application lifecycle as similar as possible, avoiding costly shortcuts.</span></span> <span data-ttu-id="0cf4d-214">在这里，采用容器可以极大地促进相同的执行环境。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-214">Here, the adoption of containers can greatly contribute by promoting the same execution environment.</span></span> |
| <span data-ttu-id="0cf4d-215">11</span><span class="sxs-lookup"><span data-stu-id="0cf4d-215">11</span></span> | <span data-ttu-id="0cf4d-216">日志记录</span><span class="sxs-lookup"><span data-stu-id="0cf4d-216">Logging</span></span> | <span data-ttu-id="0cf4d-217">将微服务生成的日志视为事件流。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-217">Treat logs generated by microservices as event streams.</span></span> <span data-ttu-id="0cf4d-218">使用事件聚合器处理它们，并将数据传播到数据挖掘/日志管理工具（如 Azure 监视器或 Splunk），并最终进行长期存档。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-218">Process them with an event aggregator and propagate the data to data-mining/log management tools like Azure Monitor or Splunk and eventually long-term archival.</span></span> |
| <span data-ttu-id="0cf4d-219">12</span><span class="sxs-lookup"><span data-stu-id="0cf4d-219">12</span></span> | <span data-ttu-id="0cf4d-220">管理流程</span><span class="sxs-lookup"><span data-stu-id="0cf4d-220">Admin Processes</span></span> | <span data-ttu-id="0cf4d-221">将管理/管理任务作为一次性流程运行。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-221">Run administrative/management tasks as one-off processes.</span></span> <span data-ttu-id="0cf4d-222">任务可以包括报表的数据清理和拉取分析。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-222">Tasks can include data cleanup and pulling analytics for a report.</span></span> <span data-ttu-id="0cf4d-223">执行这些任务的工具应从生产环境调用，但与应用程序分开调用。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-223">Tools executing these tasks should be  invoked from the production environment, but separately from the application.</span></span> |

<span data-ttu-id="0cf4d-224">在《 [十二因素应用》](https://content.pivotal.io/blog/beyond-the-twelve-factor-app)一书中，作者凯文·霍夫曼详细介绍了最初的12个因素（写于2011年）。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-224">In the book, [Beyond the Twelve-Factor App](https://content.pivotal.io/blog/beyond-the-twelve-factor-app), author Kevin Hoffman details each of the original 12 factors (written in 2011).</span></span> <span data-ttu-id="0cf4d-225">此外，本书还提供了反映当今现代云应用程序设计的三个附加因素。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-225">Additionally, the book provides three additional factors that reflect today's modern cloud application design.</span></span>

|    |  <span data-ttu-id="0cf4d-226">新因素</span><span class="sxs-lookup"><span data-stu-id="0cf4d-226">New Factor</span></span> | <span data-ttu-id="0cf4d-227">说明</span><span class="sxs-lookup"><span data-stu-id="0cf4d-227">Explanation</span></span>  |
| :-------- | :-------- | :-------- |
| <span data-ttu-id="0cf4d-228">13</span><span class="sxs-lookup"><span data-stu-id="0cf4d-228">13</span></span> | <span data-ttu-id="0cf4d-229">API 优先</span><span class="sxs-lookup"><span data-stu-id="0cf4d-229">API First</span></span> | <span data-ttu-id="0cf4d-230">使一切成为服务。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-230">Make everything a service.</span></span> <span data-ttu-id="0cf4d-231">假设您的代码将被前端客户端、网关或其他服务使用。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-231">Assume your code will be consumed by a front-end client, gateway, or another service.</span></span> |
| <span data-ttu-id="0cf4d-232">14</span><span class="sxs-lookup"><span data-stu-id="0cf4d-232">14</span></span> | <span data-ttu-id="0cf4d-233">遥测</span><span class="sxs-lookup"><span data-stu-id="0cf4d-233">Telemetry</span></span> | <span data-ttu-id="0cf4d-234">在工作站上，您可以深入了解应用程序及其行为。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-234">On a workstation, you have deep visibility into your application and its behavior.</span></span> <span data-ttu-id="0cf4d-235">在云中，你没有。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-235">In the cloud, you don't.</span></span> <span data-ttu-id="0cf4d-236">确保您的设计包括监视、特定于域和运行状况/系统数据的集合。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-236">Make sure your design includes the collection of monitoring, domain-specific, and health/system data.</span></span> |
| <span data-ttu-id="0cf4d-237">15</span><span class="sxs-lookup"><span data-stu-id="0cf4d-237">15</span></span> | <span data-ttu-id="0cf4d-238">身份验证/授权</span><span class="sxs-lookup"><span data-stu-id="0cf4d-238">Authentication/ Authorization</span></span>  | <span data-ttu-id="0cf4d-239">从一开始就实现标识。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-239">Implement identity from the start.</span></span> <span data-ttu-id="0cf4d-240">考虑公共云中可用的[RBAC（基于角色的访问控制）](https://docs.microsoft.com/azure/role-based-access-control/overview)功能。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-240">Consider [RBAC (role-based access control)](https://docs.microsoft.com/azure/role-based-access-control/overview) features available in public clouds.</span></span>  |

<span data-ttu-id="0cf4d-241">我们将参考本章和整个书中的 12 个以上因素中的许多。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-241">We'll refer to many of the 12+ factors in this chapter and throughout the book.</span></span>

### <a name="critical-design-considerations"></a><span data-ttu-id="0cf4d-242">关键设计注意事项</span><span class="sxs-lookup"><span data-stu-id="0cf4d-242">Critical Design Considerations</span></span>

<span data-ttu-id="0cf4d-243">除了由十二因素方法提供的指导外，在构建分布式系统时，还必须做出一些关键的设计决策。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-243">Beyond the guidance provided from the twelve-factor methodology, there are several critical design decisions you must make when constructing distributed systems.</span></span>

<span data-ttu-id="0cf4d-244">*通信*</span><span class="sxs-lookup"><span data-stu-id="0cf4d-244">*Communication*</span></span>

<span data-ttu-id="0cf4d-245">前端客户端应用程序将如何与后端核心服务通信？</span><span class="sxs-lookup"><span data-stu-id="0cf4d-245">How will front-end client applications communicate with backed-end core services?</span></span> <span data-ttu-id="0cf4d-246">你会允许直接沟通吗？</span><span class="sxs-lookup"><span data-stu-id="0cf4d-246">Will you allow direct communication?</span></span> <span data-ttu-id="0cf4d-247">或者，您是否使用提供灵活性、控制和安全性的网关外观抽象后端服务？</span><span class="sxs-lookup"><span data-stu-id="0cf4d-247">Or, might you abstract the back-end services with a gateway façade that provides  flexibility, control, and security?</span></span>

<span data-ttu-id="0cf4d-248">后端核心服务将如何相互通信？</span><span class="sxs-lookup"><span data-stu-id="0cf4d-248">How will back-end core services communicate with each other?</span></span> <span data-ttu-id="0cf4d-249">您是否允许直接 HTTP 调用导致耦合并影响性能和敏捷性？</span><span class="sxs-lookup"><span data-stu-id="0cf4d-249">Will you allow direct HTTP calls that lead to coupling and impact performance and agility?</span></span> <span data-ttu-id="0cf4d-250">或者，您可以考虑将消息传送与队列和主题技术分离？</span><span class="sxs-lookup"><span data-stu-id="0cf4d-250">Or might you consider decoupled messaging with queue and topic technologies?</span></span>

<span data-ttu-id="0cf4d-251">通信内容详包括第 4 章，*云-原生通信模式*。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-251">Communication is covered in detail Chapter 4, *Cloud-Native Communication Patterns*.</span></span>

<span data-ttu-id="0cf4d-252">*复原*</span><span class="sxs-lookup"><span data-stu-id="0cf4d-252">*Resiliency*</span></span>

<span data-ttu-id="0cf4d-253">微服务体系结构将系统从进程内移动到网络通信。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-253">A microservices architecture moves your system from in-process to network communication.</span></span> <span data-ttu-id="0cf4d-254">在分布式环境中，当服务 B 未响应服务 A 的呼叫时，您将执行什么操作？</span><span class="sxs-lookup"><span data-stu-id="0cf4d-254">In a distributed environment, what will you do when Service B isn't responding to a call from Service A?</span></span> <span data-ttu-id="0cf4d-255">当服务 C 暂时不可用，其他调用它的服务将其堆叠并降低系统性能时，会发生什么情况？</span><span class="sxs-lookup"><span data-stu-id="0cf4d-255">What happens when Service C becomes up temporarily unavailable and other services calling it stack and degrade system performance?</span></span>

<span data-ttu-id="0cf4d-256">复原能力详包括第6章，*云原生弹性*。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-256">Resiliency is covered in detail Chapter 6, *Cloud-Native Resiliency*.</span></span>

<span data-ttu-id="0cf4d-257">*分布式数据*</span><span class="sxs-lookup"><span data-stu-id="0cf4d-257">*Distributed Data*</span></span>

<span data-ttu-id="0cf4d-258">根据设计，每个微服务封装自己的数据，通过其公共接口公开操作。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-258">By design, each microservice encapsulates its own data, exposing operations via its public interface.</span></span> <span data-ttu-id="0cf4d-259">如果是，您如何查询数据或跨多个服务实现事务？</span><span class="sxs-lookup"><span data-stu-id="0cf4d-259">If so, how do you query data or implement a transaction across multiple services?</span></span>

<span data-ttu-id="0cf4d-260">分布式数据详包括第 5 章，*云原生数据模式*。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-260">Distributed data is covered in detail Chapter 5, *Cloud-Native Data Patterns*.</span></span>

<span data-ttu-id="0cf4d-261">*标识*</span><span class="sxs-lookup"><span data-stu-id="0cf4d-261">*Identity*</span></span>

<span data-ttu-id="0cf4d-262">您的服务将如何识别访问它的人员以及他们拥有哪些权限？</span><span class="sxs-lookup"><span data-stu-id="0cf4d-262">How will your service identify who is accessing it and what permissions they have?</span></span>

<span data-ttu-id="0cf4d-263">身份详包括第8章 *，《身份*》。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-263">Identity is covered in detail Chapter 8, *Identity*.</span></span>

## <a name="microservices"></a><span data-ttu-id="0cf4d-264">微服务</span><span class="sxs-lookup"><span data-stu-id="0cf4d-264">Microservices</span></span>

<span data-ttu-id="0cf4d-265">云原生系统采用微服务，这是构建现代应用程序的常用体系结构风格。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-265">Cloud-native systems embrace microservices, a popular architectural style for constructing modern applications.</span></span>

<span data-ttu-id="0cf4d-266">微服务是一组分布式独立服务，通过共享结构进行交互，具有以下特征：</span><span class="sxs-lookup"><span data-stu-id="0cf4d-266">Built as a distributed set of small, independent services that interact through a shared fabric, microservices share the following characteristics:</span></span>

- <span data-ttu-id="0cf4d-267">每个在更大的域上下文中实现特定的业务功能。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-267">Each implements a specific business capability within a larger domain context.</span></span>

- <span data-ttu-id="0cf4d-268">每个都是自主开发的，可以独立部署。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-268">Each is developed autonomously and can be deployed independently.</span></span>

- <span data-ttu-id="0cf4d-269">每个都是自包含封装自己的数据存储技术（SQL、NoSQL）和编程平台。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-269">Each is self-contained encapsulating its own data storage technology (SQL, NoSQL) and programming platform.</span></span>

- <span data-ttu-id="0cf4d-270">每个程序都运行在自己的进程中，并使用标准通信协议（如 HTTP/HTTPS、WebSocket 或[AMQP）](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol)与他人通信。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-270">Each runs in its own process and communicates with others using standard communication protocols such as HTTP/HTTPS, WebSockets, or [AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol).</span></span>

- <span data-ttu-id="0cf4d-271">它们组合在一起以形成一个应用程序。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-271">They compose together to form an application.</span></span>

<span data-ttu-id="0cf4d-272">图 1-4 将整体应用程序方法与微服务方法进行对比。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-272">Figure 1-4 contrasts a monolithic application approach with a microservices approach.</span></span> <span data-ttu-id="0cf4d-273">请注意单体如何由分层体系结构组成，该体系结构在单个进程中执行。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-273">Note how the monolith is composed of a layered architecture, which executes in a single process.</span></span> <span data-ttu-id="0cf4d-274">它通常使用关系数据库。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-274">It typically consumes a relational database.</span></span> <span data-ttu-id="0cf4d-275">但是，微服务方法将功能隔离到包含逻辑和数据的独立服务中。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-275">The microservice approach, however, segregates functionality into independent services that include logic and data.</span></span> <span data-ttu-id="0cf4d-276">每个微服务都托管自己的数据存储。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-276">Each microservice hosts its own datastore.</span></span>

![单片部署与微服务](./media/monolithic-vs-microservices.png)

<span data-ttu-id="0cf4d-278">**图 1-4。**</span><span class="sxs-lookup"><span data-stu-id="0cf4d-278">**Figure 1-4.**</span></span> <span data-ttu-id="0cf4d-279">单片部署与微服务</span><span class="sxs-lookup"><span data-stu-id="0cf4d-279">Monolithic deployment versus microservices</span></span>

<span data-ttu-id="0cf4d-280">请注意，微服务如何从本章前面讨论的[十二因子应用程序中](https://12factor.net/)推广"一个代码库，一个应用程序"原则。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-280">Note how microservices promote the "One Codebase, One Application" principle from the [Twelve-Factor Application](https://12factor.net/), discussed earlier in the chapter.</span></span>

> <span data-ttu-id="0cf4d-281">*因子\#1 指定"每个微服务的单一代码库，存储在其自己的存储库中。通过版本控制进行跟踪，它可以部署到多个环境。*</span><span class="sxs-lookup"><span data-stu-id="0cf4d-281">*Factor \#1  specifies "A single codebase for each microservice, stored in its own repository. Tracked with version control, it can deploy to multiple environments."*</span></span>

### <a name="why-microservices"></a><span data-ttu-id="0cf4d-282">为何使用微服务？</span><span class="sxs-lookup"><span data-stu-id="0cf4d-282">Why microservices?</span></span>

<span data-ttu-id="0cf4d-283">微服务提供敏捷性。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-283">Microservices provide agility.</span></span>

<span data-ttu-id="0cf4d-284">在本章前面，我们将构建为单一的电子商务应用程序与微服务进行了比较。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-284">Earlier in the chapter, we compared an eCommerce application built as a monolith to that with microservices.</span></span> <span data-ttu-id="0cf4d-285">在此示例中，我们看到了一些明显的好处：</span><span class="sxs-lookup"><span data-stu-id="0cf4d-285">In the example, we saw some clear benefits:</span></span>

- <span data-ttu-id="0cf4d-286">每个微服务都有自主生命周期，可以独立发展并频繁部署。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-286">Each microservice has an autonomous lifecycle and can evolve independently and deploy frequently.</span></span> <span data-ttu-id="0cf4d-287">您不必等待季度版本来部署新功能或更新。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-287">You don't have to wait for a quarterly release to deploy a new features or update.</span></span> <span data-ttu-id="0cf4d-288">您可以更新复杂应用程序的一小块区域，从而降低破坏整个系统的风险。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-288">You can update a small area of a complex application with less risk of disrupting the entire system.</span></span>

- <span data-ttu-id="0cf4d-289">每个微服务都可以独立扩展。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-289">Each microservice can scale independently.</span></span> <span data-ttu-id="0cf4d-290">您只扩展那些需要更多处理能力或网络带宽的服务，而不是将整个应用程序扩展为单个单元。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-290">Instead of scaling the entire application as a single unit, you scale out only those services that require more processing power or network bandwidth.</span></span> <span data-ttu-id="0cf4d-291">这种细粒度的扩展方法可更好地控制系统，并有助于在扩展系统部分（而不是所有内容）时降低总体成本。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-291">This  fine-grained approach to scaling provides for greater control of your system and helps to reduce overall costs as you scale portions of your system, not everything.</span></span>

<span data-ttu-id="0cf4d-292">理解微服务的优秀参考指南是[.NET 微服务：容器化 .NET 应用程序的体系结构](https://docs.microsoft.com/dotnet/standard/microservices-architecture/)。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-292">An excellent reference guide for understanding microservices is [.NET Microservices: Architecture for Containerized .NET Applications](https://docs.microsoft.com/dotnet/standard/microservices-architecture/).</span></span> <span data-ttu-id="0cf4d-293">这本书深入探讨了微服务设计和建筑。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-293">The book deep dives into microservices design and architecture.</span></span> <span data-ttu-id="0cf4d-294">它是从 Microsoft 免费下载的[全栈微服务参考体系结构](https://github.com/dotnet-architecture/eShopOnContainers)的配套。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-294">It's a companion for a [full-stack microservice reference architecture](https://github.com/dotnet-architecture/eShopOnContainers) available as a free download from Microsoft.</span></span>

### <a name="developing-microservices"></a><span data-ttu-id="0cf4d-295">开发微服务</span><span class="sxs-lookup"><span data-stu-id="0cf4d-295">Developing microservices</span></span>

<span data-ttu-id="0cf4d-296">微服务可以使用任何现代开发平台创建。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-296">Microservices can be created with any modern development platform.</span></span>

<span data-ttu-id="0cf4d-297">微软 .NET 核心平台是一个绝佳的选择。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-297">The Microsoft .NET Core platform is an excellent choice.</span></span> <span data-ttu-id="0cf4d-298">它具有许多内置功能，可简化微服务开发， 具有免费和开源功能。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-298">Free and open source, it has many built-in features to simplify microservice development.</span></span> <span data-ttu-id="0cf4d-299">.NET 核心是跨平台的。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-299">.NET Core is cross-platform.</span></span> <span data-ttu-id="0cf4d-300">可以在 Windows、macOS 和大多数 Linux 风格上构建和运行应用程序。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-300">Applications can be built and run on Windows, macOS, and most flavors of Linux.</span></span>

<span data-ttu-id="0cf4d-301">.NET Core 性能极高，与 Node.js 和其他竞争平台相比得分很高。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-301">.NET Core is highly performant and has scored well in comparison to Node.js and other competing platforms.</span></span> <span data-ttu-id="0cf4d-302">有趣的是[，TechEmpower](https://www.techempower.com/)在许多 Web 应用程序平台和框架中进行了一套广泛的[性能基准](https://www.techempower.com/benchmarks/#section=data-r17&hw=ph&test=plaintext)测试。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-302">Interestingly, [TechEmpower](https://www.techempower.com/) conducted an extensive set of [performance benchmarks](https://www.techempower.com/benchmarks/#section=data-r17&hw=ph&test=plaintext) across many web application platforms and frameworks.</span></span> <span data-ttu-id="0cf4d-303">.NET Core 得分在前 10 名 - 远高于 Node.js 和其他竞争平台。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-303">.NET Core scored in the top 10 - well above Node.js and other competing platforms.</span></span>

<span data-ttu-id="0cf4d-304">.NET 核心由 Microsoft 和 GitHub 上的 .NET 社区维护。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-304">.NET Core is maintained by Microsoft and the .NET community on GitHub.</span></span>

## <a name="containers"></a><span data-ttu-id="0cf4d-305">容器</span><span class="sxs-lookup"><span data-stu-id="0cf4d-305">Containers</span></span>

<span data-ttu-id="0cf4d-306">如今，在任何有关*云原生*的对话中，都自然而然地听到术语*容器*。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-306">Nowadays, it's natural to hear the term *container* mentioned in any conversation concerning *cloud native*.</span></span> <span data-ttu-id="0cf4d-307">在《[云原生模式](https://www.manning.com/books/cloud-native-patterns)》一书中，作者科妮莉亚·戴维斯指出，"容器是云原生软件的一大推动因素。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-307">In the book, [Cloud Native Patterns](https://www.manning.com/books/cloud-native-patterns), author Cornelia Davis observes that, "Containers are a great enabler of cloud-native software."</span></span> <span data-ttu-id="0cf4d-308">云原生计算基金会将微服务容器化作为[云原生跟踪地图](https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png)的第一步 - 为企业开始云原生之旅的指导。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-308">The Cloud Native Computing Foundation places microservice containerization as the first step in their [Cloud-Native Trail Map](https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png) - guidance for enterprises beginning their cloud-native journey.</span></span>

<span data-ttu-id="0cf4d-309">将微服务容器化简单明了。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-309">Containerizing a microservice is simple and straightforward.</span></span> <span data-ttu-id="0cf4d-310">代码、其依赖项和运行时打包到称为[容器映像](https://docs.docker.com/glossary/?term=image)的二进制文件中。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-310">The code, its dependencies, and runtime are packaged into a binary called a [container image](https://docs.docker.com/glossary/?term=image).</span></span> <span data-ttu-id="0cf4d-311">图像存储在[容器注册表](https://caylent.com/container-registries/)中，它充当图像的存储库或库。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-311">Images are stored in a [container registry](https://caylent.com/container-registries/), which acts as a repository or library for images.</span></span> <span data-ttu-id="0cf4d-312">注册表可以位于开发计算机、数据中心或公共云中。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-312">A registry can be located on your development computer, in your data center, or in a public cloud.</span></span> <span data-ttu-id="0cf4d-313">Docker 本身通过 Docker [Hub](https://hub.docker.com/)维护公共注册表。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-313">Docker itself maintains a public registry via [Docker Hub](https://hub.docker.com/).</span></span> <span data-ttu-id="0cf4d-314">Azure 云具有[容器注册表](https://azure.microsoft.com/services/container-registry/)，用于存储靠近将运行它们的云应用程序的容器映像。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-314">The Azure cloud features a [container registry](https://azure.microsoft.com/services/container-registry/) to store container images close to the cloud applications that will run them.</span></span>

<span data-ttu-id="0cf4d-315">如果需要，可以将映像转换为正在运行的容器实例。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-315">When needed, you transform the image into a running container instance.</span></span> <span data-ttu-id="0cf4d-316">实例在安装了[容器运行时](https://kubernetes.io/docs/setup/production-environment/container-runtimes/)引擎的任何计算机上运行。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-316">The instance runs on any computer that has a [container runtime](https://kubernetes.io/docs/setup/production-environment/container-runtimes/) engine installed.</span></span> <span data-ttu-id="0cf4d-317">可以根据需要拥有尽可能多的容器化服务的实例。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-317">You can have as many instances of the containerized service as needed.</span></span>

<span data-ttu-id="0cf4d-318">图 1-5 显示了三个不同的微服务，每个微服务都位于其自己的容器中，在单个主机上运行。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-318">Figure 1-5 shows three different microservices, each in its own container, running on a single host.</span></span>

![在一个容器主机上运行多个容器](./media/hosting-mulitple-containers.png)

<span data-ttu-id="0cf4d-320">**图 1-5**.</span><span class="sxs-lookup"><span data-stu-id="0cf4d-320">**Figure 1-5**.</span></span> <span data-ttu-id="0cf4d-321">在一个容器主机上运行多个容器</span><span class="sxs-lookup"><span data-stu-id="0cf4d-321">Multiple containers running on a container host</span></span>

<span data-ttu-id="0cf4d-322">请注意每个容器如何维护其自己的依赖项和运行时集，这些依赖项和运行时可能不同。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-322">Note how each container maintains its own set of dependencies and runtime, which can be different.</span></span> <span data-ttu-id="0cf4d-323">在这里，我们看到产品微服务的不同版本在同一主机上运行。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-323">Here, we see different versions of the Product microservice running on the same host.</span></span> <span data-ttu-id="0cf4d-324">每个容器共享基础主机操作系统、内存和处理器的一个切片，但彼此隔离。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-324">Each container shares a slice of the underlying host operating system, memory, and processor, but is isolated from one another.</span></span>

<span data-ttu-id="0cf4d-325">请注意容器模型如何很好地接受[来自十二因子应用程序的](https://12factor.net/)"依赖"原则。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-325">Note how well the container model embraces the "Dependencies" principle from the [Twelve-Factor Application](https://12factor.net/).</span></span>

> <span data-ttu-id="0cf4d-326">*因子\#2 指定"每个微服务隔离和打包其自己的依赖项，在不影响整个系统的情况下接受更改。*</span><span class="sxs-lookup"><span data-stu-id="0cf4d-326">*Factor \#2  specifies that "Each microservice isolates and packages its own dependencies, embracing changes without impacting the entire system."*</span></span>

<span data-ttu-id="0cf4d-327">容器同时支持 Linux 和 Windows 工作负载。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-327">Containers support both Linux and Windows workloads.</span></span> <span data-ttu-id="0cf4d-328">Azure 云公开包含这两者。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-328">The Azure cloud openly embraces both.</span></span> <span data-ttu-id="0cf4d-329">有趣的是，Linux，而不是Windows服务器，已经成为Azure中最流行的操作系统。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-329">Interestingly, it's Linux, not Windows Server, that has become the most popular operating system in Azure.</span></span>

<span data-ttu-id="0cf4d-330">虽然存在几个集装箱供应商，但 Docker 已经占据了市场的大部分份额。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-330">While several container vendors exist, Docker has captured the lion's share of the market.</span></span> <span data-ttu-id="0cf4d-331">该公司一直在推动软件容器的移动。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-331">The company has been driving the software container movement.</span></span> <span data-ttu-id="0cf4d-332">它已成为打包、部署和运行云原生应用程序的实际标准。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-332">It has become the de facto standard for packaging, deploying, and running cloud-native applications.</span></span>

### <a name="why-containers"></a><span data-ttu-id="0cf4d-333">为什么选择容器？</span><span class="sxs-lookup"><span data-stu-id="0cf4d-333">Why containers?</span></span>

<span data-ttu-id="0cf4d-334">容器提供可移植性，并保证跨环境的一致性。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-334">Containers provide portability and guarantee consistency across environments.</span></span> <span data-ttu-id="0cf4d-335">通过将所有内容封装到单个包中，您将微服务及其依赖项与基础基础结构*隔离*开来。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-335">By encapsulating everything into a single package, you *isolate* the microservice and its dependencies from the underlying infrastructure.</span></span>

<span data-ttu-id="0cf4d-336">您可以在具有 Docker 运行时引擎的任何环境中部署同一容器。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-336">You can deploy that same container in any environment that has the Docker runtime engine.</span></span> <span data-ttu-id="0cf4d-337">容器化工作负载还消除了使用框架、软件库和运行时引擎预先配置每个环境的费用。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-337">Containerized workloads also eliminate the expense of pre-configuring each environment with frameworks, software libraries, and runtime engines.</span></span>

<span data-ttu-id="0cf4d-338">通过共享底层操作系统和主机资源，容器的占用空间比整个虚拟机小得多。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-338">By sharing the underlying operating system and host resources, containers have a much smaller footprint than a full virtual machine.</span></span> <span data-ttu-id="0cf4d-339">较小的大小会增加给定主机可以同时运行的*密度*或微服务的数量。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-339">The smaller size increases the *density*, or number of microservices, that a given host can run at one time.</span></span>

### <a name="container-orchestration"></a><span data-ttu-id="0cf4d-340">容器业务流程</span><span class="sxs-lookup"><span data-stu-id="0cf4d-340">Container orchestration</span></span>

<span data-ttu-id="0cf4d-341">虽然 Docker 等工具创建映像并运行容器，但您还需要工具来管理它们。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-341">While tools such as Docker create images and run containers, you also need tools to manage them.</span></span> <span data-ttu-id="0cf4d-342">容器管理使用称为容器协调器的特殊软件程序来完成。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-342">Container management is done with a special software program called a container orchestrator.</span></span> <span data-ttu-id="0cf4d-343">大规模运行时，容器编排至关重要。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-343">When operating at scale, container orchestration is essential.</span></span>

<span data-ttu-id="0cf4d-344">图 1-6 显示了容器协调器提供的管理任务。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-344">Figure 1-6 shows management tasks that container orchestrators provide.</span></span>

![容器协调器执行哪些操作](./media/what-container-orchestrators-do.png)

<span data-ttu-id="0cf4d-346">**图1-6**.</span><span class="sxs-lookup"><span data-stu-id="0cf4d-346">**Figure 1-6**.</span></span> <span data-ttu-id="0cf4d-347">容器协调器执行哪些操作</span><span class="sxs-lookup"><span data-stu-id="0cf4d-347">What container orchestrators do</span></span>

<span data-ttu-id="0cf4d-348">下表描述了常见的业务流程任务。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-348">The following table describes common orchestration tasks.</span></span>

|  <span data-ttu-id="0cf4d-349">任务</span><span class="sxs-lookup"><span data-stu-id="0cf4d-349">Tasks</span></span> | <span data-ttu-id="0cf4d-350">说明</span><span class="sxs-lookup"><span data-stu-id="0cf4d-350">Explanation</span></span>  |
| :-------- | :-------- |
| <span data-ttu-id="0cf4d-351">计划</span><span class="sxs-lookup"><span data-stu-id="0cf4d-351">Scheduling</span></span> | <span data-ttu-id="0cf4d-352">自动预配容器实例。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-352">Automatically provision container instances.</span></span>|
| <span data-ttu-id="0cf4d-353">亲和力/反亲和力</span><span class="sxs-lookup"><span data-stu-id="0cf4d-353">Affinity/anti-affinity</span></span> | <span data-ttu-id="0cf4d-354">在附近或相距甚远的地方预配容器，帮助提供可用性和性能。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-354">Provision containers nearby or far apart from each other, helping  availability and performance.</span></span> |
| <span data-ttu-id="0cf4d-355">运行状况监视</span><span class="sxs-lookup"><span data-stu-id="0cf4d-355">Health monitoring</span></span> | <span data-ttu-id="0cf4d-356">自动检测并纠正故障。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-356">Automatically detect and correct failures.</span></span>|
| <span data-ttu-id="0cf4d-357">故障转移</span><span class="sxs-lookup"><span data-stu-id="0cf4d-357">Failover</span></span> | <span data-ttu-id="0cf4d-358">自动将失败的实例重新调配到正常运行的计算机。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-358">Automatically reprovision failed instance to healthy machines.</span></span>|
| <span data-ttu-id="0cf4d-359">扩展</span><span class="sxs-lookup"><span data-stu-id="0cf4d-359">Scaling</span></span> | <span data-ttu-id="0cf4d-360">自动添加或删除容器实例以满足需求。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-360">Automatically add or remove container instance to meet demand.</span></span>|
| <span data-ttu-id="0cf4d-361">网络</span><span class="sxs-lookup"><span data-stu-id="0cf4d-361">Networking</span></span> | <span data-ttu-id="0cf4d-362">管理容器通信的网络覆盖。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-362">Manage a networking overlay for container communication.</span></span>|
| <span data-ttu-id="0cf4d-363">服务发现</span><span class="sxs-lookup"><span data-stu-id="0cf4d-363">Service Discovery</span></span> | <span data-ttu-id="0cf4d-364">使容器能够彼此定位。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-364">Enable containers to locate each other.</span></span>|
| <span data-ttu-id="0cf4d-365">滚动升级</span><span class="sxs-lookup"><span data-stu-id="0cf4d-365">Rolling Upgrades</span></span> | <span data-ttu-id="0cf4d-366">通过零停机时间部署协调增量升级。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-366">Coordinate incremental upgrades with zero downtime deployment.</span></span> <span data-ttu-id="0cf4d-367">自动回滚有问题的更改。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-367">Automatically roll back problematic changes.</span></span>|

<span data-ttu-id="0cf4d-368">请注意，协调器如何接受本章前面讨论的[十二因子应用程序中](https://12factor.net/)的可处置性和并发性原则。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-368">Note how orchestrators embrace the disposability and concurrency principles from the [Twelve-Factor Application](https://12factor.net/), discussed earlier in the chapter.</span></span>

> <span data-ttu-id="0cf4d-369">*因子\#9 指定"服务实例应该是一次性的，有利于快速启动来增加可伸缩性机会和正常关机，使系统处于正确的状态。Docker 容器以及协调器本身就满足了这一要求。*</span><span class="sxs-lookup"><span data-stu-id="0cf4d-369">*Factor \#9  specifies that "Service instances should be disposable, favoring fast startups to increase scalability opportunities and graceful shutdowns to leave the system in a correct state. Docker containers along with an orchestrator inherently satisfy this requirement."*</span></span>

> <span data-ttu-id="0cf4d-370">*因子\#8 指定"服务跨大量小型相同进程（副本）进行横向扩展，而不是在最强大的计算机上扩展单个大型实例。*</span><span class="sxs-lookup"><span data-stu-id="0cf4d-370">*Factor \#8  specifies that "Services scale out across a large number of small identical processes (copies) as opposed to scaling-up a single large instance on the most powerful machine available."*</span></span>

<span data-ttu-id="0cf4d-371">虽然存在多个容器协调器，[但库伯奈斯](https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/)已成为云原生世界的实际标准。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-371">While several container orchestrators exist, [Kubernetes](https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/) has become the de facto standard for the cloud-native world.</span></span> <span data-ttu-id="0cf4d-372">它是一个可移植的、可扩展的开源平台，用于管理容器化工作负载。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-372">It's a portable, extensible, open-source platform for managing containerized workloads.</span></span>

<span data-ttu-id="0cf4d-373">您可以托管自己的 Kubernetes 实例，但随后您将负责预配和管理其资源-这可能很复杂。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-373">You could host your own instance of Kubernetes, but then you'd be responsible for provisioning and managing its resources - which can be complex.</span></span> <span data-ttu-id="0cf4d-374">Azure 云将库伯奈斯作为托管服务[，Azure 库伯奈斯服务 （AKS） 。](https://azure.microsoft.com/services/kubernetes-service/)</span><span class="sxs-lookup"><span data-stu-id="0cf4d-374">The Azure cloud features Kubernetes as a managed service, [Azure Kubernetes Service (AKS)](https://azure.microsoft.com/services/kubernetes-service/).</span></span> <span data-ttu-id="0cf4d-375">托管服务允许您充分利用其功能，而无需安装和维护它。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-375">A managed service allows you to fully leverage its features, without having to install and maintain it.</span></span>

<span data-ttu-id="0cf4d-376">Azure 库伯奈斯服务详细介绍了第 2 章"*扩展云原生应用程序*"。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-376">Azure Kubernetes Services is covered in detail Chapter 2, *Scaling Cloud-Native Applications*.</span></span>

## <a name="backing-services"></a><span data-ttu-id="0cf4d-377">支持服务</span><span class="sxs-lookup"><span data-stu-id="0cf4d-377">Backing services</span></span>

<span data-ttu-id="0cf4d-378">云本机系统依赖于许多不同的辅助资源，如数据存储、消息代理、监视和标识服务。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-378">Cloud-native systems depend upon many different ancillary resources, such as data stores, message brokers, monitoring, and identity services.</span></span> <span data-ttu-id="0cf4d-379">这些服务被称为[支持服务](https://12factor.net/backing-services)。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-379">These services are known as [backing services](https://12factor.net/backing-services).</span></span>

 <span data-ttu-id="0cf4d-380">图 1-7 显示了云本机系统使用的许多常见支持服务。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-380">Figure 1-7 shows many common backing services that cloud-native systems consume.</span></span>

![常见的支持服务](./media/common-backing-services.png)

<span data-ttu-id="0cf4d-382">**图 1-7**.</span><span class="sxs-lookup"><span data-stu-id="0cf4d-382">**Figure 1-7**.</span></span> <span data-ttu-id="0cf4d-383">常见的支持服务</span><span class="sxs-lookup"><span data-stu-id="0cf4d-383">Common backing services</span></span>

<span data-ttu-id="0cf4d-384">支持服务从本章前面讨论的[十二因子应用](https://12factor.net/)中推广"无国籍"原则。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-384">Backing services promote the "Statelessness" principle from the [Twelve-Factor Application](https://12factor.net/), discussed earlier in the chapter.</span></span>

><span data-ttu-id="0cf4d-385">*因子\#6*指定，"每个微服务都应在其自己的进程中执行，与其他正在运行的服务隔离。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-385">*Factor \#6* specifies that, "Each microservice should execute in its own process, isolated from other running services.</span></span> <span data-ttu-id="0cf4d-386">将所需状态外部化到备份服务（如分布式缓存或数据存储）。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-386">Externalize required state to a backing service such as a distributed cache or data store."</span></span>

<span data-ttu-id="0cf4d-387">您可以托管自己的支持服务，但随后您将负责许可、预配和管理这些资源。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-387">You could host your own backing services, but then you'd be responsible for licensing, provisioning, and managing those resources.</span></span>

<span data-ttu-id="0cf4d-388">云提供商提供种类繁多的*托管支持服务。*</span><span class="sxs-lookup"><span data-stu-id="0cf4d-388">Cloud providers offer a rich assortment of *managed backing services.*</span></span> <span data-ttu-id="0cf4d-389">您只需使用该服务，而不是拥有该服务。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-389">Instead of owning the service, you simply consume it.</span></span> <span data-ttu-id="0cf4d-390">提供商大规模运营资源，并负责性能、安全性和维护。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-390">The provider operates the resource at scale and bears the responsibility for performance, security, and maintenance.</span></span> <span data-ttu-id="0cf4d-391">服务中内置了监视、冗余和可用性。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-391">Monitoring, redundancy, and availability are built into the service.</span></span> <span data-ttu-id="0cf4d-392">提供商完全支持其托管服务 - 打开票证，他们修复您的问题。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-392">Providers fully support their managed services - open a ticket and they fix your issue.</span></span>

<span data-ttu-id="0cf4d-393">云原生系统青睐云供应商的托管支持服务。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-393">Cloud-native systems favor managed backing services from cloud vendors.</span></span> <span data-ttu-id="0cf4d-394">时间和劳动力的节省很大。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-394">The savings in time and labor are great.</span></span> <span data-ttu-id="0cf4d-395">托管您自己的操作风险和遇到麻烦可能会很快变得昂贵。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-395">The operational risk of hosting your own and experiencing trouble can get expensive fast.</span></span>

<span data-ttu-id="0cf4d-396">最佳做法是将备份服务视为*附加资源*，动态绑定到微服务，其中信息（URL 和凭据）存储在外部配置中。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-396">A best practice is to treat a backing service as an *attached resource*, dynamically bound to a microservice with information (a URL and credentials) stored in an external configuration.</span></span> <span data-ttu-id="0cf4d-397">本指南在本章前面讨论的[十二因子应用程序中](https://12factor.net/)进行了详细说明。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-397">This guidance is spelled out in the [Twelve-Factor Application](https://12factor.net/), discussed earlier in the chapter.</span></span>

><span data-ttu-id="0cf4d-398">*因子\#4*指定支持服务"应通过可寻址 URL 公开。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-398">*Factor \#4* specifies that backing services "should be exposed via an addressable URL.</span></span> <span data-ttu-id="0cf4d-399">这样做会将资源与应用程序分离，使其易于互换。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-399">Doing so decouples the resource from the application, enabling it to be interchangeable."</span></span>

><span data-ttu-id="0cf4d-400">*因子\#3*指定"配置信息从微服务中移出，并通过代码外部的配置管理工具进行外部化。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-400">*Factor \#3* specifies that "Configuration information is moved out of the microservice and externalized through a configuration management tool outside of the code."</span></span>

<span data-ttu-id="0cf4d-401">使用此模式，无需更改代码即可连接和分离支持服务。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-401">With this pattern, a backing service can be attached and detached without code changes.</span></span> <span data-ttu-id="0cf4d-402">您可以将微服务从 QA 提升为暂存环境。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-402">You might promote a microservice from QA to a staging environment.</span></span> <span data-ttu-id="0cf4d-403">更新微服务配置以指向暂存中的备份服务，并通过环境变量将设置注入容器。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-403">You update the microservice configuration to point to the backing services in staging and inject the settings into your container through an environment variable.</span></span>

<span data-ttu-id="0cf4d-404">云供应商提供 API，以便您与其专有的支持服务进行通信。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-404">Cloud vendors provide APIs for you to communicate with their proprietary backing services.</span></span> <span data-ttu-id="0cf4d-405">这些库封装了管道和复杂性。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-405">These libraries encapsulate the plumbing and complexity.</span></span> <span data-ttu-id="0cf4d-406">直接与这些 API 通信会将代码与备份服务紧密耦合。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-406">Communicating directly with these APIs will tightly couple your code to the backing service.</span></span> <span data-ttu-id="0cf4d-407">最好隔离供应商 API 的实现详细信息。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-407">It's a better practice to insulate the implementation details of the vendor API.</span></span> <span data-ttu-id="0cf4d-408">引入中介层或中间 API，将泛型操作公开给服务代码。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-408">Introduce an intermediation layer, or intermediate API, exposing generic operations to your service code.</span></span> <span data-ttu-id="0cf4d-409">这种松散的耦合使您能够将一个备份服务交换到另一个备份服务，或者将代码移动到其他公共云，而无需更改主线服务代码。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-409">This loose coupling enables you to swap out one backing service for another or move your code to a different public cloud without having to make changes to the mainline service code.</span></span>

<span data-ttu-id="0cf4d-410">支持服务将详细讨论第 5 章，*云原生数据模式*，和第 4 章，*云-本机通信模式*。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-410">Backing services are discussed in detail Chapter 5, *Cloud-Native Data Patterns*, and Chapter 4, *Cloud-Native Communication Patterns*.</span></span>

## <a name="automation"></a><span data-ttu-id="0cf4d-411">自动化</span><span class="sxs-lookup"><span data-stu-id="0cf4d-411">Automation</span></span>

<span data-ttu-id="0cf4d-412">正如您所看到的，云原生系统采用微服务、容器和现代系统设计，以实现速度和敏捷性。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-412">As you've seen, cloud-native systems embrace microservices, containers, and modern system design to achieve speed and agility.</span></span> <span data-ttu-id="0cf4d-413">但是，这只是故事的一部分。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-413">But, that's only part of the story.</span></span> <span data-ttu-id="0cf4d-414">如何预配这些系统运行的云环境？</span><span class="sxs-lookup"><span data-stu-id="0cf4d-414">How do you provision the cloud environments upon which these systems run?</span></span> <span data-ttu-id="0cf4d-415">如何快速部署应用功能和更新？</span><span class="sxs-lookup"><span data-stu-id="0cf4d-415">How do you rapidly deploy app features and updates?</span></span> <span data-ttu-id="0cf4d-416">你如何全面了解情况？</span><span class="sxs-lookup"><span data-stu-id="0cf4d-416">How do you round out the full picture?</span></span>

<span data-ttu-id="0cf4d-417">输入广泛接受的[基础结构作为代码](https://docs.microsoft.com/azure/devops/learn/what-is-infrastructure-as-code)，或 IaC 的实践。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-417">Enter the widely accepted practice of [Infrastructure as Code](https://docs.microsoft.com/azure/devops/learn/what-is-infrastructure-as-code), or IaC.</span></span>

<span data-ttu-id="0cf4d-418">使用 IaC，您可以自动执行平台配置和应用程序部署。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-418">With IaC, you automate platform provisioning and application deployment.</span></span> <span data-ttu-id="0cf4d-419">您基本上将软件工程实践（如测试和版本控制）应用于 DevOps 实践。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-419">You essentially apply software engineering practices such as testing and versioning to your DevOps practices.</span></span> <span data-ttu-id="0cf4d-420">您的基础架构和部署是自动化、一致且可重复的。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-420">Your infrastructure and deployments are automated, consistent, and repeatable.</span></span>

### <a name="automating-infrastructure"></a><span data-ttu-id="0cf4d-421">自动化基础架构</span><span class="sxs-lookup"><span data-stu-id="0cf4d-421">Automating infrastructure</span></span>

<span data-ttu-id="0cf4d-422">Azure[资源管理器](https://azure.microsoft.com/documentation/articles/resource-group-overview/)、Terraform 和 Azure [CLI](https://docs.microsoft.com/cli/azure/)等工具使您能够以声明方式编写所需的云基础结构的脚本。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-422">Tools like [Azure Resource Manager](https://azure.microsoft.com/documentation/articles/resource-group-overview/), Terraform, and the [Azure CLI](https://docs.microsoft.com/cli/azure/), enable you to declaratively script the cloud infrastructure you require.</span></span> <span data-ttu-id="0cf4d-423">资源名称、位置、容量和机密是参数化的和动态的。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-423">Resource names, locations, capacities, and secrets are parameterized and dynamic.</span></span> <span data-ttu-id="0cf4d-424">脚本作为项目的项目版本控制和签入源代码管理。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-424">The script is versioned and checked into source control as an artifact of your project.</span></span> <span data-ttu-id="0cf4d-425">调用脚本可跨系统环境（如 QA、暂存和生产）预配一致且可重复的基础结构。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-425">You invoke the script to provision a consistent and repeatable infrastructure across system environments, such as QA, staging, and production.</span></span>

<span data-ttu-id="0cf4d-426">在引擎盖下，IaC是幂等的，这意味着你可以运行相同的脚本一遍又一遍没有副作用。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-426">Under the hood, IaC is idempotent, meaning that you can run the same script over and over without side effects.</span></span> <span data-ttu-id="0cf4d-427">如果团队需要进行更改，他们将编辑并重新运行脚本。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-427">If the team needs to make a change, they edit and rerun the script.</span></span> <span data-ttu-id="0cf4d-428">只有更新的资源受到影响。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-428">Only the updated resources are affected.</span></span>

<span data-ttu-id="0cf4d-429">在《[什么是基础设施是代码》](https://docs.microsoft.com/azure/devops/learn/what-is-infrastructure-as-code)一文中，作者 Sam Guckenheimer 描述了"实施 IaC 的团队如何快速、大规模地提供稳定的环境。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-429">In the article, [What is Infrastructure as Code](https://docs.microsoft.com/azure/devops/learn/what-is-infrastructure-as-code), Author Sam Guckenheimer describes how, "Teams who implement IaC can deliver stable environments rapidly and at scale.</span></span> <span data-ttu-id="0cf4d-430">团队通过代码表示其环境的所需状态，避免手动配置环境并增强一致性。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-430">Teams avoid manual configuration of environments and enforce consistency by representing the desired state of their environments via code.</span></span> <span data-ttu-id="0cf4d-431">具有 IaC 的基础结构部署是可重复的，可防止由于配置漂移或缺少依赖项而导致的运行时问题。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-431">Infrastructure deployments with IaC are repeatable and prevent runtime issues caused by configuration drift or missing dependencies.</span></span> <span data-ttu-id="0cf4d-432">DevOps 团队可以协同使用一套统一的实践和工具，快速、可靠、大规模地交付应用程序及其支持基础架构。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-432">DevOps teams can work together with a unified set of practices and tools to deliver applications and their supporting infrastructure rapidly, reliably, and at scale."</span></span>

### <a name="automating-deployments"></a><span data-ttu-id="0cf4d-433">自动化部署</span><span class="sxs-lookup"><span data-stu-id="0cf4d-433">Automating deployments</span></span>

<span data-ttu-id="0cf4d-434">前面讨论的[十二因子应用程序](https://12factor.net/)要求在将已完成的代码转换为正在运行的应用程序时采取单独的步骤。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-434">The [Twelve-Factor Application](https://12factor.net/), discussed earlier, calls for separate steps when transforming completed code into a running application.</span></span>

> <span data-ttu-id="0cf4d-435">*因子\#5*指定"每个版本必须跨生成、发布和运行阶段强制实施严格的分离。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-435">*Factor \#5* specifies that "Each release must enforce a strict separation across the build, release and run stages.</span></span> <span data-ttu-id="0cf4d-436">每个都应使用唯一的 ID 标记，并支持回滚的能力。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-436">Each should be tagged with a unique ID and support the ability to roll back."</span></span>

<span data-ttu-id="0cf4d-437">现代 CI/CD 系统有助于实现这一原则。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-437">Modern CI/CD systems help fulfill this principle.</span></span> <span data-ttu-id="0cf4d-438">它们提供了单独的部署步骤，有助于确保用户随时可用的一致且高质量的代码。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-438">They provide separate deployment steps and help ensure consistent and quality code that's readily available to users.</span></span>

<span data-ttu-id="0cf4d-439">图 1-8 显示了整个部署过程的分离。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-439">Figure 1-8 shows the separation across the deployment process.</span></span>

![CI/CD 管道中的部署步骤](./media/build-release-run-pipeline.png)

<span data-ttu-id="0cf4d-441">**图 1-8**.</span><span class="sxs-lookup"><span data-stu-id="0cf4d-441">**Figure 1-8**.</span></span> <span data-ttu-id="0cf4d-442">CI/CD 管道中的部署步骤</span><span class="sxs-lookup"><span data-stu-id="0cf4d-442">Deployment steps in a CI/CD Pipeline</span></span>

<span data-ttu-id="0cf4d-443">在上图中，特别注意任务分离。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-443">In the previous figure, pay special attention to separation of tasks.</span></span>

<span data-ttu-id="0cf4d-444">开发人员在其开发环境中构造一个功能，通过代码、运行和调试的所谓"内部循环"进行迭代。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-444">The developer constructs a feature in their development environment, iterating through what is called the "inner loop" of code, run, and debug.</span></span> <span data-ttu-id="0cf4d-445">完成后，该代码将*推送*到代码存储库中，如 GitHub、Azure DevOps 或 BitBucket。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-445">When complete, that code is *pushed* into a code repository, such as GitHub, Azure DevOps, or BitBucket.</span></span>

<span data-ttu-id="0cf4d-446">推送将触发生成阶段，将代码转换为二进制项目。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-446">The push triggers a build stage that transforms the code into a binary artifact.</span></span> <span data-ttu-id="0cf4d-447">工作使用[持续集成 （CI）](https://martinfowler.com/articles/continuousIntegration.html)管道实现。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-447">The work is implemented with a [Continuous Integration (CI)](https://martinfowler.com/articles/continuousIntegration.html) pipeline.</span></span> <span data-ttu-id="0cf4d-448">它会自动生成、测试和打包应用程序。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-448">It automatically builds, tests, and packages the application.</span></span>

<span data-ttu-id="0cf4d-449">发布阶段拾取二进制项目，应用外部应用程序和环境配置信息，并生成不可变版本。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-449">The release stage picks up the binary artifact, applies external application and environment configuration information, and produces an immutable release.</span></span> <span data-ttu-id="0cf4d-450">该版本部署到指定的环境。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-450">The release is deployed to a specified environment.</span></span> <span data-ttu-id="0cf4d-451">工作使用[连续交付 （CD）](https://martinfowler.com/bliki/ContinuousDelivery.html)管道实现。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-451">The work is implemented with a [Continuous Delivery(CD)](https://martinfowler.com/bliki/ContinuousDelivery.html) pipeline.</span></span> <span data-ttu-id="0cf4d-452">每个版本都应可识别。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-452">Each release should be identifiable.</span></span> <span data-ttu-id="0cf4d-453">您可以说，"此部署正在运行应用程序的第 2.1.1 版。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-453">You can say, "This deployment is running Release 2.1.1 of the application."</span></span>

<span data-ttu-id="0cf4d-454">最后，在目标执行环境中运行释放的功能。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-454">Finally, the released feature is run in the target execution environment.</span></span> <span data-ttu-id="0cf4d-455">版本是不可变的，这意味着任何更改都必须创建新版本。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-455">Releases are immutable meaning that any change must create a new release.</span></span>

<span data-ttu-id="0cf4d-456">应用这些实践，组织已经从根本上改变了它们运送软件的方式。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-456">Applying these practices, organizations have radically evolved how they ship software.</span></span> <span data-ttu-id="0cf4d-457">许多产品已经从季度发布迁移到按需更新。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-457">Many have moved from quarterly releases to on-demand updates.</span></span> <span data-ttu-id="0cf4d-458">目标是在开发周期的早期发现问题，而问题修复成本较低。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-458">The goal is to catch problems early in the development cycle when they're less expensive to fix.</span></span> <span data-ttu-id="0cf4d-459">集成之间的持续时间越长，解决问题的成本就越高。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-459">The longer the duration between integrations, the more expensive problems become to resolve.</span></span>  <span data-ttu-id="0cf4d-460">通过集成过程的一致性，团队可以更频繁地提交代码更改，从而提供更好的协作和软件质量。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-460">With consistency in the integration process, teams can commit code changes more frequently, leading to better collaboration and software quality.</span></span>

### <a name="azure-pipelines"></a><span data-ttu-id="0cf4d-461">Azure Pipelines</span><span class="sxs-lookup"><span data-stu-id="0cf4d-461">Azure Pipelines</span></span>

<span data-ttu-id="0cf4d-462">Azure 云包括名为[Azure 管道](https://azure.microsoft.com/services/devops/pipelines/)的新 CI/CD 服务，该服务是图 1-9 所示的[Azure DevOps](https://azure.microsoft.com/services/devops/)服务的一部分。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-462">The Azure cloud includes a new CI/CD service entitled [Azure Pipelines](https://azure.microsoft.com/services/devops/pipelines/), which is part of the [Azure DevOps](https://azure.microsoft.com/services/devops/) offering shown in Figure 1-9.</span></span>

![开发人员中的 Azure 管道](./media/devops-components.png)

<span data-ttu-id="0cf4d-464">**图 1-9**.</span><span class="sxs-lookup"><span data-stu-id="0cf4d-464">**Figure 1-9**.</span></span> <span data-ttu-id="0cf4d-465">Azure 开发人员计划产品</span><span class="sxs-lookup"><span data-stu-id="0cf4d-465">Azure DevOps offerings</span></span>

<span data-ttu-id="0cf4d-466">Azure 管道是一种云服务，结合了持续集成 （CI） 和持续交付 （CD）。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-466">Azure Pipelines is a cloud service that combines continuous integration (CI) and continuous delivery (CD).</span></span> <span data-ttu-id="0cf4d-467">您可以自动测试、生成代码并将代码运送到任何目标。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-467">You can automatically test, build, and ship your code to any target.</span></span>

<span data-ttu-id="0cf4d-468">在 YAML 文件中的代码中定义管道，以及应用的其他代码。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-468">You define your pipeline in code in a YAML file alongside the rest of the code for your app.</span></span>

- <span data-ttu-id="0cf4d-469">管道使用代码进行版本控制，并遵循相同的分支结构。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-469">The pipeline is versioned with your code and follows the same branching structure.</span></span>
- <span data-ttu-id="0cf4d-470">通过在拉取请求和分支生成策略中的代码评审来验证更改。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-470">You get validation of your changes through code reviews in pull requests and branch build policies.</span></span>
- <span data-ttu-id="0cf4d-471">使用的每个分支都可以通过修改 azure 管道.yml 文件来自定义生成策略。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-471">Every branch you use can customize the build policy by modifying the azure-pipelines.yml file.</span></span>
- <span data-ttu-id="0cf4d-472">管道文件将签入版本控制，如果存在问题，可以进行调查。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-472">The pipeline file is checked into version control and can be investigated if there's a problem.</span></span>

<span data-ttu-id="0cf4d-473">Azure 管道服务支持大多数 Git 提供程序，并可以为在 Linux、macOS 或 Windows 平台上编写的应用程序生成部署管道。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-473">The Azure Pipelines service supports most Git providers and can generate deployment pipelines for applications written on the Linux, macOS, or Windows platforms.</span></span> <span data-ttu-id="0cf4d-474">它包括对Java、.NET、JavaScript、Python、PHP、Go、XCode和C++的支持。</span><span class="sxs-lookup"><span data-stu-id="0cf4d-474">It includes support for Java, .NET, JavaScript, Python, PHP, Go, XCode, and C++.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="0cf4d-475">[上一页](introduction.md)
>[下一页](candidate-apps.md)</span><span class="sxs-lookup"><span data-stu-id="0cf4d-475">[Previous](introduction.md)
[Next](candidate-apps.md)</span></span>
