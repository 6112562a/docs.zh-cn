---
title: 定义云本机
description: 了解为云原生系统提供基岩的基础支柱
author: robvet
ms.date: 08/20/2019
ms.openlocfilehash: 756a2565bd77fcef19a5f15579987836ff0e75a4
ms.sourcegitcommit: e3cbf26d67f7e9286c7108a2752804050762d02d
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/09/2020
ms.locfileid: "80989085"
---
# <a name="defining-cloud-native"></a>定义云本机

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

停止你正在做的事情，给十位同事发短信。 请他们定义术语"云原生"。 很有可能你会得到八个不同的答案。

云原生就是改变我们构建关键业务系统的方式。

云原生系统旨在适应快速变化、大规模和弹性。

云原生计算基金会提供了一[个官方的定义](https://github.com/cncf/foundation/blob/master/charter.md)：

> *云原生技术使组织能够在公共、私有和混合云等现代动态环境中构建和运行可扩展的应用程序。容器、服务同理、微服务、不可变基础结构和声明性 API 就是此方法的例证。*

> *这些技术支持具有弹性、可管理和可观测的松散耦合系统。结合强大的自动化，它们使工程师能够以最少的辛劳频繁、可预见地进行高影响更改。*

随着用户要求越来越高，应用程序变得越来越复杂。 用户期望快速响应、创新功能和零停机时间。 性能问题、反复出现的错误和无法快速移动不再为所接受。 他们很容易转移到你的竞争对手。

云原生是很多关于*速度和**敏捷*性。 业务系统正在从支持业务能力演变为战略转型、加快业务速度和增长的武器。 立即将创意推向市场势在必行。

以下是一些已经实施了这些技术的公司。 考虑他们实现的速度、敏捷性和可扩展性。

| Company | 体验 |
| :-------- | :-------- |
| [Netflix](https://www.infoq.com/news/2013/06/netflix/) | 有 600 多种生产服务。 每天部署一百次。 |
| [超级](https://eng.uber.com/micro-deploy/) | 生产中存储了 1，000 多个服务。 每周部署几千个生成。 |
| [微信](https://www.cs.columbia.edu/~ruigu/papers/socc18-final100.pdf) | 有 300 多种生产服务。 每天进行近 1，000 次更改。 |

正如您所看到的，Netflix、优步和微信公开了由数百个独立的微服务组成的系统。 这种建筑风格使他们能够快速响应市场条件。 他们可以即时更新实时复杂应用程序的小区域，并根据需要单独缩放这些区域。

云原生的速度和敏捷性来自许多因素。 首先是云基础架构。 图 1-3 所示的另外五个基柱也为云原生系统提供了基岩。

![云原生基础支柱](./media/cloud-native-foundational-pillars.png)

**图1-3**。 云原生基础支柱

让我们花一些时间来更好地了解每个支柱的重要性。

## <a name="the-cloud"></a>云...

云原生系统充分利用了云服务模型。

这些系统旨在在动态虚拟化的云环境中蓬勃发展，广泛使用[平台即服务 （PaaS）](https://azure.microsoft.com/overview/what-is-paas/)计算基础架构和托管服务。 他们将底层基础架构视为*一次性*基础结构 - 在几分钟内预配，并通过自动化按需调整规模、缩放、移动或销毁。

考虑广泛接受的DevOps概念[宠物与牛](https://medium.com/@Joachim8675309/devops-concepts-pets-vs-cattle-2380b5aab313)。 在传统的数据中心中，服务器被视为*宠物*：物理机器，被赋予一个有意义的名称，并受到关注。 通过向同一计算机添加更多资源（向上扩展）进行扩展。 如果服务器生病，您将将其护理回运行状况。 如果服务器不可用，每个人都会注意到。

*牛*服务模式不同。 将每个实例预配为虚拟机或容器。 它们相同，并分配了系统标识符，如服务-01、服务-02等。 您可以通过创建更多（向外扩展）进行扩展。 当一个人变得不可用时，没有人会注意到。

牛模式拥抱*了不变的基础设施*。 服务器未修复或修改。 如果一个失败或需要更新，它将被销毁，并预配了新的更新 - 所有这些都通过自动化完成。

云原生系统采用牛服务模式。 它们继续随着基础结构的扩展或运行而运行，而不考虑运行的机器。

Azure 云平台支持这种类型的高弹性基础架构，具有自动缩放、自我修复和监视功能。

## <a name="modern-design"></a>现代设计

您将如何设计云原生应用？ 您的体系结构是什么样子的？ 您会遵循哪些原则、模式和最佳实践？ 哪些基础设施和运营问题很重要？

### <a name="the-twelve-factor-application"></a>十二因子应用

构建基于云的应用程序是一种被广泛接受的方法是[十二因子应用程序](https://12factor.net/)。 它描述了开发人员遵循的一组原则和实践，以构建针对现代云环境优化的应用程序。 特别注意跨环境的可移植性和声明性自动化。

虽然适用于任何基于 Web 的应用程序，但许多从业者认为它是构建云原生应用的坚实基础。 基于这些原则构建的系统可以快速部署和扩展，并添加功能以快速响应市场变化。

下表重点介绍了十二因子方法：

|    |  因素 | 说明  |
| :-------- | :-------- | :-------- |
| 1 | 代码库 | 每个微服务的单一代码库，存储在其自己的存储库中。 通过版本控制进行跟踪，它可以部署到多个环境（QA、暂存、生产）。 |
| 2 | 依赖项 | 每个微服务隔离和打包自己的依赖项，在不影响整个系统的情况下接受更改。 |
| 3 | 配置  | 配置信息从微服务中移出，并通过代码外部的配置管理工具进行外部化。 相同的部署可以在应用正确配置的环境中传播。  |
| 4 | 支持服务 | 辅助资源（数据存储、缓存、消息代理）应通过可寻址 URL 公开。 这样做会将资源与应用程序分离，使其可互换。  |
| 5 | 生成、发布、运行 | 每个版本都必须在生成、发布和运行阶段强制实施严格的分离。 每个应标记一个唯一的 ID，并支持回滚的能力。 现代 CI/CD 系统有助于实现这一原则。 |
| 6 | 进程 | 每个微服务都应在自己的进程中执行，与其他正在运行的服务隔离。 将所需状态外部化到备份服务（如分布式缓存或数据存储）。 |
| 7 | 端口绑定 | 每个微服务都应自包含其接口和功能，并在其自己的端口上公开。 这样做会与其他微服务隔离。 |
| 8 | 并发 | 服务将扩展在大量小型相同进程（副本）上，而不是在最强大的计算机上扩展单个大型实例。 |
| 9 | 可处置性 | 服务实例应该是一次性的，有利于快速启动来增加可伸缩性机会和正常关机，使系统处于正确的状态。 Docker 容器以及协调器本身就满足了此要求。 |
| 10 | 开发/升序奇偶校验 | 使整个应用程序生命周期中的环境尽可能相似，避免昂贵的快捷方式。 在这里，采用容器可以极大地促进相同的执行环境。 |
| 11 | 日志记录 | 将微服务生成的日志视为事件流。 使用事件聚合器处理它们，并将数据传播到数据挖掘/日志管理工具（如 Azure 监视器或 Splunk），并最终进行长期存档。 |
| 12 | 管理流程 | 将管理/管理任务作为一次性流程运行。 任务可以包括报表的数据清理和拉取分析。 执行这些任务的工具应从生产环境调用，但与应用程序分开调用。 |

在《 [十二因素应用》](https://content.pivotal.io/blog/beyond-the-twelve-factor-app)一书中，作者凯文·霍夫曼详细介绍了最初的12个因素（写于2011年）。 此外，本书还提供了反映当今现代云应用程序设计的三个附加因素。

|    |  新因素 | 说明  |
| :-------- | :-------- | :-------- |
| 13 | API 优先 | 使一切成为服务。 假设您的代码将被前端客户端、网关或其他服务使用。 |
| 14 | 遥测 | 在工作站上，您可以深入了解应用程序及其行为。 在云中，你没有。 确保您的设计包括监视、特定于域和运行状况/系统数据的集合。 |
| 15 | 身份验证/授权  | 从一开始就实现标识。 考虑公共云中可用的[RBAC（基于角色的访问控制）](https://docs.microsoft.com/azure/role-based-access-control/overview)功能。  |

我们将参考本章和整个书中的 12 个以上因素中的许多。

### <a name="critical-design-considerations"></a>关键设计注意事项

除了由十二因素方法提供的指导外，在构建分布式系统时，还必须做出一些关键的设计决策。

*通信*

前端客户端应用程序将如何与后端核心服务通信？ 你会允许直接沟通吗？ 或者，您是否使用提供灵活性、控制和安全性的网关外观抽象后端服务？

后端核心服务将如何相互通信？ 您是否允许直接 HTTP 调用导致耦合并影响性能和敏捷性？ 或者，您可以考虑将消息传送与队列和主题技术分离？

通信内容详包括第 4 章，*云-原生通信模式*。

*复原*

微服务体系结构将系统从进程内移动到网络通信。 在分布式环境中，当服务 B 未响应服务 A 的呼叫时，您将执行什么操作？ 当服务 C 暂时不可用，其他调用它的服务将其堆叠并降低系统性能时，会发生什么情况？

复原能力详包括第6章，*云原生弹性*。

*分布式数据*

根据设计，每个微服务封装自己的数据，通过其公共接口公开操作。 如果是，您如何查询数据或跨多个服务实现事务？

分布式数据详包括第 5 章，*云原生数据模式*。

*标识*

您的服务将如何识别访问它的人员以及他们拥有哪些权限？

身份详包括第8章 *，《身份*》。

## <a name="microservices"></a>微服务

云原生系统采用微服务，这是构建现代应用程序的常用体系结构风格。

微服务是一组分布式独立服务，通过共享结构进行交互，具有以下特征：

- 每个在更大的域上下文中实现特定的业务功能。

- 每个都是自主开发的，可以独立部署。

- 每个都是自包含封装自己的数据存储技术（SQL、NoSQL）和编程平台。

- 每个程序都运行在自己的进程中，并使用标准通信协议（如 HTTP/HTTPS、WebSocket 或[AMQP）](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol)与他人通信。

- 它们组合在一起以形成一个应用程序。

图 1-4 将整体应用程序方法与微服务方法进行对比。 请注意单体如何由分层体系结构组成，该体系结构在单个进程中执行。 它通常使用关系数据库。 但是，微服务方法将功能隔离到包含逻辑和数据的独立服务中。 每个微服务都托管自己的数据存储。

![单片部署与微服务](./media/monolithic-vs-microservices.png)

**图 1-4。** 单片部署与微服务

请注意，微服务如何从本章前面讨论的[十二因子应用程序中](https://12factor.net/)推广"一个代码库，一个应用程序"原则。

> *因子\#1 指定"每个微服务的单一代码库，存储在其自己的存储库中。通过版本控制进行跟踪，它可以部署到多个环境。*

### <a name="why-microservices"></a>为何使用微服务？

微服务提供敏捷性。

在本章前面，我们将构建为单一的电子商务应用程序与微服务进行了比较。 在此示例中，我们看到了一些明显的好处：

- 每个微服务都有自主生命周期，可以独立发展并频繁部署。 您不必等待季度版本来部署新功能或更新。 您可以更新复杂应用程序的一小块区域，从而降低破坏整个系统的风险。

- 每个微服务都可以独立扩展。 您只扩展那些需要更多处理能力或网络带宽的服务，而不是将整个应用程序扩展为单个单元。 这种细粒度的扩展方法可更好地控制系统，并有助于在扩展系统部分（而不是所有内容）时降低总体成本。

理解微服务的优秀参考指南是[.NET 微服务：容器化 .NET 应用程序的体系结构](https://docs.microsoft.com/dotnet/standard/microservices-architecture/)。 这本书深入探讨了微服务设计和建筑。 它是从 Microsoft 免费下载的[全栈微服务参考体系结构](https://github.com/dotnet-architecture/eShopOnContainers)的配套。

### <a name="developing-microservices"></a>开发微服务

微服务可以使用任何现代开发平台创建。

微软 .NET 核心平台是一个绝佳的选择。 它具有许多内置功能，可简化微服务开发， 具有免费和开源功能。 .NET 核心是跨平台的。 可以在 Windows、macOS 和大多数 Linux 风格上构建和运行应用程序。

.NET Core 性能极高，与 Node.js 和其他竞争平台相比得分很高。 有趣的是[，TechEmpower](https://www.techempower.com/)在许多 Web 应用程序平台和框架中进行了一套广泛的[性能基准](https://www.techempower.com/benchmarks/#section=data-r17&hw=ph&test=plaintext)测试。 .NET Core 得分在前 10 名 - 远高于 Node.js 和其他竞争平台。

.NET 核心由 Microsoft 和 GitHub 上的 .NET 社区维护。

## <a name="containers"></a>容器

如今，在任何有关*云原生*的对话中，都自然而然地听到术语*容器*。 在《[云原生模式](https://www.manning.com/books/cloud-native-patterns)》一书中，作者科妮莉亚·戴维斯指出，"容器是云原生软件的一大推动因素。 云原生计算基金会将微服务容器化作为[云原生跟踪地图](https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png)的第一步 - 为企业开始云原生之旅的指导。

将微服务容器化简单明了。 代码、其依赖项和运行时打包到称为[容器映像](https://docs.docker.com/glossary/?term=image)的二进制文件中。 图像存储在[容器注册表](https://caylent.com/container-registries/)中，它充当图像的存储库或库。 注册表可以位于开发计算机、数据中心或公共云中。 Docker 本身通过 Docker [Hub](https://hub.docker.com/)维护公共注册表。 Azure 云具有[容器注册表](https://azure.microsoft.com/services/container-registry/)，用于存储靠近将运行它们的云应用程序的容器映像。

如果需要，可以将映像转换为正在运行的容器实例。 实例在安装了[容器运行时](https://kubernetes.io/docs/setup/production-environment/container-runtimes/)引擎的任何计算机上运行。 可以根据需要拥有尽可能多的容器化服务的实例。

图 1-5 显示了三个不同的微服务，每个微服务都位于其自己的容器中，在单个主机上运行。

![在一个容器主机上运行多个容器](./media/hosting-mulitple-containers.png)

**图 1-5**. 在一个容器主机上运行多个容器

请注意每个容器如何维护其自己的依赖项和运行时集，这些依赖项和运行时可能不同。 在这里，我们看到产品微服务的不同版本在同一主机上运行。 每个容器共享基础主机操作系统、内存和处理器的一个切片，但彼此隔离。

请注意容器模型如何很好地接受[来自十二因子应用程序的](https://12factor.net/)"依赖"原则。

> *因子\#2 指定"每个微服务隔离和打包其自己的依赖项，在不影响整个系统的情况下接受更改。*

容器同时支持 Linux 和 Windows 工作负载。 Azure 云公开包含这两者。 有趣的是，Linux，而不是Windows服务器，已经成为Azure中最流行的操作系统。

虽然存在几个集装箱供应商，但 Docker 已经占据了市场的大部分份额。 该公司一直在推动软件容器的移动。 它已成为打包、部署和运行云原生应用程序的实际标准。

### <a name="why-containers"></a>为什么选择容器？

容器提供可移植性，并保证跨环境的一致性。 通过将所有内容封装到单个包中，您将微服务及其依赖项与基础基础结构*隔离*开来。

您可以在具有 Docker 运行时引擎的任何环境中部署同一容器。 容器化工作负载还消除了使用框架、软件库和运行时引擎预先配置每个环境的费用。

通过共享底层操作系统和主机资源，容器的占用空间比整个虚拟机小得多。 较小的大小会增加给定主机可以同时运行的*密度*或微服务的数量。

### <a name="container-orchestration"></a>容器业务流程

虽然 Docker 等工具创建映像并运行容器，但您还需要工具来管理它们。 容器管理使用称为容器协调器的特殊软件程序来完成。 大规模运行时，容器编排至关重要。

图 1-6 显示了容器协调器提供的管理任务。

![容器协调器执行哪些操作](./media/what-container-orchestrators-do.png)

**图1-6**. 容器协调器执行哪些操作

下表描述了常见的业务流程任务。

|  任务 | 说明  |
| :-------- | :-------- |
| 计划 | 自动预配容器实例。|
| 亲和力/反亲和力 | 在附近或相距甚远的地方预配容器，帮助提供可用性和性能。 |
| 运行状况监视 | 自动检测并纠正故障。|
| 故障转移 | 自动将失败的实例重新调配到正常运行的计算机。|
| 扩展 | 自动添加或删除容器实例以满足需求。|
| 网络 | 管理容器通信的网络覆盖。|
| 服务发现 | 使容器能够彼此定位。|
| 滚动升级 | 通过零停机时间部署协调增量升级。 自动回滚有问题的更改。|

请注意，协调器如何接受本章前面讨论的[十二因子应用程序中](https://12factor.net/)的可处置性和并发性原则。

> *因子\#9 指定"服务实例应该是一次性的，有利于快速启动来增加可伸缩性机会和正常关机，使系统处于正确的状态。Docker 容器以及协调器本身就满足了这一要求。*

> *因子\#8 指定"服务跨大量小型相同进程（副本）进行横向扩展，而不是在最强大的计算机上扩展单个大型实例。*

虽然存在多个容器协调器，[但库伯奈斯](https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/)已成为云原生世界的实际标准。 它是一个可移植的、可扩展的开源平台，用于管理容器化工作负载。

您可以托管自己的 Kubernetes 实例，但随后您将负责预配和管理其资源-这可能很复杂。 Azure 云将库伯奈斯作为托管服务[，Azure 库伯奈斯服务 （AKS） 。](https://azure.microsoft.com/services/kubernetes-service/) 托管服务允许您充分利用其功能，而无需安装和维护它。

Azure 库伯奈斯服务详细介绍了第 2 章"*扩展云原生应用程序*"。

## <a name="backing-services"></a>支持服务

云本机系统依赖于许多不同的辅助资源，如数据存储、消息代理、监视和标识服务。 这些服务被称为[支持服务](https://12factor.net/backing-services)。

 图 1-7 显示了云本机系统使用的许多常见支持服务。

![常见的支持服务](./media/common-backing-services.png)

**图 1-7**. 常见的支持服务

支持服务从本章前面讨论的[十二因子应用](https://12factor.net/)中推广"无国籍"原则。

>*因子\#6*指定，"每个微服务都应在其自己的进程中执行，与其他正在运行的服务隔离。 将所需状态外部化到备份服务（如分布式缓存或数据存储）。

您可以托管自己的支持服务，但随后您将负责许可、预配和管理这些资源。

云提供商提供种类繁多的*托管支持服务。* 您只需使用该服务，而不是拥有该服务。 提供商大规模运营资源，并负责性能、安全性和维护。 服务中内置了监视、冗余和可用性。 提供商完全支持其托管服务 - 打开票证，他们修复您的问题。

云原生系统青睐云供应商的托管支持服务。 时间和劳动力的节省很大。 托管您自己的操作风险和遇到麻烦可能会很快变得昂贵。

最佳做法是将备份服务视为*附加资源*，动态绑定到微服务，其中信息（URL 和凭据）存储在外部配置中。 本指南在本章前面讨论的[十二因子应用程序中](https://12factor.net/)进行了详细说明。

>*因子\#4*指定支持服务"应通过可寻址 URL 公开。 这样做会将资源与应用程序分离，使其易于互换。

>*因子\#3*指定"配置信息从微服务中移出，并通过代码外部的配置管理工具进行外部化。

使用此模式，无需更改代码即可连接和分离支持服务。 您可以将微服务从 QA 提升为暂存环境。 更新微服务配置以指向暂存中的备份服务，并通过环境变量将设置注入容器。

云供应商提供 API，以便您与其专有的支持服务进行通信。 这些库封装了管道和复杂性。 直接与这些 API 通信会将代码与备份服务紧密耦合。 最好隔离供应商 API 的实现详细信息。 引入中介层或中间 API，将泛型操作公开给服务代码。 这种松散的耦合使您能够将一个备份服务交换到另一个备份服务，或者将代码移动到其他公共云，而无需更改主线服务代码。

支持服务将详细讨论第 5 章，*云原生数据模式*，和第 4 章，*云-本机通信模式*。

## <a name="automation"></a>自动化

正如您所看到的，云原生系统采用微服务、容器和现代系统设计，以实现速度和敏捷性。 但是，这只是故事的一部分。 如何预配这些系统运行的云环境？ 如何快速部署应用功能和更新？ 你如何全面了解情况？

输入广泛接受的[基础结构作为代码](https://docs.microsoft.com/azure/devops/learn/what-is-infrastructure-as-code)，或 IaC 的实践。

使用 IaC，您可以自动执行平台配置和应用程序部署。 您基本上将软件工程实践（如测试和版本控制）应用于 DevOps 实践。 您的基础架构和部署是自动化、一致且可重复的。

### <a name="automating-infrastructure"></a>自动化基础架构

Azure[资源管理器](https://azure.microsoft.com/documentation/articles/resource-group-overview/)、Terraform 和 Azure [CLI](https://docs.microsoft.com/cli/azure/)等工具使您能够以声明方式编写所需的云基础结构的脚本。 资源名称、位置、容量和机密是参数化的和动态的。 脚本作为项目的项目版本控制和签入源代码管理。 调用脚本可跨系统环境（如 QA、暂存和生产）预配一致且可重复的基础结构。

在引擎盖下，IaC是幂等的，这意味着你可以运行相同的脚本一遍又一遍没有副作用。 如果团队需要进行更改，他们将编辑并重新运行脚本。 只有更新的资源受到影响。

在《[什么是基础设施是代码》](https://docs.microsoft.com/azure/devops/learn/what-is-infrastructure-as-code)一文中，作者 Sam Guckenheimer 描述了"实施 IaC 的团队如何快速、大规模地提供稳定的环境。 团队通过代码表示其环境的所需状态，避免手动配置环境并增强一致性。 具有 IaC 的基础结构部署是可重复的，可防止由于配置漂移或缺少依赖项而导致的运行时问题。 DevOps 团队可以协同使用一套统一的实践和工具，快速、可靠、大规模地交付应用程序及其支持基础架构。

### <a name="automating-deployments"></a>自动化部署

前面讨论的[十二因子应用程序](https://12factor.net/)要求在将已完成的代码转换为正在运行的应用程序时采取单独的步骤。

> *因子\#5*指定"每个版本必须跨生成、发布和运行阶段强制实施严格的分离。 每个都应使用唯一的 ID 标记，并支持回滚的能力。

现代 CI/CD 系统有助于实现这一原则。 它们提供了单独的部署步骤，有助于确保用户随时可用的一致且高质量的代码。

图 1-8 显示了整个部署过程的分离。

![CI/CD 管道中的部署步骤](./media/build-release-run-pipeline.png)

**图 1-8**. CI/CD 管道中的部署步骤

在上图中，特别注意任务分离。

开发人员在其开发环境中构造一个功能，通过代码、运行和调试的所谓"内部循环"进行迭代。 完成后，该代码将*推送*到代码存储库中，如 GitHub、Azure DevOps 或 BitBucket。

推送将触发生成阶段，将代码转换为二进制项目。 工作使用[持续集成 （CI）](https://martinfowler.com/articles/continuousIntegration.html)管道实现。 它会自动生成、测试和打包应用程序。

发布阶段拾取二进制项目，应用外部应用程序和环境配置信息，并生成不可变版本。 该版本部署到指定的环境。 工作使用[连续交付 （CD）](https://martinfowler.com/bliki/ContinuousDelivery.html)管道实现。 每个版本都应可识别。 您可以说，"此部署正在运行应用程序的第 2.1.1 版。

最后，在目标执行环境中运行释放的功能。 版本是不可变的，这意味着任何更改都必须创建新版本。

应用这些实践，组织已经从根本上改变了它们运送软件的方式。 许多产品已经从季度发布迁移到按需更新。 目标是在开发周期的早期发现问题，而问题修复成本较低。 集成之间的持续时间越长，解决问题的成本就越高。  通过集成过程的一致性，团队可以更频繁地提交代码更改，从而提供更好的协作和软件质量。

### <a name="azure-pipelines"></a>Azure Pipelines

Azure 云包括名为[Azure 管道](https://azure.microsoft.com/services/devops/pipelines/)的新 CI/CD 服务，该服务是图 1-9 所示的[Azure DevOps](https://azure.microsoft.com/services/devops/)服务的一部分。

![开发人员中的 Azure 管道](./media/devops-components.png)

**图 1-9**. Azure 开发人员计划产品

Azure 管道是一种云服务，结合了持续集成 （CI） 和持续交付 （CD）。 您可以自动测试、生成代码并将代码运送到任何目标。

在 YAML 文件中的代码中定义管道，以及应用的其他代码。

- 管道使用代码进行版本控制，并遵循相同的分支结构。
- 通过在拉取请求和分支生成策略中的代码评审来验证更改。
- 使用的每个分支都可以通过修改 azure 管道.yml 文件来自定义生成策略。
- 管道文件将签入版本控制，如果存在问题，可以进行调查。

Azure 管道服务支持大多数 Git 提供程序，并可以为在 Linux、macOS 或 Windows 平台上编写的应用程序生成部署管道。 它包括对Java、.NET、JavaScript、Python、PHP、Go、XCode和C++的支持。

>[!div class="step-by-step"]
>[上一页](introduction.md)
>[下一页](candidate-apps.md)
