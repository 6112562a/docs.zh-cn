---
title: 云原生应用的 Azure 安全性
description: 为 Azure 构建云本机 .NET 应用 |云本机应用的 Azure 安全性
ms.date: 06/30/2019
ms.openlocfilehash: 13b5ad7a883a83014913fa0a6a020610c28c524f
ms.sourcegitcommit: e3cbf26d67f7e9286c7108a2752804050762d02d
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/09/2020
ms.locfileid: "80989137"
---
# <a name="azure-security-for-cloud-native-apps"></a>云原生应用的 Azure 安全性

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

与传统应用程序相比，云原生应用程序可能更容易且更难安全。 不利的一面是，您需要保护更小的应用程序，并投入更多精力来构建安全基础架构。 在大多数服务部署中编程语言和样式的异质性也意味着您需要更加关注来自许多不同提供程序的安全公告。

另一方面，较小的服务（每个服务都有自己的数据存储）限制了攻击的范围。 如果攻击者危及一个系统，攻击者跳转到另一个系统可能比在单片应用程序中更难。 过程边界是强边界。 此外，如果数据库备份泄漏，则损坏会更加有限，因为该数据库仅包含一个数据子集，并且不太可能包含个人数据。

## <a name="threat-modeling"></a>威胁建模

无论这些优势是否大于云原生应用程序的缺点，都必须遵循相同的整体安全思维模式。 安全和安全思维必须成为开发和运营故事的每一步的一部分。 规划应用程序时，会提出这样的问题：

- 数据丢失将产生什么影响？
- 我们如何限制注入此服务中的不良数据造成的损坏？
- 谁应该有权访问此数据？
- 在开发和发布过程中是否有审计政策？

所有这些问题都是称为[威胁建模](https://docs.microsoft.com/azure/security/azure-security-threat-modeling-tool)的过程的一部分。 此过程试图回答系统存在哪些威胁、威胁的可能性以及威胁的潜在损害的问题。

确定威胁列表后，您需要确定它们是否值得缓解。 有时，威胁是如此不可能和昂贵，它不值得花费精力。 例如，某些州级执行组件可能会将更改注入到由数百万台设备使用的进程的设计中。 现在，该代码在环 0 中运行，而不是在[环 3](https://en.wikipedia.org/wiki/Protection_ring)中运行某一段代码。 这允许绕过虚拟机管理程序并在裸机计算机上运行攻击代码的漏洞，从而允许攻击该硬件上运行的所有虚拟机。

如果没有显微镜和对该处理器的硅设计有高级知识，改变的处理器就很难检测出来。 此方案不太可能发生，且需要缓解的成本很高，因此可能没有威胁模型会建议为其构建漏洞利用保护。

更可能的威胁（如允许`Id`增加攻击（替换为`Id=2``Id=3`URL）或 SQL 注入的访问控制中断，对构建针对的防护更具吸引力。 针对这些威胁的缓解措施相当合理，可以建立和防止影响公司声誉的尴尬安全漏洞。

## <a name="principle-of-least-privilege"></a>最低权限原则

计算机安全的基本思想之一是最小特权原则 （POLP）。 实际上，在大多数任何形式的安全中，无论是数字化还是物理安全，它都被认为是一个基本的想法。 简而言之，原则是，任何用户或进程都应具有执行其任务的权限最少。

例如，想想银行的出纳员：进入保险箱是一项不常见的活动。 所以，一般出纳员不能自己打开保险箱。 要获得访问权限，他们需要通过执行其他安全检查的银行经理上报请求。

在计算机系统中，一个奇妙的示例是连接到数据库的用户的权限。 在许多情况下，有一个用户帐户用于生成数据库结构和运行应用程序。 除极端情况外，运行应用程序的帐户不需要更新架构信息的能力。 应该有多个帐户提供不同级别的权限。 应用程序应仅使用授予对表中数据的读取和写入访问权限的权限级别。 这种保护将消除旨在删除数据库表或引入恶意触发器的攻击。

构建云原生应用程序的几乎每个部分都可以从记住最低特权原则中获益。 在基于角色的访问控制 （RBAC） 中设置防火墙、网络安全组、角色和作用域时，可以找到它在起作用。

## <a name="penetration-testing"></a>渗透测试

随着应用程序变得越来越复杂，攻击媒介的数量以惊人的速度增加。 威胁建模存在缺陷，因为它往往由构建系统的同一人员执行。 与许多开发人员在设想用户交互以及构建不可用的用户界面时遇到困难一样，大多数开发人员很难看到每个攻击媒介。 构建系统的开发人员可能不太精通攻击方法，并且忽略了一些关键内容。

渗透测试或"笔测试"包括引入外部参与者试图攻击系统。 这些攻击者可能是外部咨询公司或其他开发人员，具有业务其他部分良好的安全知识。 他们被给予点菜，试图颠覆系统。 通常，他们会发现需要修补的大量安全漏洞。 有时，攻击媒介会完全出乎意料，例如利用对 CEO 的网络钓鱼攻击。

Azure 本身不断受到[微软内部黑客团队](https://azure.microsoft.com/resources/videos/red-vs-blue-internal-security-penetration-testing-of-microsoft-azure/)的攻击。 多年来，他们一直是第一个发现几十个潜在的灾难性攻击媒介，关闭他们之前，他们可以被利用的外部。 目标越诱人，永恒的参与者就越有可能试图利用它，世界上有几个目标比 Azure 更诱人。

## <a name="monitoring"></a>监视

如果攻击者试图渗透应用程序，应该有一些警告。 通常，可以通过检查服务中的日志来发现攻击。 攻击留下的迹象，可以在它们成功之前被发现。 例如，试图猜测密码的攻击者会向登录系统发出许多请求。 监视登录系统可以检测与典型访问模式不一致奇怪的模式。 此监视可以转换为警报，从而提醒操作人员激活某种对策。 高度成熟的监控系统甚至可能根据这些偏差采取主动添加规则以阻止请求或限制响应的操作。

## <a name="securing-the-build"></a>保护生成

在构建过程中经常忽略安全性的一个位置。 生成不仅应运行安全检查，例如扫描不安全的代码或签入凭据，而且生成本身应是安全的。 如果生成服务器遭到破坏，则它提供了一个极好的矢量，用于在产品中引入任意代码。

想象一下，攻击者希望窃取登录到 Web 应用程序的用户的密码。 他们可以引入一个生成步骤，修改签出的代码，将任何登录请求镜像到另一台服务器。 下次代码通过生成时，将静默更新代码。 源代码漏洞扫描在生成之前运行时不会捕获此情况。 同样，没有人会在代码评审中捕获它，因为生成步骤位于生成服务器上。 被利用的代码将进入生产，在那里它可以获取密码。 可能没有生成过程更改的审核日志，或者至少没有人监视审核。

这是一个看似低值目标的完美示例，可用于侵入系统。 一旦攻击者破坏系统外围，他们可以开始寻找方法，将其权限提升到他们可以在他们喜欢的任何地方造成实际伤害。

## <a name="building-secure-code"></a>构建安全代码

.NET 框架已经是一个相当安全的框架。 它避免了非托管代码的一些陷阱，例如从数组的末端走开。 在发现安全漏洞时，正在积极修复这些安全漏洞。 甚至有一个错误[赏金计划](https://www.microsoft.com/msrc/bounty)，支付研究人员发现框架中的问题，并报告他们，而不是利用他们。

有许多方法可以使 .NET 代码更安全。 遵循[.NET 文章的安全编码准则](https://docs.microsoft.com/dotnet/standard/security/secure-coding-guidelines)等准则是一个合理的步骤，可确保代码从一开始是安全的。 [OWASP 前 10 名](https://owasp.org/www-project-top-ten/)是构建安全代码的另一个宝贵指南。

生成过程是放置扫描工具以在源代码中检测问题之前将其投入生产的好地方。 大多数项目都依赖于其他一些包。 可以扫描过期包的工具将在夜间生成中捕获问题。 即使在构建 Docker 映像时，检查并确保基本映像没有已知的漏洞也很有用。 另一件事要检查的是，没有人不小心签入凭据。

## <a name="built-in-security"></a>内置安全性

Azure 旨在平衡大多数用户的可用性和安全性。 不同的用户将有不同的安全要求，因此他们需要微调其云安全方法。 微软在[信任中心](https://azure.microsoft.com/support/trust-center/)发布了大量安全信息。 对于有兴趣了解内置攻击缓解技术工作方式的专业人员来说，此资源应该是第一站。

在 Azure 门户中[，Azure Advisor](https://azure.microsoft.com/services/advisor/)是一个不断扫描环境并提出建议的系统。 其中一些建议旨在节省用户资金，但其他建议旨在识别潜在的不安全配置，例如将存储容器打开给世界，不受虚拟网络的保护。

## <a name="azure-network-infrastructure"></a>Azure 网络基础结构

在本地部署环境中，大量精力用于建立网络。 设置路由器、交换机等工作很复杂。 网络允许某些资源与其他资源对话，并在某些情况下阻止访问。 频繁的网络规则是限制从开发环境访问生产环境，因为半开发的代码运行错误并删除了大量数据。

开箱即用，大多数 PaaS Azure 资源只有最基本和宽松的网络设置。 例如，Internet 上的任何人都可以访问应用服务。 新的 SQL Server 实例通常受到限制，因此外部各方无法访问它们，但 Azure 本身使用的 IP 地址范围允许通过。 因此，虽然 SQL 服务器不受外部威胁保护，但攻击者只需设置 Azure 桥头，即可对 Azure 上的所有 SQL 实例发起攻击。

幸运的是，大多数 Azure 资源都可以放入 Azure 虚拟网络，从而允许更精细的粒度访问控制。 与本地网络建立不受更广泛保护的专用网络的方式类似，虚拟网络是位于 Azure 网络内的专用 IP 地址孤岛。

![图 10-1 Azure](./media/virtual-network.png)
图**10-1**中的虚拟网络。 Azure 中的虚拟网络。

与本地网络具有管理网络访问的防火墙一样，您也可以在虚拟网络的边界处建立类似的防火墙。 默认情况下，虚拟网络上的所有资源仍可与 Internet 对话。 只有传入连接需要某种形式的显式防火墙异常。

建立网络后，可以设置存储帐户等内部资源，以便仅允许虚拟网络上的资源进行访问。 此防火墙提供了额外的安全级别，如果该存储帐户的密钥泄露，攻击者将无法连接到它以利用泄漏的密钥。 这是最低特权原则的另一个例子。

Azure Kubernetes 群集中的节点可以像 Azure 更本机的其他资源一样参与虚拟网络。 此功能称为[Azure 容器网络接口](https://github.com/Azure/azure-container-networking/blob/master/docs/cni.md)。 实际上，它在虚拟网络中分配了一个子网，在虚拟网络中分配虚拟机和容器映像。

继续沿着展示最小特权原则的道路前进，并不是虚拟网络中的每个资源都需要与所有其他资源进行对话。 例如，在通过存储帐户和 SQL 数据库提供 Web API 的应用程序中，数据库和存储帐户不太可能需要彼此对话。 它们之间的任何数据共享都将通过 Web 应用程序。 因此，[可以使用网络安全组 （NSG）](https://docs.microsoft.com/azure/virtual-network/security-overview)来拒绝两个服务之间的流量。

拒绝资源之间通信的策略可能很令人讨厌，尤其是来自使用 Azure 不受流量限制的背景。 在其他一些云上，网络安全组的概念更为普遍。 例如，AWS 上的默认策略是，资源在 NSG 中的规则启用之前，无法相互通信。 虽然开发此环境的速度较慢，但限制性更大的环境提供了更安全的默认值。 使用适当的 DevOps 实践，特别是使用[Azure 资源管理器或 Terraform](infrastructure-as-code.md)管理权限可以简化控制规则。

在设置本地和云资源之间的通信时，虚拟网络也很有用。 虚拟专用网络可用于将两个网络无缝连接在一起。 这允许运行虚拟网络，而无需任何类型的网关，因为所有用户都在现场。 有许多技术可用于建立此网络。 最简单的方法是使用可在多个路由器和 Azure 之间建立[的站点到站点 VPN。](https://docs.microsoft.com/azure/vpn-gateway/vpn-gateway-about-vpngateways?toc=%2fazure%2fvirtual-network%2ftoc.json#s2smulti) 流量通过 Internet 加密和隧道，每个字节的成本与任何其他流量相同。 对于需要更多带宽或安全性的方案，Azure 提供称为[快速路由](https://docs.microsoft.com/azure/vpn-gateway/vpn-gateway-about-vpngateways?toc=%2fazure%2fvirtual-network%2ftoc.json#ExpressRoute)的服务，该服务使用本地网络和 Azure 之间的专用电路。 它的成本更高，更难建立，但也更安全。

## <a name="role-based-access-control-for-restricting-access-to-azure-resources"></a>限制对 Azure 资源的访问的基于角色的访问控制

RBAC 是一个向在 Azure 中运行的应用程序提供标识的系统。 应用程序可以使用此标识访问资源，而不是使用密钥或密码之外。

## <a name="security-principals"></a>安全主体

RBAC 中的第一个组件是安全主体。 安全主体可以是用户、组、服务主体或托管标识。

![图 10-2 不同类型的安全主体](./media/rbac-security-principal.png)
**图 10-2**。 不同类型的安全主体。

- 用户 - 在 Azure 活动目录中具有帐户的任何用户都是用户。
- 组 - Azure 活动目录中的用户集合。 作为组的成员，用户除了承担自己的角色外，还承担该组的角色。
- 服务主体 - 服务或应用程序运行的安全标识。
- 托管标识 - 由 Azure 管理的 Azure 活动目录标识。 托管标识通常用于开发管理凭据以验证 Azure 服务的云应用程序。

安全主体可以应用于大多数任何资源。 这意味着可以将安全主体分配给在 Azure Kubernetes 中运行的容器，从而允许它访问存储在密钥保管库中的机密。 Azure 函数可以具有允许它与活动目录实例进行对话的权限，以验证呼叫用户的 JWT。 使用服务主体启用服务后，可以使用角色和作用域对服务的权限进行精细管理。

## <a name="roles"></a>角色

安全主体可以承担许多角色，或者，用更讽刺的类比，戴许多帽子。 每个角色定义一系列权限，例如"从 Azure 服务总线终结点读取消息"。 安全主体的有效权限集是分配给安全主体具有的所有角色的所有权限的组合。 Azure 具有大量内置角色，用户可以定义自己的角色。

![图 10-3 RBAC](./media/rbac-role-definition.png)
角色定义**图 10-3**。 RBAC 角色定义。

内置于 Azure 中也是许多高级角色，如所有者、参与者、读取器和用户帐户管理员。 使用"所有者"角色，安全主体可以访问所有资源并将权限分配给其他人。 参与者对所有资源具有相同级别的访问权限，但他们无法分配权限。 读者只能查看现有的 Azure 资源，用户帐户管理员可以管理对 Azure 资源的访问权限。

更精细的内置角色（如[DNS 区域参与者](https://docs.microsoft.com/azure/role-based-access-control/built-in-roles#dns-zone-contributor)）的权限仅限于单个服务。 安全主体可以承担任意数量的角色。

## <a name="scopes"></a>作用域

角色可以应用于 Azure 中的受限制资源集。 例如，将作用域应用于以前从服务总线队列读取的示例，可以将权限范围缩小到单个队列："从 Azure 服务总线终结点`blah.servicebus.windows.net/queue1`读取消息"

范围可以像单个资源一样窄，也可以应用于整个资源组、订阅甚至管理组。

测试安全主体是否具有特定权限时，将考虑角色和作用域的组合。 此组合提供了强大的授权机制。

## <a name="deny"></a>拒绝

以前，RBAC 只允许使用"允许"规则。 此行为使一些作用域难以构建。 例如，允许安全主体访问所有存储帐户，但需要向可能无休止的存储帐户列表授予显式权限。 每次创建新存储帐户时，都必须将其添加到此帐户列表中。 这增加了管理开销，这当然不可取。

拒绝规则优先于允许规则。 现在，表示相同的"允许所有人，但一个"范围可以表示为两个规则"允许所有"和"拒绝这个特定规则"。 拒绝规则不仅简化了管理，还允许通过拒绝对所有人的访问来提供额外安全的资源。

## <a name="checking-access"></a>检查访问

可以想象，拥有大量的角色和作用域会使找出服务主体的有效权限变得相当困难。 除此之外，Piling 拒绝规则只会增加复杂性。 幸运的是，有一个权限计算器可以显示任何服务主体的有效权限。 它通常位于门户中的 IAM 选项卡下，如图 10-3 所示。

![图 10-4 应用服务](./media/check-rbac.png)
权限计算器 图**10-4**。 应用服务的权限计算器。

## <a name="securing-secrets"></a>保护机密

密码和证书是攻击者的常见攻击媒介。 破解密码的硬件可以进行暴力攻击，并尝试每秒猜测数十亿个密码。 因此，用于访问资源的密码必须强大，并且具有繁多的字符，这一点很重要。 这些密码正是几乎不可能记住的密码类型。 幸运的是，Azure 中的密码实际上不需要任何人员知道。

许多安全[专家建议](https://www.troyhunt.com/password-managers-dont-have-to-be-perfect-they-just-have-to-be-better-than-not-having-one/)，使用密码管理器保留自己的密码是最好的方法。 虽然它将密码集中到一个位置，但它也允许使用高度复杂的密码，并确保每个帐户都是唯一的。 Azure 中存在相同的系统：用于保密的中央存储。

## <a name="azure-key-vault"></a>Azure Key Vault

Azure 密钥保管库提供了一个集中位置，用于存储数据库、API 密钥和证书等内容的密码。 一旦机密输入保管库，它永远不会再次显示，提取和查看它的命令是故意复杂的。 保险箱中的信息使用软件加密或 FIPS 140-2 级 2 级验证的硬件安全模块进行保护。

密钥保管库的访问权限通过 RbaC 提供，这意味着不仅任何用户可以访问保管库中的信息。 假设 Web 应用程序希望访问存储在 Azure 密钥保管库中的数据库连接字符串。 要获得访问权限，应用程序需要使用服务主体运行。 在这个假定的角色下，他们可以从保险箱中读取秘密。 有许多不同的安全设置可以进一步限制应用程序对保管库的访问，以便它无法更新机密，只能读取它们。

可以监视对密钥保管库的访问，以确保只有预期的应用程序访问保管库。 日志可以集成到 Azure 监视器中，从而解锁在遇到意外情况时设置警报的能力。

## <a name="kubernetes"></a>Kubernetes

在库伯内斯，也有类似的服务来维护一小段秘密信息。 库伯内斯的秘密可以通过典型的`kubectl`可执行文件设置。

创建机密非常简单，只需查找要存储的值的 base64 版本：

```console
echo -n 'admin' | base64
YWRtaW4=
echo -n '1f2d1e2e67df' | base64
MWYyZDFlMmU2N2Rm
```

然后将其添加到名为"例如"的`secret.yml`机密文件中，该文件看起来类似于以下示例：

```yml
apiVersion: v1
kind: Secret
metadata:
  name: mysecret
type: Opaque
data:
  username: YWRtaW4=
  password: MWYyZDFlMmU2N2Rm
```

最后，可以通过运行以下命令将此文件加载到 Kubernetes 中：

```console
kubectl apply -f ./secret.yaml
```

然后，这些机密可以装载到卷中，或通过环境变量暴露到容器进程中。 构建应用程序的[十二因子应用](https://12factor.net/)方法建议使用最低公共分母将设置传输到应用程序。 环境变量是最低的共同点，因为它们无论操作系统或应用程序都受支持。

使用内置 Kubernetes 机密的替代方法是从库伯内斯内部访问 Azure 密钥保管库中的秘密。 最简单的方法是为要加载机密的容器分配 RBAC 角色。 然后，应用程序可以使用 Azure 密钥保管库 API 来访问机密。 但是，此方法需要修改代码，并且不遵循使用环境变量的模式。 相反，可以使用[Azure 密钥保管库注入器](https://mrdevops.io/introducing-azure-key-vault-to-kubernetes-931f82364354)将值注入容器。 实际上，此方法比直接使用 Kubernetes 机密更安全，因为群集上的用户可以访问它们。

## <a name="encryption-in-transit-and-at-rest"></a>传输和静态加密

无论数据是在磁盘上还是在各种不同的服务之间传输，保持数据安全都很重要。 防止数据泄漏的最有效方法是将其加密为其他人无法轻易读取的格式。 Azure 支持各种加密选项。

### <a name="in-transit"></a>传输中

有几种方法可以加密 Azure 中网络上的流量。 对 Azure 服务的访问通常是通过使用传输层安全 （TLS） 的连接完成的。 例如，到 Azure API 的所有连接都需要 TLS 连接。 同样，与 Azure 存储中的终结点的连接可以限制为仅通过 TLS 加密连接工作。

TLS 是一个复杂的协议，只需知道连接使用 TLS 就不足以确保安全性。 例如，TLS 1.0 长期不安全，TLS 1.1 没有更好的效果。 即使在 TLS 版本中，也有多种设置，使连接更易于解密。 最佳操作方案是检查并查看服务器连接是否使用最新且配置良好的协议。

此检查可以通过外部服务（如 SSL 实验室的 SSL 服务器测试）来完成。 针对典型的 Azure 终结点（在本例中为服务总线终结点）的测试运行会产生近乎完美的 A 分数。

即使是 Azure SQL 数据库等服务也使用 TLS 加密来隐藏数据。 使用 TLS 加密传输中数据有趣的部分是，即使对于 Microsoft 来说，也不可能侦听运行 TLS 的计算机之间的连接。 这应该为担心其数据可能面临来自 Microsoft 专有甚至具有比标准攻击者资源较多的州行为者带来风险的公司提供了安慰。

![图 10-5 SSL 实验室报告显示服务总线终结点的 A 分数。](./media/ssl-report.png)
**图10-5**。 SSL 实验室报告显示服务总线终结点的 A 分数。

虽然这种级别的加密不会一直足够，但它应该激发人们的信心，即 Azure TLS 连接相当安全。 随着加密的改进，Azure 将继续改进其安全标准。 很高兴知道，有人在查看安全标准并随着 Azure 的改进而更新 Azure。

### <a name="at-rest"></a>静态

在任何应用程序中，数据在磁盘上放置的有很多位置。 应用程序代码本身是从某些存储机制加载的。 大多数应用程序还使用某种数据库，如 SQL Server、Cosmos DB，甚至具有惊人的价格效率的表存储。 这些数据库都使用大量加密的存储，以确保除了具有适当权限的应用程序之外，任何人都无法读取您的数据。 甚至系统操作员也不能读取已加密的数据。 因此，客户可以仍然相信他们的秘密信息仍然是秘密的。

### <a name="storage"></a>存储

Azure 的大部分基础是 Azure 存储引擎。 虚拟机磁盘安装在 Azure 存储的顶部。 Azure 库伯奈斯服务运行在虚拟机上运行，虚拟机本身托管在 Azure 存储上。 即使是无服务器技术（如 Azure 函数应用和 Azure 容器实例）也耗尽了属于 Azure 存储的磁盘。

如果 Azure 存储已很好地加密，则它为大多数其他内容都提供了一个基础，以便进行加密。 Azure 存储使用[FIPS 140-2](https://en.wikipedia.org/wiki/FIPS_140)兼容[256 位 AES](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard)[进行加密](https://docs.microsoft.com/azure/storage/common/storage-service-encryption)。 这是一项备受推崇的加密技术，在过去 20 年左右的岁月中一直受到广泛的学术审查。 目前，没有已知的实际攻击，允许一个人不知道密钥读取由AES加密的数据。

默认情况下，用于加密 Azure 存储的密钥由 Microsoft 管理。 有广泛的保护，以确保防止恶意访问这些密钥。 但是，具有特定加密要求的用户也可以提供在 Azure 密钥保管库中托管[的存储密钥](https://docs.microsoft.com/azure/storage/common/storage-encryption-keys-powershell)。 可以随时吊销这些密钥，这将有效地使使用它们访问的存储帐户的内容变得不可访问。

虚拟机使用加密存储，但可以使用 Windows 上的 BitLocker 或 Linux 上的 DM-Crypt 等技术提供另一层加密。 这些技术意味着，即使磁盘映像从存储中泄露，也几乎不可能读取它。

### <a name="azure-sql"></a>Azure SQL

在 Azure SQL 上托管的数据库使用称为[透明数据加密 （TDE）](/sql/relational-databases/security/encryption/transparent-data-encryption)的技术来确保数据保持加密。 默认情况下，它在所有新创建的 SQL 数据库上启用，但必须手动为旧数据库启用。 TDE 不仅执行数据库的实时加密和解密，还执行备份和事务日志。

加密参数存储在`master`数据库中，并在启动时读取到内存中以执行其余操作。 这意味着`master`数据库必须保持未加密状态。 实际密钥由 Microsoft 管理。 但是，具有严格安全要求的用户在密钥保管库中提供自己的密钥的方式可能与 Azure 存储的密钥相同。 密钥保管库提供密钥轮换和吊销等服务。

TDS 的"透明"部分来自使用加密数据库不需要客户端更改这一事实。 虽然此方法提供良好的安全性，但泄露数据库密码足以让用户能够解密数据。 还有另一种方法对数据库中的各个列或表进行加密。 [始终加密](https://docs.microsoft.com/azure/sql-database/sql-database-always-encrypted-azure-key-vault)可确保加密数据在数据库中的纯文本中始终显示。

设置此加密层需要通过 SQL Server 管理工作室中的向导运行，以选择加密类型以及密钥保管库中存储关联密钥的位置。

![图 10-6 选择表中的列，以便使用始终加密](./media/always-encrypted.png)
**图 10-6**进行加密。 选择表中的列，以便使用"始终加密"进行加密。

从这些加密列读取信息的客户端应用程序需要特别调整以读取加密数据。 连接字符串需要更新，`Column Encryption Setting=Enabled`并且必须从密钥保管库检索客户端凭据。 然后，必须使用列加密密钥来准备 SQL Server 客户端。 完成后，其余操作使用 SQL 客户端的标准接口。 也就是说，像 Dapper 和实体框架这样的工具，它们构建在 SQL 客户端之上，将继续在不进行更改的情况下工作。 对于每种语言的每个 SQL Server 驱动程序，始终未使用加密。

TDE 和"始终加密"的组合（两者都可与特定于客户端的密钥一起使用）可确保即使是最严格的加密要求也得到支持。

### <a name="cosmos-db"></a>Cosmos DB

宇宙 DB 是 Microsoft 在 Azure 中提供的最新数据库。 它从一开始就建立了，并考虑到了安全性和密码学。 AES-256 位加密是所有 Cosmos DB 数据库的标准加密，不能禁用。 再加上 TLS 1.2 通信要求，整个存储解决方案都是加密的。

![图10-7 Cosmos DB](./media/cosmos-encryption.png)
中的数据加密流图**10-7**。 Cosmos DB 中的数据加密流。

虽然 Cosmos DB 不提供客户加密密钥，但团队已做了大量工作，以确保在没有这些密钥的情况下保持 PCI-DSS 兼容。 Cosmos DB 还不支持任何类似于 Azure SQL 的"始终加密"的单列加密。

## <a name="keeping-secure"></a>保持安全

Azure 具有发布高度安全产品所需的所有工具。 然而，链条只有最薄弱的环节那么强大。 如果部署在 Azure 之上的应用程序没有以适当的安全心态和良好的安全审核来开发，那么它们就成为链中的薄弱环节。 有许多出色的静态分析工具、加密库和安全实践可用于确保 Azure 上安装的软件与 Azure 本身一样安全。 示例包括[静态分析工具](https://www.whitesourcesoftware.com/)、[加密库](https://www.libressl.org/)[和安全实践](https://azure.microsoft.com/resources/videos/red-vs-blue-internal-security-penetration-testing-of-microsoft-azure/)。

>[!div class="step-by-step"]
>[上一页](security.md)
>[下一页](devops.md)
