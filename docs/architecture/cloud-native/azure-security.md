---
title: 云原生应用的 Azure 安全性
description: 为 Azure 构建云本机 .NET 应用 |云本机应用的 Azure 安全性
ms.date: 06/30/2019
ms.openlocfilehash: 13b5ad7a883a83014913fa0a6a020610c28c524f
ms.sourcegitcommit: e3cbf26d67f7e9286c7108a2752804050762d02d
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/09/2020
ms.locfileid: "80989137"
---
# <a name="azure-security-for-cloud-native-apps"></a><span data-ttu-id="51237-103">云原生应用的 Azure 安全性</span><span class="sxs-lookup"><span data-stu-id="51237-103">Azure security for cloud-native apps</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="51237-104">与传统应用程序相比，云原生应用程序可能更容易且更难安全。</span><span class="sxs-lookup"><span data-stu-id="51237-104">Cloud-native applications can be both easier and more difficult to secure than traditional applications.</span></span> <span data-ttu-id="51237-105">不利的一面是，您需要保护更小的应用程序，并投入更多精力来构建安全基础架构。</span><span class="sxs-lookup"><span data-stu-id="51237-105">On the downside, you need to secure more smaller applications and dedicate more energy to build out the security infrastructure.</span></span> <span data-ttu-id="51237-106">在大多数服务部署中编程语言和样式的异质性也意味着您需要更加关注来自许多不同提供程序的安全公告。</span><span class="sxs-lookup"><span data-stu-id="51237-106">The heterogeneous nature of programming languages and styles in most service deployments also means you need to pay more attention to security bulletins from many different providers.</span></span>

<span data-ttu-id="51237-107">另一方面，较小的服务（每个服务都有自己的数据存储）限制了攻击的范围。</span><span class="sxs-lookup"><span data-stu-id="51237-107">On the flip side, smaller services, each with their own data store, limit the scope of an attack.</span></span> <span data-ttu-id="51237-108">如果攻击者危及一个系统，攻击者跳转到另一个系统可能比在单片应用程序中更难。</span><span class="sxs-lookup"><span data-stu-id="51237-108">If an attacker compromises one system, it's probably more difficult for the attacker to make the jump to another system than it is in a monolithic application.</span></span> <span data-ttu-id="51237-109">过程边界是强边界。</span><span class="sxs-lookup"><span data-stu-id="51237-109">Process boundaries are strong boundaries.</span></span> <span data-ttu-id="51237-110">此外，如果数据库备份泄漏，则损坏会更加有限，因为该数据库仅包含一个数据子集，并且不太可能包含个人数据。</span><span class="sxs-lookup"><span data-stu-id="51237-110">Also, if a database backup leaks, then the damage is more limited, as that database contains only a subset of data and is unlikely to contain personal data.</span></span>

## <a name="threat-modeling"></a><span data-ttu-id="51237-111">威胁建模</span><span class="sxs-lookup"><span data-stu-id="51237-111">Threat modeling</span></span>

<span data-ttu-id="51237-112">无论这些优势是否大于云原生应用程序的缺点，都必须遵循相同的整体安全思维模式。</span><span class="sxs-lookup"><span data-stu-id="51237-112">No matter if the advantages outweigh the disadvantages of cloud-native applications, the same holistic security mindset must be followed.</span></span> <span data-ttu-id="51237-113">安全和安全思维必须成为开发和运营故事的每一步的一部分。</span><span class="sxs-lookup"><span data-stu-id="51237-113">Security and secure thinking must be part of every step of the development and operations story.</span></span> <span data-ttu-id="51237-114">规划应用程序时，会提出这样的问题：</span><span class="sxs-lookup"><span data-stu-id="51237-114">When planning an application ask questions like:</span></span>

- <span data-ttu-id="51237-115">数据丢失将产生什么影响？</span><span class="sxs-lookup"><span data-stu-id="51237-115">What would be the impact of this data being lost?</span></span>
- <span data-ttu-id="51237-116">我们如何限制注入此服务中的不良数据造成的损坏？</span><span class="sxs-lookup"><span data-stu-id="51237-116">How can we limit the damage from bad data being injected into this service?</span></span>
- <span data-ttu-id="51237-117">谁应该有权访问此数据？</span><span class="sxs-lookup"><span data-stu-id="51237-117">Who should have access to this data?</span></span>
- <span data-ttu-id="51237-118">在开发和发布过程中是否有审计政策？</span><span class="sxs-lookup"><span data-stu-id="51237-118">Are there auditing policies in place around the development and release process?</span></span>

<span data-ttu-id="51237-119">所有这些问题都是称为[威胁建模](https://docs.microsoft.com/azure/security/azure-security-threat-modeling-tool)的过程的一部分。</span><span class="sxs-lookup"><span data-stu-id="51237-119">All these questions are part of a process called [threat modeling](https://docs.microsoft.com/azure/security/azure-security-threat-modeling-tool).</span></span> <span data-ttu-id="51237-120">此过程试图回答系统存在哪些威胁、威胁的可能性以及威胁的潜在损害的问题。</span><span class="sxs-lookup"><span data-stu-id="51237-120">This process tries to answer the question of what threats there are to the system, how likely the threats are, and the potential damage from them.</span></span>

<span data-ttu-id="51237-121">确定威胁列表后，您需要确定它们是否值得缓解。</span><span class="sxs-lookup"><span data-stu-id="51237-121">Once the list of threats has been established, you need to decide whether they're worth mitigating.</span></span> <span data-ttu-id="51237-122">有时，威胁是如此不可能和昂贵，它不值得花费精力。</span><span class="sxs-lookup"><span data-stu-id="51237-122">Sometimes a threat is so unlikely and expensive to plan for that it isn't worth spending energy on it.</span></span> <span data-ttu-id="51237-123">例如，某些州级执行组件可能会将更改注入到由数百万台设备使用的进程的设计中。</span><span class="sxs-lookup"><span data-stu-id="51237-123">For instance, some state level actor could inject changes into the design of a process that is used by millions of devices.</span></span> <span data-ttu-id="51237-124">现在，该代码在环 0 中运行，而不是在[环 3](https://en.wikipedia.org/wiki/Protection_ring)中运行某一段代码。</span><span class="sxs-lookup"><span data-stu-id="51237-124">Now, instead of running a certain piece of code in [Ring 3](https://en.wikipedia.org/wiki/Protection_ring), that code is run in Ring 0.</span></span> <span data-ttu-id="51237-125">这允许绕过虚拟机管理程序并在裸机计算机上运行攻击代码的漏洞，从而允许攻击该硬件上运行的所有虚拟机。</span><span class="sxs-lookup"><span data-stu-id="51237-125">This allows an exploit that can bypass the hypervisor and run the attack code on the bare metal machines, allowing attacks on all the virtual machines that are running on that hardware.</span></span>

<span data-ttu-id="51237-126">如果没有显微镜和对该处理器的硅设计有高级知识，改变的处理器就很难检测出来。</span><span class="sxs-lookup"><span data-stu-id="51237-126">The altered processors are difficult to detect without a microscope and advanced knowledge of the on silicon design of that processor.</span></span> <span data-ttu-id="51237-127">此方案不太可能发生，且需要缓解的成本很高，因此可能没有威胁模型会建议为其构建漏洞利用保护。</span><span class="sxs-lookup"><span data-stu-id="51237-127">This scenario is unlikely to happen and expensive to mitigate, so probably no threat model would recommend building exploit protection for it.</span></span>

<span data-ttu-id="51237-128">更可能的威胁（如允许`Id`增加攻击（替换为`Id=2``Id=3`URL）或 SQL 注入的访问控制中断，对构建针对的防护更具吸引力。</span><span class="sxs-lookup"><span data-stu-id="51237-128">More likely threats, such as broken access controls permitting `Id` incrementing attacks (replacing `Id=2` with `Id=3` in the URL) or SQL injection, are more attractive to build protections against.</span></span> <span data-ttu-id="51237-129">针对这些威胁的缓解措施相当合理，可以建立和防止影响公司声誉的尴尬安全漏洞。</span><span class="sxs-lookup"><span data-stu-id="51237-129">The mitigations for these threats are quite reasonable to build and prevent embarrassing security holes that smear the company's reputation.</span></span>

## <a name="principle-of-least-privilege"></a><span data-ttu-id="51237-130">最低权限原则</span><span class="sxs-lookup"><span data-stu-id="51237-130">Principle of least privilege</span></span>

<span data-ttu-id="51237-131">计算机安全的基本思想之一是最小特权原则 （POLP）。</span><span class="sxs-lookup"><span data-stu-id="51237-131">One of the founding ideas in computer security is the Principle of Least Privilege (POLP).</span></span> <span data-ttu-id="51237-132">实际上，在大多数任何形式的安全中，无论是数字化还是物理安全，它都被认为是一个基本的想法。</span><span class="sxs-lookup"><span data-stu-id="51237-132">It's actually a foundational idea in most any form of security be it digital or physical.</span></span> <span data-ttu-id="51237-133">简而言之，原则是，任何用户或进程都应具有执行其任务的权限最少。</span><span class="sxs-lookup"><span data-stu-id="51237-133">In short, the principle is that any user or process should have the smallest number of rights possible to execute its task.</span></span>

<span data-ttu-id="51237-134">例如，想想银行的出纳员：进入保险箱是一项不常见的活动。</span><span class="sxs-lookup"><span data-stu-id="51237-134">As an example, think of the tellers at a bank: accessing the safe is an uncommon activity.</span></span> <span data-ttu-id="51237-135">所以，一般出纳员不能自己打开保险箱。</span><span class="sxs-lookup"><span data-stu-id="51237-135">So, the average teller can't open the safe themselves.</span></span> <span data-ttu-id="51237-136">要获得访问权限，他们需要通过执行其他安全检查的银行经理上报请求。</span><span class="sxs-lookup"><span data-stu-id="51237-136">To gain access, they need to escalate their request through a bank manager, who performs additional security checks.</span></span>

<span data-ttu-id="51237-137">在计算机系统中，一个奇妙的示例是连接到数据库的用户的权限。</span><span class="sxs-lookup"><span data-stu-id="51237-137">In a computer system, a fantastic example is the rights of a user connecting to a database.</span></span> <span data-ttu-id="51237-138">在许多情况下，有一个用户帐户用于生成数据库结构和运行应用程序。</span><span class="sxs-lookup"><span data-stu-id="51237-138">In many cases, there's a single user account used to both build the database structure and run the application.</span></span> <span data-ttu-id="51237-139">除极端情况外，运行应用程序的帐户不需要更新架构信息的能力。</span><span class="sxs-lookup"><span data-stu-id="51237-139">Except in extreme cases, the account running the application doesn't need the ability to update schema information.</span></span> <span data-ttu-id="51237-140">应该有多个帐户提供不同级别的权限。</span><span class="sxs-lookup"><span data-stu-id="51237-140">There should be several accounts that provide different levels of privilege.</span></span> <span data-ttu-id="51237-141">应用程序应仅使用授予对表中数据的读取和写入访问权限的权限级别。</span><span class="sxs-lookup"><span data-stu-id="51237-141">The application should only use the permission level that grants read and write access to the data in the tables.</span></span> <span data-ttu-id="51237-142">这种保护将消除旨在删除数据库表或引入恶意触发器的攻击。</span><span class="sxs-lookup"><span data-stu-id="51237-142">This kind of protection would eliminate attacks that aimed to drop database tables or introduce malicious triggers.</span></span>

<span data-ttu-id="51237-143">构建云原生应用程序的几乎每个部分都可以从记住最低特权原则中获益。</span><span class="sxs-lookup"><span data-stu-id="51237-143">Almost every part of building a cloud-native application can benefit from remembering the principle of least privilege.</span></span> <span data-ttu-id="51237-144">在基于角色的访问控制 （RBAC） 中设置防火墙、网络安全组、角色和作用域时，可以找到它在起作用。</span><span class="sxs-lookup"><span data-stu-id="51237-144">You can find it at play when setting up firewalls, network security groups, roles, and scopes in Role-based access control (RBAC).</span></span>

## <a name="penetration-testing"></a><span data-ttu-id="51237-145">渗透测试</span><span class="sxs-lookup"><span data-stu-id="51237-145">Penetration testing</span></span>

<span data-ttu-id="51237-146">随着应用程序变得越来越复杂，攻击媒介的数量以惊人的速度增加。</span><span class="sxs-lookup"><span data-stu-id="51237-146">As applications become more complicated the number of attack vectors increases at an alarming rate.</span></span> <span data-ttu-id="51237-147">威胁建模存在缺陷，因为它往往由构建系统的同一人员执行。</span><span class="sxs-lookup"><span data-stu-id="51237-147">Threat modeling is flawed in that it tends to be executed by the same people building the system.</span></span> <span data-ttu-id="51237-148">与许多开发人员在设想用户交互以及构建不可用的用户界面时遇到困难一样，大多数开发人员很难看到每个攻击媒介。</span><span class="sxs-lookup"><span data-stu-id="51237-148">In the same way that many developers have trouble envisioning user interactions and then build unusable user interfaces, most developers have difficulty seeing every attack vector.</span></span> <span data-ttu-id="51237-149">构建系统的开发人员可能不太精通攻击方法，并且忽略了一些关键内容。</span><span class="sxs-lookup"><span data-stu-id="51237-149">It's also possible that the developers building the system aren't well versed in attack methodologies and miss something crucial.</span></span>

<span data-ttu-id="51237-150">渗透测试或"笔测试"包括引入外部参与者试图攻击系统。</span><span class="sxs-lookup"><span data-stu-id="51237-150">Penetration testing or "pen testing" involves bringing in external actors to attempt to attack the system.</span></span> <span data-ttu-id="51237-151">这些攻击者可能是外部咨询公司或其他开发人员，具有业务其他部分良好的安全知识。</span><span class="sxs-lookup"><span data-stu-id="51237-151">These attackers may be an external consulting company or other developers with good security knowledge from another part of the business.</span></span> <span data-ttu-id="51237-152">他们被给予点菜，试图颠覆系统。</span><span class="sxs-lookup"><span data-stu-id="51237-152">They're given carte blanche to attempt to subvert the system.</span></span> <span data-ttu-id="51237-153">通常，他们会发现需要修补的大量安全漏洞。</span><span class="sxs-lookup"><span data-stu-id="51237-153">Frequently, they'll find extensive security holes that need to be patched.</span></span> <span data-ttu-id="51237-154">有时，攻击媒介会完全出乎意料，例如利用对 CEO 的网络钓鱼攻击。</span><span class="sxs-lookup"><span data-stu-id="51237-154">Sometimes the attack vector will be something totally unexpected like exploiting a phishing attack against the CEO.</span></span>

<span data-ttu-id="51237-155">Azure 本身不断受到[微软内部黑客团队](https://azure.microsoft.com/resources/videos/red-vs-blue-internal-security-penetration-testing-of-microsoft-azure/)的攻击。</span><span class="sxs-lookup"><span data-stu-id="51237-155">Azure itself is constantly undergoing attacks from a [team of hackers inside Microsoft](https://azure.microsoft.com/resources/videos/red-vs-blue-internal-security-penetration-testing-of-microsoft-azure/).</span></span> <span data-ttu-id="51237-156">多年来，他们一直是第一个发现几十个潜在的灾难性攻击媒介，关闭他们之前，他们可以被利用的外部。</span><span class="sxs-lookup"><span data-stu-id="51237-156">Over the years, they've been the first to find dozens of potentially catastrophic attack vectors, closing them before they can be exploited externally.</span></span> <span data-ttu-id="51237-157">目标越诱人，永恒的参与者就越有可能试图利用它，世界上有几个目标比 Azure 更诱人。</span><span class="sxs-lookup"><span data-stu-id="51237-157">The more tempting a target, the more likely that eternal actors will attempt to exploit it and there are a few targets in the world more tempting than Azure.</span></span>

## <a name="monitoring"></a><span data-ttu-id="51237-158">监视</span><span class="sxs-lookup"><span data-stu-id="51237-158">Monitoring</span></span>

<span data-ttu-id="51237-159">如果攻击者试图渗透应用程序，应该有一些警告。</span><span class="sxs-lookup"><span data-stu-id="51237-159">Should an attacker attempt to penetrate an application, there should be some warning of it.</span></span> <span data-ttu-id="51237-160">通常，可以通过检查服务中的日志来发现攻击。</span><span class="sxs-lookup"><span data-stu-id="51237-160">Frequently, attacks can be spotted by examining the logs from services.</span></span> <span data-ttu-id="51237-161">攻击留下的迹象，可以在它们成功之前被发现。</span><span class="sxs-lookup"><span data-stu-id="51237-161">Attacks leave telltale signs that can be spotted before they succeed.</span></span> <span data-ttu-id="51237-162">例如，试图猜测密码的攻击者会向登录系统发出许多请求。</span><span class="sxs-lookup"><span data-stu-id="51237-162">For instance, an attacker attempting to guess a password will make many requests to a login system.</span></span> <span data-ttu-id="51237-163">监视登录系统可以检测与典型访问模式不一致奇怪的模式。</span><span class="sxs-lookup"><span data-stu-id="51237-163">Monitoring around the login system can detect weird patterns that are out of line with the typical access pattern.</span></span> <span data-ttu-id="51237-164">此监视可以转换为警报，从而提醒操作人员激活某种对策。</span><span class="sxs-lookup"><span data-stu-id="51237-164">This monitoring can be turned into an alert that can, in turn, alert an operations person to activate some sort of countermeasure.</span></span> <span data-ttu-id="51237-165">高度成熟的监控系统甚至可能根据这些偏差采取主动添加规则以阻止请求或限制响应的操作。</span><span class="sxs-lookup"><span data-stu-id="51237-165">A highly mature monitoring system might even take action based on these deviations proactively adding rules to block requests or throttle responses.</span></span>

## <a name="securing-the-build"></a><span data-ttu-id="51237-166">保护生成</span><span class="sxs-lookup"><span data-stu-id="51237-166">Securing the build</span></span>

<span data-ttu-id="51237-167">在构建过程中经常忽略安全性的一个位置。</span><span class="sxs-lookup"><span data-stu-id="51237-167">One place where security is often overlooked is around the build process.</span></span> <span data-ttu-id="51237-168">生成不仅应运行安全检查，例如扫描不安全的代码或签入凭据，而且生成本身应是安全的。</span><span class="sxs-lookup"><span data-stu-id="51237-168">Not only should the build run security checks, such as scanning for insecure code or checked-in credentials, but the build itself should be secure.</span></span> <span data-ttu-id="51237-169">如果生成服务器遭到破坏，则它提供了一个极好的矢量，用于在产品中引入任意代码。</span><span class="sxs-lookup"><span data-stu-id="51237-169">If the build server is compromised, then it provides a fantastic vector for introducing arbitrary code into the product.</span></span>

<span data-ttu-id="51237-170">想象一下，攻击者希望窃取登录到 Web 应用程序的用户的密码。</span><span class="sxs-lookup"><span data-stu-id="51237-170">Imagine that an attacker is looking to steal the passwords of people signing into a web application.</span></span> <span data-ttu-id="51237-171">他们可以引入一个生成步骤，修改签出的代码，将任何登录请求镜像到另一台服务器。</span><span class="sxs-lookup"><span data-stu-id="51237-171">They could introduce a build step that modifies the checked-out code to mirror any login request to another server.</span></span> <span data-ttu-id="51237-172">下次代码通过生成时，将静默更新代码。</span><span class="sxs-lookup"><span data-stu-id="51237-172">The next time code goes through the build, it's silently updated.</span></span> <span data-ttu-id="51237-173">源代码漏洞扫描在生成之前运行时不会捕获此情况。</span><span class="sxs-lookup"><span data-stu-id="51237-173">The source code vulnerability scanning won't catch this as it runs before the build.</span></span> <span data-ttu-id="51237-174">同样，没有人会在代码评审中捕获它，因为生成步骤位于生成服务器上。</span><span class="sxs-lookup"><span data-stu-id="51237-174">Equally, nobody will catch it in a code review because the build steps live on the build server.</span></span> <span data-ttu-id="51237-175">被利用的代码将进入生产，在那里它可以获取密码。</span><span class="sxs-lookup"><span data-stu-id="51237-175">The exploited code will go to production where it can harvest passwords.</span></span> <span data-ttu-id="51237-176">可能没有生成过程更改的审核日志，或者至少没有人监视审核。</span><span class="sxs-lookup"><span data-stu-id="51237-176">Probably there's no audit log of the build process changes, or at least nobody monitoring the audit.</span></span>

<span data-ttu-id="51237-177">这是一个看似低值目标的完美示例，可用于侵入系统。</span><span class="sxs-lookup"><span data-stu-id="51237-177">This is a perfect example of a seemingly low value target that can be used to break into the system.</span></span> <span data-ttu-id="51237-178">一旦攻击者破坏系统外围，他们可以开始寻找方法，将其权限提升到他们可以在他们喜欢的任何地方造成实际伤害。</span><span class="sxs-lookup"><span data-stu-id="51237-178">Once an attacker breaches the perimeter of the system, they can start working on finding ways to elevate their permissions to the point that they can cause real harm anywhere they like.</span></span>

## <a name="building-secure-code"></a><span data-ttu-id="51237-179">构建安全代码</span><span class="sxs-lookup"><span data-stu-id="51237-179">Building secure code</span></span>

<span data-ttu-id="51237-180">.NET 框架已经是一个相当安全的框架。</span><span class="sxs-lookup"><span data-stu-id="51237-180">.NET Framework is already a quite secure framework.</span></span> <span data-ttu-id="51237-181">它避免了非托管代码的一些陷阱，例如从数组的末端走开。</span><span class="sxs-lookup"><span data-stu-id="51237-181">It avoids some of the pitfalls of unmanaged code, such as walking off the ends of arrays.</span></span> <span data-ttu-id="51237-182">在发现安全漏洞时，正在积极修复这些安全漏洞。</span><span class="sxs-lookup"><span data-stu-id="51237-182">Work is actively done to fix security holes as they're discovered.</span></span> <span data-ttu-id="51237-183">甚至有一个错误[赏金计划](https://www.microsoft.com/msrc/bounty)，支付研究人员发现框架中的问题，并报告他们，而不是利用他们。</span><span class="sxs-lookup"><span data-stu-id="51237-183">There's even a [bug bounty program](https://www.microsoft.com/msrc/bounty) that pays researchers to find issues in the framework and report them instead of exploiting them.</span></span>

<span data-ttu-id="51237-184">有许多方法可以使 .NET 代码更安全。</span><span class="sxs-lookup"><span data-stu-id="51237-184">There are many ways to make .NET code more secure.</span></span> <span data-ttu-id="51237-185">遵循[.NET 文章的安全编码准则](https://docs.microsoft.com/dotnet/standard/security/secure-coding-guidelines)等准则是一个合理的步骤，可确保代码从一开始是安全的。</span><span class="sxs-lookup"><span data-stu-id="51237-185">Following guidelines such as the [Secure coding guidelines for .NET](https://docs.microsoft.com/dotnet/standard/security/secure-coding-guidelines) article is a reasonable step to take to ensure that the code is secure from the ground up.</span></span> <span data-ttu-id="51237-186">[OWASP 前 10 名](https://owasp.org/www-project-top-ten/)是构建安全代码的另一个宝贵指南。</span><span class="sxs-lookup"><span data-stu-id="51237-186">The [OWASP top 10](https://owasp.org/www-project-top-ten/) is another invaluable guide to build secure code.</span></span>

<span data-ttu-id="51237-187">生成过程是放置扫描工具以在源代码中检测问题之前将其投入生产的好地方。</span><span class="sxs-lookup"><span data-stu-id="51237-187">The build process is a good place to put scanning tools to detect problems in source code before they make it into production.</span></span> <span data-ttu-id="51237-188">大多数项目都依赖于其他一些包。</span><span class="sxs-lookup"><span data-stu-id="51237-188">Most every project has dependencies on some other packages.</span></span> <span data-ttu-id="51237-189">可以扫描过期包的工具将在夜间生成中捕获问题。</span><span class="sxs-lookup"><span data-stu-id="51237-189">A tool that can scan for outdated packages will catch problems in a nightly build.</span></span> <span data-ttu-id="51237-190">即使在构建 Docker 映像时，检查并确保基本映像没有已知的漏洞也很有用。</span><span class="sxs-lookup"><span data-stu-id="51237-190">Even when building Docker images, it's useful to check and make sure that the base image doesn't have known vulnerabilities.</span></span> <span data-ttu-id="51237-191">另一件事要检查的是，没有人不小心签入凭据。</span><span class="sxs-lookup"><span data-stu-id="51237-191">Another thing to check is that nobody has accidentally checked in credentials.</span></span>

## <a name="built-in-security"></a><span data-ttu-id="51237-192">内置安全性</span><span class="sxs-lookup"><span data-stu-id="51237-192">Built-in security</span></span>

<span data-ttu-id="51237-193">Azure 旨在平衡大多数用户的可用性和安全性。</span><span class="sxs-lookup"><span data-stu-id="51237-193">Azure is designed to balance usability and security for the majority of users.</span></span> <span data-ttu-id="51237-194">不同的用户将有不同的安全要求，因此他们需要微调其云安全方法。</span><span class="sxs-lookup"><span data-stu-id="51237-194">Different users are going to have different security requirements, so they need to fine-tune their approach to cloud security.</span></span> <span data-ttu-id="51237-195">微软在[信任中心](https://azure.microsoft.com/support/trust-center/)发布了大量安全信息。</span><span class="sxs-lookup"><span data-stu-id="51237-195">Microsoft publishes a great deal of security information in the [Trust Center](https://azure.microsoft.com/support/trust-center/).</span></span> <span data-ttu-id="51237-196">对于有兴趣了解内置攻击缓解技术工作方式的专业人员来说，此资源应该是第一站。</span><span class="sxs-lookup"><span data-stu-id="51237-196">This resource should be the first stop for those professionals interested in understanding how the built-in attack mitigation technologies work.</span></span>

<span data-ttu-id="51237-197">在 Azure 门户中[，Azure Advisor](https://azure.microsoft.com/services/advisor/)是一个不断扫描环境并提出建议的系统。</span><span class="sxs-lookup"><span data-stu-id="51237-197">Within the Azure portal, the [Azure Advisor](https://azure.microsoft.com/services/advisor/) is a system that is constantly scanning an environment and making recommendations.</span></span> <span data-ttu-id="51237-198">其中一些建议旨在节省用户资金，但其他建议旨在识别潜在的不安全配置，例如将存储容器打开给世界，不受虚拟网络的保护。</span><span class="sxs-lookup"><span data-stu-id="51237-198">Some of these recommendations are designed to save users money, but others are designed to identify potentially insecure configurations, such as having a storage container open to the world and not protected by a Virtual Network.</span></span>

## <a name="azure-network-infrastructure"></a><span data-ttu-id="51237-199">Azure 网络基础结构</span><span class="sxs-lookup"><span data-stu-id="51237-199">Azure network infrastructure</span></span>

<span data-ttu-id="51237-200">在本地部署环境中，大量精力用于建立网络。</span><span class="sxs-lookup"><span data-stu-id="51237-200">In an on-premises deployment environment, a great deal of energy is dedicated to setting up networking.</span></span> <span data-ttu-id="51237-201">设置路由器、交换机等工作很复杂。</span><span class="sxs-lookup"><span data-stu-id="51237-201">Setting up routers, switches, and the such is complicated work.</span></span> <span data-ttu-id="51237-202">网络允许某些资源与其他资源对话，并在某些情况下阻止访问。</span><span class="sxs-lookup"><span data-stu-id="51237-202">Networks allow certain resources to talk to other resources and prevent access in some cases.</span></span> <span data-ttu-id="51237-203">频繁的网络规则是限制从开发环境访问生产环境，因为半开发的代码运行错误并删除了大量数据。</span><span class="sxs-lookup"><span data-stu-id="51237-203">A frequent network rule is to restrict access to the production environment from the development environment on the off chance that a half-developed piece of code runs awry and deletes a swath of data.</span></span>

<span data-ttu-id="51237-204">开箱即用，大多数 PaaS Azure 资源只有最基本和宽松的网络设置。</span><span class="sxs-lookup"><span data-stu-id="51237-204">Out of the box, most PaaS Azure resources have only the most basic and permissive networking setup.</span></span> <span data-ttu-id="51237-205">例如，Internet 上的任何人都可以访问应用服务。</span><span class="sxs-lookup"><span data-stu-id="51237-205">For instance, anybody on the Internet can access an app service.</span></span> <span data-ttu-id="51237-206">新的 SQL Server 实例通常受到限制，因此外部各方无法访问它们，但 Azure 本身使用的 IP 地址范围允许通过。</span><span class="sxs-lookup"><span data-stu-id="51237-206">New SQL Server instances typically come restricted, so that external parties can't access them, but the IP address ranges used by Azure itself are permitted through.</span></span> <span data-ttu-id="51237-207">因此，虽然 SQL 服务器不受外部威胁保护，但攻击者只需设置 Azure 桥头，即可对 Azure 上的所有 SQL 实例发起攻击。</span><span class="sxs-lookup"><span data-stu-id="51237-207">So, while the SQL server is protected from external threats, an attacker only needs to set up an Azure bridgehead from where they can launch attacks against all SQL instances on Azure.</span></span>

<span data-ttu-id="51237-208">幸运的是，大多数 Azure 资源都可以放入 Azure 虚拟网络，从而允许更精细的粒度访问控制。</span><span class="sxs-lookup"><span data-stu-id="51237-208">Fortunately, most Azure resources can be placed into an Azure Virtual Network that allows finer grained access control.</span></span> <span data-ttu-id="51237-209">与本地网络建立不受更广泛保护的专用网络的方式类似，虚拟网络是位于 Azure 网络内的专用 IP 地址孤岛。</span><span class="sxs-lookup"><span data-stu-id="51237-209">Similar to the way that on-premises networks establish private networks that are protected from the wider world, virtual networks are islands of private IP addresses that are located within the Azure network.</span></span>

<span data-ttu-id="51237-210">![图 10-1 Azure](./media/virtual-network.png)
图**10-1**中的虚拟网络。</span><span class="sxs-lookup"><span data-stu-id="51237-210">![Figure 10-1 A virtual network in Azure](./media/virtual-network.png)
**Figure 10-1**.</span></span> <span data-ttu-id="51237-211">Azure 中的虚拟网络。</span><span class="sxs-lookup"><span data-stu-id="51237-211">A virtual network in Azure.</span></span>

<span data-ttu-id="51237-212">与本地网络具有管理网络访问的防火墙一样，您也可以在虚拟网络的边界处建立类似的防火墙。</span><span class="sxs-lookup"><span data-stu-id="51237-212">In the same way that on-premises networks have a firewall governing access to the network, you can establish a similar firewall at the boundary of the virtual network.</span></span> <span data-ttu-id="51237-213">默认情况下，虚拟网络上的所有资源仍可与 Internet 对话。</span><span class="sxs-lookup"><span data-stu-id="51237-213">By default, all the resources on a virtual network can still talk to the Internet.</span></span> <span data-ttu-id="51237-214">只有传入连接需要某种形式的显式防火墙异常。</span><span class="sxs-lookup"><span data-stu-id="51237-214">It's only incoming connections that require some form of explicit firewall exception.</span></span>

<span data-ttu-id="51237-215">建立网络后，可以设置存储帐户等内部资源，以便仅允许虚拟网络上的资源进行访问。</span><span class="sxs-lookup"><span data-stu-id="51237-215">With the network established, internal resources like storage accounts can be set up to only allow for access by resources that are also on the Virtual Network.</span></span> <span data-ttu-id="51237-216">此防火墙提供了额外的安全级别，如果该存储帐户的密钥泄露，攻击者将无法连接到它以利用泄漏的密钥。</span><span class="sxs-lookup"><span data-stu-id="51237-216">This firewall provides an extra level of security, should the keys for that storage account be leaked, attackers wouldn't be able to connect to it to exploit the leaked keys.</span></span> <span data-ttu-id="51237-217">这是最低特权原则的另一个例子。</span><span class="sxs-lookup"><span data-stu-id="51237-217">This is another example of the principle of least privilege.</span></span>

<span data-ttu-id="51237-218">Azure Kubernetes 群集中的节点可以像 Azure 更本机的其他资源一样参与虚拟网络。</span><span class="sxs-lookup"><span data-stu-id="51237-218">The nodes in an Azure Kubernetes cluster can participate in a virtual network just like other resources that are more native to Azure.</span></span> <span data-ttu-id="51237-219">此功能称为[Azure 容器网络接口](https://github.com/Azure/azure-container-networking/blob/master/docs/cni.md)。</span><span class="sxs-lookup"><span data-stu-id="51237-219">This functionality is called [Azure Container Networking Interface](https://github.com/Azure/azure-container-networking/blob/master/docs/cni.md).</span></span> <span data-ttu-id="51237-220">实际上，它在虚拟网络中分配了一个子网，在虚拟网络中分配虚拟机和容器映像。</span><span class="sxs-lookup"><span data-stu-id="51237-220">In effect, it allocates a subnet within the virtual network on which virtual machines and container images are allocated.</span></span>

<span data-ttu-id="51237-221">继续沿着展示最小特权原则的道路前进，并不是虚拟网络中的每个资源都需要与所有其他资源进行对话。</span><span class="sxs-lookup"><span data-stu-id="51237-221">Continuing down the path of illustrating the principle of least privilege, not every resource within a Virtual Network needs to talk to every other resource.</span></span> <span data-ttu-id="51237-222">例如，在通过存储帐户和 SQL 数据库提供 Web API 的应用程序中，数据库和存储帐户不太可能需要彼此对话。</span><span class="sxs-lookup"><span data-stu-id="51237-222">For instance, in an application that provides a web API over a storage account and a SQL database, it's unlikely that the database and the storage account need to talk to one another.</span></span> <span data-ttu-id="51237-223">它们之间的任何数据共享都将通过 Web 应用程序。</span><span class="sxs-lookup"><span data-stu-id="51237-223">Any data sharing between them would go through the web application.</span></span> <span data-ttu-id="51237-224">因此，[可以使用网络安全组 （NSG）](https://docs.microsoft.com/azure/virtual-network/security-overview)来拒绝两个服务之间的流量。</span><span class="sxs-lookup"><span data-stu-id="51237-224">So, a [network security group (NSG)](https://docs.microsoft.com/azure/virtual-network/security-overview) could be used to deny traffic between the two services.</span></span>

<span data-ttu-id="51237-225">拒绝资源之间通信的策略可能很令人讨厌，尤其是来自使用 Azure 不受流量限制的背景。</span><span class="sxs-lookup"><span data-stu-id="51237-225">A policy of denying communication between resources can be annoying to implement, especially coming from a background of using Azure without traffic restrictions.</span></span> <span data-ttu-id="51237-226">在其他一些云上，网络安全组的概念更为普遍。</span><span class="sxs-lookup"><span data-stu-id="51237-226">On some other clouds, the concept of network security groups is much more prevalent.</span></span> <span data-ttu-id="51237-227">例如，AWS 上的默认策略是，资源在 NSG 中的规则启用之前，无法相互通信。</span><span class="sxs-lookup"><span data-stu-id="51237-227">For instance, the default policy on AWS is that resources can't communicate among themselves until enabled by rules in an NSG.</span></span> <span data-ttu-id="51237-228">虽然开发此环境的速度较慢，但限制性更大的环境提供了更安全的默认值。</span><span class="sxs-lookup"><span data-stu-id="51237-228">While slower to develop this, more restrictive environment provides a more secure default.</span></span> <span data-ttu-id="51237-229">使用适当的 DevOps 实践，特别是使用[Azure 资源管理器或 Terraform](infrastructure-as-code.md)管理权限可以简化控制规则。</span><span class="sxs-lookup"><span data-stu-id="51237-229">Making use of proper DevOps practices, especially using [Azure Resource Manager or Terraform](infrastructure-as-code.md) to manage permissions can make controlling the rules easier.</span></span>

<span data-ttu-id="51237-230">在设置本地和云资源之间的通信时，虚拟网络也很有用。</span><span class="sxs-lookup"><span data-stu-id="51237-230">Virtual Networks can also be useful when setting up communication between on-premises and cloud resources.</span></span> <span data-ttu-id="51237-231">虚拟专用网络可用于将两个网络无缝连接在一起。</span><span class="sxs-lookup"><span data-stu-id="51237-231">A virtual private network can be used to seamlessly attach the two networks together.</span></span> <span data-ttu-id="51237-232">这允许运行虚拟网络，而无需任何类型的网关，因为所有用户都在现场。</span><span class="sxs-lookup"><span data-stu-id="51237-232">This allows running a virtual network without any sort of gateway for scenarios where all the users are on-site.</span></span> <span data-ttu-id="51237-233">有许多技术可用于建立此网络。</span><span class="sxs-lookup"><span data-stu-id="51237-233">There are a number of technologies that can be used to establish this network.</span></span> <span data-ttu-id="51237-234">最简单的方法是使用可在多个路由器和 Azure 之间建立[的站点到站点 VPN。](https://docs.microsoft.com/azure/vpn-gateway/vpn-gateway-about-vpngateways?toc=%2fazure%2fvirtual-network%2ftoc.json#s2smulti)</span><span class="sxs-lookup"><span data-stu-id="51237-234">The simplest is to use a [site-to-site VPN](https://docs.microsoft.com/azure/vpn-gateway/vpn-gateway-about-vpngateways?toc=%2fazure%2fvirtual-network%2ftoc.json#s2smulti) that can be established between many routers and Azure.</span></span> <span data-ttu-id="51237-235">流量通过 Internet 加密和隧道，每个字节的成本与任何其他流量相同。</span><span class="sxs-lookup"><span data-stu-id="51237-235">Traffic is encrypted and tunneled over the Internet at the same cost per byte as any other traffic.</span></span> <span data-ttu-id="51237-236">对于需要更多带宽或安全性的方案，Azure 提供称为[快速路由](https://docs.microsoft.com/azure/vpn-gateway/vpn-gateway-about-vpngateways?toc=%2fazure%2fvirtual-network%2ftoc.json#ExpressRoute)的服务，该服务使用本地网络和 Azure 之间的专用电路。</span><span class="sxs-lookup"><span data-stu-id="51237-236">For scenarios where more bandwidth or more security is desirable, Azure offers a service called [Express Route](https://docs.microsoft.com/azure/vpn-gateway/vpn-gateway-about-vpngateways?toc=%2fazure%2fvirtual-network%2ftoc.json#ExpressRoute) that uses a private circuit between an on-premises network and Azure.</span></span> <span data-ttu-id="51237-237">它的成本更高，更难建立，但也更安全。</span><span class="sxs-lookup"><span data-stu-id="51237-237">It's more costly and difficult to establish but also more secure.</span></span>

## <a name="role-based-access-control-for-restricting-access-to-azure-resources"></a><span data-ttu-id="51237-238">限制对 Azure 资源的访问的基于角色的访问控制</span><span class="sxs-lookup"><span data-stu-id="51237-238">Role-based access control for restricting access to Azure resources</span></span>

<span data-ttu-id="51237-239">RBAC 是一个向在 Azure 中运行的应用程序提供标识的系统。</span><span class="sxs-lookup"><span data-stu-id="51237-239">RBAC is a system that provides an identity to applications running in Azure.</span></span> <span data-ttu-id="51237-240">应用程序可以使用此标识访问资源，而不是使用密钥或密码之外。</span><span class="sxs-lookup"><span data-stu-id="51237-240">Applications can access resources using this identity instead of or in addition to using keys or passwords.</span></span>

## <a name="security-principals"></a><span data-ttu-id="51237-241">安全主体</span><span class="sxs-lookup"><span data-stu-id="51237-241">Security Principals</span></span>

<span data-ttu-id="51237-242">RBAC 中的第一个组件是安全主体。</span><span class="sxs-lookup"><span data-stu-id="51237-242">The first component in RBAC is a security principal.</span></span> <span data-ttu-id="51237-243">安全主体可以是用户、组、服务主体或托管标识。</span><span class="sxs-lookup"><span data-stu-id="51237-243">A security principal can be a user, group, service principal, or managed identity.</span></span>

<span data-ttu-id="51237-244">![图 10-2 不同类型的安全主体](./media/rbac-security-principal.png)
**图 10-2**。</span><span class="sxs-lookup"><span data-stu-id="51237-244">![Figure 10-2 Different types of security principals](./media/rbac-security-principal.png)
**Figure 10-2**.</span></span> <span data-ttu-id="51237-245">不同类型的安全主体。</span><span class="sxs-lookup"><span data-stu-id="51237-245">Different types of security principals.</span></span>

- <span data-ttu-id="51237-246">用户 - 在 Azure 活动目录中具有帐户的任何用户都是用户。</span><span class="sxs-lookup"><span data-stu-id="51237-246">User - Any user who has an account in Azure Active Directory is a user.</span></span>
- <span data-ttu-id="51237-247">组 - Azure 活动目录中的用户集合。</span><span class="sxs-lookup"><span data-stu-id="51237-247">Group - A collection of users from Azure Active Directory.</span></span> <span data-ttu-id="51237-248">作为组的成员，用户除了承担自己的角色外，还承担该组的角色。</span><span class="sxs-lookup"><span data-stu-id="51237-248">As a member of a group, a user takes on the roles of that group in addition to their own.</span></span>
- <span data-ttu-id="51237-249">服务主体 - 服务或应用程序运行的安全标识。</span><span class="sxs-lookup"><span data-stu-id="51237-249">Service principal - A security identity under which services or applications run.</span></span>
- <span data-ttu-id="51237-250">托管标识 - 由 Azure 管理的 Azure 活动目录标识。</span><span class="sxs-lookup"><span data-stu-id="51237-250">Managed identity - An Azure Active Directory identity managed by Azure.</span></span> <span data-ttu-id="51237-251">托管标识通常用于开发管理凭据以验证 Azure 服务的云应用程序。</span><span class="sxs-lookup"><span data-stu-id="51237-251">Managed identities are typically used when developing cloud applications that manage the credentials for authenticating to Azure services.</span></span>

<span data-ttu-id="51237-252">安全主体可以应用于大多数任何资源。</span><span class="sxs-lookup"><span data-stu-id="51237-252">The security principal can be applied to most any resource.</span></span> <span data-ttu-id="51237-253">这意味着可以将安全主体分配给在 Azure Kubernetes 中运行的容器，从而允许它访问存储在密钥保管库中的机密。</span><span class="sxs-lookup"><span data-stu-id="51237-253">This means that it's possible to assign a security principal to a container running within Azure Kubernetes, allowing it to access secrets stored in Key Vault.</span></span> <span data-ttu-id="51237-254">Azure 函数可以具有允许它与活动目录实例进行对话的权限，以验证呼叫用户的 JWT。</span><span class="sxs-lookup"><span data-stu-id="51237-254">An Azure Function could take on a permission allowing it to talk to an Active Directory instance to validate a JWT for a calling user.</span></span> <span data-ttu-id="51237-255">使用服务主体启用服务后，可以使用角色和作用域对服务的权限进行精细管理。</span><span class="sxs-lookup"><span data-stu-id="51237-255">Once services are enabled with a service principal, their permissions can be managed granularly using roles and scopes.</span></span>

## <a name="roles"></a><span data-ttu-id="51237-256">角色</span><span class="sxs-lookup"><span data-stu-id="51237-256">Roles</span></span>

<span data-ttu-id="51237-257">安全主体可以承担许多角色，或者，用更讽刺的类比，戴许多帽子。</span><span class="sxs-lookup"><span data-stu-id="51237-257">A security principal can take on many roles or, using a more sartorial analogy, wear many hats.</span></span> <span data-ttu-id="51237-258">每个角色定义一系列权限，例如"从 Azure 服务总线终结点读取消息"。</span><span class="sxs-lookup"><span data-stu-id="51237-258">Each role defines a series of permissions such as "Read messages from Azure Service Bus endpoint".</span></span> <span data-ttu-id="51237-259">安全主体的有效权限集是分配给安全主体具有的所有角色的所有权限的组合。</span><span class="sxs-lookup"><span data-stu-id="51237-259">The effective permission set of a security principal is the combination of all the permissions assigned to all the roles that security principal has.</span></span> <span data-ttu-id="51237-260">Azure 具有大量内置角色，用户可以定义自己的角色。</span><span class="sxs-lookup"><span data-stu-id="51237-260">Azure has a large number of built-in roles and users can define their own roles.</span></span>

<span data-ttu-id="51237-261">![图 10-3 RBAC](./media/rbac-role-definition.png)
角色定义**图 10-3**。</span><span class="sxs-lookup"><span data-stu-id="51237-261">![Figure 10-3 RBAC role definitions](./media/rbac-role-definition.png)
**Figure 10-3**.</span></span> <span data-ttu-id="51237-262">RBAC 角色定义。</span><span class="sxs-lookup"><span data-stu-id="51237-262">RBAC role definitions.</span></span>

<span data-ttu-id="51237-263">内置于 Azure 中也是许多高级角色，如所有者、参与者、读取器和用户帐户管理员。</span><span class="sxs-lookup"><span data-stu-id="51237-263">Built into Azure are also a number of high-level roles such as Owner, Contributor, Reader, and User Account Administrator.</span></span> <span data-ttu-id="51237-264">使用"所有者"角色，安全主体可以访问所有资源并将权限分配给其他人。</span><span class="sxs-lookup"><span data-stu-id="51237-264">With the Owner role, a security principal can access all resources and assign permissions to others.</span></span> <span data-ttu-id="51237-265">参与者对所有资源具有相同级别的访问权限，但他们无法分配权限。</span><span class="sxs-lookup"><span data-stu-id="51237-265">A contributor has the same level of access to all resources but they can't assign permissions.</span></span> <span data-ttu-id="51237-266">读者只能查看现有的 Azure 资源，用户帐户管理员可以管理对 Azure 资源的访问权限。</span><span class="sxs-lookup"><span data-stu-id="51237-266">A Reader can only view existing Azure resources and a User Account Administrator can manage access to Azure resources.</span></span>

<span data-ttu-id="51237-267">更精细的内置角色（如[DNS 区域参与者](https://docs.microsoft.com/azure/role-based-access-control/built-in-roles#dns-zone-contributor)）的权限仅限于单个服务。</span><span class="sxs-lookup"><span data-stu-id="51237-267">More granular built-in roles such as [DNS Zone Contributor](https://docs.microsoft.com/azure/role-based-access-control/built-in-roles#dns-zone-contributor) have rights limited to a single service.</span></span> <span data-ttu-id="51237-268">安全主体可以承担任意数量的角色。</span><span class="sxs-lookup"><span data-stu-id="51237-268">Security principals can take on any number of roles.</span></span>

## <a name="scopes"></a><span data-ttu-id="51237-269">作用域</span><span class="sxs-lookup"><span data-stu-id="51237-269">Scopes</span></span>

<span data-ttu-id="51237-270">角色可以应用于 Azure 中的受限制资源集。</span><span class="sxs-lookup"><span data-stu-id="51237-270">Roles can be applied to a restricted set of resources within Azure.</span></span> <span data-ttu-id="51237-271">例如，将作用域应用于以前从服务总线队列读取的示例，可以将权限范围缩小到单个队列："从 Azure 服务总线终结点`blah.servicebus.windows.net/queue1`读取消息"</span><span class="sxs-lookup"><span data-stu-id="51237-271">For instance, applying scope to the previous example of reading from a Service Bus queue, you can narrow the permission to a single queue: "Read messages from Azure Service Bus endpoint `blah.servicebus.windows.net/queue1`"</span></span>

<span data-ttu-id="51237-272">范围可以像单个资源一样窄，也可以应用于整个资源组、订阅甚至管理组。</span><span class="sxs-lookup"><span data-stu-id="51237-272">The scope can be as narrow as a single resource or it can be applied to an entire resource group, subscription, or even management group.</span></span>

<span data-ttu-id="51237-273">测试安全主体是否具有特定权限时，将考虑角色和作用域的组合。</span><span class="sxs-lookup"><span data-stu-id="51237-273">When testing if a security principal has a certain permission, the combination of role and scope are taken into account.</span></span> <span data-ttu-id="51237-274">此组合提供了强大的授权机制。</span><span class="sxs-lookup"><span data-stu-id="51237-274">This combination provides a powerful authorization mechanism.</span></span>

## <a name="deny"></a><span data-ttu-id="51237-275">拒绝</span><span class="sxs-lookup"><span data-stu-id="51237-275">Deny</span></span>

<span data-ttu-id="51237-276">以前，RBAC 只允许使用"允许"规则。</span><span class="sxs-lookup"><span data-stu-id="51237-276">Previously, only "allow" rules were permitted for RBAC.</span></span> <span data-ttu-id="51237-277">此行为使一些作用域难以构建。</span><span class="sxs-lookup"><span data-stu-id="51237-277">This behavior made some scopes complicated to build.</span></span> <span data-ttu-id="51237-278">例如，允许安全主体访问所有存储帐户，但需要向可能无休止的存储帐户列表授予显式权限。</span><span class="sxs-lookup"><span data-stu-id="51237-278">For instance, allowing a security principal access to all storage accounts except one required granting explicit permission to a potentially endless list of storage accounts.</span></span> <span data-ttu-id="51237-279">每次创建新存储帐户时，都必须将其添加到此帐户列表中。</span><span class="sxs-lookup"><span data-stu-id="51237-279">Every time a new storage account was created, it would have to be added to this list of accounts.</span></span> <span data-ttu-id="51237-280">这增加了管理开销，这当然不可取。</span><span class="sxs-lookup"><span data-stu-id="51237-280">This added management overhead that certainly wasn't desirable.</span></span>

<span data-ttu-id="51237-281">拒绝规则优先于允许规则。</span><span class="sxs-lookup"><span data-stu-id="51237-281">Deny rules take precedence over allow rules.</span></span> <span data-ttu-id="51237-282">现在，表示相同的"允许所有人，但一个"范围可以表示为两个规则"允许所有"和"拒绝这个特定规则"。</span><span class="sxs-lookup"><span data-stu-id="51237-282">Now representing the same "allow all but one" scope could be represented as two rules "allow all" and "deny this one specific one".</span></span> <span data-ttu-id="51237-283">拒绝规则不仅简化了管理，还允许通过拒绝对所有人的访问来提供额外安全的资源。</span><span class="sxs-lookup"><span data-stu-id="51237-283">Deny rules not only ease management but allow for resources that are extra secure by denying access to everybody.</span></span>

## <a name="checking-access"></a><span data-ttu-id="51237-284">检查访问</span><span class="sxs-lookup"><span data-stu-id="51237-284">Checking access</span></span>

<span data-ttu-id="51237-285">可以想象，拥有大量的角色和作用域会使找出服务主体的有效权限变得相当困难。</span><span class="sxs-lookup"><span data-stu-id="51237-285">As you can imagine, having a large number of roles and scopes can make figuring out the effective permission of a service principal quite difficult.</span></span> <span data-ttu-id="51237-286">除此之外，Piling 拒绝规则只会增加复杂性。</span><span class="sxs-lookup"><span data-stu-id="51237-286">Piling deny rules on top of that, only serves to increase the complexity.</span></span> <span data-ttu-id="51237-287">幸运的是，有一个权限计算器可以显示任何服务主体的有效权限。</span><span class="sxs-lookup"><span data-stu-id="51237-287">Fortunately, there's a permissions calculator that can show the effective permissions for any service principal.</span></span> <span data-ttu-id="51237-288">它通常位于门户中的 IAM 选项卡下，如图 10-3 所示。</span><span class="sxs-lookup"><span data-stu-id="51237-288">It's typically found under the IAM tab in the portal, as shown in Figure 10-3.</span></span>

<span data-ttu-id="51237-289">![图 10-4 应用服务](./media/check-rbac.png)
权限计算器 图**10-4**。</span><span class="sxs-lookup"><span data-stu-id="51237-289">![Figure 10-4 Permission calculator for an app service](./media/check-rbac.png)
**Figure 10-4**.</span></span> <span data-ttu-id="51237-290">应用服务的权限计算器。</span><span class="sxs-lookup"><span data-stu-id="51237-290">Permission calculator for an app service.</span></span>

## <a name="securing-secrets"></a><span data-ttu-id="51237-291">保护机密</span><span class="sxs-lookup"><span data-stu-id="51237-291">Securing secrets</span></span>

<span data-ttu-id="51237-292">密码和证书是攻击者的常见攻击媒介。</span><span class="sxs-lookup"><span data-stu-id="51237-292">Passwords and certificates are a common attack vector for attackers.</span></span> <span data-ttu-id="51237-293">破解密码的硬件可以进行暴力攻击，并尝试每秒猜测数十亿个密码。</span><span class="sxs-lookup"><span data-stu-id="51237-293">Password-cracking hardware can do a  brute-force attack and try to guess billions of passwords per second.</span></span> <span data-ttu-id="51237-294">因此，用于访问资源的密码必须强大，并且具有繁多的字符，这一点很重要。</span><span class="sxs-lookup"><span data-stu-id="51237-294">So it's important that the passwords that are used to access resources are strong, with a large variety of characters.</span></span> <span data-ttu-id="51237-295">这些密码正是几乎不可能记住的密码类型。</span><span class="sxs-lookup"><span data-stu-id="51237-295">These passwords are exactly the kind of passwords that are near impossible to remember.</span></span> <span data-ttu-id="51237-296">幸运的是，Azure 中的密码实际上不需要任何人员知道。</span><span class="sxs-lookup"><span data-stu-id="51237-296">Fortunately, the passwords in Azure don't actually need to be known by any human.</span></span>

<span data-ttu-id="51237-297">许多安全[专家建议](https://www.troyhunt.com/password-managers-dont-have-to-be-perfect-they-just-have-to-be-better-than-not-having-one/)，使用密码管理器保留自己的密码是最好的方法。</span><span class="sxs-lookup"><span data-stu-id="51237-297">Many security [experts suggest](https://www.troyhunt.com/password-managers-dont-have-to-be-perfect-they-just-have-to-be-better-than-not-having-one/) that using a password manager to keep your own passwords is the best approach.</span></span> <span data-ttu-id="51237-298">虽然它将密码集中到一个位置，但它也允许使用高度复杂的密码，并确保每个帐户都是唯一的。</span><span class="sxs-lookup"><span data-stu-id="51237-298">While it centralizes your passwords in one location, it also allows using highly complex passwords and ensuring they're unique for each account.</span></span> <span data-ttu-id="51237-299">Azure 中存在相同的系统：用于保密的中央存储。</span><span class="sxs-lookup"><span data-stu-id="51237-299">The same system exists within Azure: a central store for secrets.</span></span>

## <a name="azure-key-vault"></a><span data-ttu-id="51237-300">Azure Key Vault</span><span class="sxs-lookup"><span data-stu-id="51237-300">Azure Key Vault</span></span>

<span data-ttu-id="51237-301">Azure 密钥保管库提供了一个集中位置，用于存储数据库、API 密钥和证书等内容的密码。</span><span class="sxs-lookup"><span data-stu-id="51237-301">Azure Key Vault provides a centralized location to store passwords for things such as databases, API keys, and certificates.</span></span> <span data-ttu-id="51237-302">一旦机密输入保管库，它永远不会再次显示，提取和查看它的命令是故意复杂的。</span><span class="sxs-lookup"><span data-stu-id="51237-302">Once a secret is entered into the Vault, it's never shown again and the commands to extract and view it are purposefully complicated.</span></span> <span data-ttu-id="51237-303">保险箱中的信息使用软件加密或 FIPS 140-2 级 2 级验证的硬件安全模块进行保护。</span><span class="sxs-lookup"><span data-stu-id="51237-303">The information in the safe is protected using either software encryption or FIPS 140-2 Level 2 validated Hardware Security Modules.</span></span>

<span data-ttu-id="51237-304">密钥保管库的访问权限通过 RbaC 提供，这意味着不仅任何用户可以访问保管库中的信息。</span><span class="sxs-lookup"><span data-stu-id="51237-304">Access to the key vault is provided through RBACs, meaning that not just any user can access the information in the vault.</span></span> <span data-ttu-id="51237-305">假设 Web 应用程序希望访问存储在 Azure 密钥保管库中的数据库连接字符串。</span><span class="sxs-lookup"><span data-stu-id="51237-305">Say a web application wishes to access the database connection string stored in Azure Key Vault.</span></span> <span data-ttu-id="51237-306">要获得访问权限，应用程序需要使用服务主体运行。</span><span class="sxs-lookup"><span data-stu-id="51237-306">To gain access, applications need to run using a service principal.</span></span> <span data-ttu-id="51237-307">在这个假定的角色下，他们可以从保险箱中读取秘密。</span><span class="sxs-lookup"><span data-stu-id="51237-307">Under this assumed role, they can read the secrets from the safe.</span></span> <span data-ttu-id="51237-308">有许多不同的安全设置可以进一步限制应用程序对保管库的访问，以便它无法更新机密，只能读取它们。</span><span class="sxs-lookup"><span data-stu-id="51237-308">There are a number of different security settings that can further limit the access that an application has to the vault, so that it can't update secrets but only read them.</span></span>

<span data-ttu-id="51237-309">可以监视对密钥保管库的访问，以确保只有预期的应用程序访问保管库。</span><span class="sxs-lookup"><span data-stu-id="51237-309">Access to the key vault can be monitored to ensure that only the expected applications are accessing the vault.</span></span> <span data-ttu-id="51237-310">日志可以集成到 Azure 监视器中，从而解锁在遇到意外情况时设置警报的能力。</span><span class="sxs-lookup"><span data-stu-id="51237-310">The logs can be integrated back into Azure Monitor, unlocking the ability to set up alerts when unexpected conditions are encountered.</span></span>

## <a name="kubernetes"></a><span data-ttu-id="51237-311">Kubernetes</span><span class="sxs-lookup"><span data-stu-id="51237-311">Kubernetes</span></span>

<span data-ttu-id="51237-312">在库伯内斯，也有类似的服务来维护一小段秘密信息。</span><span class="sxs-lookup"><span data-stu-id="51237-312">Within Kubernetes, there's a similar service for maintaining small pieces of secret information.</span></span> <span data-ttu-id="51237-313">库伯内斯的秘密可以通过典型的`kubectl`可执行文件设置。</span><span class="sxs-lookup"><span data-stu-id="51237-313">Kubernetes Secrets can be set via the typical `kubectl` executable.</span></span>

<span data-ttu-id="51237-314">创建机密非常简单，只需查找要存储的值的 base64 版本：</span><span class="sxs-lookup"><span data-stu-id="51237-314">Creating a secret is as simple as finding the base64 version of the values to be stored:</span></span>

```console
echo -n 'admin' | base64
YWRtaW4=
echo -n '1f2d1e2e67df' | base64
MWYyZDFlMmU2N2Rm
```

<span data-ttu-id="51237-315">然后将其添加到名为"例如"的`secret.yml`机密文件中，该文件看起来类似于以下示例：</span><span class="sxs-lookup"><span data-stu-id="51237-315">Then adding it to a secrets file named `secret.yml` for example that looks similar to the following example:</span></span>

```yml
apiVersion: v1
kind: Secret
metadata:
  name: mysecret
type: Opaque
data:
  username: YWRtaW4=
  password: MWYyZDFlMmU2N2Rm
```

<span data-ttu-id="51237-316">最后，可以通过运行以下命令将此文件加载到 Kubernetes 中：</span><span class="sxs-lookup"><span data-stu-id="51237-316">Finally, this file can be loaded into Kubernetes by running the following command:</span></span>

```console
kubectl apply -f ./secret.yaml
```

<span data-ttu-id="51237-317">然后，这些机密可以装载到卷中，或通过环境变量暴露到容器进程中。</span><span class="sxs-lookup"><span data-stu-id="51237-317">These secrets can then be mounted into volumes or exposed to container processes through environment variables.</span></span> <span data-ttu-id="51237-318">构建应用程序的[十二因子应用](https://12factor.net/)方法建议使用最低公共分母将设置传输到应用程序。</span><span class="sxs-lookup"><span data-stu-id="51237-318">The [Twelve-factor app](https://12factor.net/) approach to building applications suggests using the lowest common denominator to transmit settings to an application.</span></span> <span data-ttu-id="51237-319">环境变量是最低的共同点，因为它们无论操作系统或应用程序都受支持。</span><span class="sxs-lookup"><span data-stu-id="51237-319">Environment variables are the lowest common denominator, because they're supported no matter the operating system or application.</span></span>

<span data-ttu-id="51237-320">使用内置 Kubernetes 机密的替代方法是从库伯内斯内部访问 Azure 密钥保管库中的秘密。</span><span class="sxs-lookup"><span data-stu-id="51237-320">An alternative to use the built-in Kubernetes secrets is to access the secrets in Azure Key Vault from within Kubernetes.</span></span> <span data-ttu-id="51237-321">最简单的方法是为要加载机密的容器分配 RBAC 角色。</span><span class="sxs-lookup"><span data-stu-id="51237-321">The simplest way to do this is to assign an RBAC role to the container looking to load secrets.</span></span> <span data-ttu-id="51237-322">然后，应用程序可以使用 Azure 密钥保管库 API 来访问机密。</span><span class="sxs-lookup"><span data-stu-id="51237-322">The application can then use the Azure Key Vault APIs to access the secrets.</span></span> <span data-ttu-id="51237-323">但是，此方法需要修改代码，并且不遵循使用环境变量的模式。</span><span class="sxs-lookup"><span data-stu-id="51237-323">However, this approach requires modifications to the code and doesn't follow the pattern of using environment variables.</span></span> <span data-ttu-id="51237-324">相反，可以使用[Azure 密钥保管库注入器](https://mrdevops.io/introducing-azure-key-vault-to-kubernetes-931f82364354)将值注入容器。</span><span class="sxs-lookup"><span data-stu-id="51237-324">Instead, it's possible to inject values into a container through the use of the [Azure Key Vault Injector](https://mrdevops.io/introducing-azure-key-vault-to-kubernetes-931f82364354).</span></span> <span data-ttu-id="51237-325">实际上，此方法比直接使用 Kubernetes 机密更安全，因为群集上的用户可以访问它们。</span><span class="sxs-lookup"><span data-stu-id="51237-325">This approach is actually more secure than using the Kubernetes secrets directly, as they can be accessed by users on the cluster.</span></span>

## <a name="encryption-in-transit-and-at-rest"></a><span data-ttu-id="51237-326">传输和静态加密</span><span class="sxs-lookup"><span data-stu-id="51237-326">Encryption in transit and at rest</span></span>

<span data-ttu-id="51237-327">无论数据是在磁盘上还是在各种不同的服务之间传输，保持数据安全都很重要。</span><span class="sxs-lookup"><span data-stu-id="51237-327">Keeping data safe is important whether it's on disk or transiting between various different services.</span></span> <span data-ttu-id="51237-328">防止数据泄漏的最有效方法是将其加密为其他人无法轻易读取的格式。</span><span class="sxs-lookup"><span data-stu-id="51237-328">The most effective way to keep data from leaking is to encrypt it into a format that can't be easily read by others.</span></span> <span data-ttu-id="51237-329">Azure 支持各种加密选项。</span><span class="sxs-lookup"><span data-stu-id="51237-329">Azure supports a wide range of encryption options.</span></span>

### <a name="in-transit"></a><span data-ttu-id="51237-330">传输中</span><span class="sxs-lookup"><span data-stu-id="51237-330">In transit</span></span>

<span data-ttu-id="51237-331">有几种方法可以加密 Azure 中网络上的流量。</span><span class="sxs-lookup"><span data-stu-id="51237-331">There are several ways to encrypt traffic on the network in Azure.</span></span> <span data-ttu-id="51237-332">对 Azure 服务的访问通常是通过使用传输层安全 （TLS） 的连接完成的。</span><span class="sxs-lookup"><span data-stu-id="51237-332">The access to Azure services is typically done over connections that use Transport Layer Security (TLS).</span></span> <span data-ttu-id="51237-333">例如，到 Azure API 的所有连接都需要 TLS 连接。</span><span class="sxs-lookup"><span data-stu-id="51237-333">For instance, all the connections to the Azure APIs require TLS connections.</span></span> <span data-ttu-id="51237-334">同样，与 Azure 存储中的终结点的连接可以限制为仅通过 TLS 加密连接工作。</span><span class="sxs-lookup"><span data-stu-id="51237-334">Equally, connections to endpoints in Azure storage can be restricted to work only over TLS encrypted connections.</span></span>

<span data-ttu-id="51237-335">TLS 是一个复杂的协议，只需知道连接使用 TLS 就不足以确保安全性。</span><span class="sxs-lookup"><span data-stu-id="51237-335">TLS is a complicated protocol and simply knowing that the connection is using TLS isn't sufficient to ensure security.</span></span> <span data-ttu-id="51237-336">例如，TLS 1.0 长期不安全，TLS 1.1 没有更好的效果。</span><span class="sxs-lookup"><span data-stu-id="51237-336">For instance, TLS 1.0 is chronically insecure, and TLS 1.1 isn't much better.</span></span> <span data-ttu-id="51237-337">即使在 TLS 版本中，也有多种设置，使连接更易于解密。</span><span class="sxs-lookup"><span data-stu-id="51237-337">Even within the versions of TLS, there are various settings that can make the connections easier to decrypt.</span></span> <span data-ttu-id="51237-338">最佳操作方案是检查并查看服务器连接是否使用最新且配置良好的协议。</span><span class="sxs-lookup"><span data-stu-id="51237-338">The best course of action is to check and see if the server connection is using up-to-date and well configured protocols.</span></span>

<span data-ttu-id="51237-339">此检查可以通过外部服务（如 SSL 实验室的 SSL 服务器测试）来完成。</span><span class="sxs-lookup"><span data-stu-id="51237-339">This check can be done by an external service such as SSL labs' SSL Server Test.</span></span> <span data-ttu-id="51237-340">针对典型的 Azure 终结点（在本例中为服务总线终结点）的测试运行会产生近乎完美的 A 分数。</span><span class="sxs-lookup"><span data-stu-id="51237-340">A test run against a typical Azure endpoint, in this case a service bus endpoint, yields a near perfect score of A.</span></span>

<span data-ttu-id="51237-341">即使是 Azure SQL 数据库等服务也使用 TLS 加密来隐藏数据。</span><span class="sxs-lookup"><span data-stu-id="51237-341">Even services like Azure SQL databases use TLS encryption to keep data hidden.</span></span> <span data-ttu-id="51237-342">使用 TLS 加密传输中数据有趣的部分是，即使对于 Microsoft 来说，也不可能侦听运行 TLS 的计算机之间的连接。</span><span class="sxs-lookup"><span data-stu-id="51237-342">The interesting part about encrypting the data in transit using TLS is that it isn't possible, even for Microsoft, to listen in on the connection between computers running TLS.</span></span> <span data-ttu-id="51237-343">这应该为担心其数据可能面临来自 Microsoft 专有甚至具有比标准攻击者资源较多的州行为者带来风险的公司提供了安慰。</span><span class="sxs-lookup"><span data-stu-id="51237-343">This should provide comfort for companies concerned that their data may be at risk from Microsoft proper or even a state actor with more resources than the standard attacker.</span></span>

<span data-ttu-id="51237-344">![图 10-5 SSL 实验室报告显示服务总线终结点的 A 分数。](./media/ssl-report.png)
**图10-5**。</span><span class="sxs-lookup"><span data-stu-id="51237-344">![Figure 10-5 SSL labs report showing a score of A for a Service Bus endpoint.](./media/ssl-report.png)
**Figure 10-5**.</span></span> <span data-ttu-id="51237-345">SSL 实验室报告显示服务总线终结点的 A 分数。</span><span class="sxs-lookup"><span data-stu-id="51237-345">SSL labs report showing a score of A for a Service Bus endpoint.</span></span>

<span data-ttu-id="51237-346">虽然这种级别的加密不会一直足够，但它应该激发人们的信心，即 Azure TLS 连接相当安全。</span><span class="sxs-lookup"><span data-stu-id="51237-346">While this level of encryption isn't going to be sufficient for all time, it should inspire confidence that Azure TLS connections are quite secure.</span></span> <span data-ttu-id="51237-347">随着加密的改进，Azure 将继续改进其安全标准。</span><span class="sxs-lookup"><span data-stu-id="51237-347">Azure will continue to evolve its security standards as encryption improves.</span></span> <span data-ttu-id="51237-348">很高兴知道，有人在查看安全标准并随着 Azure 的改进而更新 Azure。</span><span class="sxs-lookup"><span data-stu-id="51237-348">It's nice to know that there's somebody watching the security standards and updating Azure as they improve.</span></span>

### <a name="at-rest"></a><span data-ttu-id="51237-349">静态</span><span class="sxs-lookup"><span data-stu-id="51237-349">At rest</span></span>

<span data-ttu-id="51237-350">在任何应用程序中，数据在磁盘上放置的有很多位置。</span><span class="sxs-lookup"><span data-stu-id="51237-350">In any application, there are a number of places where data rests on disk.</span></span> <span data-ttu-id="51237-351">应用程序代码本身是从某些存储机制加载的。</span><span class="sxs-lookup"><span data-stu-id="51237-351">The application code itself is loaded from some storage mechanism.</span></span> <span data-ttu-id="51237-352">大多数应用程序还使用某种数据库，如 SQL Server、Cosmos DB，甚至具有惊人的价格效率的表存储。</span><span class="sxs-lookup"><span data-stu-id="51237-352">Most applications also use some kind of database such as SQL Server, Cosmos DB, or even the amazingly price-efficient Table Storage.</span></span> <span data-ttu-id="51237-353">这些数据库都使用大量加密的存储，以确保除了具有适当权限的应用程序之外，任何人都无法读取您的数据。</span><span class="sxs-lookup"><span data-stu-id="51237-353">These databases all use heavily encrypted storage to ensure that nobody other than the applications with proper permissions can read your data.</span></span> <span data-ttu-id="51237-354">甚至系统操作员也不能读取已加密的数据。</span><span class="sxs-lookup"><span data-stu-id="51237-354">Even the system operators can't read data that has been encrypted.</span></span> <span data-ttu-id="51237-355">因此，客户可以仍然相信他们的秘密信息仍然是秘密的。</span><span class="sxs-lookup"><span data-stu-id="51237-355">So customers can remain confident their secret information remains secret.</span></span>

### <a name="storage"></a><span data-ttu-id="51237-356">存储</span><span class="sxs-lookup"><span data-stu-id="51237-356">Storage</span></span>

<span data-ttu-id="51237-357">Azure 的大部分基础是 Azure 存储引擎。</span><span class="sxs-lookup"><span data-stu-id="51237-357">The underpinning of much of Azure is the Azure Storage engine.</span></span> <span data-ttu-id="51237-358">虚拟机磁盘安装在 Azure 存储的顶部。</span><span class="sxs-lookup"><span data-stu-id="51237-358">Virtual machine disks are mounted on top of Azure Storage.</span></span> <span data-ttu-id="51237-359">Azure 库伯奈斯服务运行在虚拟机上运行，虚拟机本身托管在 Azure 存储上。</span><span class="sxs-lookup"><span data-stu-id="51237-359">Azure Kubernetes Services run on virtual machines that, themselves, are hosted on Azure Storage.</span></span> <span data-ttu-id="51237-360">即使是无服务器技术（如 Azure 函数应用和 Azure 容器实例）也耗尽了属于 Azure 存储的磁盘。</span><span class="sxs-lookup"><span data-stu-id="51237-360">Even serverless technologies, such as Azure Functions Apps and Azure Container Instances, run out of disk that is part of Azure Storage.</span></span>

<span data-ttu-id="51237-361">如果 Azure 存储已很好地加密，则它为大多数其他内容都提供了一个基础，以便进行加密。</span><span class="sxs-lookup"><span data-stu-id="51237-361">If Azure Storage is well encrypted, then it provides for a foundation for most everything else to also be encrypted.</span></span> <span data-ttu-id="51237-362">Azure 存储使用[FIPS 140-2](https://en.wikipedia.org/wiki/FIPS_140)兼容[256 位 AES](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard)[进行加密](https://docs.microsoft.com/azure/storage/common/storage-service-encryption)。</span><span class="sxs-lookup"><span data-stu-id="51237-362">Azure Storage [is encrypted](https://docs.microsoft.com/azure/storage/common/storage-service-encryption) with [FIPS 140-2](https://en.wikipedia.org/wiki/FIPS_140) compliant [256-bit AES](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard).</span></span> <span data-ttu-id="51237-363">这是一项备受推崇的加密技术，在过去 20 年左右的岁月中一直受到广泛的学术审查。</span><span class="sxs-lookup"><span data-stu-id="51237-363">This is a well-regarded encryption technology having been the subject of extensive academic scrutiny over the last 20 or so years.</span></span> <span data-ttu-id="51237-364">目前，没有已知的实际攻击，允许一个人不知道密钥读取由AES加密的数据。</span><span class="sxs-lookup"><span data-stu-id="51237-364">At present, there's no known practical attack that would allow someone without knowledge of the key to read data encrypted by AES.</span></span>

<span data-ttu-id="51237-365">默认情况下，用于加密 Azure 存储的密钥由 Microsoft 管理。</span><span class="sxs-lookup"><span data-stu-id="51237-365">By default, the keys used for encrypting Azure Storage are managed by Microsoft.</span></span> <span data-ttu-id="51237-366">有广泛的保护，以确保防止恶意访问这些密钥。</span><span class="sxs-lookup"><span data-stu-id="51237-366">There are extensive protections in place to ensure to prevent malicious access to these keys.</span></span> <span data-ttu-id="51237-367">但是，具有特定加密要求的用户也可以提供在 Azure 密钥保管库中托管[的存储密钥](https://docs.microsoft.com/azure/storage/common/storage-encryption-keys-powershell)。</span><span class="sxs-lookup"><span data-stu-id="51237-367">However, users with particular encryption requirements can also [provide their own storage keys](https://docs.microsoft.com/azure/storage/common/storage-encryption-keys-powershell) that are managed in Azure Key Vault.</span></span> <span data-ttu-id="51237-368">可以随时吊销这些密钥，这将有效地使使用它们访问的存储帐户的内容变得不可访问。</span><span class="sxs-lookup"><span data-stu-id="51237-368">These keys can be revoked at any time, which would effectively render the contents of the Storage account using them inaccessible.</span></span>

<span data-ttu-id="51237-369">虚拟机使用加密存储，但可以使用 Windows 上的 BitLocker 或 Linux 上的 DM-Crypt 等技术提供另一层加密。</span><span class="sxs-lookup"><span data-stu-id="51237-369">Virtual machines use encrypted storage, but it's possible to provide another layer of encryption by using technologies like BitLocker on Windows or DM-Crypt on Linux.</span></span> <span data-ttu-id="51237-370">这些技术意味着，即使磁盘映像从存储中泄露，也几乎不可能读取它。</span><span class="sxs-lookup"><span data-stu-id="51237-370">These technologies mean that even if the disk image was leaked off of storage, it would remain near impossible to read it.</span></span>

### <a name="azure-sql"></a><span data-ttu-id="51237-371">Azure SQL</span><span class="sxs-lookup"><span data-stu-id="51237-371">Azure SQL</span></span>

<span data-ttu-id="51237-372">在 Azure SQL 上托管的数据库使用称为[透明数据加密 （TDE）](/sql/relational-databases/security/encryption/transparent-data-encryption)的技术来确保数据保持加密。</span><span class="sxs-lookup"><span data-stu-id="51237-372">Databases hosted on Azure SQL use a technology called [Transparent Data Encryption (TDE)](/sql/relational-databases/security/encryption/transparent-data-encryption) to ensure data remains encrypted.</span></span> <span data-ttu-id="51237-373">默认情况下，它在所有新创建的 SQL 数据库上启用，但必须手动为旧数据库启用。</span><span class="sxs-lookup"><span data-stu-id="51237-373">It's enabled by default on all newly created SQL databases, but must be enabled manually for legacy databases.</span></span> <span data-ttu-id="51237-374">TDE 不仅执行数据库的实时加密和解密，还执行备份和事务日志。</span><span class="sxs-lookup"><span data-stu-id="51237-374">TDE executes real-time encryption and decryption of not just the database, but also the backups and transaction logs.</span></span>

<span data-ttu-id="51237-375">加密参数存储在`master`数据库中，并在启动时读取到内存中以执行其余操作。</span><span class="sxs-lookup"><span data-stu-id="51237-375">The encryption parameters are stored in the `master` database and, on startup, are read into memory for the remaining operations.</span></span> <span data-ttu-id="51237-376">这意味着`master`数据库必须保持未加密状态。</span><span class="sxs-lookup"><span data-stu-id="51237-376">This means that the `master` database must remain unencrypted.</span></span> <span data-ttu-id="51237-377">实际密钥由 Microsoft 管理。</span><span class="sxs-lookup"><span data-stu-id="51237-377">The actual key is managed by Microsoft.</span></span> <span data-ttu-id="51237-378">但是，具有严格安全要求的用户在密钥保管库中提供自己的密钥的方式可能与 Azure 存储的密钥相同。</span><span class="sxs-lookup"><span data-stu-id="51237-378">However, users with exacting security requirements may provide their own key in Key Vault in much the same way as is done for Azure Storage.</span></span> <span data-ttu-id="51237-379">密钥保管库提供密钥轮换和吊销等服务。</span><span class="sxs-lookup"><span data-stu-id="51237-379">The Key Vault provides for such services as key rotation and revocation.</span></span>

<span data-ttu-id="51237-380">TDS 的"透明"部分来自使用加密数据库不需要客户端更改这一事实。</span><span class="sxs-lookup"><span data-stu-id="51237-380">The "Transparent" part of TDS comes from the fact that there aren't client changes needed to use an encrypted database.</span></span> <span data-ttu-id="51237-381">虽然此方法提供良好的安全性，但泄露数据库密码足以让用户能够解密数据。</span><span class="sxs-lookup"><span data-stu-id="51237-381">While this approach provides for good security, leaking the database password is enough for users to be able to decrypt the data.</span></span> <span data-ttu-id="51237-382">还有另一种方法对数据库中的各个列或表进行加密。</span><span class="sxs-lookup"><span data-stu-id="51237-382">There's another approach that encrypts individual columns or tables in a database.</span></span> <span data-ttu-id="51237-383">[始终加密](https://docs.microsoft.com/azure/sql-database/sql-database-always-encrypted-azure-key-vault)可确保加密数据在数据库中的纯文本中始终显示。</span><span class="sxs-lookup"><span data-stu-id="51237-383">[Always Encrypted](https://docs.microsoft.com/azure/sql-database/sql-database-always-encrypted-azure-key-vault) ensures that at no point the encrypted data appears in plain text inside the database.</span></span>

<span data-ttu-id="51237-384">设置此加密层需要通过 SQL Server 管理工作室中的向导运行，以选择加密类型以及密钥保管库中存储关联密钥的位置。</span><span class="sxs-lookup"><span data-stu-id="51237-384">Setting up this tier of encryption requires running through a wizard in SQL Server Management Studio to select the sort of encryption and where in Key Vault to store the associated keys.</span></span>

<span data-ttu-id="51237-385">![图 10-6 选择表中的列，以便使用始终加密](./media/always-encrypted.png)
**图 10-6**进行加密。</span><span class="sxs-lookup"><span data-stu-id="51237-385">![Figure 10-6 Selecting columns in a table to be encrypted using Always Encrypted](./media/always-encrypted.png)
**Figure 10-6**.</span></span> <span data-ttu-id="51237-386">选择表中的列，以便使用"始终加密"进行加密。</span><span class="sxs-lookup"><span data-stu-id="51237-386">Selecting columns in a table to be encrypted using Always Encrypted.</span></span>

<span data-ttu-id="51237-387">从这些加密列读取信息的客户端应用程序需要特别调整以读取加密数据。</span><span class="sxs-lookup"><span data-stu-id="51237-387">Client applications that read information from these encrypted columns need to make special allowances to read encrypted data.</span></span> <span data-ttu-id="51237-388">连接字符串需要更新，`Column Encryption Setting=Enabled`并且必须从密钥保管库检索客户端凭据。</span><span class="sxs-lookup"><span data-stu-id="51237-388">Connection strings need to be updated with `Column Encryption Setting=Enabled` and client credentials must be retrieved from the Key Vault.</span></span> <span data-ttu-id="51237-389">然后，必须使用列加密密钥来准备 SQL Server 客户端。</span><span class="sxs-lookup"><span data-stu-id="51237-389">The SQL Server client must then be primed with the column encryption keys.</span></span> <span data-ttu-id="51237-390">完成后，其余操作使用 SQL 客户端的标准接口。</span><span class="sxs-lookup"><span data-stu-id="51237-390">Once that is done, the remaining actions use the standard interfaces to SQL Client.</span></span> <span data-ttu-id="51237-391">也就是说，像 Dapper 和实体框架这样的工具，它们构建在 SQL 客户端之上，将继续在不进行更改的情况下工作。</span><span class="sxs-lookup"><span data-stu-id="51237-391">That is, tools like Dapper and Entity Framework, which are built on top of SQL Client, will continue to work without changes.</span></span> <span data-ttu-id="51237-392">对于每种语言的每个 SQL Server 驱动程序，始终未使用加密。</span><span class="sxs-lookup"><span data-stu-id="51237-392">Always Encrypted may not yet be available for every SQL Server driver on every language.</span></span>

<span data-ttu-id="51237-393">TDE 和"始终加密"的组合（两者都可与特定于客户端的密钥一起使用）可确保即使是最严格的加密要求也得到支持。</span><span class="sxs-lookup"><span data-stu-id="51237-393">The combination of TDE and Always Encrypted, both of which can be used with client-specific keys, ensures that even the most exacting encryption requirements are supported.</span></span>

### <a name="cosmos-db"></a><span data-ttu-id="51237-394">Cosmos DB</span><span class="sxs-lookup"><span data-stu-id="51237-394">Cosmos DB</span></span>

<span data-ttu-id="51237-395">宇宙 DB 是 Microsoft 在 Azure 中提供的最新数据库。</span><span class="sxs-lookup"><span data-stu-id="51237-395">Cosmos DB is the newest database provided by Microsoft in Azure.</span></span> <span data-ttu-id="51237-396">它从一开始就建立了，并考虑到了安全性和密码学。</span><span class="sxs-lookup"><span data-stu-id="51237-396">It has been built from the ground up with security and cryptography in mind.</span></span> <span data-ttu-id="51237-397">AES-256 位加密是所有 Cosmos DB 数据库的标准加密，不能禁用。</span><span class="sxs-lookup"><span data-stu-id="51237-397">AES-256bit encryption is standard for all Cosmos DB databases and can't be disabled.</span></span> <span data-ttu-id="51237-398">再加上 TLS 1.2 通信要求，整个存储解决方案都是加密的。</span><span class="sxs-lookup"><span data-stu-id="51237-398">Coupled with the TLS 1.2 requirement for communication, the entire storage solution is encrypted.</span></span>

<span data-ttu-id="51237-399">![图10-7 Cosmos DB](./media/cosmos-encryption.png)
中的数据加密流图**10-7**。</span><span class="sxs-lookup"><span data-stu-id="51237-399">![Figure 10-7 The flow of data encryption within Cosmos DB](./media/cosmos-encryption.png)
**Figure 10-7**.</span></span> <span data-ttu-id="51237-400">Cosmos DB 中的数据加密流。</span><span class="sxs-lookup"><span data-stu-id="51237-400">The flow of data encryption within Cosmos DB.</span></span>

<span data-ttu-id="51237-401">虽然 Cosmos DB 不提供客户加密密钥，但团队已做了大量工作，以确保在没有这些密钥的情况下保持 PCI-DSS 兼容。</span><span class="sxs-lookup"><span data-stu-id="51237-401">While Cosmos DB doesn't provide for supplying customer encryption keys, there has been significant work done by the team to ensure it remains PCI-DSS compliant without that.</span></span> <span data-ttu-id="51237-402">Cosmos DB 还不支持任何类似于 Azure SQL 的"始终加密"的单列加密。</span><span class="sxs-lookup"><span data-stu-id="51237-402">Cosmos DB also doesn't support any sort of single column encryption similar to Azure SQL's Always Encrypted yet.</span></span>

## <a name="keeping-secure"></a><span data-ttu-id="51237-403">保持安全</span><span class="sxs-lookup"><span data-stu-id="51237-403">Keeping secure</span></span>

<span data-ttu-id="51237-404">Azure 具有发布高度安全产品所需的所有工具。</span><span class="sxs-lookup"><span data-stu-id="51237-404">Azure has all the tools necessary to release a highly secure product.</span></span> <span data-ttu-id="51237-405">然而，链条只有最薄弱的环节那么强大。</span><span class="sxs-lookup"><span data-stu-id="51237-405">However, a chain is only as strong as its weakest link.</span></span> <span data-ttu-id="51237-406">如果部署在 Azure 之上的应用程序没有以适当的安全心态和良好的安全审核来开发，那么它们就成为链中的薄弱环节。</span><span class="sxs-lookup"><span data-stu-id="51237-406">If the applications deployed on top of Azure aren't developed with a proper security mindset and good security audits, then they become the weak link in the chain.</span></span> <span data-ttu-id="51237-407">有许多出色的静态分析工具、加密库和安全实践可用于确保 Azure 上安装的软件与 Azure 本身一样安全。</span><span class="sxs-lookup"><span data-stu-id="51237-407">There are many great static analysis tools, encryption libraries, and security practices that can be used to ensure that the software installed on Azure is as secure as Azure itself.</span></span> <span data-ttu-id="51237-408">示例包括[静态分析工具](https://www.whitesourcesoftware.com/)、[加密库](https://www.libressl.org/)[和安全实践](https://azure.microsoft.com/resources/videos/red-vs-blue-internal-security-penetration-testing-of-microsoft-azure/)。</span><span class="sxs-lookup"><span data-stu-id="51237-408">Examples include [static analysis tools](https://www.whitesourcesoftware.com/), [encryption libraries](https://www.libressl.org/), and [security practices](https://azure.microsoft.com/resources/videos/red-vs-blue-internal-security-penetration-testing-of-microsoft-azure/).</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="51237-409">[上一页](security.md)
>[下一页](devops.md)</span><span class="sxs-lookup"><span data-stu-id="51237-409">[Previous](security.md)
[Next](devops.md)</span></span>
