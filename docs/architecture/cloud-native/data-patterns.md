---
title: 云本机数据模式
description: 构建适用于 Azure 的云本机 .NET 应用 |云本机数据模式
ms.date: 06/30/2019
ms.openlocfilehash: 0d251f3046fcd3f3a2f5d856a123a35d3f7ecff2
ms.sourcegitcommit: 559fcfbe4871636494870a8b716bf7325df34ac5
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 10/30/2019
ms.locfileid: "73841821"
---
# <a name="cloud-native-data-patterns"></a>云本机数据模式

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

虽然分散的数据可能会提高性能、可伸缩性和节省成本，但它也带来了许多挑战。 跨微服务查询数据非常复杂。 跨微服务的事务必须以编程方式进行管理，因为云本机应用程序中不支持分布式事务。 从一开始就是从*即时一致性*转变到*最终一致性*。

现在我们讨论了这些难题。

## <a name="cross-service-queries"></a>跨服务查询

应用程序如何查询分散在多个独立微服务上的数据？

图5-4 显示了这种情况。

![跨微服务进行查询](./media/cross-service-query.png)

**图 5-4**。 跨微服务进行查询

请注意，在上图中，如何查看购物篮微服务，将物品添加到用户的购物车。 尽管购物篮的数据存储包含购物篮和 lineItem 表，但它不包含产品或定价数据，因为在产品和价格微服务中找到这些项目。 若要添加项，购物篮微服务需要产品数据和定价数据。 用于获取产品和定价数据的选项有哪些？

图5-5 显示了微服务对产品目录和定价微服务进行直接 HTTP 调用的购物篮。

![直接 http 通信](./media/direct-http-communication.png)

**图 5-5**。 直接 HTTP 通信

虽然实现可行，但在第4章介绍了如何在微服务中直接进行 HTTP 调用，而不是一种很好的做法。

我们可以实现微服务图5-6 中所示的聚合器。

![聚合微服务](./media/aggregator-microservice.png)

**如 5-6**。 聚合微服务

虽然这种方法会在单独的微服务中封装业务操作工作流，但它增加了复杂性，但仍会导致直接 HTTP 调用。

执行跨服务查询的常用方法是使用图5-7 中所示的[具体化视图模式](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)。

![具体化视图模式](./media/materialized-view-pattern.png)

**Figure5-7**。 具体化视图模式

使用此模式，直接将本地表（称为 "*读取模型*"）放置在购物篮服务中，该服务包含产品和定价微服务所需的数据的非规范化副本。 将这些数据放入购物篮微服务，无需调用昂贵的跨服务呼叫。 利用服务的本地数据，可以提高响应时间和可靠性。

使用此方法时，有了系统中的重复数据。 在云本机系统中，重复数据不会被视为[反模式](https://en.wikipedia.org/wiki/Anti-pattern)，并且通常在云本机系统中实现。 但是，其中一个系统可以是任何数据集的所有者，并且你需要为记录系统实现一种同步机制，以便在每次更改其基础数据时更新所有关联的读取模型。

## <a name="transactional-support"></a>事务性支持

尽管跨微服务的查询有挑战性，但跨微服务实现事务可能会很复杂。 在驻留在不同微服务中的数据源之间维护数据一致性的固有挑战不能 understated。 图5-8 显示了问题。

![Saga 模式中的事务](./media/saga-transaction-operation.png)

**图 5-8**。 跨微服务实现事务

请注意上图中的第五个独立微服务如何参与分布式*创建订单*交易。 但是，五个单独微服务中每一个的事务必须成功，否则必须中止并回滚操作。 虽然内置事务支持在每个微服务中均可用，但不支持跨所有五项服务的分布式事务。

由于事务支持对于此操作至关重要，使每个微服务中的数据保持一致，因此必须以编程方式构造分布式事务。

以编程方式添加事务性支持的常见模式是[Saga 模式](https://blog.couchbase.com/saga-pattern-implement-business-transactions-using-microservices-part/)。 这是通过将本地事务组合在一起并按顺序调用每个事务来实现的。 如果本地事务失败，Saga 将中止该操作，并调用一组[补偿事务](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction)来撤消前面的本地事务所做的更改。 图5-9 显示了具有 Saga 模式的失败的事务。

![在 saga 模式中回滚](./media/saga-rollback-operation.png)

**图 5-9**。 回滚事务

请注意上图中的如何*GenerateContent*操作在音乐微服务中失败。 Saga 调用补偿事务（红色）以删除内容、取消付款并取消订单，并将每个微服务的数据返回到一致的状态。

Saga 模式通常编排为一系列相关事件，或作为一组相关命令进行协调。

## <a name="cqrs-pattern"></a>CQRS 模式

CQRS 或[命令和查询责任分离](https://docs.microsoft.com/azure/architecture/patterns/cqrs)是一种体系结构模式，用于将读取数据的操作与写入数据的操作分离。 此模式可帮助最大限度地提高性能、可伸缩性和安全性。

在正常数据访问方案中，您实现了一个*同时*执行读写数据操作的单一模型（实体和存储库对象）。

但是，更高级的数据访问方案可能会受益于用于读取和写入的单独的模型和数据表。 为了提高性能，读取操作（称为*查询*）可能会针对数据的高度非规范化表示，以避免重复的重复表联接。 但*写入*操作（称为*命令*）可能会针对数据的完全标准化表示形式进行更新。 然后需要实现一种机制，使这两种表示形式保持同步。通常，只要修改写入表，就会引发将数据修改复制到读取表的事件。

图5-10 显示了 CQRS 模式的实现。

![CQRS 实现](./media/cqrs-implementation.png)

**图 5-10**。 CQRS 实现

请注意上图中如何实现不同的命令和查询模型。 此外，每个数据写入操作都会保存到写入存储，然后传播到读取存储。 请密切注意传播过程如何按照[最终一致性](https://www.cloudcomputingpatterns.org/eventual_consistency/)原则操作，而读取模型最终与写入模型同步，但在此过程中可能会出现一些延迟。

通过实现分离，可以单独缩放读取和写入。 同样，对写入操作的安全性可能比涉及读取操作的安全性更严格。

通常，CQRS 模式根据特定需求应用于系统的有限部分。

## <a name="relational-vs-nosql"></a>关系与 NoSQL

[NoSQL](https://www.geeksforgeeks.org/introduction-to-nosql/)技术的影响不能言过其实，尤其是对于分布式云本机系统。 这一领域新数据技术的激增导致了只依赖于关系数据库的解决方案。

另一方面，关系数据库是数十年的一项普遍技术。 它们是成熟、经过验证且广泛实现的。 竞争的数据库产品、专业技能和工具 abounds。 关系数据库提供相关数据表的存储区。 这些表具有固定的架构，使用 SQL （结构化查询语言）来管理数据，并获得[ACID](https://www.geeksforgeeks.org/acid-properties-in-dbms/) （也称为原子性、一致性、隔离和持续性）。

另一方面，非 SQL 数据库指的是高性能、非关系型数据存储。 它们采用易用性、可伸缩性、复原能力和可用性特征提供了方便。 NoSQL 将自描述（无架构）数据通常存储在 JSON 文档中，而不是联接规范化数据的表。 它们不提供[ACID](https://www.geeksforgeeks.org/acid-properties-in-dbms/)保证。

要了解这两种类型的数据库之间的差异，可以参阅[CAP 定理](https://towardsdatascience.com/cap-theorem-and-distributed-database-management-systems-5c2be977950e)（一组可应用于存储状态的分布式系统的原则）。 图5-11 显示了 CAP 定理的三个属性。

![CAP 定理](./media/cap-theorem.png)

**图 5-11**。 CAP 定理

定理指出，任何分布式数据系统都将在一致性、可用性和分区容差之间提供折衷，并且任何数据库只能保证三个属性中的两个：

- *一致性*：群集中的每个节点都将使用最新的数据做出响应，即使它需要阻塞请求，直到所有副本都得到正确更新。

- *可用性*：每个节点都将在合理的时间内返回响应，即使该响应不是最新的数据也是如此。

- *分区容差*：保证当某个节点出现故障或失去与其他节点的连接时，系统将继续运行。

关系数据库显示一致性和可用性，但不提供分区容差。 分区关系数据库（如分片）非常困难，可能会影响性能。

另一方面，NoSQL 数据库通常会表现出分区容差（称为水平可伸缩性和高可用性）。 作为 CAP 定理指定，您只能有这三个原则中的两个，而您会丢失一致性属性。

NoSQL 数据库在商用服务器之间进行分发和一般横向扩展。 这样做可以在地理区域内和跨地理区域提供高可用性，同时降低成本。 可以在这些计算机或节点上对数据进行分区和复制，从而提供冗余和容错能力。 缺点是一致性。 对一个 NoSQL 节点上的数据所做的更改可能需要一段时间才能传播到其他节点。 通常，NoSQL 数据库节点会立即响应查询，即使正在呈现的数据已过时，并且尚未更新。

这是已知的[最终一致性](https://www.cloudcomputingpatterns.org/eventual_consistency/)，即不支持 ACID 事务的分布式数据系统的特征。 在更新数据项目和将更新传播到每个副本节点所用的时间之间，会有短暂的延迟。 如果在美国中更新 NoSQL 数据库中的产品项，但同时从欧洲的副本节点中查询同一数据项，则可以检索先前的产品信息-直到欧盟节点更新了产品更改。 权衡是指在返回查询结果[之前，要](https://en.wikipedia.org/wiki/Strong_consistency)等待所有副本节点进行更新，而不是在返回查询结果之前，您可以支持巨大的规模和流量，但可能会显示较旧的数据。

可以通过以下四个模型对 NoSQL 数据库进行分类：

- *文档存储区*（MongoDB、CouchDB、Couchbase）：数据（以及相应的元数据）在数据库中的基于非标准化 JSON 的文档中存储为非 relationally。

- *键/值存储区*（Redis、Riak、memcached）：在简单的键值对中存储数据，这些键值对映射到用户数据值的唯一访问键执行系统操作。

- *宽列存储*（HBase，Cassandra）：相关数据以纵栏式格式存储在单个列中，并以一组嵌套键/值对的形式存储在单个列中，数据通常以单个单元的形式进行检索，而不必将多个表联接在一起。

- *Graph 商店*（neo4j，titan）：数据存储为一个节点内的图形表示形式以及指定节点之间的关系的边缘。

可以优化 NoSQL 数据库来处理大规模数据，尤其是在数据相对简单时。 在以下情况时，请考虑 NoSQL 数据库：

- 工作负荷需要大规模和高并发性。
- 用户数很多。
- 您的数据可以简单地表示而不是关系。
- 需要将数据分散到不同的位置。
- 不需要 ACID 保证。
- 将部署到商用硬件。

然后，在以下情况下考虑关系数据库：

- 你的工作负载需要大中型。
- 并发不是主要考虑因素。
- 需要 ACID 保证。
- 数据是最 relationally 的。
- 你的应用程序将部署到大型高端硬件。

接下来，我们来看看 Azure 云中的数据存储。

>[!div class="step-by-step"]
>[上一页](distributed-data.md)
>[下一页](azure-data-storage.md)
