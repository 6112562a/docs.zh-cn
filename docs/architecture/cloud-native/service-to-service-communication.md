---
title: 服务到服务通信
description: 了解后端云原生微服务如何与其他后端微服务进行通信。
author: robvet
ms.date: 09/09/2019
ms.openlocfilehash: 926be3c2eb4513c89ebcd1f31dceb7d58639dc6f
ms.sourcegitcommit: 79b0dd8bfc63f33a02137121dd23475887ecefda
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/01/2020
ms.locfileid: "80523553"
---
# <a name="service-to-service-communication"></a><span data-ttu-id="1aa32-103">服务到服务通信</span><span class="sxs-lookup"><span data-stu-id="1aa32-103">Service-to-service communication</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="1aa32-104">从前端客户端，我们现在处理后端微服务相互通信。</span><span class="sxs-lookup"><span data-stu-id="1aa32-104">Moving from the front-end client, we now address back-end microservices communicate with each other.</span></span>

<span data-ttu-id="1aa32-105">构建云本机应用程序时，您需要对后端服务如何相互通信敏感。</span><span class="sxs-lookup"><span data-stu-id="1aa32-105">When constructing a cloud-native application, you'll want to be sensitive to how back-end services communicate with each other.</span></span> <span data-ttu-id="1aa32-106">理想情况下，服务间通信越少越好。</span><span class="sxs-lookup"><span data-stu-id="1aa32-106">Ideally, the less inter-service communication, the better.</span></span> <span data-ttu-id="1aa32-107">但是，由于后端服务通常相互依赖来完成操作，因此并非始终能够避免。</span><span class="sxs-lookup"><span data-stu-id="1aa32-107">However, avoidance isn't always possible as back-end services often rely on one another to complete an operation.</span></span>

<span data-ttu-id="1aa32-108">实施跨服务通信的方法被广泛接受。</span><span class="sxs-lookup"><span data-stu-id="1aa32-108">There are several widely accepted approaches to implementing cross-service communication.</span></span> <span data-ttu-id="1aa32-109">*通信交互的类型*通常将决定最佳方法。</span><span class="sxs-lookup"><span data-stu-id="1aa32-109">The *type of communication interaction* will often determine the best approach.</span></span>

<span data-ttu-id="1aa32-110">请考虑以下交互类型：</span><span class="sxs-lookup"><span data-stu-id="1aa32-110">Consider the following interaction types:</span></span>

- <span data-ttu-id="1aa32-111">*查询*– 当调用微服务需要来自被调用的微服务的响应时，例如"嘿，给我给定客户 ID 的买方信息。</span><span class="sxs-lookup"><span data-stu-id="1aa32-111">*Query* – when a calling microservice requires a response from a called microservice, such as, "Hey, give me the buyer information for a given customer Id."</span></span>

- <span data-ttu-id="1aa32-112">*命令*– 当调用微服务需要另一个微服务来执行操作，但不需要响应时，例如"嘿，只需发出此订单"。</span><span class="sxs-lookup"><span data-stu-id="1aa32-112">*Command* – when the calling microservice needs another microservice to execute an action but doesn't require a response, such as, "Hey, just ship this order."</span></span>

- <span data-ttu-id="1aa32-113">*事件*— 当称为发布服务器的微服务引发状态已更改或已发生操作的事件时。</span><span class="sxs-lookup"><span data-stu-id="1aa32-113">*Event* – when a microservice, called the publisher, raises an event that state has changed or an action has occurred.</span></span> <span data-ttu-id="1aa32-114">其他微服务（称为订阅者）有兴趣，可以对事件做出适当的反应。</span><span class="sxs-lookup"><span data-stu-id="1aa32-114">Other microservices, called subscribers, who are interested, can react to the event appropriately.</span></span> <span data-ttu-id="1aa32-115">发布者和订阅者彼此不知道。</span><span class="sxs-lookup"><span data-stu-id="1aa32-115">The publisher and the subscribers aren't aware of each other.</span></span>

<span data-ttu-id="1aa32-116">在执行需要跨服务交互的操作时，微服务系统通常使用这些交互类型的组合。</span><span class="sxs-lookup"><span data-stu-id="1aa32-116">Microservice systems typically use a combination of these interaction types when executing operations that require cross-service interaction.</span></span> <span data-ttu-id="1aa32-117">让我们仔细看看每个以及如何实现它们。</span><span class="sxs-lookup"><span data-stu-id="1aa32-117">Let's take a close look at each and how you might implement them.</span></span>

## <a name="queries"></a><span data-ttu-id="1aa32-118">查询</span><span class="sxs-lookup"><span data-stu-id="1aa32-118">Queries</span></span>

<span data-ttu-id="1aa32-119">很多时候，一个微服务可能需要*查询*另一个微服务，需要立即响应才能完成操作。</span><span class="sxs-lookup"><span data-stu-id="1aa32-119">Many times, one microservice might need to *query* another, requiring an immediate response to complete an operation.</span></span> <span data-ttu-id="1aa32-120">购物篮微服务可能需要产品信息和价格才能将商品添加到其购物篮中。</span><span class="sxs-lookup"><span data-stu-id="1aa32-120">A shopping basket microservice may need product information and a price to add an item to its basket.</span></span> <span data-ttu-id="1aa32-121">实现查询操作的方法有很多种。</span><span class="sxs-lookup"><span data-stu-id="1aa32-121">There are a number of approaches for implementing query operations.</span></span>

### <a name="requestresponse-messaging"></a><span data-ttu-id="1aa32-122">请求/响应消息传送</span><span class="sxs-lookup"><span data-stu-id="1aa32-122">Request/Response Messaging</span></span>

<span data-ttu-id="1aa32-123">实现此方案的一个选项是调用后端微服务，以便直接向需要查询的微服务发出 HTTP 请求，如图 4-8 所示。</span><span class="sxs-lookup"><span data-stu-id="1aa32-123">One option for implementing this scenario is for the calling back-end microservice to make direct HTTP requests to the microservices it needs to query, shown in Figure 4-8.</span></span>

![直接 HTTP 通信](./media/direct-http-communication.png)

<span data-ttu-id="1aa32-125">**图4-8**。</span><span class="sxs-lookup"><span data-stu-id="1aa32-125">**Figure 4-8**.</span></span> <span data-ttu-id="1aa32-126">直接 HTTP 通信</span><span class="sxs-lookup"><span data-stu-id="1aa32-126">Direct HTTP communication</span></span>

<span data-ttu-id="1aa32-127">虽然微服务之间的直接 HTTP 调用执行起来相对简单，但应注意将这种做法降至最低。</span><span class="sxs-lookup"><span data-stu-id="1aa32-127">While direct HTTP calls between microservices are relatively simple to implement, care should be taken to minimize this practice.</span></span> <span data-ttu-id="1aa32-128">要启动，这些调用始终是*同步*的，并将阻止操作，直到返回结果或请求超时。</span><span class="sxs-lookup"><span data-stu-id="1aa32-128">To start, these calls are always *synchronous* and will block the operation until a result is returned or the request times outs.</span></span> <span data-ttu-id="1aa32-129">曾经自成一体的独立服务能够独立发展并频繁部署，现在却相互耦合。</span><span class="sxs-lookup"><span data-stu-id="1aa32-129">What were once self-contained, independent services, able to evolve independently and deploy frequently, now become coupled to each other.</span></span> <span data-ttu-id="1aa32-130">随着微服务之间的耦合增加，其体系结构优势逐渐降低。</span><span class="sxs-lookup"><span data-stu-id="1aa32-130">As coupling among microservices increase, their architectural benefits diminish.</span></span>

<span data-ttu-id="1aa32-131">执行对另一个微服务进行单个直接 HTTP 调用的不常见请求对于某些系统可能是可以接受的。</span><span class="sxs-lookup"><span data-stu-id="1aa32-131">Executing an infrequent request that makes a single direct HTTP call to another microservice might be acceptable for some systems.</span></span> <span data-ttu-id="1aa32-132">但是，不建议调用对多个微服务直接 HTTP 调用的高容量调用。</span><span class="sxs-lookup"><span data-stu-id="1aa32-132">However, high-volume calls that invoke direct HTTP calls to multiple microservices aren't advisable.</span></span> <span data-ttu-id="1aa32-133">它们会增加延迟，并产生负面影响系统的性能、可扩展性和可用性。</span><span class="sxs-lookup"><span data-stu-id="1aa32-133">They can increase latency and negatively impact the performance, scalability, and availability of your system.</span></span> <span data-ttu-id="1aa32-134">更糟糕的是，一系列直接 HTTP 通信可能导致同步微服务调用的深层和复杂链，如图 4-9 所示：</span><span class="sxs-lookup"><span data-stu-id="1aa32-134">Even worse, a long series of direct HTTP communication can lead to deep and complex chains of synchronous microservices calls, shown in Figure 4-9:</span></span>

![链接 HTTP 查询](./media/chaining-http-queries.png)

<span data-ttu-id="1aa32-136">**图4-9**。</span><span class="sxs-lookup"><span data-stu-id="1aa32-136">**Figure 4-9**.</span></span> <span data-ttu-id="1aa32-137">链接 HTTP 查询</span><span class="sxs-lookup"><span data-stu-id="1aa32-137">Chaining HTTP queries</span></span>

<span data-ttu-id="1aa32-138">您当然可以想象前一张图片中显示的设计中的风险。</span><span class="sxs-lookup"><span data-stu-id="1aa32-138">You can certainly imagine the risk in the design shown in the previous image.</span></span> <span data-ttu-id="1aa32-139">如果步骤\#3 失败，会发生什么情况？</span><span class="sxs-lookup"><span data-stu-id="1aa32-139">What happens if Step \#3 fails?</span></span> <span data-ttu-id="1aa32-140">还是步骤\#8 失败？</span><span class="sxs-lookup"><span data-stu-id="1aa32-140">Or Step \#8 fails?</span></span> <span data-ttu-id="1aa32-141">你如何恢复？</span><span class="sxs-lookup"><span data-stu-id="1aa32-141">How do you recover?</span></span> <span data-ttu-id="1aa32-142">如果步骤\#6 由于基础服务繁忙而速度较慢，该怎么办？</span><span class="sxs-lookup"><span data-stu-id="1aa32-142">What if Step \#6 is slow because the underlying service is busy?</span></span> <span data-ttu-id="1aa32-143">你如何继续？</span><span class="sxs-lookup"><span data-stu-id="1aa32-143">How do you continue?</span></span> <span data-ttu-id="1aa32-144">即使所有操作都正常工作，也想想此调用产生的延迟，即每个步骤的延迟总和。</span><span class="sxs-lookup"><span data-stu-id="1aa32-144">Even if all works correctly, think of the latency this call would incur, which is the sum of the latency of each step.</span></span>

<span data-ttu-id="1aa32-145">上图中大量耦合表明，服务没有进行最佳建模。</span><span class="sxs-lookup"><span data-stu-id="1aa32-145">The large degree of coupling in the previous image suggests the services weren't optimally modeled.</span></span> <span data-ttu-id="1aa32-146">团队应该重新审视他们的设计。</span><span class="sxs-lookup"><span data-stu-id="1aa32-146">It would behoove the team to revisit their design.</span></span>

### <a name="materialized-view-pattern"></a><span data-ttu-id="1aa32-147">具体化视图模式</span><span class="sxs-lookup"><span data-stu-id="1aa32-147">Materialized View pattern</span></span>

<span data-ttu-id="1aa32-148">删除微服务耦合的一个常用选项是[具体化视图模式](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)。</span><span class="sxs-lookup"><span data-stu-id="1aa32-148">A popular option for removing microservice coupling is the [Materialized View pattern](https://docs.microsoft.com/azure/architecture/patterns/materialized-view).</span></span> <span data-ttu-id="1aa32-149">使用此模式，微服务存储其自己的本地、非规范化数据副本，这些副本由其他服务拥有。</span><span class="sxs-lookup"><span data-stu-id="1aa32-149">With this pattern, a microservice stores its own local, denormalized copy of data that's owned by other services.</span></span> <span data-ttu-id="1aa32-150">它维护自己的本地数据副本，而不是查询产品目录和定价微服务的购物篮微服务。</span><span class="sxs-lookup"><span data-stu-id="1aa32-150">Instead of the Shopping Basket microservice querying the Product Catalog and Pricing microservices, it maintains its own local copy of that data.</span></span> <span data-ttu-id="1aa32-151">此模式消除了不必要的耦合，提高了可靠性和响应时间。</span><span class="sxs-lookup"><span data-stu-id="1aa32-151">This pattern eliminates unnecessary coupling and improves reliability and response time.</span></span> <span data-ttu-id="1aa32-152">整个操作在单个进程内执行。</span><span class="sxs-lookup"><span data-stu-id="1aa32-152">The entire operation executes inside a single process.</span></span> <span data-ttu-id="1aa32-153">我们在第 5 章中探讨此模式和其他数据问题。</span><span class="sxs-lookup"><span data-stu-id="1aa32-153">We explore this pattern and other data concerns in Chapter 5.</span></span>

### <a name="service-aggregator-pattern"></a><span data-ttu-id="1aa32-154">服务聚合器模式</span><span class="sxs-lookup"><span data-stu-id="1aa32-154">Service Aggregator Pattern</span></span>

<span data-ttu-id="1aa32-155">消除微服务到微服务耦合的另一个选项是[聚合器微服务](https://devblogs.microsoft.com/cesardelatorre/designing-and-implementing-api-gateways-with-ocelot-in-a-microservices-and-container-based-architecture/)，如图 4-10 中紫色所示。</span><span class="sxs-lookup"><span data-stu-id="1aa32-155">Another option for eliminating microservice-to-microservice coupling is an [Aggregator microservice](https://devblogs.microsoft.com/cesardelatorre/designing-and-implementing-api-gateways-with-ocelot-in-a-microservices-and-container-based-architecture/), shown in purple in Figure 4-10.</span></span>

![聚合器服务](./media/aggregator-service.png)

<span data-ttu-id="1aa32-157">**图 4-10**。</span><span class="sxs-lookup"><span data-stu-id="1aa32-157">**Figure 4-10**.</span></span> <span data-ttu-id="1aa32-158">聚合器微服务</span><span class="sxs-lookup"><span data-stu-id="1aa32-158">Aggregator microservice</span></span>

<span data-ttu-id="1aa32-159">该模式隔离了对多个后端微服务进行调用的操作，将其逻辑集中到专用微服务中。</span><span class="sxs-lookup"><span data-stu-id="1aa32-159">The pattern isolates an operation that makes calls to multiple back-end microservices, centralizing its logic into a specialized microservice.</span></span>  <span data-ttu-id="1aa32-160">上图中的紫色签出聚合器微服务协调签出操作的工作流。</span><span class="sxs-lookup"><span data-stu-id="1aa32-160">The purple checkout aggregator microservice in the previous figure orchestrates the workflow for the Checkout operation.</span></span> <span data-ttu-id="1aa32-161">它包括按顺序顺序对多个后端微服务的调用。</span><span class="sxs-lookup"><span data-stu-id="1aa32-161">It includes calls to several back-end microservices in a sequenced order.</span></span> <span data-ttu-id="1aa32-162">来自工作流的数据将聚合并返回到调用方。</span><span class="sxs-lookup"><span data-stu-id="1aa32-162">Data from the workflow is aggregated and returned to the caller.</span></span> <span data-ttu-id="1aa32-163">虽然它仍然实现直接 HTTP 调用，但聚合器微服务减少了后端微服务之间的直接依赖关系。</span><span class="sxs-lookup"><span data-stu-id="1aa32-163">While it still implements direct HTTP calls, the aggregator microservice reduces direct dependencies among back-end microservices.</span></span>

### <a name="requestreply-pattern"></a><span data-ttu-id="1aa32-164">请求/回复模式</span><span class="sxs-lookup"><span data-stu-id="1aa32-164">Request/Reply Pattern</span></span>

<span data-ttu-id="1aa32-165">分离同步 HTTP 消息的另一种方法是[请求回复模式](https://www.enterpriseintegrationpatterns.com/patterns/messaging/RequestReply.html)，它使用队列通信。</span><span class="sxs-lookup"><span data-stu-id="1aa32-165">Another approach for decoupling synchronous HTTP messages is a [Request-Reply Pattern](https://www.enterpriseintegrationpatterns.com/patterns/messaging/RequestReply.html), which uses queuing communication.</span></span> <span data-ttu-id="1aa32-166">使用队列的通信始终是单向通道，生产者发送消息并接收使用者。</span><span class="sxs-lookup"><span data-stu-id="1aa32-166">Communication using a queue is always a one-way channel, with a producer sending the message and consumer receiving it.</span></span> <span data-ttu-id="1aa32-167">使用此模式，将实现请求队列和响应队列，如图 4-11 所示。</span><span class="sxs-lookup"><span data-stu-id="1aa32-167">With this pattern, both a request queue and response queue are implemented, shown in Figure 4-11.</span></span>

![请求-回复模式](./media/request-reply-pattern.png)

<span data-ttu-id="1aa32-169">**图 4-11**。</span><span class="sxs-lookup"><span data-stu-id="1aa32-169">**Figure 4-11**.</span></span> <span data-ttu-id="1aa32-170">请求-回复模式</span><span class="sxs-lookup"><span data-stu-id="1aa32-170">Request-reply pattern</span></span>

<span data-ttu-id="1aa32-171">在这里，消息生成器创建一个基于查询的消息，其中包含唯一的相关性 ID 并将其放入请求队列中。</span><span class="sxs-lookup"><span data-stu-id="1aa32-171">Here, the message producer creates a query-based message that contains a unique correlation ID and places it into a request queue.</span></span> <span data-ttu-id="1aa32-172">使用服务取消消息排队，处理消息，并将响应放在具有相同关联 ID 的响应队列中。</span><span class="sxs-lookup"><span data-stu-id="1aa32-172">The consuming service dequeues the messages, processes it and places the response into the response queue with the same correlation ID.</span></span> <span data-ttu-id="1aa32-173">生产者服务取消消息的排队，将其与相关 ID 匹配并继续处理。</span><span class="sxs-lookup"><span data-stu-id="1aa32-173">The producer service dequeues the message, matches it with the correlation ID and continues processing.</span></span> <span data-ttu-id="1aa32-174">我们将在下一节中详细介绍队列。</span><span class="sxs-lookup"><span data-stu-id="1aa32-174">We cover queues in detail in the next section.</span></span>

## <a name="commands"></a><span data-ttu-id="1aa32-175">命令</span><span class="sxs-lookup"><span data-stu-id="1aa32-175">Commands</span></span>

<span data-ttu-id="1aa32-176">另一种类型的通信交互是*命令*。</span><span class="sxs-lookup"><span data-stu-id="1aa32-176">Another type of communication interaction is a *command*.</span></span> <span data-ttu-id="1aa32-177">微服务可能需要另一个微服务来执行操作。</span><span class="sxs-lookup"><span data-stu-id="1aa32-177">A microservice may need another microservice to perform an action.</span></span> <span data-ttu-id="1aa32-178">订购微服务可能需要运输微服务为已批准的订单创建货件。</span><span class="sxs-lookup"><span data-stu-id="1aa32-178">The Ordering microservice may need the Shipping microservice to create a shipment for an approved order.</span></span> <span data-ttu-id="1aa32-179">在图 4-12 中，一个称为"生产者"的微服务向另一个微服务"使用者"发送消息，命令它执行某些操作。</span><span class="sxs-lookup"><span data-stu-id="1aa32-179">In Figure 4-12, one microservice, called a Producer, sends a message to another microservice, the Consumer, commanding it to do something.</span></span>

![命令与队列的交互](./media/command-interaction-with-queue.png)

<span data-ttu-id="1aa32-181">图 4-12\*\*\*\*。</span><span class="sxs-lookup"><span data-stu-id="1aa32-181">**Figure 4-12**.</span></span> <span data-ttu-id="1aa32-182">命令与队列的交互</span><span class="sxs-lookup"><span data-stu-id="1aa32-182">Command interaction with a queue</span></span>

<span data-ttu-id="1aa32-183">通常，生产者不需要响应，可能会*触发和忘记*消息。</span><span class="sxs-lookup"><span data-stu-id="1aa32-183">Most often, the Producer doesn't require a response and can *fire-and-forget* the message.</span></span> <span data-ttu-id="1aa32-184">如果需要回复，使用者将发送单独的消息回另一个通道上的生产者。</span><span class="sxs-lookup"><span data-stu-id="1aa32-184">If a reply is needed, the Consumer sends a separate message back to Producer on another channel.</span></span> <span data-ttu-id="1aa32-185">命令消息最好使用消息队列异步发送。</span><span class="sxs-lookup"><span data-stu-id="1aa32-185">A command message is best sent asynchronously with a message queue.</span></span> <span data-ttu-id="1aa32-186">由轻量级消息代理支持。</span><span class="sxs-lookup"><span data-stu-id="1aa32-186">supported by a lightweight message broker.</span></span> <span data-ttu-id="1aa32-187">在上图中，请注意队列如何分离和分离两个服务。</span><span class="sxs-lookup"><span data-stu-id="1aa32-187">In the previous diagram, note how a queue separates and decouples both services.</span></span>

<span data-ttu-id="1aa32-188">消息队列是一种中间构造，生产者和使用者通过它传递消息。</span><span class="sxs-lookup"><span data-stu-id="1aa32-188">A message queue is an intermediary construct through which a producer and consumer pass a message.</span></span> <span data-ttu-id="1aa32-189">队列实现异步点对点消息传递模式。</span><span class="sxs-lookup"><span data-stu-id="1aa32-189">Queues implement an asynchronous, point-to-point messaging pattern.</span></span> <span data-ttu-id="1aa32-190">生产者知道需要发送命令的位置并相应地路由。</span><span class="sxs-lookup"><span data-stu-id="1aa32-190">The Producer knows where a command needs to be sent and routes appropriately.</span></span> <span data-ttu-id="1aa32-191">队列保证消息由从通道读取的使用者实例之一处理。</span><span class="sxs-lookup"><span data-stu-id="1aa32-191">The queue guarantees that a message is processed by exactly one of the consumer instances that are reading from the channel.</span></span> <span data-ttu-id="1aa32-192">在这种情况下，生产者或使用者服务可以横向扩展，而不会影响其他服务。</span><span class="sxs-lookup"><span data-stu-id="1aa32-192">In this scenario, either the producer or consumer service can scale out without affecting the other.</span></span> <span data-ttu-id="1aa32-193">同样，技术在两侧可能各不相同，这意味着我们可能有一个 Java 微服务，称为[Golang](https://golang.org)微服务。</span><span class="sxs-lookup"><span data-stu-id="1aa32-193">As well, technologies can be disparate on each side, meaning that we might have a Java microservice calling a [Golang](https://golang.org) microservice.</span></span>

<span data-ttu-id="1aa32-194">在第 1 章中，我们讨论了*支持服务*。</span><span class="sxs-lookup"><span data-stu-id="1aa32-194">In chapter 1, we talked about *backing services*.</span></span> <span data-ttu-id="1aa32-195">支持服务是云原生系统所依赖的辅助资源。</span><span class="sxs-lookup"><span data-stu-id="1aa32-195">Backing services are ancillary resources upon which cloud-native systems depend.</span></span> <span data-ttu-id="1aa32-196">消息队列是支持服务。</span><span class="sxs-lookup"><span data-stu-id="1aa32-196">Message queues are backing services.</span></span> <span data-ttu-id="1aa32-197">Azure 云支持两种类型的消息队列，云原生系统可用于实现命令消息传递：Azure 存储队列和 Azure 服务总线队列。</span><span class="sxs-lookup"><span data-stu-id="1aa32-197">The Azure cloud supports two types of message queues that your cloud-native systems can consume to implement command messaging: Azure Storage Queues and Azure Service Bus Queues.</span></span>

### <a name="azure-storage-queues"></a><span data-ttu-id="1aa32-198">Azure 存储队列</span><span class="sxs-lookup"><span data-stu-id="1aa32-198">Azure Storage Queues</span></span>

<span data-ttu-id="1aa32-199">Azure 存储队列提供快速、经济实惠并由 Azure 存储帐户提供支持的简单队列基础结构。</span><span class="sxs-lookup"><span data-stu-id="1aa32-199">Azure storage queues offer a simple queueing infrastructure that is fast, affordable, and backed by Azure storage accounts.</span></span>

<span data-ttu-id="1aa32-200">[Azure 存储队列](https://docs.microsoft.com/azure/storage/queues/storage-queues-introduction)具有基于 REST 的排队机制，具有可靠且持久的消息传递。</span><span class="sxs-lookup"><span data-stu-id="1aa32-200">[Azure Storage Queues](https://docs.microsoft.com/azure/storage/queues/storage-queues-introduction) feature a REST-based queuing mechanism with reliable and persistent messaging.</span></span> <span data-ttu-id="1aa32-201">它们提供最少的功能集，但价格低廉，并存储数百万条消息。</span><span class="sxs-lookup"><span data-stu-id="1aa32-201">They provide a minimal feature set, but are inexpensive and store millions of messages.</span></span> <span data-ttu-id="1aa32-202">其容量范围可达 500 TB。</span><span class="sxs-lookup"><span data-stu-id="1aa32-202">Their capacity ranges up to 500 TB.</span></span> <span data-ttu-id="1aa32-203">一条消息的大小可达 64 KB。</span><span class="sxs-lookup"><span data-stu-id="1aa32-203">A single message can be up to 64 KB in size.</span></span>

<span data-ttu-id="1aa32-204">您可以使用 HTTP 或 HTTPS 通过经过身份验证的呼叫从世界任何地方访问消息。</span><span class="sxs-lookup"><span data-stu-id="1aa32-204">You can access messages from anywhere in the world via authenticated calls using HTTP or HTTPS.</span></span> <span data-ttu-id="1aa32-205">存储队列可以扩展到大量并发客户端，以处理流量峰值。</span><span class="sxs-lookup"><span data-stu-id="1aa32-205">Storage queues can scale out to large numbers of concurrent clients to handle traffic spikes.</span></span>

<span data-ttu-id="1aa32-206">也就是说，服务存在限制：</span><span class="sxs-lookup"><span data-stu-id="1aa32-206">That said, there are limitations with the service:</span></span>

- <span data-ttu-id="1aa32-207">消息顺序不保证。</span><span class="sxs-lookup"><span data-stu-id="1aa32-207">Message order isn't guaranteed.</span></span>

- <span data-ttu-id="1aa32-208">消息只能保留七天，然后才能自动删除。</span><span class="sxs-lookup"><span data-stu-id="1aa32-208">A message can only persist for seven days before it's automatically removed.</span></span>

- <span data-ttu-id="1aa32-209">不支持状态管理、重复检测或事务不可用。</span><span class="sxs-lookup"><span data-stu-id="1aa32-209">Support for state management, duplicate detection, or transactions isn't available.</span></span>

<span data-ttu-id="1aa32-210">图 4-13 显示了 Azure 存储队列的层次结构。</span><span class="sxs-lookup"><span data-stu-id="1aa32-210">Figure 4-13 shows the hierarchy of an Azure Storage Queue.</span></span>

![存储队列层次结构](./media/storage-queue-hierarchy.png)

<span data-ttu-id="1aa32-212">**图4-13**。</span><span class="sxs-lookup"><span data-stu-id="1aa32-212">**Figure 4-13**.</span></span> <span data-ttu-id="1aa32-213">存储队列层次结构</span><span class="sxs-lookup"><span data-stu-id="1aa32-213">Storage queue hierarchy</span></span>

<span data-ttu-id="1aa32-214">在上图中，请注意存储队列如何将其消息存储在基础 Azure 存储帐户中。</span><span class="sxs-lookup"><span data-stu-id="1aa32-214">In the previous figure, note how storage queues store their messages in the underlying Azure Storage account.</span></span>

<span data-ttu-id="1aa32-215">对于开发人员，Microsoft 提供了多个客户端和服务器端库，用于存储队列处理。</span><span class="sxs-lookup"><span data-stu-id="1aa32-215">For developers, Microsoft provides several client and server-side libraries for Storage queue processing.</span></span> <span data-ttu-id="1aa32-216">大多数主要平台都受支持，包括 .NET、Java、JavaScript、Ruby、Python 和 Go。</span><span class="sxs-lookup"><span data-stu-id="1aa32-216">Most major platforms are supported including .NET, Java, JavaScript, Ruby, Python, and Go.</span></span> <span data-ttu-id="1aa32-217">开发人员绝不应直接与这些库通信。</span><span class="sxs-lookup"><span data-stu-id="1aa32-217">Developers should never communicate directly with these libraries.</span></span> <span data-ttu-id="1aa32-218">这样做会将微服务代码与 Azure 存储队列服务紧密耦合。</span><span class="sxs-lookup"><span data-stu-id="1aa32-218">Doing so will tightly couple your microservice code to the Azure Storage Queue service.</span></span> <span data-ttu-id="1aa32-219">最好隔离 API 的实现详细信息。</span><span class="sxs-lookup"><span data-stu-id="1aa32-219">It's a better practice to insulate the implementation details of the API.</span></span> <span data-ttu-id="1aa32-220">引入中介层或中间 API，该层公开泛型操作并封装具体库。</span><span class="sxs-lookup"><span data-stu-id="1aa32-220">Introduce an intermediation layer, or intermediate API, that exposes generic operations and encapsulates the concrete library.</span></span> <span data-ttu-id="1aa32-221">这种松散的耦合使您能够将一个队列服务交换到另一个队列服务，而无需更改主线服务代码。</span><span class="sxs-lookup"><span data-stu-id="1aa32-221">This loose coupling enables you to swap out one queuing service for another without having to make changes to the mainline service code.</span></span>

<span data-ttu-id="1aa32-222">Azure 存储队列是在云本机应用程序中实现命令消息传递的经济选择。</span><span class="sxs-lookup"><span data-stu-id="1aa32-222">Azure Storage queues are an economical option to implement command messaging in your cloud-native applications.</span></span> <span data-ttu-id="1aa32-223">特别是当队列大小超过 80 GB 时，或者一个简单的功能集是可以接受的。</span><span class="sxs-lookup"><span data-stu-id="1aa32-223">Especially when a queue size will exceed 80 GB, or a simple feature set is acceptable.</span></span> <span data-ttu-id="1aa32-224">您只为邮件的存储付费;没有固定的小时费用。</span><span class="sxs-lookup"><span data-stu-id="1aa32-224">You only pay for the storage of the messages; there are no fixed hourly charges.</span></span>

### <a name="azure-service-bus-queues"></a><span data-ttu-id="1aa32-225">Azure 服务总线队列</span><span class="sxs-lookup"><span data-stu-id="1aa32-225">Azure Service Bus Queues</span></span>

<span data-ttu-id="1aa32-226">对于更复杂的消息传递要求，请考虑 Azure 服务总线队列。</span><span class="sxs-lookup"><span data-stu-id="1aa32-226">For more complex messaging requirements, consider Azure Service Bus queues.</span></span>

<span data-ttu-id="1aa32-227">[Azure 服务总线](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messaging-overview)位于强大的消息基础结构之上，支持*中转消息传递模型*。</span><span class="sxs-lookup"><span data-stu-id="1aa32-227">Sitting atop a robust message infrastructure, [Azure Service Bus](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messaging-overview) supports a *brokered messaging model*.</span></span> <span data-ttu-id="1aa32-228">消息可靠地存储在代理（队列）中，直到使用者收到消息。</span><span class="sxs-lookup"><span data-stu-id="1aa32-228">Messages are reliably stored in a broker (the queue) until received by the consumer.</span></span> <span data-ttu-id="1aa32-229">队列保证先到/先出 （FIFO） 消息传递，遵守消息添加到队列的顺序。</span><span class="sxs-lookup"><span data-stu-id="1aa32-229">The queue guarantees First-In/First-Out (FIFO) message delivery, respecting the order in which messages were added to the queue.</span></span>

<span data-ttu-id="1aa32-230">消息的大小可以大得多，高达 256 KB。</span><span class="sxs-lookup"><span data-stu-id="1aa32-230">The size of a message can be much larger, up to 256 KB.</span></span> <span data-ttu-id="1aa32-231">消息在队列中保留无限时间。</span><span class="sxs-lookup"><span data-stu-id="1aa32-231">Messages are persisted in the queue for an unlimited period of time.</span></span> <span data-ttu-id="1aa32-232">服务总线不仅支持基于 HTTP 的调用，而且还提供对[AMPQ 协议的](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-amqp-overview)完全支持。</span><span class="sxs-lookup"><span data-stu-id="1aa32-232">Service Bus supports not only HTTP-based calls, but also provides full support for the [AMPQ protocol](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-amqp-overview).</span></span> <span data-ttu-id="1aa32-233">AMPQ 是跨供应商的开放标准，支持二进制协议和更高可靠性度。</span><span class="sxs-lookup"><span data-stu-id="1aa32-233">AMPQ is an open-standard across vendors that supports a binary protocol and higher degrees of reliability.</span></span>

<span data-ttu-id="1aa32-234">服务总线提供了一组丰富的功能，包括[事务支持](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions)和[重复检测功能](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection)。</span><span class="sxs-lookup"><span data-stu-id="1aa32-234">Service Bus provides a rich set of features, including [transaction support](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions) and a [duplicate detection feature](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection).</span></span> <span data-ttu-id="1aa32-235">队列保证每条消息"最多传递一次"。</span><span class="sxs-lookup"><span data-stu-id="1aa32-235">The queue guarantees "at most once delivery" per message.</span></span> <span data-ttu-id="1aa32-236">它会自动丢弃已发送的消息。</span><span class="sxs-lookup"><span data-stu-id="1aa32-236">It automatically discards a message that has already been sent.</span></span> <span data-ttu-id="1aa32-237">如果生产者有疑问，它可以重新发送相同的消息，并且服务总线保证只处理一个副本。</span><span class="sxs-lookup"><span data-stu-id="1aa32-237">If a producer is in doubt, it can resend the same message, and Service Bus guarantees that only one copy will be processed.</span></span> <span data-ttu-id="1aa32-238">重复检测使您不必构建其他基础结构管道。</span><span class="sxs-lookup"><span data-stu-id="1aa32-238">Duplicate detection frees you from  having to build additional infrastructure plumbing.</span></span>

<span data-ttu-id="1aa32-239">另外两个企业功能是分区和会话。</span><span class="sxs-lookup"><span data-stu-id="1aa32-239">Two more enterprise features are partitioning and sessions.</span></span> <span data-ttu-id="1aa32-240">传统的服务总线队列由单个消息代理处理并存储在单个消息存储中。</span><span class="sxs-lookup"><span data-stu-id="1aa32-240">A conventional Service Bus queue is handled by a single message broker and stored in a single message store.</span></span> <span data-ttu-id="1aa32-241">但是，[服务总线分区](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning)将队列分散到多个消息代理和消息存储中。</span><span class="sxs-lookup"><span data-stu-id="1aa32-241">But, [Service Bus Partitioning](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning) spreads the queue across multiple message brokers and message stores.</span></span> <span data-ttu-id="1aa32-242">总体吞吐量不再受单个消息代理或消息存储的性能的限制。</span><span class="sxs-lookup"><span data-stu-id="1aa32-242">The overall throughput is no longer limited by the performance of a single message broker or messaging store.</span></span> <span data-ttu-id="1aa32-243">消息存储的临时中断不会使分区队列不可用。</span><span class="sxs-lookup"><span data-stu-id="1aa32-243">A temporary outage of a messaging store doesn't render a partitioned queue unavailable.</span></span>

<span data-ttu-id="1aa32-244">[服务总线会话](https://codingcanvas.com/azure-service-bus-sessions/)提供了一种组相关消息的方法。</span><span class="sxs-lookup"><span data-stu-id="1aa32-244">[Service Bus Sessions](https://codingcanvas.com/azure-service-bus-sessions/) provide a way to group-related messages.</span></span> <span data-ttu-id="1aa32-245">想象一下工作流方案，其中消息必须一起处理，操作在结束时完成。</span><span class="sxs-lookup"><span data-stu-id="1aa32-245">Imagine a workflow scenario where messages must be processed together and the operation completed at the end.</span></span> <span data-ttu-id="1aa32-246">要利用此优势，必须为队列显式启用会话，并且每个相关消息必须包含相同的会话 ID。</span><span class="sxs-lookup"><span data-stu-id="1aa32-246">To take advantage, sessions must be explicitly enabled for the queue and each related messaged must contain the same session ID.</span></span>

<span data-ttu-id="1aa32-247">但是，有一些重要的警告：服务总线队列大小限制为 80 GB，这比商店队列中可用的小得多。</span><span class="sxs-lookup"><span data-stu-id="1aa32-247">However, there are some important caveats: Service Bus queues size is limited to 80 GB, which is much smaller than what's available from store queues.</span></span> <span data-ttu-id="1aa32-248">此外，服务总线队列会产生基本成本和每次操作的费用。</span><span class="sxs-lookup"><span data-stu-id="1aa32-248">Additionally, Service Bus queues incur a base cost and charge per operation.</span></span>

<span data-ttu-id="1aa32-249">图 4-14 概述了服务总线队列的高级体系结构。</span><span class="sxs-lookup"><span data-stu-id="1aa32-249">Figure 4-14 outlines the high-level architecture of a Service Bus queue.</span></span>

![服务总线队列](./media/service-bus-queue.png)

<span data-ttu-id="1aa32-251">图 4-14\*\*\*\*。</span><span class="sxs-lookup"><span data-stu-id="1aa32-251">**Figure 4-14**.</span></span> <span data-ttu-id="1aa32-252">服务总线队列</span><span class="sxs-lookup"><span data-stu-id="1aa32-252">Service Bus queue</span></span>

<span data-ttu-id="1aa32-253">在上图中，请注意点对点关系。</span><span class="sxs-lookup"><span data-stu-id="1aa32-253">In the previous figure, note the point-to-point relationship.</span></span> <span data-ttu-id="1aa32-254">同一提供程序的两个实例正在将消息排入单个服务总线队列中。</span><span class="sxs-lookup"><span data-stu-id="1aa32-254">Two instances of the same provider are enqueuing messages into a single Service Bus queue.</span></span> <span data-ttu-id="1aa32-255">每条消息仅由右侧三个使用者实例中的一个使用。</span><span class="sxs-lookup"><span data-stu-id="1aa32-255">Each message is consumed by only one of three consumer instances on the right.</span></span> <span data-ttu-id="1aa32-256">接下来，我们将讨论如何在不同消费者都对同一消息感兴趣的地方实现消息传递。</span><span class="sxs-lookup"><span data-stu-id="1aa32-256">Next, we discuss how to implement messaging where different consumers may all be interested the same message.</span></span>

## <a name="events"></a><span data-ttu-id="1aa32-257">事件</span><span class="sxs-lookup"><span data-stu-id="1aa32-257">Events</span></span>

<span data-ttu-id="1aa32-258">消息队列是实现通信的有效方法，其中生产者可以异步向使用者发送消息。</span><span class="sxs-lookup"><span data-stu-id="1aa32-258">Message queuing is an effective way to implement communication where a producer can asynchronously send a consumer a message.</span></span> <span data-ttu-id="1aa32-259">但是，当*许多不同的消费者对*同一消息感兴趣时，会发生什么情况？</span><span class="sxs-lookup"><span data-stu-id="1aa32-259">However, what happens when *many different consumers* are interested in the same message?</span></span> <span data-ttu-id="1aa32-260">每个使用者的专用消息队列不会很好地扩展，并且将变得难以管理。</span><span class="sxs-lookup"><span data-stu-id="1aa32-260">A dedicated message queue for each consumer wouldn't scale well and would become difficult to manage.</span></span>

<span data-ttu-id="1aa32-261">为了解决这个问题，我们转到第三种类型的消息交互，*事件*。</span><span class="sxs-lookup"><span data-stu-id="1aa32-261">To address this scenario, we move to the third type of message interaction, the *event*.</span></span> <span data-ttu-id="1aa32-262">一个微服务宣布已发生操作。</span><span class="sxs-lookup"><span data-stu-id="1aa32-262">One microservice announces that an action had occurred.</span></span> <span data-ttu-id="1aa32-263">其他微服务（如果有兴趣）对操作或事件做出反应。</span><span class="sxs-lookup"><span data-stu-id="1aa32-263">Other microservices, if interested, react to the action, or event.</span></span>

<span data-ttu-id="1aa32-264">事件是一个两步过程。</span><span class="sxs-lookup"><span data-stu-id="1aa32-264">Eventing is a two-step process.</span></span> <span data-ttu-id="1aa32-265">对于给定的状态更改，微服务将事件发布到消息代理，使其可用于任何其他感兴趣的微服务。</span><span class="sxs-lookup"><span data-stu-id="1aa32-265">For a given state change, a microservice publishes an event to a message broker, making it available to any other interested microservice.</span></span> <span data-ttu-id="1aa32-266">通过订阅消息代理中的事件来通知感兴趣的微服务。</span><span class="sxs-lookup"><span data-stu-id="1aa32-266">The interested microservice is notified by subscribing to the event in the message broker.</span></span> <span data-ttu-id="1aa32-267">您可以使用[发布/订阅](https://docs.microsoft.com/azure/architecture/patterns/publisher-subscriber)模式来实现[基于事件的通信](https://docs.microsoft.com/dotnet/standard/microservices-architecture/multi-container-microservice-net-applications/integration-event-based-microservice-communications)。</span><span class="sxs-lookup"><span data-stu-id="1aa32-267">You use the [Publish/Subscribe](https://docs.microsoft.com/azure/architecture/patterns/publisher-subscriber) pattern to implement [event-based communication](https://docs.microsoft.com/dotnet/standard/microservices-architecture/multi-container-microservice-net-applications/integration-event-based-microservice-communications).</span></span>

<span data-ttu-id="1aa32-268">图 4-15 显示了购物篮微服务发布事件，其中另外两个微服务订阅了它。</span><span class="sxs-lookup"><span data-stu-id="1aa32-268">Figure 4-15 shows a shopping basket microservice publishing an event with two other microservices subscribing to it.</span></span>

![事件驱动消息](./media/event-driven-messaging.png)

<span data-ttu-id="1aa32-270">**图 4-15**。</span><span class="sxs-lookup"><span data-stu-id="1aa32-270">**Figure 4-15**.</span></span> <span data-ttu-id="1aa32-271">事件驱动消息</span><span class="sxs-lookup"><span data-stu-id="1aa32-271">Event-Driven messaging</span></span>

<span data-ttu-id="1aa32-272">请注意位于通信通道中间*的事件总线*组件。</span><span class="sxs-lookup"><span data-stu-id="1aa32-272">Note the *event bus* component that sits in the middle of the communication channel.</span></span> <span data-ttu-id="1aa32-273">它是一个自定义类，它封装消息代理并将其与基础应用程序分离。</span><span class="sxs-lookup"><span data-stu-id="1aa32-273">It's a custom class that encapsulates the message broker and decouples it from the underlying application.</span></span> <span data-ttu-id="1aa32-274">订购和库存微服务在彼此不知情的情况下独立操作事件，也无需购物篮微服务。</span><span class="sxs-lookup"><span data-stu-id="1aa32-274">The ordering and inventory microservices independently operate the event with no knowledge of each other, nor the shopping basket microservice.</span></span> <span data-ttu-id="1aa32-275">当注册事件发布到事件总线时，它们会对它执行操作。</span><span class="sxs-lookup"><span data-stu-id="1aa32-275">When the registered event is published to the event bus, they act upon it.</span></span>

<span data-ttu-id="1aa32-276">通过事件，我们从排队技术转向*主题*。</span><span class="sxs-lookup"><span data-stu-id="1aa32-276">With eventing, we move from queuing technology to *topics*.</span></span> <span data-ttu-id="1aa32-277">[主题](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions)类似于队列，但支持一对多消息传递模式。</span><span class="sxs-lookup"><span data-stu-id="1aa32-277">A [topic](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions) is similar to a queue, but supports a one-to-many messaging pattern.</span></span> <span data-ttu-id="1aa32-278">一个微服务发布消息。</span><span class="sxs-lookup"><span data-stu-id="1aa32-278">One microservice publishes a message.</span></span> <span data-ttu-id="1aa32-279">多个订阅微服务可以选择接收该消息并采取行动。</span><span class="sxs-lookup"><span data-stu-id="1aa32-279">Multiple subscribing microservices can choose to receive and act upon that message.</span></span> <span data-ttu-id="1aa32-280">图 4-16 显示了主题体系结构。</span><span class="sxs-lookup"><span data-stu-id="1aa32-280">Figure 4-16 shows a topic architecture.</span></span>

![主题体系结构](./media/topic-architecture.png)

<span data-ttu-id="1aa32-282">**图 4-16**。</span><span class="sxs-lookup"><span data-stu-id="1aa32-282">**Figure 4-16**.</span></span> <span data-ttu-id="1aa32-283">主题体系结构</span><span class="sxs-lookup"><span data-stu-id="1aa32-283">Topic architecture</span></span>

<span data-ttu-id="1aa32-284">在上图中，发布者向主题发送消息。</span><span class="sxs-lookup"><span data-stu-id="1aa32-284">In the previous figure, publishers send messages to the topic.</span></span> <span data-ttu-id="1aa32-285">最后，订阅者会从订阅接收消息。</span><span class="sxs-lookup"><span data-stu-id="1aa32-285">At the end, subscribers receive messages from subscriptions.</span></span> <span data-ttu-id="1aa32-286">在中间，主题根据一组*规则*将消息转发到订阅，这些规则显示在深蓝色框中。</span><span class="sxs-lookup"><span data-stu-id="1aa32-286">In the middle, the topic forwards messages to subscriptions based on a set of *rules*, shown in dark blue boxes.</span></span> <span data-ttu-id="1aa32-287">规则充当将特定消息转发到订阅的筛选器。</span><span class="sxs-lookup"><span data-stu-id="1aa32-287">Rules act as a filter that forward specific messages to a subscription.</span></span> <span data-ttu-id="1aa32-288">此处，将"创建订单"事件发送到订阅\#1 和订阅\#3，但不会发送到订阅\#2。</span><span class="sxs-lookup"><span data-stu-id="1aa32-288">Here, a "CreateOrder" event would be sent to Subscription \#1 and Subscription \#3, but not to Subscription \#2.</span></span> <span data-ttu-id="1aa32-289">"订单完成"事件将发送到订阅\#2 和订阅\#3。</span><span class="sxs-lookup"><span data-stu-id="1aa32-289">An "OrderCompleted" event would be sent to Subscription \#2 and Subscription \#3.</span></span>

<span data-ttu-id="1aa32-290">Azure 云支持两种不同的主题服务：Azure 服务总线主题和 Azure 事件网格。</span><span class="sxs-lookup"><span data-stu-id="1aa32-290">The Azure cloud supports two different topic services: Azure Service Bus Topics and Azure EventGrid.</span></span>

### <a name="azure-service-bus-topics"></a><span data-ttu-id="1aa32-291">Azure 服务总线主题</span><span class="sxs-lookup"><span data-stu-id="1aa32-291">Azure Service Bus Topics</span></span>

<span data-ttu-id="1aa32-292">坐在 Azure 服务总线队列的相同强大代理消息模型的顶部是 Azure[服务总线主题](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions)。</span><span class="sxs-lookup"><span data-stu-id="1aa32-292">Sitting on top of the same robust brokered message model of Azure Service Bus queues are [Azure Service Bus Topics](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span></span> <span data-ttu-id="1aa32-293">主题可以接收来自多个独立发布者的消息，并向多达 2，000 个订阅者发送消息。</span><span class="sxs-lookup"><span data-stu-id="1aa32-293">A topic can receive messages from multiple independent publishers and send messages to up to 2,000 subscribers.</span></span> <span data-ttu-id="1aa32-294">订阅可以在运行时动态添加或删除，而无需停止系统或重新创建主题。</span><span class="sxs-lookup"><span data-stu-id="1aa32-294">Subscriptions can be dynamically added or removed at runtime without stopping the system or recreating the topic.</span></span>

<span data-ttu-id="1aa32-295">Azure 服务总线队列中的许多高级功能也可用于主题，包括[重复检测](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection)和[事务支持](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions)。</span><span class="sxs-lookup"><span data-stu-id="1aa32-295">Many advanced features from Azure Service Bus queues are also available for topics, including [Duplicate Detection](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection) and [Transaction support](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions).</span></span> <span data-ttu-id="1aa32-296">默认情况下，服务总线主题由单个消息代理处理并存储在单个消息存储中。</span><span class="sxs-lookup"><span data-stu-id="1aa32-296">By default, Service Bus topics are handled by a single message broker and stored in a single message store.</span></span> <span data-ttu-id="1aa32-297">但是，[服务总线分区](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning)通过将主题传播到许多消息代理和消息存储中来扩展主题。</span><span class="sxs-lookup"><span data-stu-id="1aa32-297">But, [Service Bus Partitioning](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning) scales a topic by spreading it across many message brokers and message stores.</span></span>

<span data-ttu-id="1aa32-298">[计划邮件传递](https://docs.microsoft.com/azure/service-bus-messaging/message-sequencing)标记具有特定时间处理的邮件。</span><span class="sxs-lookup"><span data-stu-id="1aa32-298">[Scheduled Message Delivery](https://docs.microsoft.com/azure/service-bus-messaging/message-sequencing) tags a message with a specific time for processing.</span></span> <span data-ttu-id="1aa32-299">在此之前，该消息不会显示在主题中。</span><span class="sxs-lookup"><span data-stu-id="1aa32-299">The message won't appear in the topic before that time.</span></span> <span data-ttu-id="1aa32-300">[消息延迟](https://docs.microsoft.com/azure/service-bus-messaging/message-deferral)使您能够将邮件的检索推迟到以后。</span><span class="sxs-lookup"><span data-stu-id="1aa32-300">[Message Deferral](https://docs.microsoft.com/azure/service-bus-messaging/message-deferral) enables you to defer a retrieval of a message to a later time.</span></span> <span data-ttu-id="1aa32-301">这两种情况通常用于工作流处理方案，其中操作按特定顺序处理。</span><span class="sxs-lookup"><span data-stu-id="1aa32-301">Both are commonly used in workflow processing scenarios where operations are processed in a particular order.</span></span> <span data-ttu-id="1aa32-302">您可以推迟处理已接收的消息，直到完成之前的工作。</span><span class="sxs-lookup"><span data-stu-id="1aa32-302">You can postpone processing of received messages until prior work has been completed.</span></span>

<span data-ttu-id="1aa32-303">服务总线主题是一种强大且经过验证的技术，可在云本机系统中启用发布/订阅通信。</span><span class="sxs-lookup"><span data-stu-id="1aa32-303">Service Bus topics are a robust and proven technology for enabling publish/subscribe communication in your cloud-native systems.</span></span>

### <a name="azure-event-grid"></a><span data-ttu-id="1aa32-304">Azure 事件网格</span><span class="sxs-lookup"><span data-stu-id="1aa32-304">Azure Event Grid</span></span>

<span data-ttu-id="1aa32-305">虽然 Azure 服务总线是经过战斗测试的消息代理，具有一整套企业功能，但[Azure 事件网格](https://docs.microsoft.com/azure/event-grid/overview)是块上的新孩子。</span><span class="sxs-lookup"><span data-stu-id="1aa32-305">While Azure Service Bus is a battle-tested messaging broker with a full set of enterprise features, [Azure Event Grid](https://docs.microsoft.com/azure/event-grid/overview) is the new kid on the block.</span></span>

<span data-ttu-id="1aa32-306">乍一看，事件网格可能只是另一个基于主题的邮件系统。</span><span class="sxs-lookup"><span data-stu-id="1aa32-306">At first glance, Event Grid may look like just another topic-based messaging system.</span></span> <span data-ttu-id="1aa32-307">然而，它在许多方面是不同的。</span><span class="sxs-lookup"><span data-stu-id="1aa32-307">However, it's different in many ways.</span></span> <span data-ttu-id="1aa32-308">它专注于事件驱动的工作负载，支持实时事件处理、深度 Azure 集成和开放平台 - 所有这些都位于无服务器基础架构上。</span><span class="sxs-lookup"><span data-stu-id="1aa32-308">Focused on event-driven workloads, it enables real-time event processing, deep Azure integration, and an open-platform - all on serverless infrastructure.</span></span> <span data-ttu-id="1aa32-309">它专为现代云原生和无服务器应用程序而设计</span><span class="sxs-lookup"><span data-stu-id="1aa32-309">It's designed for contemporary cloud-native and serverless applications</span></span>

<span data-ttu-id="1aa32-310">作为集中*式事件背板*或管道，事件网格对 Azure 资源内的事件和您自己的服务做出反应。</span><span class="sxs-lookup"><span data-stu-id="1aa32-310">As a centralized *eventing backplane*, or pipe, Event Grid reacts to events inside Azure resources and from your own services.</span></span>

<span data-ttu-id="1aa32-311">事件通知发布到事件网格主题，而事件网格主题又将每个事件路由到订阅。</span><span class="sxs-lookup"><span data-stu-id="1aa32-311">Event notifications are published to an Event Grid Topic, which, in turn, routes each event to a subscription.</span></span> <span data-ttu-id="1aa32-312">订阅服务器映射到订阅并使用事件。</span><span class="sxs-lookup"><span data-stu-id="1aa32-312">Subscribers map to subscriptions and consume the events.</span></span> <span data-ttu-id="1aa32-313">与服务总线一样，事件网格支持*筛选的订阅者模型*，其中订阅集其希望接收的事件的规则。</span><span class="sxs-lookup"><span data-stu-id="1aa32-313">Like Service Bus, Event Grid supports a *filtered subscriber model* where a subscription sets rule for the events it wishes to receive.</span></span> <span data-ttu-id="1aa32-314">事件网格提供快速吞吐量，保证每秒 1000 万个事件，实现近乎实时的传递 -远远超过 Azure 服务总线所能生成的。</span><span class="sxs-lookup"><span data-stu-id="1aa32-314">Event Grid provides fast throughput with a guarantee of 10 million events per second enabling near real-time delivery - far more than what Azure Service Bus can generate.</span></span>

<span data-ttu-id="1aa32-315">事件网格的一个最佳亮点是它深入集成到 Azure 基础结构的结构中。</span><span class="sxs-lookup"><span data-stu-id="1aa32-315">A sweet spot for Event Grid is its deep integration into the fabric of Azure infrastructure.</span></span> <span data-ttu-id="1aa32-316">Azure 资源（如 Cosmos DB）可以直接将内置事件发布到其他感兴趣的 Azure 资源，而无需自定义代码。</span><span class="sxs-lookup"><span data-stu-id="1aa32-316">An Azure resource, such as Cosmos DB, can publish built-in events directly to other interested Azure resources - without the need for custom code.</span></span> <span data-ttu-id="1aa32-317">事件网格可以从 Azure 订阅、资源组或服务发布事件，使开发人员能够细粒度地控制云资源的生命周期。</span><span class="sxs-lookup"><span data-stu-id="1aa32-317">Event Grid can publish events from an Azure Subscription, Resource Group, or Service, giving developers fine-grained control over the lifecycle of cloud resources.</span></span> <span data-ttu-id="1aa32-318">但是，事件网格并不仅限于 Azure。</span><span class="sxs-lookup"><span data-stu-id="1aa32-318">However, Event Grid isn't limited to Azure.</span></span> <span data-ttu-id="1aa32-319">它是一个开放的平台，可以使用从应用程序或第三方服务发布的自定义 HTTP 事件，并将事件路由到外部订阅者。</span><span class="sxs-lookup"><span data-stu-id="1aa32-319">It's an open platform that can consume custom HTTP events published from applications or third-party services and route events to external subscribers.</span></span>

<span data-ttu-id="1aa32-320">从 Azure 资源发布和订阅本机事件时，不需要编码。</span><span class="sxs-lookup"><span data-stu-id="1aa32-320">When publishing and subscribing to native events from Azure resources, no coding is required.</span></span> <span data-ttu-id="1aa32-321">通过简单的配置，您可以利用主题和订阅的内置管道将事件从一个 Azure 资源集成到另一个 Azure 资源。</span><span class="sxs-lookup"><span data-stu-id="1aa32-321">With simple configuration, you can integrate events from one Azure resource to another leveraging built-in plumbing for Topics and Subscriptions.</span></span> <span data-ttu-id="1aa32-322">图 4-17 显示了事件网格的剖析。</span><span class="sxs-lookup"><span data-stu-id="1aa32-322">Figure 4-17 shows the anatomy of Event Grid.</span></span>

![事件网格解剖](./media/event-grid-anatomy.png)

<span data-ttu-id="1aa32-324">**图 4-17**。</span><span class="sxs-lookup"><span data-stu-id="1aa32-324">**Figure 4-17**.</span></span> <span data-ttu-id="1aa32-325">事件网格解剖</span><span class="sxs-lookup"><span data-stu-id="1aa32-325">Event Grid anatomy</span></span>

<span data-ttu-id="1aa32-326">事件网格和服务总线之间的一个主要区别是基础*消息交换模式*。</span><span class="sxs-lookup"><span data-stu-id="1aa32-326">A major difference between EventGrid and Service Bus is the underlying *message exchange pattern*.</span></span>

<span data-ttu-id="1aa32-327">服务总线实现了较旧的样式*拉取模型*，其中下游订阅者主动轮询主题订阅的新消息。</span><span class="sxs-lookup"><span data-stu-id="1aa32-327">Service Bus implements an older style *pull model* in which the downstream subscriber actively polls the topic subscription for new messages.</span></span> <span data-ttu-id="1aa32-328">有利的一面是，此方法使订阅者能够完全控制其处理消息的速度。</span><span class="sxs-lookup"><span data-stu-id="1aa32-328">On the upside, this approach gives the subscriber full control of the pace at which it processes messages.</span></span> <span data-ttu-id="1aa32-329">它控制在任意给定时间处理的时间和消息数。</span><span class="sxs-lookup"><span data-stu-id="1aa32-329">It controls when and how many messages to process at any given time.</span></span> <span data-ttu-id="1aa32-330">未读邮件将保留在订阅中，直到处理。</span><span class="sxs-lookup"><span data-stu-id="1aa32-330">Unread messages remain in the subscription until processed.</span></span> <span data-ttu-id="1aa32-331">一个重大缺点是生成事件的时间与将该消息拉至订阅者进行处理的轮询操作之间的延迟。</span><span class="sxs-lookup"><span data-stu-id="1aa32-331">A significant shortcoming is the latency between the time the event is generated and the polling operation that pulls that message to the subscriber for processing.</span></span> <span data-ttu-id="1aa32-332">此外，下一个事件的恒定轮询开销会消耗资源和资金。</span><span class="sxs-lookup"><span data-stu-id="1aa32-332">Also, the overhead of constant polling for the next event consumes resources and money.</span></span>

<span data-ttu-id="1aa32-333">但是，事件网格是不同的。</span><span class="sxs-lookup"><span data-stu-id="1aa32-333">EventGrid, however, is different.</span></span> <span data-ttu-id="1aa32-334">它实现了一个*推送模型*，其中事件在接收时发送到事件处理程序，提供近乎实时的事件传递。</span><span class="sxs-lookup"><span data-stu-id="1aa32-334">It implements a *push model* in which events are sent to the EventHandlers as received, giving near real-time event delivery.</span></span> <span data-ttu-id="1aa32-335">它还降低了成本，因为服务仅在需要使用事件时触发 -而不是与轮询那样持续。</span><span class="sxs-lookup"><span data-stu-id="1aa32-335">It also reduces cost as the service is triggered only when it's needed to consume an event – not continually as with polling.</span></span> <span data-ttu-id="1aa32-336">也就是说，事件处理程序必须处理传入负载并提供限制机制，以防止自身不堪重负。</span><span class="sxs-lookup"><span data-stu-id="1aa32-336">That said, an event handler must handle the incoming load and provide throttling mechanisms to protect itself from becoming overwhelmed.</span></span> <span data-ttu-id="1aa32-337">许多使用这些事件的 Azure 服务（如 Azure 函数和逻辑应用）提供自动自动缩放功能来处理增加的负载。</span><span class="sxs-lookup"><span data-stu-id="1aa32-337">Many Azure services that consume these events, such as Azure Functions and Logic Apps provide automatic autoscaling capabilities to handle increased loads.</span></span>  

<span data-ttu-id="1aa32-338">事件网格是一个完全托管的无服务器云服务。</span><span class="sxs-lookup"><span data-stu-id="1aa32-338">Event Grid is a fully managed serverless cloud service.</span></span> <span data-ttu-id="1aa32-339">它根据您的流量动态扩展，仅针对实际使用情况收费，而不是预购买容量。</span><span class="sxs-lookup"><span data-stu-id="1aa32-339">It dynamically scales based on your traffic and charges you only for your actual usage, not pre-purchased capacity.</span></span> <span data-ttu-id="1aa32-340">每月的前 100，000 个操作是免费的 - 操作定义为事件入口（传入事件通知）、订阅传递尝试、管理调用和按主题筛选。</span><span class="sxs-lookup"><span data-stu-id="1aa32-340">The first 100,000 operations per month are free – operations being defined as event ingress (incoming event notifications), subscription delivery attempts, management calls, and filtering by subject.</span></span> <span data-ttu-id="1aa32-341">凭借 99.99% 的可用性，EventGrid 保证在 24 小时内交付事件，并内置重试功能，以不成功交付。</span><span class="sxs-lookup"><span data-stu-id="1aa32-341">With 99.99% availability, EventGrid guarantees the delivery of an event within a 24-hour period, with built-in retry functionality for unsuccessful delivery.</span></span> <span data-ttu-id="1aa32-342">未传递的消息可以移动到"死信"队列以进行解析。</span><span class="sxs-lookup"><span data-stu-id="1aa32-342">Undelivered messages can be moved to a "dead-letter" queue for resolution.</span></span>  <span data-ttu-id="1aa32-343">与 Azure 服务总线不同，事件网格经过优化以获得快速性能，不支持有序消息传递、事务和会话等功能。</span><span class="sxs-lookup"><span data-stu-id="1aa32-343">Unlike Azure Service Bus, Event Grid is tuned for fast performance and doesn't support features like ordered messaging, transactions, and sessions.</span></span>

### <a name="streaming-messages-in-the-azure-cloud"></a><span data-ttu-id="1aa32-344">在 Azure 云中流式传输消息</span><span class="sxs-lookup"><span data-stu-id="1aa32-344">Streaming messages in the Azure cloud</span></span>

<span data-ttu-id="1aa32-345">Azure 服务总线和事件网格为公开单个离散事件（如新文档）的应用程序提供了极大的支持，这些事件已插入到 Cosmos DB 中。</span><span class="sxs-lookup"><span data-stu-id="1aa32-345">Azure Service Bus and Event Grid provide great support for applications that expose single, discrete events like a new document has been inserted into a Cosmos DB.</span></span> <span data-ttu-id="1aa32-346">但是，如果您的云原生系统需要处理*一系列相关事件*，该怎么办？</span><span class="sxs-lookup"><span data-stu-id="1aa32-346">But, what if your cloud-native system needs to process a *stream of related events*?</span></span> <span data-ttu-id="1aa32-347">[事件流](https://docs.microsoft.com/archive/msdn-magazine/2015/february/microsoft-azure-the-rise-of-event-stream-oriented-systems)更为复杂。</span><span class="sxs-lookup"><span data-stu-id="1aa32-347">[Event streams](https://docs.microsoft.com/archive/msdn-magazine/2015/february/microsoft-azure-the-rise-of-event-stream-oriented-systems) are more complex.</span></span> <span data-ttu-id="1aa32-348">它们通常是按时间顺序排列的，是相互关联的，必须作为一个组进行处理。</span><span class="sxs-lookup"><span data-stu-id="1aa32-348">They're typically time-ordered, interrelated, and must be processed as a group.</span></span>

<span data-ttu-id="1aa32-349">[Azure 事件中心](https://azure.microsoft.com/services/event-hubs/)是一个数据流平台和事件引入服务，用于收集、转换和存储事件。</span><span class="sxs-lookup"><span data-stu-id="1aa32-349">[Azure Event Hub](https://azure.microsoft.com/services/event-hubs/) is a data streaming platform and event ingestion service that collects, transforms, and stores events.</span></span> <span data-ttu-id="1aa32-350">它经过微调以捕获流数据，例如从遥测上下文中发出的连续事件通知。</span><span class="sxs-lookup"><span data-stu-id="1aa32-350">It's fine-tuned to capture streaming data, such as continuous event notifications emitted from a telemetry context.</span></span> <span data-ttu-id="1aa32-351">该服务具有高度可扩展性，每秒可以存储[和处理数百万个事件](https://docs.microsoft.com/azure/event-hubs/event-hubs-about)。</span><span class="sxs-lookup"><span data-stu-id="1aa32-351">The service is highly scalable and can store and [process millions of events per second](https://docs.microsoft.com/azure/event-hubs/event-hubs-about).</span></span> <span data-ttu-id="1aa32-352">如图 4-18 所示，它通常是事件管道的前门，将引入流与事件消耗分离。</span><span class="sxs-lookup"><span data-stu-id="1aa32-352">Shown in Figure 4-18, it's often a front door for an event pipeline, decoupling ingest stream from event consumption.</span></span>

![Azure 事件中心](./media/azure-event-hub.png)

<span data-ttu-id="1aa32-354">**图 4-18**.</span><span class="sxs-lookup"><span data-stu-id="1aa32-354">**Figure 4-18**.</span></span> <span data-ttu-id="1aa32-355">Azure 事件中心</span><span class="sxs-lookup"><span data-stu-id="1aa32-355">Azure Event Hub</span></span>

<span data-ttu-id="1aa32-356">事件中心支持低延迟和可配置的时间保留。</span><span class="sxs-lookup"><span data-stu-id="1aa32-356">Event Hub supports low latency and configurable time retention.</span></span> <span data-ttu-id="1aa32-357">与队列和主题不同，事件中心在使用者读取事件数据后保留事件数据。</span><span class="sxs-lookup"><span data-stu-id="1aa32-357">Unlike queues and topics, Event Hubs keep event data after it's been read by a consumer.</span></span> <span data-ttu-id="1aa32-358">此功能使内部和外部的其他数据分析服务能够重播数据以进行进一步分析。</span><span class="sxs-lookup"><span data-stu-id="1aa32-358">This feature enables other data analytic services, both internal and external, to replay the data for further analysis.</span></span> <span data-ttu-id="1aa32-359">存储在事件中心的事件仅在保留期到期时删除，默认情况下为一天，但可配置。</span><span class="sxs-lookup"><span data-stu-id="1aa32-359">Events stored in event hub are only deleted upon expiration of the retention period, which is one day by default, but configurable.</span></span>

<span data-ttu-id="1aa32-360">事件中心支持常见的事件发布协议，包括 HTTPS 和 AMQP。</span><span class="sxs-lookup"><span data-stu-id="1aa32-360">Event Hub supports common event publishing protocols including HTTPS and AMQP.</span></span> <span data-ttu-id="1aa32-361">它还支持卡夫卡1.0。</span><span class="sxs-lookup"><span data-stu-id="1aa32-361">It also supports Kafka 1.0.</span></span> <span data-ttu-id="1aa32-362">[现有的 Kafka 应用程序可以使用](https://docs.microsoft.com/azure/event-hubs/event-hubs-for-kafka-ecosystem-overview)Kafka 协议与事件中心通信，为管理大型 Kafka 群集提供了替代方案。</span><span class="sxs-lookup"><span data-stu-id="1aa32-362">[Existing Kafka applications can communicate with Event Hub](https://docs.microsoft.com/azure/event-hubs/event-hubs-for-kafka-ecosystem-overview) using the Kafka protocol providing an alternative to managing large Kafka clusters.</span></span> <span data-ttu-id="1aa32-363">许多开源云原生系统都拥抱卡夫卡。</span><span class="sxs-lookup"><span data-stu-id="1aa32-363">Many open-source cloud-native systems embrace Kafka.</span></span>

<span data-ttu-id="1aa32-364">事件中心通过[分区使用者模型](https://docs.microsoft.com/azure/event-hubs/event-hubs-features)实现消息流，其中每个使用者只读取消息流的特定子集或分区。</span><span class="sxs-lookup"><span data-stu-id="1aa32-364">Event Hubs implements message streaming through a [partitioned consumer model](https://docs.microsoft.com/azure/event-hubs/event-hubs-features) in which each consumer only reads a specific subset, or partition, of the message stream.</span></span> <span data-ttu-id="1aa32-365">此模式允许以极大的水平缩放规模进行事件处理，并提供队列和主题所不能提供的其他面向流的功能。</span><span class="sxs-lookup"><span data-stu-id="1aa32-365">This pattern enables tremendous horizontal scale for event processing and provides other stream-focused features that are unavailable in queues and topics.</span></span> <span data-ttu-id="1aa32-366">分区是事件中心内保留的有序事件。</span><span class="sxs-lookup"><span data-stu-id="1aa32-366">A partition is an ordered sequence of events that is held in an event hub.</span></span> <span data-ttu-id="1aa32-367">当较新的事件到达时，它们将添加到此序列的末尾。</span><span class="sxs-lookup"><span data-stu-id="1aa32-367">As newer events arrive, they're added to the end of this sequence.</span></span><span data-ttu-id="1aa32-368">图 4-19 显示了事件中心中的分区。</span><span class="sxs-lookup"><span data-stu-id="1aa32-368"> Figure 4-19 shows partitioning in an Event Hub.</span></span>

![事件中心分区](./media/event-hub-partitioning.png)

<span data-ttu-id="1aa32-370">**图 4-19**.</span><span class="sxs-lookup"><span data-stu-id="1aa32-370">**Figure 4-19**.</span></span> <span data-ttu-id="1aa32-371">事件中心分区</span><span class="sxs-lookup"><span data-stu-id="1aa32-371">Event Hub partitioning</span></span>

<span data-ttu-id="1aa32-372">每个使用者组读取消息流的子集或分区不是从同一资源读取。</span><span class="sxs-lookup"><span data-stu-id="1aa32-372">Instead of reading from the same resource, each consumer group reads across a subset, or partition, of the message stream.</span></span>

<span data-ttu-id="1aa32-373">对于必须流式传输大量事件的云原生应用程序，Azure 事件中心可以是一个强大且经济实惠的解决方案。</span><span class="sxs-lookup"><span data-stu-id="1aa32-373">For cloud-native applications that must stream large numbers of events, Azure Event Hub can be a robust and affordable solution.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="1aa32-374">[上一个](front-end-communication.md)
>[下一个](grpc.md)</span><span class="sxs-lookup"><span data-stu-id="1aa32-374">[Previous](front-end-communication.md)
[Next](grpc.md)</span></span>
