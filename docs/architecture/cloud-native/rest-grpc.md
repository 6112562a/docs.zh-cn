---
title: REST 和 gRPC
description: 了解 gRPC，它在云本机应用程序中的作用，以及它与 HTTP REST 有何不同
author: robvet
ms.date: 09/08/2019
ms.openlocfilehash: 4c829407d494a3529d1fb9953cd3f56f73e90636
ms.sourcegitcommit: 5f236cd78cf09593c8945a7d753e0850e96a0b80
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 01/07/2020
ms.locfileid: "75711631"
---
# <a name="rest-and-grpc"></a><span data-ttu-id="f359f-103">REST 和 gRPC</span><span class="sxs-lookup"><span data-stu-id="f359f-103">REST and gRPC</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="f359f-104">到目前为止，我们致力于[基于 REST 的](https://docs.microsoft.com/azure/architecture/best-practices/api-design)通信。</span><span class="sxs-lookup"><span data-stu-id="f359f-104">So far in this book, we’ve focused on [REST-based](https://docs.microsoft.com/azure/architecture/best-practices/api-design) communication.</span></span> <span data-ttu-id="f359f-105">REST 是促进分布式计算机系统之间的互操作性的体系结构样式。</span><span class="sxs-lookup"><span data-stu-id="f359f-105">REST is an architectural style that promotes interoperability between distributed computer systems.</span></span> <span data-ttu-id="f359f-106">它使用一个请求/响应模型，其中来自服务器的每个响应都是来自客户端的请求。</span><span class="sxs-lookup"><span data-stu-id="f359f-106">It uses a request/response model where every response from the server is to a request from the client.</span></span> <span data-ttu-id="f359f-107">在广泛使用的情况下，REST 并不适合每个问题。</span><span class="sxs-lookup"><span data-stu-id="f359f-107">While widely popular, REST isn't a perfect fit for every problem.</span></span> <span data-ttu-id="f359f-108">一种较新的、gRPC 的通信技术，它迅速获得普及，并使其进入云到云的世界。</span><span class="sxs-lookup"><span data-stu-id="f359f-108">A newer communication technology, entitled gRPC, is rapidly gaining popularity and making its way into the cloud-native world.</span></span>

## <a name="grpc"></a><span data-ttu-id="f359f-109">gRPC</span><span class="sxs-lookup"><span data-stu-id="f359f-109">gRPC</span></span>

<span data-ttu-id="f359f-110">gRPC 是源自 Google 的开源通信。</span><span class="sxs-lookup"><span data-stu-id="f359f-110">gRPC is an open-source communication that originates from Google.</span></span> <span data-ttu-id="f359f-111">它构建于[远程过程调用（RPC）](https://en.wikipedia.org/wiki/Remote_procedure_call)模型之上，在分布式计算中很常见。</span><span class="sxs-lookup"><span data-stu-id="f359f-111">It's built upon the [remote procedure call (RPC)](https://en.wikipedia.org/wiki/Remote_procedure_call) model, popular in distributed computing.</span></span> <span data-ttu-id="f359f-112">按照此模型，本地客户端程序将公开一个进程内方法来执行操作。</span><span class="sxs-lookup"><span data-stu-id="f359f-112">Following this model, a local client program exposes an in-process method to execute an operation.</span></span> <span data-ttu-id="f359f-113">在后台，对分布式网络上的进程外微服务调用此调用。</span><span class="sxs-lookup"><span data-stu-id="f359f-113">Behind the scenes, that call is invoked on an out-of-process microservice across a distributed network.</span></span> <span data-ttu-id="f359f-114">开发人员将操作编码为本地过程调用。</span><span class="sxs-lookup"><span data-stu-id="f359f-114">The developer codes the operation as a local procedure call.</span></span> <span data-ttu-id="f359f-115">底层平台对点到点网络通信、序列化和执行进行了抽象。</span><span class="sxs-lookup"><span data-stu-id="f359f-115">The underlying platform abstracts the point-to-point networking communication, serialization, and execution.</span></span>

<span data-ttu-id="f359f-116">gRPC 是一种轻型且高性能的新式 RPC 框架。</span><span class="sxs-lookup"><span data-stu-id="f359f-116">gRPC is a modern RPC framework that is lightweight and highly performant.</span></span> <span data-ttu-id="f359f-117">它使用 HTTP/2 作为其传输协议。</span><span class="sxs-lookup"><span data-stu-id="f359f-117">It uses HTTP/2 for its transport protocol.</span></span> <span data-ttu-id="f359f-118">与 HTTP 1.1 兼容，HTTP/2 功能很多高级功能：</span><span class="sxs-lookup"><span data-stu-id="f359f-118">While compatible with HTTP 1.1, HTTP/2 features many advanced capabilities:</span></span>

- <span data-ttu-id="f359f-119">HTTP 1.1 以明文形式发送数据，HTTP/2 是一种二进制协议。</span><span class="sxs-lookup"><span data-stu-id="f359f-119">While HTTP 1.1 sends data as clear text, HTTP/2 is a binary protocol.</span></span> <span data-ttu-id="f359f-120">它使用较少的内存更快地分析数据，降低网络延迟，同时提高速度并更有效地管理网络资源。</span><span class="sxs-lookup"><span data-stu-id="f359f-120">It parses data faster using less memory, reduces network latency with the related improvements to speed, and manages network resources more efficiently.</span></span>
- <span data-ttu-id="f359f-121">虽然 HTTP 1.1 限制为一次处理一个往返请求/响应，但 HTTP/2 支持多路复用或通过同一连接的多个并行请求。</span><span class="sxs-lookup"><span data-stu-id="f359f-121">While HTTP 1.1 is limited to processing one round-trip request/response at a time, HTTP/2 supports multiplexing, or multiple parallel requests over the same connection.</span></span>
- <span data-ttu-id="f359f-122">HTTP/2 支持全双工或双向通信，客户端和服务器都可同时进行通信。</span><span class="sxs-lookup"><span data-stu-id="f359f-122">HTTP/2 supports full-duplex, or bidirectional communication, where both client and server can communicate at the same time.</span></span> <span data-ttu-id="f359f-123">当服务器发送回响应数据时，客户端可以上载请求数据。</span><span class="sxs-lookup"><span data-stu-id="f359f-123">The client can be uploading request data at the same time the server is sending back response data.</span></span>
- <span data-ttu-id="f359f-124">流内置于 HTTP/2 中，这意味着请求和响应可以异步流式传输大型数据集。</span><span class="sxs-lookup"><span data-stu-id="f359f-124">Streaming is built into HTTP/2 meaning that both requests and responses can asynchronously stream large data sets.</span></span>
- <span data-ttu-id="f359f-125">结合 gRPC 和 HTTP/2，性能会大幅增加。</span><span class="sxs-lookup"><span data-stu-id="f359f-125">Combining gRPC and HTTP/2, performance dramatically increases.</span></span> <span data-ttu-id="f359f-126">在[Windows Communication Foundation （WCF）](https://docs.microsoft.com/dotnet/framework/wcf/whats-wcf)行话中，gRPC 性能达到并超出[wcf-nettcp 绑定](https://docs.microsoft.com/dotnet/api/system.servicemodel.nettcpbinding?view=netframework-4.8)的速度和效率。</span><span class="sxs-lookup"><span data-stu-id="f359f-126">In [Windows Communication Foundation (WCF)](https://docs.microsoft.com/dotnet/framework/wcf/whats-wcf) parlance, gRPC performance meets and exceeds the speed and efficiency of [NetTCP bindings](https://docs.microsoft.com/dotnet/api/system.servicemodel.nettcpbinding?view=netframework-4.8).</span></span> <span data-ttu-id="f359f-127">但是，与 Wcf-nettcp 不同，gRPC 不会限制为 Microsoft 语言C# ，如或 Visual Basic。</span><span class="sxs-lookup"><span data-stu-id="f359f-127">However, unlike NetTCP, gRPC isn't constrained to Microsoft languages such as C# or Visual Basic.</span></span>

<span data-ttu-id="f359f-128">跨最常用平台（包括 Java、 C#、Golang 和 NodeJS）支持 gRPC。</span><span class="sxs-lookup"><span data-stu-id="f359f-128">gRPC is supported across most popular platforms, including Java, C#, Golang, and NodeJS.</span></span>

## <a name="protocol-buffers"></a><span data-ttu-id="f359f-129">协议缓冲区</span><span class="sxs-lookup"><span data-stu-id="f359f-129">Protocol Buffers</span></span>

<span data-ttu-id="f359f-130">gRPC 涵盖了另一种开源技术，称为[协议缓冲区](https://developers.google.com/protocol-buffers/docs/overview)或 Protobuf 消息来发送和接收数据。</span><span class="sxs-lookup"><span data-stu-id="f359f-130">gRPC embraces another open-source technology called [Protocol Buffers](https://developers.google.com/protocol-buffers/docs/overview) or Protobuf messages to send and receive data.</span></span> <span data-ttu-id="f359f-131">与[WCF 数据协定](https://docs.microsoft.com/dotnet/framework/wcf/feature-details/using-data-contracts)类似，Protobuf 序列化要读写的系统的结构化数据。</span><span class="sxs-lookup"><span data-stu-id="f359f-131">Similar to a [WCF Data Contract](https://docs.microsoft.com/dotnet/framework/wcf/feature-details/using-data-contracts), Protobuf serializes structured data for systems to read and write.</span></span> <span data-ttu-id="f359f-132">它降低了用户可读的格式（如 XML 或 JSON）所产生的开销。</span><span class="sxs-lookup"><span data-stu-id="f359f-132">It reduces the overhead that human-readable formats like XML or JSON incur.</span></span>

<span data-ttu-id="f359f-133">许多对象序列化技术在运行时跨数据对象的结构。</span><span class="sxs-lookup"><span data-stu-id="f359f-133">Many object serialization techniques reflect across the structure of data objects at run-time.</span></span> <span data-ttu-id="f359f-134">Protobuf 要求使用平台不可知的语言（协议缓冲区语言）预先定义结构。</span><span class="sxs-lookup"><span data-stu-id="f359f-134">Protobuf requires you to define the structure up front with a platform-agnostic language (Protocol Buffer Language).</span></span> <span data-ttu-id="f359f-135">每个定义都存储在一个 "proto" 文件中。</span><span class="sxs-lookup"><span data-stu-id="f359f-135">Each definition is stored in a ".proto" file.</span></span> <span data-ttu-id="f359f-136">然后，使用 Protobuf 编译器 "Proton" 为任何支持的平台生成客户端代码和服务器代码。</span><span class="sxs-lookup"><span data-stu-id="f359f-136">Then using Protobuf compiler, "Proton," you generate client and server code for any of the supported platforms.</span></span> <span data-ttu-id="f359f-137">生成的代码经过优化，可快速序列化/反序列化数据。</span><span class="sxs-lookup"><span data-stu-id="f359f-137">The generated code is optimized for fast serialization/deserialization of data.</span></span> <span data-ttu-id="f359f-138">在运行时，每条消息都包装在强类型服务协定中，并序列化为标准的 Protobuf 表示形式。</span><span class="sxs-lookup"><span data-stu-id="f359f-138">At runtime, each message is wrapped in the strongly-typed service contract and serialized in a standard Protobuf representation.</span></span>

## <a name="grpc-support-in-net"></a><span data-ttu-id="f359f-139">.NET 中的 gRPC 支持</span><span class="sxs-lookup"><span data-stu-id="f359f-139">gRPC support in .NET</span></span>

<span data-ttu-id="f359f-140">Microsoft .NET Core framework 3.0 包括工具和对 gRPC 的本机支持。</span><span class="sxs-lookup"><span data-stu-id="f359f-140">The Microsoft .NET Core framework 3.0 includes tooling and native support for gRPC.</span></span> <span data-ttu-id="f359f-141">图4-20 显示了 Visual Studio 2019 模板，该模板基架用于 gRPC 服务的 gRPC 主干项目。</span><span class="sxs-lookup"><span data-stu-id="f359f-141">Figure 4-20 shows the Visual Studio 2019 template that scaffolds a gRPC skeleton project for a gRPC service.</span></span> <span data-ttu-id="f359f-142">请注意 .NET Core 如何支持 Windows、Linux 和 macOS 平台。</span><span class="sxs-lookup"><span data-stu-id="f359f-142">Note how .NET Core supports the Windows, Linux, and macOS platforms.</span></span>

![Visual Studio 2019 中的 gRPC 支持](./media/visual-studio-2019-grpc-template.png)

<span data-ttu-id="f359f-144">图 4-20。</span><span class="sxs-lookup"><span data-stu-id="f359f-144">**Figure 4-20**.</span></span> <span data-ttu-id="f359f-145">Visual Studio 2019 中的 gRPC 支持</span><span class="sxs-lookup"><span data-stu-id="f359f-145">gRPC support in Visual Studio 2019</span></span>

<span data-ttu-id="f359f-146">.NET Core 3.0 将 gRPC 无缝集成到其框架中，包括终结点路由、内置 IoC 支持和日志记录。</span><span class="sxs-lookup"><span data-stu-id="f359f-146">.NET Core 3.0 seamlessly integrates gRPC into its framework, including endpoint routing, built-in IoC support, and logging.</span></span> <span data-ttu-id="f359f-147">开源 Kestrel web 服务器完全支持 HTTP/2 连接。</span><span class="sxs-lookup"><span data-stu-id="f359f-147">The open-source Kestrel web server fully supports HTTP/2 connections.</span></span>

<span data-ttu-id="f359f-148">图4-21 显示了 Visual Studio 2019 中的 gRPC 服务的结构。</span><span class="sxs-lookup"><span data-stu-id="f359f-148">Figure 4-21 shows structure of a gRPC service in Visual Studio 2019.</span></span> <span data-ttu-id="f359f-149">请注意文件夹结构如何包含用于 proto 文件和服务代码的文件夹。</span><span class="sxs-lookup"><span data-stu-id="f359f-149">Note how the folder structure includes folders for the proto files and service code.</span></span>

![Visual Studio 2019 中的 gRPC 项目](./media/grpc-project.png  )

<span data-ttu-id="f359f-151">图 4-21。</span><span class="sxs-lookup"><span data-stu-id="f359f-151">**Figure 4-21**.</span></span> <span data-ttu-id="f359f-152">Visual Studio 2019 中的 gRPC 项目</span><span class="sxs-lookup"><span data-stu-id="f359f-152">gRPC project in Visual Studio 2019</span></span>

## <a name="grpc-usage"></a><span data-ttu-id="f359f-153">gRPC 用法</span><span class="sxs-lookup"><span data-stu-id="f359f-153">gRPC Usage</span></span>

<span data-ttu-id="f359f-154">gRPC 适用于以下方案：</span><span class="sxs-lookup"><span data-stu-id="f359f-154">gRPC is well suited for the following scenarios:</span></span>

- <span data-ttu-id="f359f-155">低延迟和高吞吐量通信。</span><span class="sxs-lookup"><span data-stu-id="f359f-155">Low latency and high throughput communication.</span></span> <span data-ttu-id="f359f-156">gRPC 非常适合轻型微服务，其中效率非常重要。</span><span class="sxs-lookup"><span data-stu-id="f359f-156">gRPC is great for lightweight microservices where efficiency is critical.</span></span>
- <span data-ttu-id="f359f-157">点到点实时通信。</span><span class="sxs-lookup"><span data-stu-id="f359f-157">Point-to-point real-time communication.</span></span> <span data-ttu-id="f359f-158">gRPC 具有对双向流式处理的出色支持。</span><span class="sxs-lookup"><span data-stu-id="f359f-158">gRPC has excellent support for bi-directional streaming.</span></span> <span data-ttu-id="f359f-159">gRPC services 无需轮询即可实时推送消息。</span><span class="sxs-lookup"><span data-stu-id="f359f-159">gRPC services can push messages in real time without polling.</span></span>
- <span data-ttu-id="f359f-160">Polyglot 环境– gRPC 工具支持最常用的开发语言，这使其成为多语言环境的不错选择。</span><span class="sxs-lookup"><span data-stu-id="f359f-160">Polyglot environments – gRPC tooling supports most popular development languages, making it a good choice for multi-language environments.</span></span>
- <span data-ttu-id="f359f-161">网络约束环境–使用 Protobuf （一种轻量消息格式）对 gRPC 消息进行序列化。</span><span class="sxs-lookup"><span data-stu-id="f359f-161">Network constrained environments – gRPC messages are serialized with Protobuf, a lightweight message format.</span></span> <span data-ttu-id="f359f-162">GRPC 消息始终小于等效的 JSON 消息。</span><span class="sxs-lookup"><span data-stu-id="f359f-162">A gRPC message is always smaller than an equivalent JSON message.</span></span>

<span data-ttu-id="f359f-163">撰写本书时，大多数浏览器对 gRPC 的支持有限。</span><span class="sxs-lookup"><span data-stu-id="f359f-163">At the time of writing of this book, most browsers have limited support for gRPC.</span></span> <span data-ttu-id="f359f-164">gRPC 大量使用 HTTP/2 功能，并且没有浏览器提供 web 请求所需的控制级别，以支持 gRPC 客户端。</span><span class="sxs-lookup"><span data-stu-id="f359f-164">gRPC heavily uses HTTP/2 features and no browser provides the level of control required over web requests to support a gRPC client.</span></span> <span data-ttu-id="f359f-165">gRPC 通常用于内部微服务到微服务通信。</span><span class="sxs-lookup"><span data-stu-id="f359f-165">gRPC is typically used for internal microservice to microservice communication.</span></span> <span data-ttu-id="f359f-166">图4-22 显示了一个简单但常用的模式。</span><span class="sxs-lookup"><span data-stu-id="f359f-166">Figure 4-22 shows a simple, but common usage pattern.</span></span>

![gRPC 使用模式](./media/grpc-usage.png)

<span data-ttu-id="f359f-168">**图 4-22**。</span><span class="sxs-lookup"><span data-stu-id="f359f-168">**Figure 4-22**.</span></span> <span data-ttu-id="f359f-169">gRPC 使用模式</span><span class="sxs-lookup"><span data-stu-id="f359f-169">gRPC usage patterns</span></span>

<span data-ttu-id="f359f-170">请注意，在上图中，在后端微服务到微服务使用 gRPC 时，如何使用 HTTP 调用前端通信。</span><span class="sxs-lookup"><span data-stu-id="f359f-170">Note in the previous figure how front-end traffic is invoked with HTTP while back-end microservice to microservice uses gRPC.</span></span>

<span data-ttu-id="f359f-171">在此之前，gRPC 可能会在 dethroning 中扮演一项重大角色，以实现云本机系统的 REST 控制。</span><span class="sxs-lookup"><span data-stu-id="f359f-171">Looking ahead, gRPC could play a major role in dethroning the dominance of REST for cloud-native systems.</span></span> <span data-ttu-id="f359f-172">性能优势和轻松开发太好了。</span><span class="sxs-lookup"><span data-stu-id="f359f-172">The performance benefits and ease of development are too good to pass up.</span></span> <span data-ttu-id="f359f-173">不过，请不要出错，REST 仍会长时间停留。</span><span class="sxs-lookup"><span data-stu-id="f359f-173">However, make no mistake, REST will still be around for a long time.</span></span> <span data-ttu-id="f359f-174">它仍为公开公开的 Api transact-sql，并出于向后兼容的原因。</span><span class="sxs-lookup"><span data-stu-id="f359f-174">It still excels for publicly exposed APIs and for backward compatibility reasons.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="f359f-175">[上一页](service-to-service-communication.md)
>[下一页](service-mesh-communication-infrastructure.md)</span><span class="sxs-lookup"><span data-stu-id="f359f-175">[Previous](service-to-service-communication.md)
[Next](service-mesh-communication-infrastructure.md)</span></span>
