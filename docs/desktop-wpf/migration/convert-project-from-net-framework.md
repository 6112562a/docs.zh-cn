---
title: 将 WPF 应用迁移到 .NET 核心 3.0
description: 了解如何将 Windows 演示文稿基础 （WPF） 应用迁移到 .NET Core 3.0。
author: mjrousos
ms.date: 09/12/2019
ms.author: mikerou
ms.openlocfilehash: f52005e7c8a6312b8c4e09a950f1f635af1894e4
ms.sourcegitcommit: cdf5084648bf5e77970cbfeaa23f1cab3e6e234e
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/01/2020
ms.locfileid: "81432592"
---
# <a name="migrating-wpf-apps-to-net-core"></a><span data-ttu-id="3a378-103">将 WPF 应用迁移到 .NET 核心</span><span class="sxs-lookup"><span data-stu-id="3a378-103">Migrating WPF apps to .NET Core</span></span>

<span data-ttu-id="3a378-104">本文介绍将 Windows 演示文稿基础 （WPF） 应用从 .NET 框架迁移到 .NET Core 3.0 所需的步骤。</span><span class="sxs-lookup"><span data-stu-id="3a378-104">This article covers the steps necessary to migrate a Windows Presentation Foundation (WPF) app from .NET Framework to .NET Core 3.0.</span></span> <span data-ttu-id="3a378-105">如果您手头没有 WPF 应用，但希望尝试此过程，则可以使用[GitHub](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader)上可用的**Bean Trader**示例应用 。</span><span class="sxs-lookup"><span data-stu-id="3a378-105">If you don't have a WPF app on hand to port, but would like to try out the process, you can use the **Bean Trader** sample app available on [GitHub](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader).</span></span> <span data-ttu-id="3a378-106">原始应用程序（目标 .NET 框架 4.7.2）可在 NetFx_BeanTraderClient 文件夹中使用。</span><span class="sxs-lookup"><span data-stu-id="3a378-106">The original app (targeting .NET Framework 4.7.2) is available in the NetFx\BeanTraderClient folder.</span></span> <span data-ttu-id="3a378-107">首先，我们将解释移植应用程序所需的步骤，然后介绍适用于**Bean Trader**示例的特定更改。</span><span class="sxs-lookup"><span data-stu-id="3a378-107">First we'll explain the steps necessary to port apps in general, and then we'll walk through the specific changes that apply to the **Bean Trader** sample.</span></span>

[!INCLUDE [desktop guide under construction](../../../includes/desktop-guide-preview-note.md)]

<span data-ttu-id="3a378-108">要迁移到 .NET 核心，必须首先：</span><span class="sxs-lookup"><span data-stu-id="3a378-108">To migrate to .NET Core, you must first:</span></span>

01. <span data-ttu-id="3a378-109">了解并更新 NuGet 依赖项：</span><span class="sxs-lookup"><span data-stu-id="3a378-109">Understand and update NuGet dependencies:</span></span>

    01. <span data-ttu-id="3a378-110">升级 NuGet 依赖项以`<PackageReference>`使用格式。</span><span class="sxs-lookup"><span data-stu-id="3a378-110">Upgrade NuGet dependencies to use the `<PackageReference>` format.</span></span>
    01. <span data-ttu-id="3a378-111">查看 .NET 核心或 .NET 标准兼容性的顶级 NuGet 依赖项。</span><span class="sxs-lookup"><span data-stu-id="3a378-111">Review top-level NuGet dependencies for .NET Core or .NET Standard compatibility.</span></span>
    01. <span data-ttu-id="3a378-112">将 NuGet 包升级到较新版本。</span><span class="sxs-lookup"><span data-stu-id="3a378-112">Upgrade NuGet packages to newer versions.</span></span>
    01. <span data-ttu-id="3a378-113">使用[.NET 可移植性分析器](../../standard/analyzers/portability-analyzer.md)了解 .NET 依赖项。</span><span class="sxs-lookup"><span data-stu-id="3a378-113">Use the [.NET Portability Analyzer](../../standard/analyzers/portability-analyzer.md) to understand .NET dependencies.</span></span>

01. <span data-ttu-id="3a378-114">将项目文件迁移到新的 SDK 样式格式：</span><span class="sxs-lookup"><span data-stu-id="3a378-114">Migrate the project file to the new SDK-style format:</span></span>

    01. <span data-ttu-id="3a378-115">选择是同时定位 .NET 核心和 .NET 框架，还是仅定位 .NET 核心。</span><span class="sxs-lookup"><span data-stu-id="3a378-115">Choose whether to target both .NET Core and .NET Framework, or only .NET Core.</span></span>
    01. <span data-ttu-id="3a378-116">将相关的项目文件属性和项复制到新项目文件。</span><span class="sxs-lookup"><span data-stu-id="3a378-116">Copy relevant project file properties and items to the new project file.</span></span>

01. <span data-ttu-id="3a378-117">修复生成问题：</span><span class="sxs-lookup"><span data-stu-id="3a378-117">Fix build issues:</span></span>

    01. <span data-ttu-id="3a378-118">添加对[Microsoft.Windows.兼容性](https://www.nuget.org/packages/Microsoft.Windows.Compatibility/)包的引用。</span><span class="sxs-lookup"><span data-stu-id="3a378-118">Add a reference to the [Microsoft.Windows.Compatibility](https://www.nuget.org/packages/Microsoft.Windows.Compatibility/) package.</span></span>
    01. <span data-ttu-id="3a378-119">查找并修复 API 级别差异。</span><span class="sxs-lookup"><span data-stu-id="3a378-119">Find and fix API-level differences.</span></span>
    01. <span data-ttu-id="3a378-120">删除 或`appSettings``connectionStrings`以外的*应用.config*部分。</span><span class="sxs-lookup"><span data-stu-id="3a378-120">Remove *app.config* sections other than `appSettings` or `connectionStrings`.</span></span>
    01. <span data-ttu-id="3a378-121">如有必要，重新生成生成的代码。</span><span class="sxs-lookup"><span data-stu-id="3a378-121">Regenerate generated code, if necessary.</span></span>

01. <span data-ttu-id="3a378-122">运行时测试：</span><span class="sxs-lookup"><span data-stu-id="3a378-122">Runtime testing:</span></span>

    01. <span data-ttu-id="3a378-123">确认移植的应用按预期工作。</span><span class="sxs-lookup"><span data-stu-id="3a378-123">Confirm the ported app works as expected.</span></span>
    01. <span data-ttu-id="3a378-124">注意<xref:System.NotSupportedException>例外情况。</span><span class="sxs-lookup"><span data-stu-id="3a378-124">Beware of <xref:System.NotSupportedException> exceptions.</span></span>

## <a name="about-the-sample"></a><span data-ttu-id="3a378-125">关于本示例</span><span class="sxs-lookup"><span data-stu-id="3a378-125">About the sample</span></span>

<span data-ttu-id="3a378-126">本文引用[Bean Trader 示例应用](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader)，因为它使用各种依赖项，类似于现实世界的 WPF 应用可能具有的依赖项。</span><span class="sxs-lookup"><span data-stu-id="3a378-126">This article references the [Bean Trader sample app](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader) because it uses a variety of dependencies similar to those that real-world WPF apps might have.</span></span> <span data-ttu-id="3a378-127">该应用程序并不大，但在复杂性方面，它意味着从"你好世界"中迈出一步。</span><span class="sxs-lookup"><span data-stu-id="3a378-127">The app isn't large, but is meant to be a step up from 'Hello World' in terms of complexity.</span></span> <span data-ttu-id="3a378-128">该应用程序演示了用户在移植实际应用时可能会遇到的一些问题。</span><span class="sxs-lookup"><span data-stu-id="3a378-128">The app demonstrates some issues users may encounter while porting real apps.</span></span> <span data-ttu-id="3a378-129">该应用程序与 WCF 服务通信，因此要正常运行，您还需要运行 BeanTraderServer 项目（在同一 GitHub 存储库中可用），并确保 BeanTraderClient 配置指向正确的终结点。</span><span class="sxs-lookup"><span data-stu-id="3a378-129">The app communicates with a WCF service, so for it to run properly, you'll also need to run the BeanTraderServer project (available in the same GitHub repository) and make sure the BeanTraderClient configuration points to the correct endpoint.</span></span> <span data-ttu-id="3a378-130">（默认情况下，该示例假定服务器在 的同一台计算机上运行，*http://localhost:8090*如果您在本地启动 BeanTraderServer，则为 true。</span><span class="sxs-lookup"><span data-stu-id="3a378-130">(By default, the sample assumes the server is running on the same machine at *http://localhost:8090*, which will be true if you launch BeanTraderServer locally.)</span></span>

<span data-ttu-id="3a378-131">请记住，此示例应用旨在演示 .NET Core 移植挑战和解决方案。</span><span class="sxs-lookup"><span data-stu-id="3a378-131">Keep in mind that this sample app is meant to demonstrate .NET Core porting challenges and solutions.</span></span> <span data-ttu-id="3a378-132">它不是要演示 WPF 最佳实践。</span><span class="sxs-lookup"><span data-stu-id="3a378-132">It's not meant to demonstrate WPF best practices.</span></span> <span data-ttu-id="3a378-133">事实上，它故意包括一些反模式，以确保你在移植时至少遇到几个有趣的挑战。</span><span class="sxs-lookup"><span data-stu-id="3a378-133">In fact, it deliberately includes some anti-patterns to make sure you come across at least a couple of interesting challenges while porting.</span></span>

## <a name="getting-ready"></a><span data-ttu-id="3a378-134">做好准备</span><span class="sxs-lookup"><span data-stu-id="3a378-134">Getting ready</span></span>

<span data-ttu-id="3a378-135">将 .NET Framework 应用迁移到 .NET Core 的主要挑战是其依赖项可能以不同的方式工作，或者根本不工作。</span><span class="sxs-lookup"><span data-stu-id="3a378-135">The primary challenge of migrating a .NET Framework app to .NET Core is that its dependencies may work differently or not at all.</span></span> <span data-ttu-id="3a378-136">迁移比过去容易得多;许多 NuGet 软件包现在都针对 .NET 标准。</span><span class="sxs-lookup"><span data-stu-id="3a378-136">Migration is much easier than it used to be; many NuGet packages now target .NET Standard.</span></span> <span data-ttu-id="3a378-137">从 .NET Core 2.0 开始，.NET 框架和 .NET 核心曲面区域变得相似。</span><span class="sxs-lookup"><span data-stu-id="3a378-137">Starting with .NET Core 2.0, the .NET Framework and .NET Core surface areas have become similar.</span></span> <span data-ttu-id="3a378-138">即便如此，仍然存在一些差异（在 NuGet 包和可用的 .NET API 中支持方面）。</span><span class="sxs-lookup"><span data-stu-id="3a378-138">Even so, some differences (both in support from NuGet packages and in available .NET APIs) remain.</span></span> <span data-ttu-id="3a378-139">迁移的第一步是查看应用的依赖项，并确保引用的格式易于迁移到 .NET Core。</span><span class="sxs-lookup"><span data-stu-id="3a378-139">The first step in migrating is to review the app's dependencies and make sure references are in a format that's easily migrated to .NET Core.</span></span>

### <a name="upgrade-to-packagereference-nuget-references"></a><span data-ttu-id="3a378-140">升级到`<PackageReference>`NuGet 引用</span><span class="sxs-lookup"><span data-stu-id="3a378-140">Upgrade to `<PackageReference>` NuGet references</span></span>

<span data-ttu-id="3a378-141">较旧的 .NET 框架项目通常在*包*中列出其 NuGet 依赖项。</span><span class="sxs-lookup"><span data-stu-id="3a378-141">Older .NET Framework projects typically list their NuGet dependencies in a *packages.config* file.</span></span> <span data-ttu-id="3a378-142">新的 SDK 样式的项目文件格式将 NuGet[`<PackageReference>`](/nuget/consume-packages/package-references-in-project-files)包作为 csproj 文件本身中的元素引用，而不是在单独的配置文件中。</span><span class="sxs-lookup"><span data-stu-id="3a378-142">The new SDK-style project file format references NuGet packages as [`<PackageReference>`](/nuget/consume-packages/package-references-in-project-files) elements in the csproj file itself rather than in a separate config file.</span></span>

<span data-ttu-id="3a378-143">迁移时，使用`<PackageReference>`-style 引用有两个优点：</span><span class="sxs-lookup"><span data-stu-id="3a378-143">When migrating, there are two advantages to using `<PackageReference>`-style references:</span></span>

- <span data-ttu-id="3a378-144">这是新的 .NET Core 项目文件所需的 NuGet 引用样式。</span><span class="sxs-lookup"><span data-stu-id="3a378-144">This is the style of NuGet reference that is required for the new .NET Core project file.</span></span> <span data-ttu-id="3a378-145">如果您已在使用`<PackageReference>`，则可以将这些项目文件元素直接复制并粘贴到新项目中。</span><span class="sxs-lookup"><span data-stu-id="3a378-145">If you're already using `<PackageReference>`, those project file elements can be copied and pasted directly into the new project.</span></span>
- <span data-ttu-id="3a378-146">与包.config 文件不同`<PackageReference>`，元素仅引用项目直接依赖的顶级依赖项。</span><span class="sxs-lookup"><span data-stu-id="3a378-146">Unlike a packages.config file, `<PackageReference>` elements only refer to the top-level dependencies that your project depends on directly.</span></span> <span data-ttu-id="3a378-147">所有其他传递 NuGet 包将在还原时确定，并记录在自动生成的 obj_project.assets.json 文件中。</span><span class="sxs-lookup"><span data-stu-id="3a378-147">All other transitive NuGet packages will be determined at restore time and recorded in the autogenerated obj\project.assets.json file.</span></span> <span data-ttu-id="3a378-148">这样可以更轻松地确定项目具有哪些依赖项，这在确定必要的依赖项是否适用于 .NET Core 上非常有用。</span><span class="sxs-lookup"><span data-stu-id="3a378-148">This makes it much easier to determine what dependencies your project has, which is useful when determining whether the necessary dependencies will work on .NET Core or not.</span></span>

<span data-ttu-id="3a378-149">将 .NET Framework 应用迁移到 .NET Core 的第一步是更新它以`<PackageReference>`使用 NuGet 引用。</span><span class="sxs-lookup"><span data-stu-id="3a378-149">The first step to migrating a .NET Framework app to .NET Core is to update it to use `<PackageReference>` NuGet references.</span></span> <span data-ttu-id="3a378-150">视觉工作室使这一点变得简单。</span><span class="sxs-lookup"><span data-stu-id="3a378-150">Visual Studio makes this simple.</span></span> <span data-ttu-id="3a378-151">只需右键单击 Visual Studio**的解决方案资源管理器**中的*包.config*文件，然后选择 **"迁移包.config 到包参考**"。</span><span class="sxs-lookup"><span data-stu-id="3a378-151">Just right-click the project's *packages.config* file in Visual Studio's **Solution Explorer**, and then select **Migrate packages.config to PackageReference**.</span></span>

![升级到包参考](./media/convert-project-from-net-framework/package-reference-migration.png)

<span data-ttu-id="3a378-153">将显示一个对话框，显示计算的顶级 NuGet 依赖项，并询问应将哪些其他 NuGet 包提升到顶级。</span><span class="sxs-lookup"><span data-stu-id="3a378-153">A dialog appears showing calculated top-level NuGet dependencies and asking which other NuGet packages should be promoted to top-level.</span></span> <span data-ttu-id="3a378-154">这些其他包都不需要是 Bean Trader 示例的顶级，因此您可以取消选中所有这些框。</span><span class="sxs-lookup"><span data-stu-id="3a378-154">None of these other packages need to be top-level for the Bean Trader sample, so you can uncheck all of those boxes.</span></span> <span data-ttu-id="3a378-155">然后，单击 **"确定"** 并删除*包.config*文件`<PackageReference>`，并将元素添加到项目文件中。</span><span class="sxs-lookup"><span data-stu-id="3a378-155">Then, click **Ok** and the *packages.config* file is removed and `<PackageReference>` elements are added to the project file.</span></span>

<span data-ttu-id="3a378-156">`<PackageReference>`-样式引用不会将 NuGet 包本地存储在包文件夹中。</span><span class="sxs-lookup"><span data-stu-id="3a378-156">`<PackageReference>`-style references don't store NuGet packages locally in a packages folder.</span></span> <span data-ttu-id="3a378-157">相反，它们作为优化存储在全局。</span><span class="sxs-lookup"><span data-stu-id="3a378-157">Instead, they're stored globally as an optimization.</span></span> <span data-ttu-id="3a378-158">迁移完成后，编辑 csproj 文件并删除引用以前来自`<Analyzer>`的分析器的任何元素 *。\包*目录。</span><span class="sxs-lookup"><span data-stu-id="3a378-158">After the migration completes, edit the csproj file and remove any `<Analyzer>` elements referring to the analyzers that previously came from the *..\packages* directory.</span></span> <span data-ttu-id="3a378-159">别担心，由于您仍然具有 NuGet 包引用，因此分析器将包含在项目中。</span><span class="sxs-lookup"><span data-stu-id="3a378-159">Don't worry; since you still have the NuGet package references, the analyzers will be included in the project.</span></span> <span data-ttu-id="3a378-160">你只需要清理旧包。 `<Analyzer>`</span><span class="sxs-lookup"><span data-stu-id="3a378-160">You just need to clean up the old packages.config-style `<Analyzer>` elements.</span></span>

### <a name="review-nuget-packages"></a><span data-ttu-id="3a378-161">查看 NuGet 包</span><span class="sxs-lookup"><span data-stu-id="3a378-161">Review NuGet packages</span></span>

<span data-ttu-id="3a378-162">现在，您可以看到项目所依赖的顶级 NuGet 包，您可以查看这些包是否在 .NET Core 上可用。</span><span class="sxs-lookup"><span data-stu-id="3a378-162">Now that you can see the top-level NuGet packages that the project depends on, you can review whether those packages are available on .NET Core.</span></span> <span data-ttu-id="3a378-163">您可以通过查看包对[nuget.org](https://www.nuget.org/)的依赖项来确定包是否支持 .NET Core。社区创建的[fuget.org](https://www.fuget.org/)网站在包信息页面顶部醒目地显示此信息。</span><span class="sxs-lookup"><span data-stu-id="3a378-163">You can determine whether a package supports .NET Core by looking at its dependencies on [nuget.org](https://www.nuget.org/). The community-created [fuget.org](https://www.fuget.org/) site shows this information prominently at the top of the package information page.</span></span>

<span data-ttu-id="3a378-164">当定位 .NET Core 3.0 时，任何针对 .NET Core 或 .NET 标准包都应工作（因为 .NET Core 实现了 .NET 标准表面积）。</span><span class="sxs-lookup"><span data-stu-id="3a378-164">When targeting .NET Core 3.0, any packages targeting .NET Core or .NET Standard should work (since .NET Core implements the .NET Standard surface area).</span></span> <span data-ttu-id="3a378-165">在某些情况下，所使用的包的特定版本不会针对 .NET Core 或 .NET 标准，但较新版本将面向.</span><span class="sxs-lookup"><span data-stu-id="3a378-165">In some cases, the specific version of a package that's used won't target .NET Core or .NET Standard, but newer versions will.</span></span> <span data-ttu-id="3a378-166">在这种情况下，应考虑升级到最新版本的包。</span><span class="sxs-lookup"><span data-stu-id="3a378-166">In this case, you should consider upgrading to the latest version of the package.</span></span>

<span data-ttu-id="3a378-167">您也可以使用针对 .NET 框架的包，但这会带来一些风险。</span><span class="sxs-lookup"><span data-stu-id="3a378-167">You can use packages targeting .NET Framework, as well, but that introduces some risk.</span></span> <span data-ttu-id="3a378-168">.NET Core 到 .NET 框架依赖项是允许的，因为 .NET Core 和 .NET 框架曲面区域足够相似，因此此类依赖项*通常*工作。</span><span class="sxs-lookup"><span data-stu-id="3a378-168">.NET Core to .NET Framework dependencies are allowed because .NET Core and .NET Framework surface areas are similar enough that such dependencies *often* work.</span></span> <span data-ttu-id="3a378-169">但是，如果包尝试使用 .NET Core 中不存在的 .NET API，则会遇到运行时异常。</span><span class="sxs-lookup"><span data-stu-id="3a378-169">However, if the package tries to use a .NET API that isn't present in .NET Core, you'll encounter a runtime exception.</span></span> <span data-ttu-id="3a378-170">因此，您应该仅在没有其他选项可用时引用 .NET Framework 包，并了解这样做会带来测试负担。</span><span class="sxs-lookup"><span data-stu-id="3a378-170">Because of that, you should only reference .NET Framework packages when no other options are available and understand that doing so imposes a test burden.</span></span>

<span data-ttu-id="3a378-171">如果引用的包不针对 .NET Core 或 .NET 标准，则必须考虑其他备选方案：</span><span class="sxs-lookup"><span data-stu-id="3a378-171">If there are packages referenced that don't target .NET Core or .NET Standard, you'll have to think about other alternatives:</span></span>

- <span data-ttu-id="3a378-172">是否有其他类似的软件包可以代替使用？</span><span class="sxs-lookup"><span data-stu-id="3a378-172">Are there other similar packages that can be used instead?</span></span> <span data-ttu-id="3a378-173">有时 NuGet 作者发布单独的'。核心的库版本专门针对 .NET Core。</span><span class="sxs-lookup"><span data-stu-id="3a378-173">Sometimes NuGet authors publish separate '.Core' versions of their libraries specifically targeting .NET Core.</span></span> <span data-ttu-id="3a378-174">企业库包是社区发布的一个示例"。NetCore"替代方案。</span><span class="sxs-lookup"><span data-stu-id="3a378-174">Enterprise Library packages are an example of the community publishing ".NetCore" alternatives.</span></span> <span data-ttu-id="3a378-175">在其他情况下，对于 .NET 标准，可用于特定服务的较新的 SDK（有时具有不同的包名）。</span><span class="sxs-lookup"><span data-stu-id="3a378-175">In other cases, newer SDKs for a particular service (sometimes with different package names) are available for .NET Standard.</span></span> <span data-ttu-id="3a378-176">如果没有可用的替代方案，则可以继续使用 .NET Framework 目标包，同时请记住，在 .NET Core 上运行后，需要对其进行彻底测试。</span><span class="sxs-lookup"><span data-stu-id="3a378-176">If no alternatives are available, you can proceed using the .NET Framework-targeted packages, bearing in mind that you'll need to test them thoroughly once running on .NET Core.</span></span>

<span data-ttu-id="3a378-177">Bean 交易者示例具有以下顶级 NuGet 依赖项：</span><span class="sxs-lookup"><span data-stu-id="3a378-177">The Bean Trader sample has the following top-level NuGet dependencies:</span></span>

- [<span data-ttu-id="3a378-178">**城堡.温莎，版本 4.1.1**</span><span class="sxs-lookup"><span data-stu-id="3a378-178">**Castle.Windsor, version 4.1.1**</span></span>](https://www.castleproject.org/projects/windsor/)  

  <span data-ttu-id="3a378-179">此包以 .NET 标准 1.6 为目标，因此适用于 .NET 核心。</span><span class="sxs-lookup"><span data-stu-id="3a378-179">This package targets .NET Standard 1.6, so it works on .NET Core.</span></span>

- [<span data-ttu-id="3a378-180">**微软.代码分析.FxCopAnalyzers，版本2.6.3**</span><span class="sxs-lookup"><span data-stu-id="3a378-180">**Microsoft.CodeAnalysis.FxCopAnalyzers, version 2.6.3**</span></span>](https://www.nuget.org/packages/Microsoft.CodeAnalysis.FxCopAnalyzers/2.6.3)  
  <span data-ttu-id="3a378-181">这是一个元包，因此它支持哪些平台并不立即明显，但[文档](https://github.com/dotnet/roslyn-analyzers#microsoftcodeanalysisfxcopanalyzers)表明其最新版本 （2.9.2） 将同时适用于 .NET 框架和 .NET Core。</span><span class="sxs-lookup"><span data-stu-id="3a378-181">This is a meta-package, so it's not immediately obvious which platforms it supports, but [documentation](https://github.com/dotnet/roslyn-analyzers#microsoftcodeanalysisfxcopanalyzers) indicates that its newest version (2.9.2) will work for both .NET Framework and .NET Core.</span></span>

- [<span data-ttu-id="3a378-182">**Nito.AsyncEx，版本 4.0.1**</span><span class="sxs-lookup"><span data-stu-id="3a378-182">**Nito.AsyncEx, version 4.0.1**</span></span>](https://www.nuget.org/packages/Nito.AsyncEx/4.0.1)  

  <span data-ttu-id="3a378-183">此包不针对 .NET Core，但较新的 5.0 版本支持.</span><span class="sxs-lookup"><span data-stu-id="3a378-183">This package doesn't target .NET Core, but the newer 5.0 version does.</span></span> <span data-ttu-id="3a378-184">迁移时很常见，因为许多 NuGet 包最近添加了 .NET 标准支持，但较旧的项目版本将仅针对 .NET 框架。</span><span class="sxs-lookup"><span data-stu-id="3a378-184">This is common when migrating because many NuGet packages have added .NET Standard support recently, but older project versions will only target .NET Framework.</span></span> <span data-ttu-id="3a378-185">如果版本差异只是一个较小的版本差异，则通常很容易升级到较新版本。</span><span class="sxs-lookup"><span data-stu-id="3a378-185">If the version difference is only a minor version difference, it's often easy to upgrade to the newer version.</span></span> <span data-ttu-id="3a378-186">由于这是一个重大版本更改，因此需要谨慎升级，因为包中可能会有重大更改。</span><span class="sxs-lookup"><span data-stu-id="3a378-186">Because this is a major version change, you need to be cautious upgrading since there could be breaking changes in the package.</span></span> <span data-ttu-id="3a378-187">不过，有一条前进的道路，这很好。</span><span class="sxs-lookup"><span data-stu-id="3a378-187">There is a path forward, though, which is good.</span></span>

- [<span data-ttu-id="3a378-188">**MahApps.Metro，版本 1.6.5**</span><span class="sxs-lookup"><span data-stu-id="3a378-188">**MahApps.Metro, version 1.6.5**</span></span>](https://www.nuget.org/packages/MahApps.Metro/1.6.5)  

  <span data-ttu-id="3a378-189">此包也不针对 .NET Core，但有较新的预发行版本 （2.0-alpha）。</span><span class="sxs-lookup"><span data-stu-id="3a378-189">This package also doesn't target .NET Core, but has a newer pre-release (2.0-alpha) that does.</span></span> <span data-ttu-id="3a378-190">同样，你必须留意重大的变化，但较新的软件包是令人鼓舞的。</span><span class="sxs-lookup"><span data-stu-id="3a378-190">Again, you have to look out for breaking changes, but the newer package is encouraging.</span></span>

<span data-ttu-id="3a378-191">Bean Trader 示例的 NuGet 依赖项都针对 .NET 标准/.NET Core，或者具有较新版本，因此这里不太可能存在任何阻塞问题。</span><span class="sxs-lookup"><span data-stu-id="3a378-191">The Bean Trader sample's NuGet dependencies all either target .NET Standard/.NET Core or have newer versions that do, so there are unlikely to be any blocking issues here.</span></span>

### <a name="upgrade-nuget-packages"></a><span data-ttu-id="3a378-192">升级 NuGet 包</span><span class="sxs-lookup"><span data-stu-id="3a378-192">Upgrade NuGet packages</span></span>

<span data-ttu-id="3a378-193">如果可能，最好升级仅针对 .NET Core 或 .NET 标准的任何包的版本，此时更新版本（项目仍以 .NET Framework 为目标），以便及早发现和解决任何重大更改。</span><span class="sxs-lookup"><span data-stu-id="3a378-193">If possible, it would be good to upgrade the versions of any packages that only target .NET Core or .NET Standard with more recent versions at this point (with the project still targeting .NET Framework) to discover and address any breaking changes early.</span></span>

<span data-ttu-id="3a378-194">如果您不希望对应用的现有 .NET Framework 版本进行任何实质性更改，则可以等到您有针对 .NET Core 的新项目文件。</span><span class="sxs-lookup"><span data-stu-id="3a378-194">If you would rather not make any material changes to the existing .NET Framework version of the app, this can wait until you have a new project file targeting .NET Core.</span></span> <span data-ttu-id="3a378-195">但是，提前将 NuGet 包升级到 .NET Core 兼容版本，一旦创建新的项目文件并减少应用 .NET Framework 和 .NET Core 版本之间的差异，迁移过程就变得更加容易。</span><span class="sxs-lookup"><span data-stu-id="3a378-195">However, upgrading the NuGet packages to .NET Core-compatible versions ahead of time makes the migration process even easier once you create the new project file and reduces the number of differences between the .NET Framework and .NET Core versions of the app.</span></span>

<span data-ttu-id="3a378-196">使用 Bean Trader 示例，所有必要的升级都可以轻松进行（使用 Visual Studio 的 NuGet 软件包管理器），但有一个例外：从**MahApps.Metro 1.6.5**升级到**2.0**揭示了与主题和重音管理 API 相关的重大更改。</span><span class="sxs-lookup"><span data-stu-id="3a378-196">With the Bean Trader sample, all of the necessary upgrades can be made easily (using Visual Studio's NuGet package manager) with one exception: upgrading from **MahApps.Metro 1.6.5** to **2.0** reveals breaking changes related to theme and accent management APIs.</span></span>

<span data-ttu-id="3a378-197">理想情况下，应用将更新以使用包的较新版本（因为这更有可能适用于 .NET Core）。</span><span class="sxs-lookup"><span data-stu-id="3a378-197">Ideally, the app would be updated to use the newer version of the package (since that is more likely to work on .NET Core).</span></span> <span data-ttu-id="3a378-198">然而，在某些情况下，这可能不可行。</span><span class="sxs-lookup"><span data-stu-id="3a378-198">In some cases, however, that may not be feasible.</span></span> <span data-ttu-id="3a378-199">在这些情况下，不要升级**MahApps.Metro，** 因为必要的更改是非琐碎的，本教程侧重于迁移到 .NET Core 3，而不是**MahApps.Metro 2。**</span><span class="sxs-lookup"><span data-stu-id="3a378-199">In these cases, don't upgrade **MahApps.Metro** because the necessary changes are non-trivial and this tutorial focuses on migrating to .NET Core 3, not to **MahApps.Metro 2.**</span></span> <span data-ttu-id="3a378-200">此外，这是一个低风险 .NET 框架依赖项，因为 Bean Trader 应用程序只行使**MahApps.Metro 的**一小部分。</span><span class="sxs-lookup"><span data-stu-id="3a378-200">Also, this is a low-risk .NET Framework dependency because the Bean Trader app only exercises a small part of **MahApps.Metro**.</span></span> <span data-ttu-id="3a378-201">当然，它将需要测试，以确保迁移完成后一切工作。</span><span class="sxs-lookup"><span data-stu-id="3a378-201">It will, of course, require testing to make sure everything's working once the migration is complete.</span></span> <span data-ttu-id="3a378-202">如果这是一个真实的场景，最好提交一个问题来跟踪工作移动到**MahApps.Metro**版本2.0，因为不做迁移现在留下一些技术债务。</span><span class="sxs-lookup"><span data-stu-id="3a378-202">If this were a real-world scenario, it would be good to file an issue to track the work to move to **MahApps.Metro** version 2.0 since not doing the migration now leaves behind some technical debt.</span></span>

<span data-ttu-id="3a378-203">将 NuGet 包更新到最新版本后，"Bean `<PackageReference>` Trader"示例的项目文件中的项目组应如下所示。</span><span class="sxs-lookup"><span data-stu-id="3a378-203">Once the NuGet packages are updated to recent versions, the `<PackageReference>` item group in the Bean Trader sample's project file should look like this.</span></span>

```xml
<ItemGroup>
  <PackageReference Include="Castle.Windsor">
    <Version>4.1.1</Version>
  </PackageReference>
  <PackageReference Include="MahApps.Metro">
    <Version>1.6.5</Version>
  </PackageReference>
  <PackageReference Include="Microsoft.CodeAnalysis.FxCopAnalyzers">
    <Version>2.9.2</Version>
  </PackageReference>
  <PackageReference Include="Nito.AsyncEx">
    <Version>5.0.0</Version>
  </PackageReference>
</ItemGroup>
```

### <a name="net-framework-portability-analysis"></a><span data-ttu-id="3a378-204">.NET 框架可移植性分析</span><span class="sxs-lookup"><span data-stu-id="3a378-204">.NET Framework portability analysis</span></span>

<span data-ttu-id="3a378-205">了解项目的 NuGet 依赖项的状态后，需要考虑的下一件事是 .NET Framework API 依赖项。</span><span class="sxs-lookup"><span data-stu-id="3a378-205">Once you understand the state of your project's NuGet dependencies, the next thing to consider is .NET Framework API dependencies.</span></span> <span data-ttu-id="3a378-206">[.NET 可移植性分析器](../../standard/analyzers/portability-analyzer.md)工具可用于了解项目使用的 .NET API 在其他 .NET 平台上可用。</span><span class="sxs-lookup"><span data-stu-id="3a378-206">The [.NET Portability Analyzer](../../standard/analyzers/portability-analyzer.md) tool is useful for understanding which of the .NET APIs your project uses are available on other .NET platforms.</span></span>

<span data-ttu-id="3a378-207">该工具作为[Visual Studio插件](https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer)，[一个命令行工具](https://github.com/Microsoft/dotnet-apiport/releases)，或包装在一[个简单的GUI，](https://github.com/Microsoft/dotnet-apiport-ui)这简化了它的选项。</span><span class="sxs-lookup"><span data-stu-id="3a378-207">The tool comes as a [Visual Studio plugin](https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer), a [command-line tool](https://github.com/Microsoft/dotnet-apiport/releases), or wrapped in a [simple GUI](https://github.com/Microsoft/dotnet-apiport-ui), which simplifies its options.</span></span> <span data-ttu-id="3a378-208">您可以阅读有关使用 .NET 可移植性分析器 （API 端口） 在[将桌面应用移植到 .NET Core](https://devblogs.microsoft.com/dotnet/porting-desktop-apps-to-net-core/)博客文章中的 GUI 的详细信息。</span><span class="sxs-lookup"><span data-stu-id="3a378-208">You can read more about using the .NET Portability Analyzer (API Port) using the GUI in the [Porting desktop apps to .NET Core](https://devblogs.microsoft.com/dotnet/porting-desktop-apps-to-net-core/) blog post.</span></span> <span data-ttu-id="3a378-209">如果希望使用命令行，则必要的步骤是：</span><span class="sxs-lookup"><span data-stu-id="3a378-209">If you prefer to use the command line, the necessary steps are:</span></span>

1. <span data-ttu-id="3a378-210">如果您还没有[.NET 可移植性分析器](https://github.com/Microsoft/dotnet-apiport/releases)，请下载它。</span><span class="sxs-lookup"><span data-stu-id="3a378-210">Download the [.NET Portability Analyzer](https://github.com/Microsoft/dotnet-apiport/releases) if you don't already have it.</span></span>
1. <span data-ttu-id="3a378-211">确保成功移植 .NET Framework 应用（无论在迁移之前，这是一个好主意）。</span><span class="sxs-lookup"><span data-stu-id="3a378-211">Make sure the .NET Framework app to be ported builds successfully (this is a good idea prior to migration regardless).</span></span>
1. <span data-ttu-id="3a378-212">使用这样的命令行运行 API 端口。</span><span class="sxs-lookup"><span data-stu-id="3a378-212">Run API Port with a command line like this.</span></span>

    ```console
    ApiPort.exe analyze -f <PathToBeanTraderBinaries> -r html -r excel -t ".NET Core"
    ```

    <span data-ttu-id="3a378-213">参数`-f`指定包含要分析的二进制文件的路径。</span><span class="sxs-lookup"><span data-stu-id="3a378-213">The `-f` argument specifies the path containing the binaries to analyze.</span></span> <span data-ttu-id="3a378-214">参数`-r`指定所需的输出文件格式。</span><span class="sxs-lookup"><span data-stu-id="3a378-214">The `-r` argument specifies which output file format you want.</span></span> <span data-ttu-id="3a378-215">参数`-t`指定要针对哪个 .NET 平台分析 API 使用情况。</span><span class="sxs-lookup"><span data-stu-id="3a378-215">The `-t` argument specifies which .NET platform to analyze API usage against.</span></span> <span data-ttu-id="3a378-216">在这种情况下，您需要 .NET 核心。</span><span class="sxs-lookup"><span data-stu-id="3a378-216">In this case, you want .NET Core.</span></span>

<span data-ttu-id="3a378-217">打开 HTML 报表时，第一部分将列出所有分析的二进制文件，以及他们使用的 .NET API 的百分比在目标平台上可用。</span><span class="sxs-lookup"><span data-stu-id="3a378-217">When you open the HTML report, the first section will list all of the analyzed binaries and what percentage of the .NET APIs they use are available on the targeted platform.</span></span> <span data-ttu-id="3a378-218">这个百分比本身没有意义。</span><span class="sxs-lookup"><span data-stu-id="3a378-218">The percentage is not meaningful by itself.</span></span> <span data-ttu-id="3a378-219">更有用的是查看缺少的特定 API。</span><span class="sxs-lookup"><span data-stu-id="3a378-219">What's more useful is to see the specific APIs that are missing.</span></span> <span data-ttu-id="3a378-220">为此，请选择程序集名称或向下滚动到各个程序集的报表。</span><span class="sxs-lookup"><span data-stu-id="3a378-220">To do that, either select an assembly name or scroll down to the reports for individual assemblies.</span></span>

<span data-ttu-id="3a378-221">关注您拥有的源代码的程序集。</span><span class="sxs-lookup"><span data-stu-id="3a378-221">Focus on the assemblies that you own the source code for.</span></span> <span data-ttu-id="3a378-222">例如，在 Bean Trader ApiPort 报告中，列出了许多二进制文件，但大多数都属于 NuGet 包。</span><span class="sxs-lookup"><span data-stu-id="3a378-222">In the Bean Trader ApiPort report, for example, there are many binaries listed, but most of them belong to NuGet packages.</span></span> <span data-ttu-id="3a378-223">`Castle.Windsor`显示它依赖于 .NET Core 中缺少的某些 System.Web API。</span><span class="sxs-lookup"><span data-stu-id="3a378-223">`Castle.Windsor` shows that it depends on some System.Web APIs that are missing in .NET Core.</span></span> <span data-ttu-id="3a378-224">这不是问题，因为您以前已验证支持`Castle.Windsor`.NET Core。</span><span class="sxs-lookup"><span data-stu-id="3a378-224">This isn't a concern because you previously verified that `Castle.Windsor` supports .NET Core.</span></span> <span data-ttu-id="3a378-225">NuGet 包具有不同的二进制文件用于不同的 .NET 平台是很常见的，因此，只要包也针对 .NET`Castle.Windsor`标准或 .NET Core（它这样做），.NET 框架版本是否使用 System.Web API 都无关紧要。</span><span class="sxs-lookup"><span data-stu-id="3a378-225">It is common for NuGet packages to have different binaries for use with different .NET platforms, so whether the .NET Framework version of `Castle.Windsor` uses System.Web APIs or not is irrelevant as long as the package also targets .NET Standard or .NET Core (which it does).</span></span>

<span data-ttu-id="3a378-226">使用 Bean Trader 示例时，您需要考虑的唯一二进制文件是**BeanTraderClient，** 报告显示仅缺少两个 .NET `System.ServiceModel.ClientBase<T>.Close` API：`System.ServiceModel.ClientBase<T>.Open`和 。</span><span class="sxs-lookup"><span data-stu-id="3a378-226">With the Bean Trader sample, the only binary that you need to consider is **BeanTraderClient** and the report shows that only two .NET APIs are missing: `System.ServiceModel.ClientBase<T>.Close` and `System.ServiceModel.ClientBase<T>.Open`.</span></span>

![豆交易客户端可移植性报告](./media/convert-project-from-net-framework/portability-report.png)

<span data-ttu-id="3a378-228">这些不太可能阻止问题，因为 WCF 客户端 API（大部分）在 .NET Core 上受支持，因此必须为这些中央 API 提供替代方案。</span><span class="sxs-lookup"><span data-stu-id="3a378-228">These are unlikely to be blocking issues because WCF Client APIs are (mostly) supported on .NET Core, so there must be alternatives available for these central APIs.</span></span> <span data-ttu-id="3a378-229">事实上，查看`System.ServiceModel`.NET 核心表面积（使用<https://apisof.net>），您会看到 .NET Core 中有异步替代方案。</span><span class="sxs-lookup"><span data-stu-id="3a378-229">In fact, looking at `System.ServiceModel`'s .NET Core surface area (using <https://apisof.net>), you see that there are async alternatives in .NET Core instead.</span></span>

<span data-ttu-id="3a378-230">基于此报告和以前的 NuGet 依赖项分析，似乎不应存在将 Bean Trader 示例迁移到 .NET Core 的大问题。</span><span class="sxs-lookup"><span data-stu-id="3a378-230">Based on this report and the previous NuGet dependency analysis, it looks like there should be no major issues migrating the Bean Trader sample to .NET Core.</span></span> <span data-ttu-id="3a378-231">您已准备好下一步，在此步骤中，您将实际开始迁移。</span><span class="sxs-lookup"><span data-stu-id="3a378-231">You're ready for the next step in which you'll actually start the migration.</span></span>

## <a name="migrating-the-project-file"></a><span data-ttu-id="3a378-232">迁移项目文件</span><span class="sxs-lookup"><span data-stu-id="3a378-232">Migrating the project file</span></span>

<span data-ttu-id="3a378-233">如果你的应用没有使用新的[SDK 风格的项目文件格式](../../core/tools/csproj.md)，则需要一个新的项目文件来定位 .NET Core。</span><span class="sxs-lookup"><span data-stu-id="3a378-233">If your app isn't using the new [SDK-style project file format](../../core/tools/csproj.md), you'll need a new project file to target .NET Core.</span></span> <span data-ttu-id="3a378-234">您可以替换现有的 csproj 文件，或者，如果您希望保持现有项目保持其当前状态不变，则可以添加针对 .NET Core 的新 csproj 文件。</span><span class="sxs-lookup"><span data-stu-id="3a378-234">You can replace the existing csproj file or, if you prefer to keep the existing project untouched in its current state, you can add a new csproj file targeting .NET Core.</span></span> <span data-ttu-id="3a378-235">您可以使用具有[多目标的](../../standard/library-guidance/cross-platform-targeting.md)单个 SDK 样式项目文件（指定多个`<TargetFrameworks>`目标）为 .NET 框架和 .NET Core 构建应用版本。</span><span class="sxs-lookup"><span data-stu-id="3a378-235">You can build versions of the app for .NET Framework and .NET Core with a single SDK-style project file with [multi-targeting](../../standard/library-guidance/cross-platform-targeting.md) (specifying multiple `<TargetFrameworks>` targets).</span></span>

<span data-ttu-id="3a378-236">要创建新的项目文件，可以在 Visual Studio 中创建新的 WPF 项目，或者`dotnet new wpf`使用临时目录中的命令生成项目文件，然后将其复制/重命名到正确的位置。</span><span class="sxs-lookup"><span data-stu-id="3a378-236">To create the new project file, you can create a new WPF project in Visual Studio or use the `dotnet new wpf` command in a temporary directory to generate the project file and then copy/rename it to the correct location.</span></span> <span data-ttu-id="3a378-237">还有一个社区创建的工具[，CsprojToVs2017，](https://github.com/hvanbakel/CsprojToVs2017)它可以自动执行一些项目文件迁移。</span><span class="sxs-lookup"><span data-stu-id="3a378-237">There is also a community-created tool, [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017), that can automate some of the project file migration.</span></span> <span data-ttu-id="3a378-238">该工具很有用，但仍需要人工查看结果，以确保迁移的所有详细信息都正确无误。</span><span class="sxs-lookup"><span data-stu-id="3a378-238">The tool is helpful but still needs a human to review the results to make sure all the details of the migration are correct.</span></span> <span data-ttu-id="3a378-239">该工具无法最好地处理的一个特定区域是从包迁移 NuGet 包 *。*</span><span class="sxs-lookup"><span data-stu-id="3a378-239">One particular area that the tool doesn't handle optimally is migrating NuGet packages from *packages.config* files.</span></span> <span data-ttu-id="3a378-240">如果该工具在仍使用*包.config*文件引用 NuGet 包的项目文件上运行，它将自动迁移到`<PackageReference>`元素，但会为所有包添加`<PackageReference>`元素，而不仅仅是顶级*all*包的元素。</span><span class="sxs-lookup"><span data-stu-id="3a378-240">If the tool runs on a project file that still uses a *packages.config* file to reference NuGet packages, it will migrate to `<PackageReference>` elements automatically, but will add `<PackageReference>` elements for *all* of the packages instead of just top-level ones.</span></span> <span data-ttu-id="3a378-241">如果您已经迁移到`<PackageReference>`了使用 Visual Studio 的元素（如本示例中所做的那样），则该工具可以帮助完成转换的其余部分。</span><span class="sxs-lookup"><span data-stu-id="3a378-241">If you have already migrated to`<PackageReference>` elements with Visual Studio (as you've done in this sample), then the tool can help with the rest of the conversion.</span></span> <span data-ttu-id="3a378-242">像斯科特·汉塞尔曼[在他的博客文章中建议迁移csproj文件](https://www.hanselman.com/blog/UpgradingAnExistingNETProjectFilesToTheLeanNewCSPROJFormatFromNETCore.aspx)，手工移植是教育性的，如果你只有几个项目移植，将提供更好的结果。</span><span class="sxs-lookup"><span data-stu-id="3a378-242">Like Scott Hanselman recommends in [his blog post on migrating csproj files](https://www.hanselman.com/blog/UpgradingAnExistingNETProjectFilesToTheLeanNewCSPROJFormatFromNETCore.aspx), porting by hand is educational and will give better results if you only have a few projects to port.</span></span> <span data-ttu-id="3a378-243">但是，如果您移植了几十个或数百个项目文件，那么像 [CprojToVs2017] 这样的工具可能是一个帮助。</span><span class="sxs-lookup"><span data-stu-id="3a378-243">But if you are porting dozens or hundreds of project files, then a tool like [CsprojToVs2017] can be a help.</span></span>

<span data-ttu-id="3a378-244">要为 Bean Trader 示例创建新的项目文件，请`dotnet new wpf`运行临时目录中，并将生成的 *.csproj*文件移动到*BeanTraderClient*文件夹中，并将其重命名为**BeanTraderClient.Core.csproj**。</span><span class="sxs-lookup"><span data-stu-id="3a378-244">To create a new project file for the Bean Trader sample, run `dotnet new wpf` in a temporary directory and move the generated *.csproj* file into the *BeanTraderClient* folder and rename it **BeanTraderClient.Core.csproj**.</span></span>

<span data-ttu-id="3a378-245">由于新的项目文件格式自动包括 C# 文件 *、resx*文件和 XAML 文件，它在其目录中或在其目录下找到，因此项目文件已几乎完成！</span><span class="sxs-lookup"><span data-stu-id="3a378-245">Because the new project file format automatically includes C# files, *resx* files, and XAML files that it finds in or under its directory, the project file is already almost complete!</span></span> <span data-ttu-id="3a378-246">要完成迁移，请并排打开新旧项目文件，并查看旧项目文件以查看是否需要迁移其中包含的任何信息。</span><span class="sxs-lookup"><span data-stu-id="3a378-246">To finish the migration, open the old and new project files side-by-side and look through the old one to see if any information it contains needs to be migrated.</span></span> <span data-ttu-id="3a378-247">在"豆交易"示例案例中，应将以下项目复制到新项目：</span><span class="sxs-lookup"><span data-stu-id="3a378-247">In the Bean Trader sample case, the following items should be copied to the new project:</span></span>

- <span data-ttu-id="3a378-248">全部`<RootNamespace>`应`<AssemblyName>`复制`<ApplicationIcon>`和 属性。</span><span class="sxs-lookup"><span data-stu-id="3a378-248">The `<RootNamespace>`, `<AssemblyName>`, and `<ApplicationIcon>` properties should all be copied.</span></span>

- <span data-ttu-id="3a378-249">您还需要向新项目文件添加`<GenerateAssemblyInfo>false</GenerateAssemblyInfo>`属性，因为 Bean Trader 示例在AssemblyInfo.cs文件中包含程序集级属性（如`[AssemblyTitle]`）。"属性"。</span><span class="sxs-lookup"><span data-stu-id="3a378-249">You also need to add a `<GenerateAssemblyInfo>false</GenerateAssemblyInfo>` property to the new project file since the Bean Trader sample includes assembly-level attributes (like `[AssemblyTitle]`) in an AssemblyInfo.cs file.</span></span> <span data-ttu-id="3a378-250">默认情况下，新的 SDK 样式项目将根据 csproj 文件中的属性自动生成这些属性。</span><span class="sxs-lookup"><span data-stu-id="3a378-250">By default, new SDK-style projects will autogenerate these attributes based on properties in the csproj file.</span></span> <span data-ttu-id="3a378-251">由于在这种情况下不希望这种情况发生（自动生成的属性将与AssemblyInfo.cs的属性冲突），因此使用 禁用自动生成的属性`<GenerateAssemblyInfo>`。</span><span class="sxs-lookup"><span data-stu-id="3a378-251">Because you don't want that to happen in this case (the autogenerated attributes would conflict with those from AssemblyInfo.cs), you disable the autogenerated attributes with `<GenerateAssemblyInfo>`.</span></span>

- <span data-ttu-id="3a378-252">尽管*resx*文件自动作为嵌入资源包含在内`<Resource>`，但其他项目（如图像）则不包括在内。</span><span class="sxs-lookup"><span data-stu-id="3a378-252">Although *resx* files are automatically included as embedded resources, other `<Resource>` items like images are not.</span></span> <span data-ttu-id="3a378-253">因此，`<Resource>`复制嵌入图像和图标文件的元素。</span><span class="sxs-lookup"><span data-stu-id="3a378-253">So, copy the `<Resource>` elements for embedding image and icon files.</span></span> <span data-ttu-id="3a378-254">您可以使用新项目文件格式对 globing 模式的支持来简化对单行的 png 引用： `<Resource Include="**\*.png" />`。</span><span class="sxs-lookup"><span data-stu-id="3a378-254">You can simplify the png references to a single line by using the new project file format's support for globbing patterns: `<Resource Include="**\*.png" />`.</span></span>

- <span data-ttu-id="3a378-255">同样，`<None>`项目会自动包含，但默认情况下不会将其复制到输出目录。</span><span class="sxs-lookup"><span data-stu-id="3a378-255">Similarly, `<None>` items are included automatically, but they aren't copied to the output directory, by default.</span></span> <span data-ttu-id="3a378-256">由于 Bean Trader 项目`<None>`包含*复制到*输出目录（使用`PreserveNewest`行为）的项目，因此您需要更新该文件自动填充`<None>`的项，如下所示。</span><span class="sxs-lookup"><span data-stu-id="3a378-256">Because the Bean Trader project includes a `<None>` item that *is* copied to the output directory (using `PreserveNewest` behaviors), you need to update the automatically populated `<None>` item for that file, like this.</span></span>

  ```xml
  <None Update="BeanTrader.pfx">
    <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </None>
  ```

- <span data-ttu-id="3a378-257">Bean Trader 示例包括 XAML 文件 （Default.Accent.xaml） 作为`Content`（`Page`而不是作为 ），因为在此文件中定义的主题和重音在运行时从文件的 XAML 加载，而不是嵌入到应用本身中。</span><span class="sxs-lookup"><span data-stu-id="3a378-257">The Bean Trader sample includes a XAML file (Default.Accent.xaml) as `Content` (rather than as a `Page`) because themes and accents defined in this file are loaded from the file's XAML at runtime, rather than being embedded in the app itself.</span></span> <span data-ttu-id="3a378-258">但是，新项目系统会自动将此文件作为`<Page>`，因为它是 XAML 文件。</span><span class="sxs-lookup"><span data-stu-id="3a378-258">The new project system automatically includes this file as a `<Page>`, however, since it's a XAML file.</span></span> <span data-ttu-id="3a378-259">因此，您需要同时删除 XAML 文件作为页面 （`<Page Remove="**\Default.Accent.xaml" />`）， 并将其添加为内容。</span><span class="sxs-lookup"><span data-stu-id="3a378-259">So, you need to both remove the XAML file as a page (`<Page Remove="**\Default.Accent.xaml" />`) and add it as content.</span></span>

  ```xml
  <Content Include="Resources\Themes\Default.Accent.xaml">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </Content>
  ```

- <span data-ttu-id="3a378-260">最后，通过复制`<ItemGroup>`所有`<PackageReference>`元素来添加 NuGet 引用。</span><span class="sxs-lookup"><span data-stu-id="3a378-260">Finally, add NuGet references by copying the `<ItemGroup>` with all the `<PackageReference>` elements.</span></span> <span data-ttu-id="3a378-261">如果您以前没有将 NuGet 包升级到 .NET Core 兼容版本，则现在可以执行此操作，因为包引用位于 .NET Core 特定的项目中。</span><span class="sxs-lookup"><span data-stu-id="3a378-261">If you hadn't previously upgraded the NuGet packages to .NET Core-compatible versions, you could do that now that the package references are in a .NET Core-specific project.</span></span>

<span data-ttu-id="3a378-262">此时，应该可以将新项目添加到 BeanTrader 解决方案并在 Visual Studio 中打开它。</span><span class="sxs-lookup"><span data-stu-id="3a378-262">At this point, it should be possible to add the new project to the BeanTrader solution and open it in Visual Studio.</span></span> <span data-ttu-id="3a378-263">项目在**解决方案资源管理器**中应看起来正确，并`dotnet restore BeanTraderClient.Core.csproj`应成功还原包（与 MahApps.Metro 版本相关的两个预期警告，您使用的定位目标 .NET Framework）。</span><span class="sxs-lookup"><span data-stu-id="3a378-263">The project should look correct in **Solution Explorer**, and `dotnet restore BeanTraderClient.Core.csproj` should successfully restore packages (with two expected warnings related to the MahApps.Metro version you're using targeting .NET Framework).</span></span>

<span data-ttu-id="3a378-264">尽管可以同时保留两个项目文件（如果要保持旧项目完全按照现在的身份构建，甚至可能是可取的），但它使迁移过程复杂化（这两个项目将尝试使用相同的 bin 和 obj 文件夹），通常没有必要。</span><span class="sxs-lookup"><span data-stu-id="3a378-264">Although it's possible to keep both project files side-by-side (and may even be desirable if you want to keep building the old project exactly as it was), it complicates the migration process (the two projects will try to use the same bin and obj folders) and usually isn't necessary.</span></span> <span data-ttu-id="3a378-265">如果要同时为 .NET Core 和 .NET 框架目标生成，则可以`<TargetFramework>netcoreapp3.0</TargetFramework>``<TargetFrameworks>netcoreapp3.0;net472</TargetFrameworks>`改为替换新项目文件中的属性。</span><span class="sxs-lookup"><span data-stu-id="3a378-265">If you want to build for both .NET Core and .NET Framework targets, you can replace the `<TargetFramework>netcoreapp3.0</TargetFramework>` property in the new project file with `<TargetFrameworks>netcoreapp3.0;net472</TargetFrameworks>` instead.</span></span> <span data-ttu-id="3a378-266">对于 Bean Trader 示例，请删除旧项目文件（BeanTraderClient.csproj），因为它不再需要。</span><span class="sxs-lookup"><span data-stu-id="3a378-266">For the Bean Trader sample, delete the old project file (BeanTraderClient.csproj) since it's no longer needed.</span></span> <span data-ttu-id="3a378-267">如果您希望保留这两个项目文件，请确保将它们构建到不同的输出和中间输出路径。</span><span class="sxs-lookup"><span data-stu-id="3a378-267">If you prefer to keep both project files, be sure to have them build to different output and intermediate output paths.</span></span>

## <a name="fix-build-issues"></a><span data-ttu-id="3a378-268">修复生成问题</span><span class="sxs-lookup"><span data-stu-id="3a378-268">Fix build issues</span></span>

<span data-ttu-id="3a378-269">移植过程的第三步是生成项目。</span><span class="sxs-lookup"><span data-stu-id="3a378-269">The third step of the porting process is getting the project to build.</span></span> <span data-ttu-id="3a378-270">一旦项目文件转换为 SDK 样式的项目，某些应用将成功生成。</span><span class="sxs-lookup"><span data-stu-id="3a378-270">Some apps will already build successfully once the project file is converted to an SDK-style project.</span></span> <span data-ttu-id="3a378-271">如果你的应用如此，恭喜你！</span><span class="sxs-lookup"><span data-stu-id="3a378-271">If that's the case for your app, congratulations!</span></span> <span data-ttu-id="3a378-272">您可以继续执行步骤 4。</span><span class="sxs-lookup"><span data-stu-id="3a378-272">You can go on to Step 4.</span></span> <span data-ttu-id="3a378-273">其他应用将需要一些更新，以使它们为 .NET Core 构建。</span><span class="sxs-lookup"><span data-stu-id="3a378-273">Other apps will need some updates to get them building for .NET Core.</span></span> <span data-ttu-id="3a378-274">如果您尝试现在`dotnet build`运行 Bean Trader 示例项目（例如，或在 Visual Studio 中构建），将有许多错误，但很快就会修复它们。</span><span class="sxs-lookup"><span data-stu-id="3a378-274">If you try to run `dotnet build` on the Bean Trader sample project now, for example, (or build it in Visual Studio), there will be many errors, but you'll get them fixed quickly.</span></span>

### <a name="systemservicemodel-references-and-microsoftwindowscompatibility"></a><span data-ttu-id="3a378-275">系统.服务模型引用和微软.Windows.兼容性</span><span class="sxs-lookup"><span data-stu-id="3a378-275">System.ServiceModel references and Microsoft.Windows.Compatibility</span></span>

<span data-ttu-id="3a378-276">常见的错误来源是缺少可用于 .NET Core 但未自动包含在 .NET Core 应用元包中的 API 的引用。</span><span class="sxs-lookup"><span data-stu-id="3a378-276">A common source of errors is missing references for APIs that are available for .NET Core but not automatically included in the .NET Core app metapackage.</span></span> <span data-ttu-id="3a378-277">为此，应引用该`Microsoft.Windows.Compatibility`包。</span><span class="sxs-lookup"><span data-stu-id="3a378-277">To address this, you should reference the `Microsoft.Windows.Compatibility` package.</span></span> <span data-ttu-id="3a378-278">兼容性包包括 Windows 桌面应用中常见的广泛 API 集，例如 WCF 客户端、目录服务、注册表、配置、ACL API 等。</span><span class="sxs-lookup"><span data-stu-id="3a378-278">The compatibility package includes a broad set of APIs that are common in Windows desktop apps, such as WCF client, directory services, registry, configuration, ACLs APIs, and more.</span></span>

<span data-ttu-id="3a378-279">使用 Bean Trader 示例，大多数生成错误是由于缺少<xref:System.ServiceModel>类型造成的。</span><span class="sxs-lookup"><span data-stu-id="3a378-279">With the Bean Trader sample, the majority of the build errors are due to missing <xref:System.ServiceModel> types.</span></span> <span data-ttu-id="3a378-280">这些可以通过引用必要的 WCF NuGet 包来解决。</span><span class="sxs-lookup"><span data-stu-id="3a378-280">These could be addressed by referencing the necessary WCF NuGet packages.</span></span> <span data-ttu-id="3a378-281">但是，WCF 客户端 API 是`Microsoft.Windows.Compatibility`包中存在的一部分，因此引用兼容性包是一个更好的解决方案（因为它还解决了与 API 相关的任何问题以及兼容性包提供的 WCF 问题的解决方案）。</span><span class="sxs-lookup"><span data-stu-id="3a378-281">WCF client APIs are among those present in the `Microsoft.Windows.Compatibility` package, though, so referencing the compatibility package is an even better solution (since it also addresses any issues related to APIs as well as solutions to the WCF issues that the compatibility package makes available).</span></span> <span data-ttu-id="3a378-282">在大多数`Microsoft.Windows.Compatibility`.NET Core 3.0 WPF 和 WinForms 移植方案中，该包都很有帮助。</span><span class="sxs-lookup"><span data-stu-id="3a378-282">The `Microsoft.Windows.Compatibility` package helps in most .NET Core 3.0 WPF and WinForms porting scenarios.</span></span> <span data-ttu-id="3a378-283">将 NuGet 引用添加到`Microsoft.Windows.Compatibility`后，仅保留一个生成错误！</span><span class="sxs-lookup"><span data-stu-id="3a378-283">After adding the NuGet reference to `Microsoft.Windows.Compatibility`, only one build error remains!</span></span>

### <a name="cleaning-up-unused-files"></a><span data-ttu-id="3a378-284">清理未使用的文件</span><span class="sxs-lookup"><span data-stu-id="3a378-284">Cleaning up unused files</span></span>

<span data-ttu-id="3a378-285">出现一种类型的迁移问题通常与以前未包含在生成中的新 SDK 样式项目（自动包含*所有*源）的 C# 和 XAML 文件有关。</span><span class="sxs-lookup"><span data-stu-id="3a378-285">One type of migration issue that comes up often relates to C# and XAML files that weren't previously included in the build getting picked up by the new SDK-style projects that include *all* source automatically.</span></span>

<span data-ttu-id="3a378-286">您在 Bean Trader 示例中看到的下一个生成错误是指*OldUnusedViewModel.cs*中的一个错误接口实现。</span><span class="sxs-lookup"><span data-stu-id="3a378-286">The next build error you see in the Bean Trader sample refers to a bad interface implementation in *OldUnusedViewModel.cs*.</span></span> <span data-ttu-id="3a378-287">文件名是提示，但在检查时，您会发现此源文件不正确。</span><span class="sxs-lookup"><span data-stu-id="3a378-287">The file name is a hint, but on inspection, you'll find that this source file is incorrect.</span></span> <span data-ttu-id="3a378-288">它以前没有引起问题，因为它未包含在原始的 .NET 框架项目中。</span><span class="sxs-lookup"><span data-stu-id="3a378-288">It didn't cause issues previously because it wasn't included in the original .NET Framework project.</span></span> <span data-ttu-id="3a378-289">磁盘上存在但未包含在旧*csproj*中的源文件现在会自动包含。</span><span class="sxs-lookup"><span data-stu-id="3a378-289">Source files that were present on disk but not included in the old *csproj* are included automatically now.</span></span>

<span data-ttu-id="3a378-290">对于这样的一次性问题，很容易与以前的*csproj*进行比较，以确认该文件不需要，然后`<Compile Remove="" />`要么它，要么，如果源文件不再需要任何地方，请将其删除。</span><span class="sxs-lookup"><span data-stu-id="3a378-290">For one-off issues like this, it's easy to compare to the previous *csproj* to confirm that the file isn't needed, and then either `<Compile Remove="" />` it or, if the source file isn't needed anywhere anymore, delete it.</span></span> <span data-ttu-id="3a378-291">在这种情况下，只需删除*OldUnusedViewModel.cs*是安全的。</span><span class="sxs-lookup"><span data-stu-id="3a378-291">In this case, it's safe to just delete *OldUnusedViewModel.cs*.</span></span>

<span data-ttu-id="3a378-292">如果有许多需要以这种方式排除的源文件，则可以通过在项目文件中将`<EnableDefaultCompileItems>`属性设置为 false 来禁用自动包含 C# 文件。</span><span class="sxs-lookup"><span data-stu-id="3a378-292">If you have many source files that would need to be excluded this way, you can disable auto-inclusion of C# files by setting the `<EnableDefaultCompileItems>` property to false in the project file.</span></span> <span data-ttu-id="3a378-293">然后，您可以将项目从`<Compile Include>`旧项目文件复制到新项目文件，以便仅生成要包括的源。</span><span class="sxs-lookup"><span data-stu-id="3a378-293">Then, you can copy `<Compile Include>` items from the old project file to the new one in order to only build sources you intended to include.</span></span> <span data-ttu-id="3a378-294">同样，`<EnableDefaultPageItems>`可用于关闭 XAML 页面的自动包含，并且`<EnableDefaultItems>`可以使用单个属性控制这两个页面。</span><span class="sxs-lookup"><span data-stu-id="3a378-294">Similarly, `<EnableDefaultPageItems>` can be used to turn off auto-inclusion of XAML pages and `<EnableDefaultItems>` can control both with a single property.</span></span>

### <a name="a-brief-aside-on-multi-pass-compilers"></a><span data-ttu-id="3a378-295">多通道编译器的简短旁加</span><span class="sxs-lookup"><span data-stu-id="3a378-295">A brief aside on multi-pass compilers</span></span>

<span data-ttu-id="3a378-296">从 Bean Trader 示例中删除违规文件后，您可以重新生成，并将得到四个错误。</span><span class="sxs-lookup"><span data-stu-id="3a378-296">After removing the offending file from the Bean Trader sample, you can re-build and will get four errors.</span></span> <span data-ttu-id="3a378-297">你以前没有吗？</span><span class="sxs-lookup"><span data-stu-id="3a378-297">Didn't you have one before?</span></span> <span data-ttu-id="3a378-298">为什么错误数会上升？</span><span class="sxs-lookup"><span data-stu-id="3a378-298">Why did the number of errors go up?</span></span> <span data-ttu-id="3a378-299">C# 编译器是[多通道编译器](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes)。</span><span class="sxs-lookup"><span data-stu-id="3a378-299">The C# compiler is a [multi-pass compiler](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes).</span></span> <span data-ttu-id="3a378-300">这意味着它遍遍每个源文件两次。</span><span class="sxs-lookup"><span data-stu-id="3a378-300">This means that it goes through each source file twice.</span></span> <span data-ttu-id="3a378-301">首先，编译器只查看每个源文件中的元数据和声明，并标识任何声明级问题。</span><span class="sxs-lookup"><span data-stu-id="3a378-301">First, the compiler just looks at metadata and declarations in each source file and identifies any declaration-level problems.</span></span> <span data-ttu-id="3a378-302">这些是您修复的错误。</span><span class="sxs-lookup"><span data-stu-id="3a378-302">Those are the errors you've fixed.</span></span> <span data-ttu-id="3a378-303">然后，它再次通过代码将 C# 源构建到 IL;这些是你现在看到的第二组错误。</span><span class="sxs-lookup"><span data-stu-id="3a378-303">Then it goes through the code again to build the C# source into IL; those are the second set of errors that you're seeing now.</span></span>

> [!NOTE]
> <span data-ttu-id="3a378-304">C# 编译器[执行的不仅仅是两个传递](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes)，但最终结果是，对于像这样的大型代码更改的编译器错误往往以两个波表示。</span><span class="sxs-lookup"><span data-stu-id="3a378-304">The C# compiler does [more than just two passes](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes), but the end result is that compiler errors for large code changes like this tend to come in two waves.</span></span>

### <a name="third-party-dependency-fixes-castlewindsor"></a><span data-ttu-id="3a378-305">第三方依赖项修复（城堡.温莎）</span><span class="sxs-lookup"><span data-stu-id="3a378-305">Third-party dependency fixes (Castle.Windsor)</span></span>

<span data-ttu-id="3a378-306">某些迁移方案中出现的另一类问题是依赖项 .NET Framework 和 .NET Core 版本之间的 API 差异。</span><span class="sxs-lookup"><span data-stu-id="3a378-306">Another class of issue that comes up in some migration scenarios is API differences between .NET Framework and .NET Core versions of dependencies.</span></span> <span data-ttu-id="3a378-307">即使 NuGet 包同时面向 .NET 框架和 .NET 标准或 .NET Core，也可能有不同的库可用于不同的 .NET 目标。</span><span class="sxs-lookup"><span data-stu-id="3a378-307">Even if a NuGet package targets both .NET Framework and .NET Standard or .NET Core, there may be different libraries for use with different .NET targets.</span></span> <span data-ttu-id="3a378-308">这允许包支持许多不同的 .NET 平台，这可能需要不同的实现。</span><span class="sxs-lookup"><span data-stu-id="3a378-308">This allows the packages to support many different .NET platforms, which may require different implementations.</span></span> <span data-ttu-id="3a378-309">这也意味着，当针对不同的 .NET 平台时，库中可能存在较小的 API 差异。</span><span class="sxs-lookup"><span data-stu-id="3a378-309">It also means that there may be small API differences in the libraries when targeting different .NET platforms.</span></span>

<span data-ttu-id="3a378-310">您将在"豆交易"示例中看到的下一组错误与`Castle.Windsor`API 相关。</span><span class="sxs-lookup"><span data-stu-id="3a378-310">The next set of errors you'll see in the Bean Trader sample are related to `Castle.Windsor` APIs.</span></span> <span data-ttu-id="3a378-311">.NET 核心 Bean Trader 项目使用与`Castle.Windsor`.NET Framework 目标项目 （4.1.1） 相同的版本，但这两个平台的实现略有不同。</span><span class="sxs-lookup"><span data-stu-id="3a378-311">The .NET Core Bean Trader project uses the same version of `Castle.Windsor` as the .NET Framework-targeted project (4.1.1), but the implementations for those two platforms are slightly different.</span></span>

<span data-ttu-id="3a378-312">在这种情况下，您将看到需要修复的以下问题：</span><span class="sxs-lookup"><span data-stu-id="3a378-312">In this case, you see the following issues that need to be fixed:</span></span>

1. <span data-ttu-id="3a378-313">`Castle.MicroKernel.Registration.Classes.FromThisAssembly`不在 .NET 核心上可用。</span><span class="sxs-lookup"><span data-stu-id="3a378-313">`Castle.MicroKernel.Registration.Classes.FromThisAssembly` isn't available on .NET Core.</span></span> <span data-ttu-id="3a378-314">但是，有类似的`Classes.FromAssemblyContaining`API 可用，因此我们可以将 调用 的`Classes.FromThisAssembly()`两个用途替换为`Classes.FromAssemblyContaining(t)`调用`t`，其中发出调用的类型在哪里。</span><span class="sxs-lookup"><span data-stu-id="3a378-314">There is, however, the similar API `Classes.FromAssemblyContaining` available, so we can replace both uses of `Classes.FromThisAssembly()` with calls to `Classes.FromAssemblyContaining(t)`, where `t` is the type making the call.</span></span>
1. <span data-ttu-id="3a378-315">同样，在*Bootstrapper.cs*`Castle.Windsor.Installer.FromAssembly`中。这在 .NET 核心上不可用。</span><span class="sxs-lookup"><span data-stu-id="3a378-315">Similarly, in *Bootstrapper.cs*, `Castle.Windsor.Installer.FromAssembly`.This is unavailable on .NET Core.</span></span> <span data-ttu-id="3a378-316">相反，该调用可以替换为`FromAssembly.Containing(typeof(Bootstrapper))`。</span><span class="sxs-lookup"><span data-stu-id="3a378-316">Instead, that call can be replaced with `FromAssembly.Containing(typeof(Bootstrapper))`.</span></span>

### <a name="updating-wcf-client-usage"></a><span data-ttu-id="3a378-317">更新 WCF 客户端使用情况</span><span class="sxs-lookup"><span data-stu-id="3a378-317">Updating WCF client usage</span></span>

<span data-ttu-id="3a378-318">修复了`Castle.Windsor`差异后，.NET Core Bean Trader 项目中最后剩余的生成错误是`BeanTraderServiceClient`（派生自`DuplexClientBase`）没有`Open`方法。</span><span class="sxs-lookup"><span data-stu-id="3a378-318">Having fixed the `Castle.Windsor` differences, the last remaining build error in the .NET Core Bean Trader project is that `BeanTraderServiceClient` (which derives from `DuplexClientBase`) doesn't have an `Open` method.</span></span> <span data-ttu-id="3a378-319">这并不奇怪，因为这是在此迁移过程开始时由 .NET 可移植性分析器突出显示的 API。</span><span class="sxs-lookup"><span data-stu-id="3a378-319">This isn't surprising since this is an API that was highlighted by the .NET Portability Analyzer at the beginning of this migration process.</span></span> <span data-ttu-id="3a378-320">不过，`BeanTraderServiceClient`让我们注意到一个更大的问题。</span><span class="sxs-lookup"><span data-stu-id="3a378-320">Looking at `BeanTraderServiceClient` draws our attention to a larger issue, though.</span></span> <span data-ttu-id="3a378-321">此 WCF 客户端由[Svcutil.exe](../../framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)工具自动生成。</span><span class="sxs-lookup"><span data-stu-id="3a378-321">This WCF client was autogenerated by the [Svcutil.exe](../../framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) tool.</span></span>

<span data-ttu-id="3a378-322">**Svcutil 生成的 WCF 客户端用于 .NET 框架。**</span><span class="sxs-lookup"><span data-stu-id="3a378-322">**WCF clients generated by Svcutil are meant for use on .NET Framework.**</span></span>

<span data-ttu-id="3a378-323">使用 svcutil 生成的 WCF 客户端的解决方案需要重新生成 .NET 标准兼容的客户端，以便与 .NET Core 一起使用。</span><span class="sxs-lookup"><span data-stu-id="3a378-323">Solutions that use svcutil-generated WCF clients will need to regenerate .NET Standard-compatible clients for use with .NET Core.</span></span> <span data-ttu-id="3a378-324">旧客户端无法工作的主要原因之一是，它们依赖于应用配置来定义 WCF 绑定和终结点。</span><span class="sxs-lookup"><span data-stu-id="3a378-324">One of the main reasons the old clients won't work is that they depend on app configuration for defining WCF bindings and endpoints.</span></span> <span data-ttu-id="3a378-325">由于 .NET 标准 WCF API 可以跨平台工作（其中 System.配置 API 不可用），因此 .NET 核心和 .NET 标准方案的 WCF 客户端必须以编程方式定义绑定和终结点，而不是在配置中定义绑定和终结点。</span><span class="sxs-lookup"><span data-stu-id="3a378-325">Because .NET Standard WCF APIs can work cross-platform (where System.Configuration APIs aren't available), WCF clients for .NET Core and .NET Standard scenarios must define bindings and endpoints programmatically instead of in configuration.</span></span>

<span data-ttu-id="3a378-326">事实上，任何 WCF 客户端使用依赖于`<system.serviceModel>`app.config 部分（无论是使用 Svcutil 还是手动创建的）都需要更改为在 .NET Core 上工作。</span><span class="sxs-lookup"><span data-stu-id="3a378-326">In fact, any WCF client usage that depends on the `<system.serviceModel>` app.config section (whether created with Svcutil or manually) will need to be changed to work on .NET Core.</span></span>

<span data-ttu-id="3a378-327">有两种方法可以自动生成与 .NET 标准兼容的 WCF 客户端：</span><span class="sxs-lookup"><span data-stu-id="3a378-327">There are two ways to automatically generate .NET Standard-compatible WCF clients:</span></span>

- <span data-ttu-id="3a378-328">该工具`dotnet-svcutil`是一个 .NET 工具，以类似于 Svcutil 以前的工作方式的方式生成 WCF 客户端。</span><span class="sxs-lookup"><span data-stu-id="3a378-328">The `dotnet-svcutil` tool is a .NET tool that generates WCF clients in a way that is similar to how Svcutil worked previously.</span></span>
- <span data-ttu-id="3a378-329">Visual Studio 可以使用其连接服务功能的[WCF Web 服务参考](../../core/additional-tools/wcf-web-service-reference-guide.md)选项生成 WCF 客户端。</span><span class="sxs-lookup"><span data-stu-id="3a378-329">Visual Studio can generate WCF clients using the [WCF Web Service Reference](../../core/additional-tools/wcf-web-service-reference-guide.md) option of its Connected Services feature.</span></span>

<span data-ttu-id="3a378-330">两种方法都有效。</span><span class="sxs-lookup"><span data-stu-id="3a378-330">Either approach works well.</span></span> <span data-ttu-id="3a378-331">或者，当然，您可以自己编写 WCF 客户端代码。</span><span class="sxs-lookup"><span data-stu-id="3a378-331">Alternatively, of course, you could write the WCF client code yourself.</span></span> <span data-ttu-id="3a378-332">对于此示例，我选择使用可视化工作室连接服务功能。</span><span class="sxs-lookup"><span data-stu-id="3a378-332">For this sample, I chose to use the Visual Studio Connected Service feature.</span></span> <span data-ttu-id="3a378-333">为此，请右键单击 Visual Studio 解决方案资源管理器中的*BeanTraderClient.Core*项目，然后选择"**添加** > **连接服务**"。</span><span class="sxs-lookup"><span data-stu-id="3a378-333">To do that, right-click on the *BeanTraderClient.Core* project in Visual Studio's solution explorer and select **Add** > **Connected Service**.</span></span> <span data-ttu-id="3a378-334">接下来，选择 WCF Web 服务参考提供程序。</span><span class="sxs-lookup"><span data-stu-id="3a378-334">Next, choose the WCF Web Service Reference Provider.</span></span> <span data-ttu-id="3a378-335">这将弹出一个对话框，您可以在其中指定后端 Bean Trader Web 服务的地址（`localhost:8080`如果您在本地运行服务器）和生成类型的命名空间应使用（例如**BeanTrader.Service）。**</span><span class="sxs-lookup"><span data-stu-id="3a378-335">This will bring up a dialog where you can specify the address of the backend Bean Trader web service (`localhost:8080` if you are running the server locally) and the namespace that generated types should use (**BeanTrader.Service**, for example).</span></span>

![WCF Web 服务参考连接的服务对话框](./media/convert-project-from-net-framework/connected-service-dialog.png)

<span data-ttu-id="3a378-337">选择 **"完成"** 按钮后，将添加新的"已连接服务"节点，并在该节点下添加一个Reference.cs文件，其中包含用于访问 Bean Trader 服务的新 .NET 标准 WCF 客户端。</span><span class="sxs-lookup"><span data-stu-id="3a378-337">After you select the **Finish** button, a new Connected Services node is added to the project and a Reference.cs file is added under that node containing the new .NET Standard WCF client for accessing the Bean Trader service.</span></span> <span data-ttu-id="3a378-338">如果查看该文件中的`GetEndpointAddress`或`GetBindingForEndpoint`方法，您将看到绑定和终结点现在以编程方式生成（而不是通过应用配置）。</span><span class="sxs-lookup"><span data-stu-id="3a378-338">If you look at the `GetEndpointAddress` or `GetBindingForEndpoint` methods in that file, you'll see that bindings and endpoints are now generated programmatically (instead of via app config).</span></span> <span data-ttu-id="3a378-339">"添加已连接服务"功能还可能添加对项目文件中某些 System.ServiceModel 包的引用，因为所有必需的 WCF 包都通过 Microsoft.Windows.兼容性包含在内，因此不需要这些引用。</span><span class="sxs-lookup"><span data-stu-id="3a378-339">The 'Add Connected Services' feature may also add references to some System.ServiceModel packages in the project file, which aren't needed since all necessary WCF packages are included via Microsoft.Windows.Compatibility.</span></span> <span data-ttu-id="3a378-340">检查 csproj 以查看是否添加了任何额外的 System.ServiceModel`<PackageReference>`项目，如果是，请删除它们。</span><span class="sxs-lookup"><span data-stu-id="3a378-340">Check the csproj to see if any extra System.ServiceModel `<PackageReference>` items have been added, and if so, remove them.</span></span>

<span data-ttu-id="3a378-341">我们的项目现在有新的WCF客户端类（*在Reference.cs），* 但它也有旧的（在BeanTrader.cs）。</span><span class="sxs-lookup"><span data-stu-id="3a378-341">Our project has new WCF client classes now (in *Reference.cs*), but it also still has the old ones (in BeanTrader.cs).</span></span> <span data-ttu-id="3a378-342">此时有两个选项：</span><span class="sxs-lookup"><span data-stu-id="3a378-342">There are two options at this point:</span></span>

- <span data-ttu-id="3a378-343">如果希望能够构建原始的 .NET Framework 项目（以及新的 .NET Core 目标项目），则可以使用`<Compile Remove="BeanTrader.cs" />`.NET Core 项目的 csproj 文件中的项目，以便应用程序的 .NET 框架和 .NET Core 版本使用不同的 WCF 客户端。</span><span class="sxs-lookup"><span data-stu-id="3a378-343">If you want to be able to build the original .NET Framework project (alongside the new .NET Core-targeted one), you can use a `<Compile Remove="BeanTrader.cs" />` item in the .NET Core project's csproj file so that the .NET Framework and .NET Core versions of the app use different WCF clients.</span></span> <span data-ttu-id="3a378-344">这样做的好处是使现有的 .NET Framework 项目保持不变，但缺点是使用生成的 WCF 客户端的代码可能需要在 .NET Core 案例中与 .NET 框架项目中的代码略有不同，因此您可能需要使用`#if`指令有条件地编译某些 WCF 客户端使用情况（例如创建客户端），以便在为 .NET Core 构建时采用单向方式工作，在为 .NET 框架构建时，可能需要另一种方式。</span><span class="sxs-lookup"><span data-stu-id="3a378-344">This has the advantage of leaving the existing .NET Framework project unchanged, but has the disadvantage that code using the generated WCF clients may need to be slightly different in the .NET Core case than it was in the .NET Framework project, so you'll likely need to use `#if` directives to conditionally compile some WCF client usage (creating clients, for example) to work one way when built for .NET Core and another way when built for .NET Framework.</span></span>

- <span data-ttu-id="3a378-345">另一方面，如果现有的 .NET Framework 项目中的某些代码改动是可以接受的，则可以同时删除*BeanTrader.cs。*</span><span class="sxs-lookup"><span data-stu-id="3a378-345">If, on the other hand, some code churn in the existing .NET Framework project is acceptable, you can remove *BeanTrader.cs* all together.</span></span> <span data-ttu-id="3a378-346">由于新的 WCF 客户端是为 .NET 标准构建的，因此它将同时在 .NET Core 和 .NET 框架方案中工作。</span><span class="sxs-lookup"><span data-stu-id="3a378-346">Because the new WCF client is built for .NET Standard, it will work in both .NET Core and .NET Framework scenarios.</span></span> <span data-ttu-id="3a378-347">如果要为 .NET 框架构建 .NET 框架（通过多目标或具有两个 csproj 文件），则可以对两个目标使用此新的*Reference.cs*文件。</span><span class="sxs-lookup"><span data-stu-id="3a378-347">If you are building for .NET Framework in addition to .NET Core (either by multi-targeting or by having two csproj files), you can use this new *Reference.cs* file for both targets.</span></span> <span data-ttu-id="3a378-348">此方法的优点是，代码不需要分叉来支持两个不同的 WCF 客户端;相同的代码将在任何地方使用。</span><span class="sxs-lookup"><span data-stu-id="3a378-348">This approach has the advantage that the code won't need to bifurcate to support two different WCF clients; the same code will be used everywhere.</span></span> <span data-ttu-id="3a378-349">缺点是它涉及更改 （大概稳定） .NET 框架项目。</span><span class="sxs-lookup"><span data-stu-id="3a378-349">The drawback is that it involves changing the (presumably stable) .NET Framework project.</span></span>

<span data-ttu-id="3a378-350">在 Bean Trader 示例中，如果原始项目使迁移更容易，则可以对原始项目进行少量更改，因此请按照以下步骤协调 WCF 客户端使用情况：</span><span class="sxs-lookup"><span data-stu-id="3a378-350">In the case of the Bean Trader sample, you can make small changes to the original project if it makes migration easier, so follow these steps to reconcile WCF client usage:</span></span>

01. <span data-ttu-id="3a378-351">使用解决方案资源管理器中的"添加现有项目"上下文菜单将新的Reference.cs文件添加到 .NET 框架*BeanTraderClient.csproj*项目中。</span><span class="sxs-lookup"><span data-stu-id="3a378-351">Add the new Reference.cs file to the .NET Framework *BeanTraderClient.csproj* project using the 'Add existing item' context menu from the solution explorer.</span></span> <span data-ttu-id="3a378-352">请务必添加"作为链接"，以便两个项目使用相同的文件（而不是复制 C# 文件）。</span><span class="sxs-lookup"><span data-stu-id="3a378-352">Be sure to add 'as link' so that the same file is used by both projects (as opposed to copying the C# file).</span></span> <span data-ttu-id="3a378-353">如果要使用单个 csproj（使用多目标）为 .NET Core 和 .NET 框架构建，则此步骤是不必要的。</span><span class="sxs-lookup"><span data-stu-id="3a378-353">If you are building for both .NET Core and .NET Framework with a single csproj (using multi-targeting) then this step isn't necessary.</span></span>

01. <span data-ttu-id="3a378-354">删除*BeanTrader.cs*。</span><span class="sxs-lookup"><span data-stu-id="3a378-354">Delete *BeanTrader.cs*.</span></span>

01. <span data-ttu-id="3a378-355">新的 WCF 客户端与旧客户端类似，但生成的代码中的多个命名空间不同。</span><span class="sxs-lookup"><span data-stu-id="3a378-355">The new WCF client is similar to the old one, but a number of namespaces in the generated code are different.</span></span> <span data-ttu-id="3a378-356">因此，有必要更新项目，以便 WCF 客户端类型从 BeanTrader.Service.Service（或您选择的任何命名空间名称）而不是 BeanTrader.Model 或没有命名空间使用。</span><span class="sxs-lookup"><span data-stu-id="3a378-356">Because of this, it is necessary to update the project so that WCF client types are used from BeanTrader.Service (or whatever namespace name you chose) instead of BeanTrader.Model or without a namespace.</span></span> <span data-ttu-id="3a378-357">构建*BeanTraderClient.Core.csproj*将有助于确定需要进行更改的位置。</span><span class="sxs-lookup"><span data-stu-id="3a378-357">Building *BeanTraderClient.Core.csproj* will help to identify where these changes need to be made.</span></span> <span data-ttu-id="3a378-358">在 C# 和 XAML 源文件中都需要修复。</span><span class="sxs-lookup"><span data-stu-id="3a378-358">Fixes will be needed both in C# and in XAML source files.</span></span>

01. <span data-ttu-id="3a378-359">最后，您将发现*BeanTraderServiceClientFactory.cs*存在错误，因为`BeanTraderServiceClient`类型的可用构造函数已更改。</span><span class="sxs-lookup"><span data-stu-id="3a378-359">Finally, you'll discover that there is an error in *BeanTraderServiceClientFactory.cs* because the available constructors for the `BeanTraderServiceClient` type have changed.</span></span> <span data-ttu-id="3a378-360">它曾经可以提供一个`InstanceContext`参数（这是使用`CallbackHandler``Castle.Windsor`IoC 容器创建的）。</span><span class="sxs-lookup"><span data-stu-id="3a378-360">It used to be possible to supply an `InstanceContext` argument (which was created using a `CallbackHandler` from the `Castle.Windsor` IoC container).</span></span> <span data-ttu-id="3a378-361">新的构造函数创建新`CallbackHandler`的 s。</span><span class="sxs-lookup"><span data-stu-id="3a378-361">The new constructors create new `CallbackHandler`s.</span></span> <span data-ttu-id="3a378-362">但是，在 基类型中`BeanTraderServiceClient`，构造函数与所需内容相匹配。</span><span class="sxs-lookup"><span data-stu-id="3a378-362">There are, however, constructors in `BeanTraderServiceClient`'s base type that match what you want.</span></span> <span data-ttu-id="3a378-363">由于自动生成的 WCF 客户端代码都存在于部分类中，因此可以轻松地扩展它。</span><span class="sxs-lookup"><span data-stu-id="3a378-363">Since the autogenerated WCF client code all exists in partial classes, you can easily extend it.</span></span> <span data-ttu-id="3a378-364">为此，请创建一个名为*BeanTraderServiceClient.cs*的新文件，然后创建具有相同名称的部分类（使用 BeanTrader.Service 命名空间）。</span><span class="sxs-lookup"><span data-stu-id="3a378-364">To do this, create a new file called *BeanTraderServiceClient.cs* and then create a partial class with that same name (using the BeanTrader.Service namespace).</span></span> <span data-ttu-id="3a378-365">然后，将一个构造函数添加到部分类型，如下所示。</span><span class="sxs-lookup"><span data-stu-id="3a378-365">Then, add one constructor to the partial type as shown here.</span></span>

    ```csharp
    public BeanTraderServiceClient(System.ServiceModel.InstanceContext callbackInstance) :
        base(callbackInstance, EndpointConfiguration.NetTcpBinding_BeanTraderService)
            { }
    ```

<span data-ttu-id="3a378-366">进行这些更改后，Bean Trader 示例现在将使用新的 .NET 标准兼容的 WCF 客户端，您可以TradingService.cs改为更改`Open`调用*TradingService.cs*`await OpenAsync`的最后修复方法。</span><span class="sxs-lookup"><span data-stu-id="3a378-366">With those changes made, the Bean Trader sample will now be using a new .NET Standard-compatible WCF client and you can make the final fix of changing the `Open` call in *TradingService.cs* to use `await OpenAsync` instead.</span></span>

<span data-ttu-id="3a378-367">随着 WCF 问题的解决，Bean Trader 示例的 .NET 核心版本现在构建干净！</span><span class="sxs-lookup"><span data-stu-id="3a378-367">With the WCF issues addressed, the .NET Core version of the Bean Trader sample now builds cleanly!</span></span>

## <a name="runtime-testing"></a><span data-ttu-id="3a378-368">运行时测试</span><span class="sxs-lookup"><span data-stu-id="3a378-368">Runtime testing</span></span>

<span data-ttu-id="3a378-369">很容易忘记，一旦项目针对 .NET Core 干净地构建，迁移工作就不会完成。</span><span class="sxs-lookup"><span data-stu-id="3a378-369">It's easy to forget that migration work isn't done as soon as the project builds cleanly against .NET Core.</span></span> <span data-ttu-id="3a378-370">留出时间测试移植的应用程序也很重要。</span><span class="sxs-lookup"><span data-stu-id="3a378-370">It's important to leave time for testing the ported app, too.</span></span> <span data-ttu-id="3a378-371">成功生成内容后，请确保应用按预期运行并工作，尤其是在使用针对 .NET Framework 的任何包时。</span><span class="sxs-lookup"><span data-stu-id="3a378-371">Once things build successfully, make sure the app runs and works as expected, especially if you are using any packages targeting .NET Framework.</span></span>

<span data-ttu-id="3a378-372">让我们尝试启动移植的豆交易应用程序，看看会发生什么。</span><span class="sxs-lookup"><span data-stu-id="3a378-372">Let's try launching the ported Bean Trader app and see what happens.</span></span> <span data-ttu-id="3a378-373">除了以下例外情况外，应用在失败之前不会走得太远。</span><span class="sxs-lookup"><span data-stu-id="3a378-373">The app doesn't get far before failing with the following exception.</span></span>

```output
System.Configuration.ConfigurationErrorsException: 'Configuration system failed to initialize'

Inner Exception
ConfigurationErrorsException: Unrecognized configuration section system.serviceModel.
```

<span data-ttu-id="3a378-374">当然，这是有道理的。</span><span class="sxs-lookup"><span data-stu-id="3a378-374">This makes sense, of course.</span></span> <span data-ttu-id="3a378-375">请记住，WCF 不再使用应用配置，因此需要删除 app.config 文件的旧系统.serviceModel 部分。</span><span class="sxs-lookup"><span data-stu-id="3a378-375">Remember that WCF no longer uses app configuration, so the old system.serviceModel section of the app.config file needs to be removed.</span></span> <span data-ttu-id="3a378-376">更新后的 WCF 客户端在其代码中包含所有相同的信息，因此不再需要配置部分。</span><span class="sxs-lookup"><span data-stu-id="3a378-376">The updated WCF client includes all of the same information in its code, so the config section isn't needed anymore.</span></span> <span data-ttu-id="3a378-377">如果希望 WCF 终结点在 app.config 中可配置，则可以将其添加为应用设置，并更新 WCF 客户端代码以从配置中检索 WCF 服务终结点。</span><span class="sxs-lookup"><span data-stu-id="3a378-377">If you wanted the WCF endpoint to be configurable in app.config, you could add it as an app setting and update the WCF client code to retrieve the WCF service endpoint from configuration.</span></span>

<span data-ttu-id="3a378-378">删除*app.config*的 system.serviceModel 部分后，应用启动，但在用户登录时失败，但另一个例外。</span><span class="sxs-lookup"><span data-stu-id="3a378-378">After removing the system.serviceModel section of *app.config*, the app launches but fails with another exception when a user signs in.</span></span>

```output
System.PlatformNotSupportedException: 'Operation is not supported on this platform.'
```

<span data-ttu-id="3a378-379">不支持的 API`Func<T>.BeginInvoke`是 。</span><span class="sxs-lookup"><span data-stu-id="3a378-379">The unsupported API is `Func<T>.BeginInvoke`.</span></span> <span data-ttu-id="3a378-380">如[dotnet/corefx_5940](https://github.com/dotnet/corefx/issues/5940)中所述，.NET Core 不支持`BeginInvoke`委托`EndInvoke`类型和方法，因为存在基础的远程处理依赖关系。</span><span class="sxs-lookup"><span data-stu-id="3a378-380">As explained in [dotnet/corefx#5940](https://github.com/dotnet/corefx/issues/5940), .NET Core doesn't support the `BeginInvoke` and `EndInvoke` methods on delegate types due to underlying remoting dependencies.</span></span> <span data-ttu-id="3a378-381">此问题及其修复程序在迁移委托中进行了更详细的解释[。 BeginInvoke 调用 .NET Core](https://devblogs.microsoft.com/dotnet/migrating-delegate-begininvoke-calls-for-net-core/)博客文章，但要点是，`BeginInvoke``EndInvoke`调用应替换为`Task.Run`（或异步替代，如果可能）。</span><span class="sxs-lookup"><span data-stu-id="3a378-381">This issue and its fix are explained in more detail in the [Migrating Delegate.BeginInvoke Calls for .NET Core](https://devblogs.microsoft.com/dotnet/migrating-delegate-begininvoke-calls-for-net-core/) blog post, but the gist is that `BeginInvoke` and `EndInvoke` calls should be replaced with `Task.Run` (or async alternatives, if possible).</span></span> <span data-ttu-id="3a378-382">在此处应用常规解决方案，`BeginInvoke`呼叫可以替换为 由`Invoke``Task.Run`启动的呼叫。</span><span class="sxs-lookup"><span data-stu-id="3a378-382">Applying the general solution here, the `BeginInvoke` call can be replaced with an `Invoke` call launched by `Task.Run`.</span></span>

```csharp
Task.Run(() =>
{
    return userInfoRetriever.Invoke();
}).ContinueWith(result =>
{
    // BeginInvoke's callback is replaced with ContinueWith
    var task = result.ConfigureAwait(false);
    CurrentTrader = task.GetAwaiter().GetResult();
}, TaskScheduler.Default);
```

<span data-ttu-id="3a378-383">删除`BeginInvoke`使用后，豆交易者应用程序在 .NET 核心上成功运行！</span><span class="sxs-lookup"><span data-stu-id="3a378-383">After removing the `BeginInvoke` usage, the Bean Trader app runs successfully on .NET Core!</span></span>

![在 .NET 核心上运行的豆交易者](./media/convert-project-from-net-framework/running-on-core.png)

<span data-ttu-id="3a378-385">所有应用都不同，因此将您自己的应用迁移到 .NET Core 所需的特定步骤会有所不同。</span><span class="sxs-lookup"><span data-stu-id="3a378-385">All apps are different, so the specific steps needed to migrate your own apps to .NET Core will vary.</span></span> <span data-ttu-id="3a378-386">但希望 Bean Trader 示例演示了常规工作流和可以预期的问题类型。</span><span class="sxs-lookup"><span data-stu-id="3a378-386">But hopefully the Bean Trader sample demonstrates the general workflow and the types of issues that can be expected.</span></span> <span data-ttu-id="3a378-387">而且，尽管本文的长度，豆交易者样本中所需的实际更改，使其在 .NET Core 上工作相当有限。</span><span class="sxs-lookup"><span data-stu-id="3a378-387">And, despite this article's length, the actual changes needed in the Bean Trader sample to make it work on .NET Core were fairly limited.</span></span> <span data-ttu-id="3a378-388">许多应用以同样方式迁移到 .NET Core;需要有限甚至无需更改代码。</span><span class="sxs-lookup"><span data-stu-id="3a378-388">Many apps migrate to .NET Core in this same way; with limited or even no code changes needed.</span></span>
