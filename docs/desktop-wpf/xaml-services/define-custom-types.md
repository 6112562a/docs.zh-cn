---
title: 定义与 .NET XAML 服务一起使用的自定义类型
ms.date: 03/30/2017
helpviewer_keywords:
- defining custom types [XAML Services]
ms.assetid: c2667cbd-2f46-4a7f-9dfc-53696e35e8e4
ms.openlocfilehash: ff7e4229450e801a6d618c5141efde8cdcbef03d
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/12/2020
ms.locfileid: "81433072"
---
# <a name="define-custom-types-for-use-with-net-xaml-services"></a><span data-ttu-id="c3455-102">定义用于 .NET XAML 服务的自定义类型</span><span class="sxs-lookup"><span data-stu-id="c3455-102">Define custom types for use with .NET XAML Services</span></span>

<span data-ttu-id="c3455-103">当您定义业务对象或对特定框架不依赖的类型时，您可以遵循 XAML 的某些最佳做法。</span><span class="sxs-lookup"><span data-stu-id="c3455-103">When you define custom types that are business objects or are types that do not have a dependency on specific frameworks, there are certain best practices for XAML you can follow.</span></span> <span data-ttu-id="c3455-104">如果您遵循这些实践，.NET XAML 服务及其 XAML 读取器和 XAML 编写器可以发现您类型的 XAML 特征，并使用 XAML 类型系统在 XAML 节点流中为其提供适当的表示形式。</span><span class="sxs-lookup"><span data-stu-id="c3455-104">If you follow these practices, .NET XAML Services and its XAML readers and XAML writers can discover the XAML characteristics of your type and give it appropriate representation in a XAML node stream using the XAML type system.</span></span> <span data-ttu-id="c3455-105">本主题介绍类型定义、成员定义和类型或成员的 CLR 归因的最佳做法。</span><span class="sxs-lookup"><span data-stu-id="c3455-105">This topic describes best practices for type definitions, member definitions, and CLR attributing of types or members.</span></span>

## <a name="constructor-patterns-and-type-definitions-for-xaml"></a><span data-ttu-id="c3455-106">XAML 的构造函数模式和类型定义</span><span class="sxs-lookup"><span data-stu-id="c3455-106">Constructor Patterns and Type Definitions for XAML</span></span>

<span data-ttu-id="c3455-107">要在 XAML 中实例化为对象元素，自定义类必须满足以下要求：</span><span class="sxs-lookup"><span data-stu-id="c3455-107">To be instantiated as an object element in XAML, a custom class must meet the following requirements:</span></span>

- <span data-ttu-id="c3455-108">自定义类必须是公共的，并且必须公开无参数的公共构造函数。</span><span class="sxs-lookup"><span data-stu-id="c3455-108">The custom class must be public and must expose a parameterless public constructor.</span></span> <span data-ttu-id="c3455-109">（有关结构注释，请参阅下节内容。）</span><span class="sxs-lookup"><span data-stu-id="c3455-109">(See following section for notes regarding structures.)</span></span>

- <span data-ttu-id="c3455-110">自定义类不能是嵌套类。</span><span class="sxs-lookup"><span data-stu-id="c3455-110">The custom class must not be a nested class.</span></span> <span data-ttu-id="c3455-111">全名路径中的额外"点"使类命名空间划分不明确，并干扰其他 XAML 功能（如附加属性）。</span><span class="sxs-lookup"><span data-stu-id="c3455-111">The extra "dot" in the full-name path makes the class-namespace division ambiguous, and interferes with other XAML features such as attached properties.</span></span>
<span data-ttu-id="c3455-112">如果对象可以实例化为对象元素，则创建的对象可以填充将对象作为其基础类型的任何属性的属性元素形式。</span><span class="sxs-lookup"><span data-stu-id="c3455-112">If an object can be instantiated as an object element, the created object can fill the property element form of any properties that take the object as their underlying type.</span></span>

<span data-ttu-id="c3455-113">如果启用值转换器，仍可以为不符合这些标准的类型提供对象值。</span><span class="sxs-lookup"><span data-stu-id="c3455-113">You can still provide object values for types that do not meet these criteria, if you enable a value converter.</span></span> <span data-ttu-id="c3455-114">有关详细信息，请参阅[XAML 的类型转换器和标记扩展](type-converters-and-markup-extensions.md)。</span><span class="sxs-lookup"><span data-stu-id="c3455-114">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

### <a name="structures"></a><span data-ttu-id="c3455-115">结构</span><span class="sxs-lookup"><span data-stu-id="c3455-115">Structures</span></span>

<span data-ttu-id="c3455-116">结构始终能够在 XAML 中通过 CLR 定义构造。</span><span class="sxs-lookup"><span data-stu-id="c3455-116">Structures are always able to be constructed in XAML, by CLR definition.</span></span> <span data-ttu-id="c3455-117">这是因为 CLR 编译器隐式为结构创建了无参数构造函数。</span><span class="sxs-lookup"><span data-stu-id="c3455-117">This is because a CLR compiler implicitly creates a parameterless constructor for a structure.</span></span> <span data-ttu-id="c3455-118">此构造函数将所有属性值初始化到其默认值。</span><span class="sxs-lookup"><span data-stu-id="c3455-118">This constructor initializes all property values to their defaults.</span></span>

<span data-ttu-id="c3455-119">在某些情况下，结构的默认构造行为是不需要的。</span><span class="sxs-lookup"><span data-stu-id="c3455-119">In some cases, the default construction behavior for a structure is not desirable.</span></span> <span data-ttu-id="c3455-120">这可能是因为结构旨在填充值，并在概念上作为联合进行函数。</span><span class="sxs-lookup"><span data-stu-id="c3455-120">This might be because the structure is intended to fill values and function conceptually as a union.</span></span> <span data-ttu-id="c3455-121">作为联合，包含的值可能具有互斥的解释，因此，其属性都不是可设置的。</span><span class="sxs-lookup"><span data-stu-id="c3455-121">As a union, the contained values might have mutually exclusive interpretations, and therefore, none of its properties are settable.</span></span> <span data-ttu-id="c3455-122">WPF 词汇中这种结构的一个示例是<xref:System.Windows.GridLength>。</span><span class="sxs-lookup"><span data-stu-id="c3455-122">An example of such a structure in the WPF vocabulary is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="c3455-123">此类结构应实现类型转换器，以便通过使用创建结构值的不同解释或模式的字符串约定，以属性形式表示值。</span><span class="sxs-lookup"><span data-stu-id="c3455-123">Such structures should implement a type converter so that the values can be expressed in attribute form, by using string conventions that create the different interpretations or modes of the structure values.</span></span> <span data-ttu-id="c3455-124">结构还应通过非参数构造函数公开代码构造的类似行为。</span><span class="sxs-lookup"><span data-stu-id="c3455-124">The structure should also expose similar behavior for code construction through a non-parameterless constructor.</span></span>

### <a name="interfaces"></a><span data-ttu-id="c3455-125">接口</span><span class="sxs-lookup"><span data-stu-id="c3455-125">Interfaces</span></span>

<span data-ttu-id="c3455-126">接口可用作成员的基础类型。</span><span class="sxs-lookup"><span data-stu-id="c3455-126">Interfaces can be used as underlying types of members.</span></span> <span data-ttu-id="c3455-127">XAML 类型系统检查可分配列表，并期望作为值提供的对象可以分配给接口。</span><span class="sxs-lookup"><span data-stu-id="c3455-127">The XAML type system checks the assignable list and expects that the object that is provided as the value can be assigned to the interface.</span></span> <span data-ttu-id="c3455-128">只要相关的可分配类型支持 XAML 构造要求，则对于接口必须作为 XAML 类型呈现的概念是没有概念的。</span><span class="sxs-lookup"><span data-stu-id="c3455-128">There is no concept of how the interface must be presented as a XAML type as long as a relevant assignable type supports the XAML construction requirements.</span></span>

### <a name="factory-methods"></a><span data-ttu-id="c3455-129">工厂方法</span><span class="sxs-lookup"><span data-stu-id="c3455-129">Factory Methods</span></span>

<span data-ttu-id="c3455-130">工厂方法是 XAML 2009 功能。</span><span class="sxs-lookup"><span data-stu-id="c3455-130">Factory methods are a XAML 2009 feature.</span></span> <span data-ttu-id="c3455-131">它们修改了 XAML 原则，即对象必须具有无参数构造函数。</span><span class="sxs-lookup"><span data-stu-id="c3455-131">They modify the XAML principle that objects must have parameterless constructors.</span></span> <span data-ttu-id="c3455-132">本文没有记录工厂方法。</span><span class="sxs-lookup"><span data-stu-id="c3455-132">Factory methods are not documented in this article.</span></span> <span data-ttu-id="c3455-133">请参阅[x：工厂方法指令](xfactorymethod-directive.md)。</span><span class="sxs-lookup"><span data-stu-id="c3455-133">See [x:FactoryMethod Directive](xfactorymethod-directive.md).</span></span>

## <a name="enumerations"></a><span data-ttu-id="c3455-134">枚举</span><span class="sxs-lookup"><span data-stu-id="c3455-134">Enumerations</span></span>

<span data-ttu-id="c3455-135">枚举具有 XAML 本机类型转换行为。</span><span class="sxs-lookup"><span data-stu-id="c3455-135">Enumerations have XAML native type conversion behavior.</span></span> <span data-ttu-id="c3455-136">根据基础枚举类型解析 XAML 中指定的枚举常量名称，并将枚举值返回给 XAML 对象编写器。</span><span class="sxs-lookup"><span data-stu-id="c3455-136">Enumeration constant names specified in XAML are resolved against the underlying enumeration type, and return the enumeration value to a XAML object writer.</span></span>

<span data-ttu-id="c3455-137">XAML 支持<xref:System.FlagsAttribute>应用的枚举标记样式用法。</span><span class="sxs-lookup"><span data-stu-id="c3455-137">XAML supports a flags-style usage for enumerations with <xref:System.FlagsAttribute> applied.</span></span> <span data-ttu-id="c3455-138">有关详细信息，请参阅[XAML 语法详细信息](../../framework/wpf/advanced/xaml-syntax-in-detail.md)。</span><span class="sxs-lookup"><span data-stu-id="c3455-138">For more information, see [XAML Syntax In Detail](../../framework/wpf/advanced/xaml-syntax-in-detail.md).</span></span> <span data-ttu-id="c3455-139">[（XAML 语法详细](../../framework/wpf/advanced/xaml-syntax-in-detail.md)为 WPF 受众编写，但该主题中的大多数信息与不特定于特定实现框架的 XAML 相关。</span><span class="sxs-lookup"><span data-stu-id="c3455-139">([XAML Syntax In Detail](../../framework/wpf/advanced/xaml-syntax-in-detail.md) is written for the WPF audience, but most of the information in that topic is relevant for XAML that is not specific to a particular implementing framework.)</span></span>

## <a name="member-definitions"></a><span data-ttu-id="c3455-140">成员定义</span><span class="sxs-lookup"><span data-stu-id="c3455-140">Member Definitions</span></span>

<span data-ttu-id="c3455-141">类型可以为 XAML 使用定义成员。</span><span class="sxs-lookup"><span data-stu-id="c3455-141">Types can define members for XAML usage.</span></span> <span data-ttu-id="c3455-142">类型可以定义 XAML 可用的成员，即使该特定类型不可用于 XAML。</span><span class="sxs-lookup"><span data-stu-id="c3455-142">It's possible for types to define members that are XAML-usable even if that specific type is not XAML-usable.</span></span> <span data-ttu-id="c3455-143">这是可能的，因为CLR继承。</span><span class="sxs-lookup"><span data-stu-id="c3455-143">This is possible because of CLR inheritance.</span></span> <span data-ttu-id="c3455-144">只要继承该成员的某些类型支持 XAML 使用作为类型，并且该成员支持其基础类型的 XAML 用法或具有本机 XAML 语法可用，该成员即可用于 XAML。</span><span class="sxs-lookup"><span data-stu-id="c3455-144">So long as some type that inherits the member supports XAML usage as a type, and the member supports XAML usage for its underlying type or has a native XAML syntax available, that member is XAML-usable.</span></span>

### <a name="properties"></a><span data-ttu-id="c3455-145">属性</span><span class="sxs-lookup"><span data-stu-id="c3455-145">Properties</span></span>

<span data-ttu-id="c3455-146">如果使用典型的`get`CLR 和访问模式以及`set`语言适当的关键字将属性定义为公共 CLR 属性，则 XAML 类型系统可以将该属性报告为成员，并提供有关<xref:System.Xaml.XamlMember>属性（如<xref:System.Xaml.XamlMember.IsReadPublic%2A>和<xref:System.Xaml.XamlMember.IsWritePublic%2A>）等属性的适当信息。</span><span class="sxs-lookup"><span data-stu-id="c3455-146">If you define properties as a public CLR property using the typical CLR `get` and `set` accessor patterns and language-appropriate keywording, the XAML type system can report the property as a member with appropriate information provided for <xref:System.Xaml.XamlMember> properties, such as <xref:System.Xaml.XamlMember.IsReadPublic%2A> and <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span></span>

<span data-ttu-id="c3455-147">特定属性可以通过应用<xref:System.ComponentModel.TypeConverterAttribute>启用文本语法来启用文本语法。</span><span class="sxs-lookup"><span data-stu-id="c3455-147">Specific properties can enable a text syntax by applying <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="c3455-148">有关详细信息，请参阅[XAML 的类型转换器和标记扩展](type-converters-and-markup-extensions.md)。</span><span class="sxs-lookup"><span data-stu-id="c3455-148">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

<span data-ttu-id="c3455-149">在没有文本语法或本机 XAML 转换的情况下，在没有进一步间接（如标记扩展用法）的情况下，属性的类型（<xref:System.Xaml.XamlMember.TargetType%2A>在 XAML 类型系统中）必须能够将实例视为 CLR 类型，将实例返回到 XAML 对象编写器。</span><span class="sxs-lookup"><span data-stu-id="c3455-149">In the absence of a text syntax or native XAML conversion and in the absence of further indirection, such as a markup extension usage, the type of a property (<xref:System.Xaml.XamlMember.TargetType%2A> in the XAML type system) must be able to return an instance to a XAML object writer by treating the target type as a CLR type.</span></span>

<span data-ttu-id="c3455-150">如果使用 XAML 2009，则如果未满足以前的注意事项，可以使用[x：参考标记扩展](xreference-markup-extension.md)提供值;但是，这更多的是使用问题，而不是类型定义问题。</span><span class="sxs-lookup"><span data-stu-id="c3455-150">If using XAML 2009, [x:Reference Markup Extension](xreference-markup-extension.md) can be used to provide values if the previous considerations are not met; however, that is more of a usage issue than a type definition issue.</span></span>

### <a name="events"></a><span data-ttu-id="c3455-151">事件</span><span class="sxs-lookup"><span data-stu-id="c3455-151">Events</span></span>

<span data-ttu-id="c3455-152">如果将事件定义为公共 CLR 事件，XAML 类型系统可以将事件报告为 具有<xref:System.Xaml.XamlMember.IsEvent%2A>的成员。 `true`</span><span class="sxs-lookup"><span data-stu-id="c3455-152">If you define events as a public CLR event, the XAML type system can report the event as a member with <xref:System.Xaml.XamlMember.IsEvent%2A> as `true`.</span></span> <span data-ttu-id="c3455-153">连接事件处理程序不在 .NET XAML 服务功能范围内;因此，在 .NET XAML 服务功能范围内，则对事件处理程序进行布线。线路留给特定的框架和实现。</span><span class="sxs-lookup"><span data-stu-id="c3455-153">Wiring the event handlers is not within the scope of .NET XAML Services capabilities; wiring is left to specific frameworks and implementations.</span></span>

### <a name="methods"></a><span data-ttu-id="c3455-154">方法</span><span class="sxs-lookup"><span data-stu-id="c3455-154">Methods</span></span>

<span data-ttu-id="c3455-155">方法的内联代码不是默认的 XAML 功能。</span><span class="sxs-lookup"><span data-stu-id="c3455-155">Inline code for methods is not a default XAML capability.</span></span> <span data-ttu-id="c3455-156">在大多数情况下，您不会直接引用 XAML 中的方法成员，并且方法在 XAML 中的角色只是为特定的 XAML 模式提供支持。</span><span class="sxs-lookup"><span data-stu-id="c3455-156">In most cases, you do not directly reference method members from XAML, and the role of methods in XAML is only to provide support for specific XAML patterns.</span></span> <span data-ttu-id="c3455-157">[x：工厂方法指令](xfactorymethod-directive.md)是一个例外。</span><span class="sxs-lookup"><span data-stu-id="c3455-157">[x:FactoryMethod Directive](xfactorymethod-directive.md) is an exception.</span></span>

### <a name="fields"></a><span data-ttu-id="c3455-158">字段</span><span class="sxs-lookup"><span data-stu-id="c3455-158">Fields</span></span>

<span data-ttu-id="c3455-159">CLR 设计指南阻止非静态字段。</span><span class="sxs-lookup"><span data-stu-id="c3455-159">CLR design guidelines discourage nonstatic fields.</span></span> <span data-ttu-id="c3455-160">对于静态字段，只能通过[x：静态标记扩展](xstatic-markup-extension.md)访问静态字段值。在这种情况下，您没有在 CLR 定义中执行任何特殊操作来公开[x：静态](xstatic-markup-extension.md)用法的字段。</span><span class="sxs-lookup"><span data-stu-id="c3455-160">For static fields, you can access static field values only through [x:Static Markup Extension](xstatic-markup-extension.md); in this case you are not doing anything special in the CLR definition to expose a field for [x:Static](xstatic-markup-extension.md) usages.</span></span>

## <a name="attachable-members"></a><span data-ttu-id="c3455-161">可附加成员</span><span class="sxs-lookup"><span data-stu-id="c3455-161">Attachable Members</span></span>

<span data-ttu-id="c3455-162">可附加成员通过定义类型上的访问器方法模式向 XAML 公开。</span><span class="sxs-lookup"><span data-stu-id="c3455-162">Attachable members are exposed to XAML through an accessor method pattern on a defining type.</span></span> <span data-ttu-id="c3455-163">定义类型本身不需要 XAML 作为对象可用。</span><span class="sxs-lookup"><span data-stu-id="c3455-163">The defining type itself does not need to be XAML-usable as an object.</span></span> <span data-ttu-id="c3455-164">实际上，一种常见模式是声明服务类，其作用是拥有可附加成员并实现相关行为，但不提供其他函数，如 UI 表示形式。</span><span class="sxs-lookup"><span data-stu-id="c3455-164">In fact, a common pattern is to declare a service class whose role is to own the attachable member and implement the related behaviors, but serve no other function such as a UI representation.</span></span> <span data-ttu-id="c3455-165">对于以下部分，占位符*属性名称*表示可附加成员的名称。</span><span class="sxs-lookup"><span data-stu-id="c3455-165">For the following sections, the placeholder *PropertyName* represents the name of your attachable member.</span></span> <span data-ttu-id="c3455-166">该名称必须在[XamlName 语法](xamlname-grammar.md)中有效。</span><span class="sxs-lookup"><span data-stu-id="c3455-166">That name must be valid in the [XamlName Grammar](xamlname-grammar.md).</span></span>

<span data-ttu-id="c3455-167">小心这些模式和类型的其他方法之间的名称冲突。</span><span class="sxs-lookup"><span data-stu-id="c3455-167">Be cautious of name collisions between these patterns and other methods of a type.</span></span> <span data-ttu-id="c3455-168">如果存在与其中一种模式匹配的成员，则 XAML 处理器可以将其解释为可附加成员使用路径，即使这不是您的意图。</span><span class="sxs-lookup"><span data-stu-id="c3455-168">If a member exists that matches one of the patterns, it can be interpreted as an attachable member usage pathway by a XAML processor even if that was not your intention.</span></span>

#### <a name="the-getpropertyname-accessor"></a><span data-ttu-id="c3455-169">获取属性名称访问器</span><span class="sxs-lookup"><span data-stu-id="c3455-169">The GetPropertyName Accessor</span></span>

<span data-ttu-id="c3455-170">访问器的签名`GetPropertyName`必须为：</span><span class="sxs-lookup"><span data-stu-id="c3455-170">The signature for the `GetPropertyName` accessor must be:</span></span>

`public static object GetPropertyName(object target)`

- <span data-ttu-id="c3455-171">`target` 对象在实现中可以指定为更具体的类型。</span><span class="sxs-lookup"><span data-stu-id="c3455-171">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="c3455-172">您可以使用它来限定可附加成员的使用范围;预期范围以外的用法将引发无效强制转换异常，然后由 XAML 分析错误显示。</span><span class="sxs-lookup"><span data-stu-id="c3455-172">You can use this to scope the usage of your attachable member; usages outside your intended scope will throw invalid cast exceptions that are then surfaced by a XAML parse error.</span></span> <span data-ttu-id="c3455-173">参数名称`target`不是要求，但在大多数实现中按约定`target`命名。</span><span class="sxs-lookup"><span data-stu-id="c3455-173">The parameter name `target` is not a requirement, but is named `target` by convention in most implementations.</span></span>

- <span data-ttu-id="c3455-174">返回值在实现中可以指定为更具体的类型。</span><span class="sxs-lookup"><span data-stu-id="c3455-174">The return value can be specified as a more specific type in your implementation.</span></span>

<span data-ttu-id="c3455-175">要支持<xref:System.ComponentModel.TypeConverter>启用的文本语法，以便附加成员的属性使用，请应用于<xref:System.ComponentModel.TypeConverterAttribute>`GetPropertyName`访问器。</span><span class="sxs-lookup"><span data-stu-id="c3455-175">To support a <xref:System.ComponentModel.TypeConverter> enabled text syntax for attribute usage of the attachable member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `GetPropertyName` accessor.</span></span> <span data-ttu-id="c3455-176">申请`get`，而不是`set`可能看起来不直观;但是，此约定可以支持可序列化的只读可附加成员的概念，这在设计器方案中很有用。</span><span class="sxs-lookup"><span data-stu-id="c3455-176">Applying to the `get` instead of the `set` may seem non-intuitive; however, this convention can support the concept of read-only attachable members that are serializable, which is useful in designer scenarios.</span></span>

#### <a name="the-setpropertyname-accessor"></a><span data-ttu-id="c3455-177">设置属性名称访问器</span><span class="sxs-lookup"><span data-stu-id="c3455-177">The SetPropertyName Accessor</span></span>

<span data-ttu-id="c3455-178">访问器的签名`SetPropertyName`必须为：</span><span class="sxs-lookup"><span data-stu-id="c3455-178">The signature for the `SetPropertyName` accessor must be:</span></span>

`public static void SetPropertyName(object target, object value)`

- <span data-ttu-id="c3455-179">该`target`对象可以指定为实现中更具体的类型，其逻辑和后果与上一节所述相同。</span><span class="sxs-lookup"><span data-stu-id="c3455-179">The `target` object can be specified as a more specific type in your implementation, with same logic and consequences as described in the previous section.</span></span>

- <span data-ttu-id="c3455-180">`value` 对象在实现中可以指定为更具体的类型。</span><span class="sxs-lookup"><span data-stu-id="c3455-180">The `value` object can be specified as a more specific type in your implementation.</span></span>

<span data-ttu-id="c3455-181">请记住，此方法的值是来自 XAML 用法的输入，通常以属性形式提供。</span><span class="sxs-lookup"><span data-stu-id="c3455-181">Remember that the value for this method is the input coming from the XAML usage, typically in attribute form.</span></span> <span data-ttu-id="c3455-182">从属性窗体中，必须支持文本语法的值转换器，并且对`GetPropertyName`s 访问器的属性。</span><span class="sxs-lookup"><span data-stu-id="c3455-182">From attribute form there must be value converter support for a text syntax, and you attribute on the `GetPropertyName`s accessor.</span></span>

### <a name="attachable-member-stores"></a><span data-ttu-id="c3455-183">可附加会员商店</span><span class="sxs-lookup"><span data-stu-id="c3455-183">Attachable Member Stores</span></span>

<span data-ttu-id="c3455-184">访问器方法通常不足以提供将可附加成员值放入对象图形的方法，或从对象图中检索值并正确序列化它们。</span><span class="sxs-lookup"><span data-stu-id="c3455-184">The accessor methods are typically not enough to provide a means to place attachable member values into an object graph, or to retrieve values out of the object graph and serialize them properly.</span></span> <span data-ttu-id="c3455-185">要提供此功能，`target`以前访问器签名中的对象必须能够存储值。</span><span class="sxs-lookup"><span data-stu-id="c3455-185">To provide this functionality, the `target` objects in the previous accessor signatures must be capable of storing values.</span></span> <span data-ttu-id="c3455-186">存储机制应符合可附加成员原则，即成员可附加到可附加成员不在成员列表中的目标。</span><span class="sxs-lookup"><span data-stu-id="c3455-186">The storage mechanism should be consistent with the attachable member principle that the member is attachable to targets where the attachable member is not in the members list.</span></span> <span data-ttu-id="c3455-187">.NET XAML 服务通过 API<xref:System.Xaml.IAttachedPropertyStore>和<xref:System.Xaml.AttachablePropertyServices>为可附加成员存储提供了一种实现技术。</span><span class="sxs-lookup"><span data-stu-id="c3455-187">.NET XAML Services provides an implementation technique for attachable member stores through the APIs <xref:System.Xaml.IAttachedPropertyStore> and <xref:System.Xaml.AttachablePropertyServices>.</span></span> <span data-ttu-id="c3455-188"><xref:System.Xaml.IAttachedPropertyStore>XAML 编写器用于发现存储实现，并且应在访问器`target`的类型上实现。</span><span class="sxs-lookup"><span data-stu-id="c3455-188"><xref:System.Xaml.IAttachedPropertyStore> is used by the XAML writers to discover the store implementation, and should be implemented on the type that is the `target` of the accessors.</span></span> <span data-ttu-id="c3455-189">静态<xref:System.Xaml.AttachablePropertyServices>API 在访问器的正文中使用，并通过 其<xref:System.Xaml.AttachableMemberIdentifier>引用可连接成员。</span><span class="sxs-lookup"><span data-stu-id="c3455-189">The static <xref:System.Xaml.AttachablePropertyServices> APIs are used within the body of the accessors, and refer to the attachable member by its <xref:System.Xaml.AttachableMemberIdentifier>.</span></span>

## <a name="xaml-related-clr-attributes"></a><span data-ttu-id="c3455-190">与 XAML 相关的 CLR 属性</span><span class="sxs-lookup"><span data-stu-id="c3455-190">XAML-Related CLR Attributes</span></span>

<span data-ttu-id="c3455-191">正确分配类型、成员和程序集对于向 .NET XAML 服务报告 XAML 类型系统信息非常重要。</span><span class="sxs-lookup"><span data-stu-id="c3455-191">Correctly attributing your types, members, and assemblies is important in order to report XAML type system information to .NET XAML Services.</span></span> <span data-ttu-id="c3455-192">如果适用以下任一情况，报告 XAML 类型系统信息是相关的：</span><span class="sxs-lookup"><span data-stu-id="c3455-192">Reporting XAML type system information is relevant if either of the following situations apply:</span></span>

- <span data-ttu-id="c3455-193">您希望类型与直接基于 .NET XAML 服务 XAML 服务读取器和 XAML 写入器的 XAML 系统一起使用。</span><span class="sxs-lookup"><span data-stu-id="c3455-193">You intend your types for use with XAML systems that are directly based on .NET XAML Services XAML readers and XAML writers.</span></span>
- <span data-ttu-id="c3455-194">您定义或使用基于这些 XAML 读取器和 XAML 编写器的 XAML 利用框架。</span><span class="sxs-lookup"><span data-stu-id="c3455-194">You define or use a XAML-utilizing framework that's based on those XAML readers and XAML writers.</span></span>

<span data-ttu-id="c3455-195">有关与自定义类型的 XAML 支持相关的每个 XAML 相关属性的列表，请参阅[自定义类型和库的 XAML 相关 CLR 属性](clr-attributes-with-custom-types-and-libraries.md)。</span><span class="sxs-lookup"><span data-stu-id="c3455-195">For a listing of each XAML-related attribute that's relevant for XAML support of your custom types, see [XAML-Related CLR Attributes for Custom Types and Libraries](clr-attributes-with-custom-types-and-libraries.md).</span></span>

## <a name="usage"></a><span data-ttu-id="c3455-196">使用情况</span><span class="sxs-lookup"><span data-stu-id="c3455-196">Usage</span></span>

<span data-ttu-id="c3455-197">自定义类型的使用要求标记作者必须映射包含自定义类型的程序集和 CLR 命名空间的前缀。</span><span class="sxs-lookup"><span data-stu-id="c3455-197">Usage of custom types requires that the markup author must map a prefix for the assembly and CLR namespace that contain the custom type.</span></span> <span data-ttu-id="c3455-198">本主题中未记录此过程。</span><span class="sxs-lookup"><span data-stu-id="c3455-198">This procedure is not documented in this topic.</span></span>

## <a name="access-level"></a><span data-ttu-id="c3455-199">访问级别</span><span class="sxs-lookup"><span data-stu-id="c3455-199">Access Level</span></span>

<span data-ttu-id="c3455-200">XAML 提供了一种加载和实例化具有`internal`访问级别的类型的方法。</span><span class="sxs-lookup"><span data-stu-id="c3455-200">XAML provides a means to load and instantiate types that have an `internal` access level.</span></span> <span data-ttu-id="c3455-201">提供此功能，以便用户代码可以定义自己的类型，然后从也是同一用户代码作用域的标记实例化这些类。</span><span class="sxs-lookup"><span data-stu-id="c3455-201">This capability is provided so that user code can define its own types, and then instantiate those classes from markup that is also part of the same user code scope.</span></span>

<span data-ttu-id="c3455-202">WPF 的一个示例是，每当用户代码<xref:System.Windows.Controls.UserControl>定义 旨在重构 UI 行为的方法时，而不是作为任何可能的扩展机制的一部分，这些扩展机制可能通过声明具有`public`访问级别的支持类来暗示。</span><span class="sxs-lookup"><span data-stu-id="c3455-202">An example from WPF is whenever user code defines a <xref:System.Windows.Controls.UserControl> that is intended as a way to refactor a UI behavior, but not as part of any possible extension mechanism that might be implied by declaring the supporting class with `public` access level.</span></span> <span data-ttu-id="c3455-203">如果支持<xref:System.Windows.Controls.UserControl>代码编译到引用`internal`为 XAML 类型的同一程序集中，则可以通过访问权限声明此类 。</span><span class="sxs-lookup"><span data-stu-id="c3455-203">Such a <xref:System.Windows.Controls.UserControl> can be declared with `internal` access if the backing code is compiled into the same assembly from which it is referenced as a XAML type.</span></span>

<span data-ttu-id="c3455-204">对于在完全信任下加载 XAML 并使用<xref:System.Xaml.XamlObjectWriter>的应用程序，始终启用具有`internal`访问级别的加载类。</span><span class="sxs-lookup"><span data-stu-id="c3455-204">For an application that loads XAML under full trust and uses <xref:System.Xaml.XamlObjectWriter>, loading classes with `internal` access level is always enabled.</span></span>

<span data-ttu-id="c3455-205">对于在部分信任下加载 XAML 的应用程序，可以使用<xref:System.Xaml.Permissions.XamlAccessLevel>API 来控制访问级别特征。</span><span class="sxs-lookup"><span data-stu-id="c3455-205">For an application that loads XAML under partial trust, you can control the access level characteristics by using the <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span></span> <span data-ttu-id="c3455-206">此外，延迟机制（如 WPF 模板系统）必须能够传播任何访问级别权限，并将其保留为最终的运行时评估;这通过传递信息在<xref:System.Xaml.Permissions.XamlAccessLevel>内部处理。</span><span class="sxs-lookup"><span data-stu-id="c3455-206">Also, deferral mechanisms (such as the WPF template system) must be able to propagate any access level permissions and preserve them for the eventual run time evaluations; this is handled internally by passing the <xref:System.Xaml.Permissions.XamlAccessLevel> information.</span></span>

### <a name="wpf-implementation"></a><span data-ttu-id="c3455-207">WPF 实施</span><span class="sxs-lookup"><span data-stu-id="c3455-207">WPF Implementation</span></span>

<span data-ttu-id="c3455-208">WPF XAML 使用部分信任访问模型，其中如果 BAML 在部分信任下加载，则<xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A>访问仅限于作为 BAML 源的程序集。</span><span class="sxs-lookup"><span data-stu-id="c3455-208">WPF XAML uses a partial-trust access model where if BAML is loaded under partial trust, access is restricted to <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> for the assembly that is the BAML source.</span></span> <span data-ttu-id="c3455-209">对于延迟，WPF 用作<xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType>传递访问级别信息的机制。</span><span class="sxs-lookup"><span data-stu-id="c3455-209">For deferral, WPF uses <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> as a mechanism for passing the access level information.</span></span>

<span data-ttu-id="c3455-210">在 WPF XAML 术语中，*内部类型*是由同一程序集定义的类型，该程序集还包括引用 XAML。</span><span class="sxs-lookup"><span data-stu-id="c3455-210">In WPF XAML terminology, an *internal type* is a type that is defined by the same assembly that also includes the referencing XAML.</span></span> <span data-ttu-id="c3455-211">此类类型可以通过 XAML 命名空间映射，该命名空间有意省略映射的程序集部分，`xmlns:local="clr-namespace:WPFApplication1"`例如 。</span><span class="sxs-lookup"><span data-stu-id="c3455-211">Such a type can be mapped through a XAML namespace that deliberately omits the assembly= portion of a mapping, for example, `xmlns:local="clr-namespace:WPFApplication1"`.</span></span> <span data-ttu-id="c3455-212">如果 BAML 引用内部类型，并且该`internal`类型具有访问级别，这将`GeneratedInternalTypeHelper`为程序集生成一个类。</span><span class="sxs-lookup"><span data-stu-id="c3455-212">If BAML references an internal type and that type has `internal` access level, this generates a `GeneratedInternalTypeHelper` class for the assembly.</span></span> <span data-ttu-id="c3455-213">如果要避免`GeneratedInternalTypeHelper`，则必须使用`public`访问级别，或者必须将相关类考虑到单独的程序集中，并使该程序集与程序集相关。</span><span class="sxs-lookup"><span data-stu-id="c3455-213">If you want to avoid `GeneratedInternalTypeHelper`, you either must use `public` access level, or must factor the relevant class into a separate assembly and make that assembly dependent.</span></span>

## <a name="see-also"></a><span data-ttu-id="c3455-214">请参阅</span><span class="sxs-lookup"><span data-stu-id="c3455-214">See also</span></span>

- [<span data-ttu-id="c3455-215">自定义类型和库的 XAML 相关 CLR 特性</span><span class="sxs-lookup"><span data-stu-id="c3455-215">XAML-Related CLR Attributes for Custom Types and Libraries</span></span>](clr-attributes-with-custom-types-and-libraries.md)
- [<span data-ttu-id="c3455-216">XAML 服务</span><span class="sxs-lookup"><span data-stu-id="c3455-216">XAML Services</span></span>](../../../api/index.md)
