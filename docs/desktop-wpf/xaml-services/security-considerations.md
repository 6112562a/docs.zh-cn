---
title: XAML 安全注意事项
ms.date: 03/30/2017
helpviewer_keywords:
- security [XAML Services], .NET XAML services
- XAML security [XAML Services]
ms.assetid: 544296d4-f38e-4498-af49-c9f4dad28964
ms.openlocfilehash: 1864910b339c74e3033fb4d6d8baebffada1a4f8
ms.sourcegitcommit: c2d9718996402993cf31541f11e95531bc68bad0
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/27/2020
ms.locfileid: "81432916"
---
# <a name="xaml-security-considerations"></a><span data-ttu-id="7be72-102">XAML 安全注意事项</span><span class="sxs-lookup"><span data-stu-id="7be72-102">XAML security considerations</span></span>

<span data-ttu-id="7be72-103">本文介绍了在使用 XAML 和 .NET XAML 服务 API 时应用程序中安全性的最佳做法。</span><span class="sxs-lookup"><span data-stu-id="7be72-103">This article describes best practices for security in applications when you use XAML and .NET XAML Services API.</span></span>

## <a name="untrusted-xaml-in-applications"></a><span data-ttu-id="7be72-104">应用程序中的不受信任的 XAML</span><span class="sxs-lookup"><span data-stu-id="7be72-104">Untrusted XAML in Applications</span></span>

<span data-ttu-id="7be72-105">在最一般意义上，不受信任的 XAML 是应用程序未具体包含或发出的任何 XAML 源。</span><span class="sxs-lookup"><span data-stu-id="7be72-105">In the most general sense, untrusted XAML is any XAML source that your application did not specifically include or emit.</span></span>

<span data-ttu-id="7be72-106">编译到受信任和签名程序集中的`resx`-类型资源或存储为 -类型的 XAML 本质上不受信任。</span><span class="sxs-lookup"><span data-stu-id="7be72-106">XAML that is compiled into or stored as a `resx`-type resource within a trusted and signed assembly is not inherently untrusted.</span></span> <span data-ttu-id="7be72-107">您可以像信任整个程序集一样信任 XAML。</span><span class="sxs-lookup"><span data-stu-id="7be72-107">You can trust the XAML as much as you trust the assembly as a whole.</span></span> <span data-ttu-id="7be72-108">在大多数情况下，您只关心松散的 XAML 的信任方面，这是从流或其他 I/O 加载的 XAML 源。</span><span class="sxs-lookup"><span data-stu-id="7be72-108">In most cases, you are only concerned with the trust aspects of loose XAML, which is a XAML source that you load from a stream or other I/O.</span></span> <span data-ttu-id="7be72-109">松散 XAML 不是具有部署和打包基础结构的应用程序模型的特定组件或功能。</span><span class="sxs-lookup"><span data-stu-id="7be72-109">Loose XAML is not a specific component or feature of an application model with a deployment and packaging infrastructure.</span></span> <span data-ttu-id="7be72-110">但是，程序集可能实现涉及加载松散 XAML 的行为。</span><span class="sxs-lookup"><span data-stu-id="7be72-110">However, an assembly might implement a behavior that involves loading loose XAML.</span></span>

<span data-ttu-id="7be72-111">对于不受信任的 XAML，通常应该将其视为不受信任的代码。</span><span class="sxs-lookup"><span data-stu-id="7be72-111">For untrusted XAML, you should treat it generally the same as if it were untrusted code.</span></span> <span data-ttu-id="7be72-112">使用沙盒或其他隐喻来防止可能不受信任的 XAML 访问受信任的代码。</span><span class="sxs-lookup"><span data-stu-id="7be72-112">Use sandboxing or other metaphors to prevent possibly untrusted XAML from accessing your trusted code.</span></span>

<span data-ttu-id="7be72-113">XAML 功能的性质使 XAML 有权构造对象并设置其属性。</span><span class="sxs-lookup"><span data-stu-id="7be72-113">The nature of XAML capabilities gives the XAML the right to construct objects and set their properties.</span></span> <span data-ttu-id="7be72-114">这些功能还包括访问类型转换器、映射和访问应用程序域中的程序集，使用标记扩展、`x:Code`块等。</span><span class="sxs-lookup"><span data-stu-id="7be72-114">These capabilities also include accessing type converters, mapping and accessing assemblies in the application domain, using markup extensions, `x:Code` blocks, and so on.</span></span>

<span data-ttu-id="7be72-115">除了语言级功能外，XAML 还用于许多技术的 UI 定义。</span><span class="sxs-lookup"><span data-stu-id="7be72-115">In addition to its language-level capabilities, XAML is used for UI definition in many technologies.</span></span> <span data-ttu-id="7be72-116">加载不受信任的 XAML 可能意味着加载恶意欺骗 UI。</span><span class="sxs-lookup"><span data-stu-id="7be72-116">Loading untrusted XAML might mean loading a malicious spoofing UI.</span></span>

## <a name="sharing-context-between-readers-and-writers"></a><span data-ttu-id="7be72-117">读者和作者之间共享上下文</span><span class="sxs-lookup"><span data-stu-id="7be72-117">Sharing Context Between Readers and Writers</span></span>

<span data-ttu-id="7be72-118">.NET XAML 服务体系结构适用于 XAML 读取器和 XAML 编写器，通常需要将 XAML 读取器共享给 XAML 编写器或共享 XAML 架构上下文。</span><span class="sxs-lookup"><span data-stu-id="7be72-118">.NET XAML Services architecture for XAML readers and XAML writers often requires sharing a XAML reader to a XAML writer, or a shared XAML schema context.</span></span> <span data-ttu-id="7be72-119">如果要编写 XAML 节点循环逻辑或提供自定义保存路径，则可能需要共享对象或上下文。</span><span class="sxs-lookup"><span data-stu-id="7be72-119">Sharing objects or contexts might be required if you are writing XAML node loop logic, or providing a custom save path.</span></span> <span data-ttu-id="7be72-120">不要在受信任的代码和不受信任的代码之间共享 XAML 读取器实例、非默认 XAML 架构上下文或 XAML 读取器/写入器类的设置。</span><span class="sxs-lookup"><span data-stu-id="7be72-120">Don't share XAML reader instances, nondefault XAML schema context, or settings for XAML reader/writer classes between trusted and untrusted code.</span></span>

<span data-ttu-id="7be72-121">大多数涉及基于 CLR 的类型备份的 XAML 对象写入的方案和操作都只能使用默认的 XAML 架构上下文。</span><span class="sxs-lookup"><span data-stu-id="7be72-121">Most scenarios and operations involving XAML object writing for a CLR-based type backing can just use default XAML schema context.</span></span> <span data-ttu-id="7be72-122">默认 XAML 架构上下文没有明确包含可能危及完全信任的设置。</span><span class="sxs-lookup"><span data-stu-id="7be72-122">The default XAML schema context does not explicitly include settings that could compromise full trust.</span></span> <span data-ttu-id="7be72-123">因此，在受信任的和不受信任的 XAML 读取器/写入器组件之间共享上下文是安全的。</span><span class="sxs-lookup"><span data-stu-id="7be72-123">It is thus safe to share context between trusted and untrusted XAML reader/writer components.</span></span> <span data-ttu-id="7be72-124">但是，如果您这样做，最好还是将这些读者和作者保存在单独的<xref:System.AppDomain>作用域中，其中一个专门打算/沙盒用于部分信任。</span><span class="sxs-lookup"><span data-stu-id="7be72-124">However, if you do this, it is still a best practice to keep such readers and writers in separate <xref:System.AppDomain> scopes, with one of them specifically intended/sandboxed for partial trust.</span></span>

## <a name="xaml-namespaces-and-assembly-trust"></a><span data-ttu-id="7be72-125">XAML 命名空间和程序集信任</span><span class="sxs-lookup"><span data-stu-id="7be72-125">XAML Namespaces and Assembly Trust</span></span>

<span data-ttu-id="7be72-126">XAML 如何将自定义 XAML 命名空间映射解释为程序集的基本限定语法和定义不会区分加载到应用程序域中的受信任程序集和不受信任的程序集。</span><span class="sxs-lookup"><span data-stu-id="7be72-126">The basic unqualified syntax and definition for how XAML interprets a custom XAML namespace mapping to an assembly does not distinguish between a trusted and untrusted assembly as loaded into the application domain.</span></span> <span data-ttu-id="7be72-127">因此，从技术上讲，不受信任的程序集可以欺骗受信任的程序集的预期 XAML 命名空间映射并捕获 XAML 源声明的对象和属性信息。</span><span class="sxs-lookup"><span data-stu-id="7be72-127">Thus, it is technically possible for an untrusted assembly to spoof a trusted assembly's intended XAML namespace mapping and capture a XAML source's declared object and property information.</span></span> <span data-ttu-id="7be72-128">如果您有安全要求以避免这种情况，则应使用以下技术之一进行预期的 XAML 命名空间映射：</span><span class="sxs-lookup"><span data-stu-id="7be72-128">If you have security requirements to avoid this situation, your intended XAML namespace mapping should be made using one of the following techniques:</span></span>

- <span data-ttu-id="7be72-129">在应用程序的 XAML 进行的任何 XAML 命名空间映射中使用具有强名称的完全限定程序集名称。</span><span class="sxs-lookup"><span data-stu-id="7be72-129">Use a fully qualified assembly name with strong name in any XAML namespace mapping made by your application's XAML.</span></span>

- <span data-ttu-id="7be72-130">通过构造特定于 XAML 读取器和 XAML<xref:System.Xaml.XamlSchemaContext>对象编写器的程序集映射，将程序集映射限制为一组固定的引用程序集。</span><span class="sxs-lookup"><span data-stu-id="7be72-130">Restrict assembly mapping to a fixed set of reference assemblies, by constructing a specific <xref:System.Xaml.XamlSchemaContext> for your XAML readers and XAML object writers.</span></span> <span data-ttu-id="7be72-131">请参阅 <xref:System.Xaml.XamlSchemaContext.%23ctor%28System.Collections.Generic.IEnumerable%7BSystem.Reflection.Assembly%7D%29>。</span><span class="sxs-lookup"><span data-stu-id="7be72-131">See <xref:System.Xaml.XamlSchemaContext.%23ctor%28System.Collections.Generic.IEnumerable%7BSystem.Reflection.Assembly%7D%29>.</span></span>

## <a name="xaml-type-mapping-and-type-system-access"></a><span data-ttu-id="7be72-132">XAML 类型映射和类型系统访问</span><span class="sxs-lookup"><span data-stu-id="7be72-132">XAML Type Mapping and Type System Access</span></span>

<span data-ttu-id="7be72-133">XAML 支持其自己的类型系统，在许多方面，该系统是 CLR 如何实现基本 CLR 类型系统的对等体。</span><span class="sxs-lookup"><span data-stu-id="7be72-133">XAML supports its own type system, which in many ways is a peer to how CLR implements the basic CLR type system.</span></span> <span data-ttu-id="7be72-134">但是，对于类型感知的某些方面，如果您根据类型信息对类型做出信任决策，则应服从 CLR 支持类型中的类型信息。</span><span class="sxs-lookup"><span data-stu-id="7be72-134">However, for certain aspects of type awareness where you are making trust decisions about a type based on its type information, you should defer to the type information in the CLR backing types.</span></span> <span data-ttu-id="7be72-135">这是因为 XAML 类型系统的一些特定报告功能作为虚拟方法处于打开状态，因此并不完全受原始 .NET XAML 服务实现的控制。</span><span class="sxs-lookup"><span data-stu-id="7be72-135">This is because some of the specific reporting capabilities of the XAML type system are left open as virtual methods and are therefore, not fully under the control of the original .NET XAML Services implementations.</span></span> <span data-ttu-id="7be72-136">存在这些扩展点是因为 XAML 类型系统是可扩展的，以匹配 XAML 本身的可扩展性及其可能的替代类型映射策略与默认 CLR 支持的实现和默认 XAML 架构上下文。</span><span class="sxs-lookup"><span data-stu-id="7be72-136">These extensibility points exist because the XAML type system is extensible, to match the extensibility of XAML itself and its possible alternative type-mapping strategies versus the default CLR-backed implementation and default XAML schema context.</span></span> <span data-ttu-id="7be72-137">有关详细信息，请参阅 有关<xref:System.Xaml.XamlType>和<xref:System.Xaml.XamlMember>的几种属性的特定注释。</span><span class="sxs-lookup"><span data-stu-id="7be72-137">For more information, see the specific notes on several of the properties of <xref:System.Xaml.XamlType> and <xref:System.Xaml.XamlMember>.</span></span>

## <a name="see-also"></a><span data-ttu-id="7be72-138">请参阅</span><span class="sxs-lookup"><span data-stu-id="7be72-138">See also</span></span>

- <xref:System.Xaml.Permissions.XamlAccessLevel>
