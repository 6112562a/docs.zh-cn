---
title: 编写自定义 .NET Core 运行时主机
description: 了解从本机代码托管 .NET Core 运行时，以支持需要控制 .NET Core 运行时工作方式的高级方案。
author: mjrousos
ms.date: 02/03/2017
ms.custom: seodec18
ms.openlocfilehash: 861a02d2e409637d11c874f16ecd56a1a0fcd92a
ms.sourcegitcommit: e6ad58812807937b03f5c581a219dcd7d1726b1d
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 12/10/2018
ms.locfileid: "53169633"
---
# <a name="write-a-custom-net-core-host-to-control-the-net-runtime-from-your-native-code"></a><span data-ttu-id="09e85-103">编写自定义 .NET Core 主机以从本机代码控制 .NET 运行时</span><span class="sxs-lookup"><span data-stu-id="09e85-103">Write a custom .NET Core host to control the .NET runtime from your native code</span></span>

<span data-ttu-id="09e85-104">像所有的托管代码一样，.NET Core 应用程序也由主机执行。</span><span class="sxs-lookup"><span data-stu-id="09e85-104">Like all managed code, .NET Core applications are executed by a host.</span></span> <span data-ttu-id="09e85-105">主机负责启动运行时（包括 JIT 和垃圾回收器等组件）、创建 AppDomain 并调用托管的入口点。</span><span class="sxs-lookup"><span data-stu-id="09e85-105">The host is responsible for starting the runtime (including components like the JIT and garbage collector), creating AppDomains, and invoking managed entry points.</span></span>

<span data-ttu-id="09e85-106">托管 .NET Core 运行时是高级方案，在大多数情况下，.NET Core 开发人员无需担心托管问题，因为 .NET Core 生成过程会提供默认主机来运行 .NET Core 应用程序。</span><span class="sxs-lookup"><span data-stu-id="09e85-106">Hosting the .NET Core runtime is an advanced scenario and, in most cases, .NET Core developers don't need to worry about hosting because .NET Core build processes provide a default host to run .NET Core applications.</span></span> <span data-ttu-id="09e85-107">虽然在某些特殊情况下，它对显式托管 .NET Core 运行时非常有用 - 无论是作为一种在本机进程中调用托管代码的方式还是为了获得对运行时工作原理更好的控制。</span><span class="sxs-lookup"><span data-stu-id="09e85-107">In some specialized circumstances, though, it can be useful to explicitly host the .NET Core runtime, either as a means of invoking managed code in a native process or in order to gain more control over how the runtime works.</span></span>

<span data-ttu-id="09e85-108">本文概述了从本机代码启动 .NET Core 运行时、创建初始应用程序域 (<xref:System.AppDomain>) 以及在域中执行托管代码的必要步骤。</span><span class="sxs-lookup"><span data-stu-id="09e85-108">This article gives an overview of the steps necessary to start the .NET Core runtime from native code, create an initial application domain (<xref:System.AppDomain>), and execute managed code in it.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="09e85-109">系统必备</span><span class="sxs-lookup"><span data-stu-id="09e85-109">Prerequisites</span></span>

<span data-ttu-id="09e85-110">由于主机是本机应用程序，所以本教程将介绍如何构造 C++ 应用程序以托管 .NET Core。</span><span class="sxs-lookup"><span data-stu-id="09e85-110">Because hosts are native applications, this tutorial will cover constructing a C++ application to host .NET Core.</span></span> <span data-ttu-id="09e85-111">将需要一个 C++ 开发环境（例如，[Visual Studio](https://aka.ms/vsdownload?utm_source=mscom&utm_campaign=msdocs) 提供的环境）。</span><span class="sxs-lookup"><span data-stu-id="09e85-111">You will need a C++ development environment (such as that provided by [Visual Studio](https://aka.ms/vsdownload?utm_source=mscom&utm_campaign=msdocs)).</span></span>

<span data-ttu-id="09e85-112">还将需要一个简单的 .NET Core 应用程序来测试主机，因此应安装 [.NET Core SDK](https://www.microsoft.com/net/core) 并[构建一个小型的 .NET Core 测试应用](../../core/tutorials/with-visual-studio.md)（例如，“Hello World”应用）。</span><span class="sxs-lookup"><span data-stu-id="09e85-112">You will also want a simple .NET Core application to test the host with, so you should install the [.NET Core SDK](https://www.microsoft.com/net/core) and [build a small .NET Core test app](../../core/tutorials/with-visual-studio.md) (such as a 'Hello World' app).</span></span> <span data-ttu-id="09e85-113">使用通过新 .NET Core 控制台项目模板创建的“Hello World”应用就足够了。</span><span class="sxs-lookup"><span data-stu-id="09e85-113">The 'Hello World' app created by the new .NET Core console project template is sufficient.</span></span>

<span data-ttu-id="09e85-114">本教程及其相关示例会构建一个 Windows 主机，请参阅本文结尾处有关在 Unix 上托管的说明。</span><span class="sxs-lookup"><span data-stu-id="09e85-114">This tutorial and its associated sample build a Windows host; see the notes at the end of this article about hosting on Unix.</span></span>

## <a name="creating-the-host"></a><span data-ttu-id="09e85-115">创建主机</span><span class="sxs-lookup"><span data-stu-id="09e85-115">Creating the host</span></span>

<span data-ttu-id="09e85-116">有关展示本文中所述步骤的[示例主机](https://github.com/dotnet/samples/tree/master/core/hosting)，请访问 dotnet/samples GitHub 存储库。</span><span class="sxs-lookup"><span data-stu-id="09e85-116">A [sample host](https://github.com/dotnet/samples/tree/master/core/hosting) demonstrating the steps outlined in this article is available in the dotnet/samples GitHub repository.</span></span> <span data-ttu-id="09e85-117">该示例的 host.cpp 文件中的注释清楚地将本教程中已编号的步骤与它们在示例中的执行位置关联。</span><span class="sxs-lookup"><span data-stu-id="09e85-117">Comments in the sample's *host.cpp* file clearly associate the numbered steps from this tutorial with where they're performed in the sample.</span></span> <span data-ttu-id="09e85-118">有关下载说明，请参阅[示例和教程](../../samples-and-tutorials/index.md#viewing-and-downloading-samples)。</span><span class="sxs-lookup"><span data-stu-id="09e85-118">For download instructions, see [Samples and Tutorials](../../samples-and-tutorials/index.md#viewing-and-downloading-samples).</span></span>

<span data-ttu-id="09e85-119">请记住，示例主机的用途在于提供学习指导，在纠错方面不甚严谨，其重在可读性而非效率。</span><span class="sxs-lookup"><span data-stu-id="09e85-119">Keep in mind that the sample host is meant to be used for learning purposes, so it is light on error checking and is designed to emphasize readability over efficiency.</span></span> <span data-ttu-id="09e85-120">更多的真实主机示例可从 [dotnet/coreclr](https://github.com/dotnet/coreclr/tree/master/src/coreclr/hosts) 存储库获取。</span><span class="sxs-lookup"><span data-stu-id="09e85-120">More real-world host samples are available in the [dotnet/coreclr](https://github.com/dotnet/coreclr/tree/master/src/coreclr/hosts) repository.</span></span> <span data-ttu-id="09e85-121">尤其是 [CoreRun 主机](https://github.com/dotnet/coreclr/tree/master/src/coreclr/hosts/corerun)，它是学习者了解简单示例后用来深入学习的通用主机。</span><span class="sxs-lookup"><span data-stu-id="09e85-121">The [CoreRun host](https://github.com/dotnet/coreclr/tree/master/src/coreclr/hosts/corerun), in particular, is a good general-purpose host to study after reading through the simpler sample.</span></span>

### <a name="a-note-about-mscoreeh"></a><span data-ttu-id="09e85-122">有关 mscoree.h 的说明</span><span class="sxs-lookup"><span data-stu-id="09e85-122">A note about mscoree.h</span></span>
<span data-ttu-id="09e85-123">.NET Core 主托管接口 (`ICLRRuntimeHost2`) 在 [MSCOREE.IDL](https://github.com/dotnet/coreclr/blob/master/src/inc/MSCOREE.IDL) 中定义。</span><span class="sxs-lookup"><span data-stu-id="09e85-123">The primary .NET Core hosting interface (`ICLRRuntimeHost2`) is defined in [MSCOREE.IDL](https://github.com/dotnet/coreclr/blob/master/src/inc/MSCOREE.IDL).</span></span> <span data-ttu-id="09e85-124">主机需要引用的此文件 (mscoree.h) 的标头版本，该版本是在构建 [.NET Core 运行时](https://github.com/dotnet/coreclr/)时通过 MIDL 生成。</span><span class="sxs-lookup"><span data-stu-id="09e85-124">A header version of this file (mscoree.h), which your host will need to reference, is produced via MIDL when the [.NET Core runtime](https://github.com/dotnet/coreclr/) is built.</span></span> <span data-ttu-id="09e85-125">如果不想构建 .NET Core 运行时，还可在 dotnet/coreclr 存储库中将 mscoree.h 获取为[预生成的标头](https://github.com/dotnet/coreclr/tree/master/src/pal/prebuilt/inc)。</span><span class="sxs-lookup"><span data-stu-id="09e85-125">If you do not want to build the .NET Core runtime, mscoree.h is also available as a [pre-built header](https://github.com/dotnet/coreclr/tree/master/src/pal/prebuilt/inc) in the dotnet/coreclr repository.</span></span> <span data-ttu-id="09e85-126">[有关构建 .NET Core 运行时的说明](https://github.com/dotnet/coreclr#building-the-repository)可在其 GitHub 存储库中找到。</span><span class="sxs-lookup"><span data-stu-id="09e85-126">[Instructions on building the .NET Core runtime](https://github.com/dotnet/coreclr#building-the-repository) can be found in its GitHub repository.</span></span> 

### <a name="step-1---identify-the-managed-entry-point"></a><span data-ttu-id="09e85-127">步骤 1 - 标识托管的入口点</span><span class="sxs-lookup"><span data-stu-id="09e85-127">Step 1 - Identify the managed entry point</span></span>
<span data-ttu-id="09e85-128">引用必要的标头后（例如，[mscoree.h](https://github.com/dotnet/coreclr/tree/master/src/pal/prebuilt/inc/mscoree.h) 和 stdio.h），.NET Core 主机必须完成的首要任务之一就是找到要使用的托管入口点。</span><span class="sxs-lookup"><span data-stu-id="09e85-128">After referencing necessary headers ([mscoree.h](https://github.com/dotnet/coreclr/tree/master/src/pal/prebuilt/inc/mscoree.h) and stdio.h, for example), one of the first things a .NET Core host must do is locate the managed entry point it will be using.</span></span> <span data-ttu-id="09e85-129">在示例主机中，通过将主机的第一个命令行参数作为托管的二进制文件（将执行该文件的 `main` 方法）的路径，即可完成此操作。</span><span class="sxs-lookup"><span data-stu-id="09e85-129">In our sample host, this is done by just taking the first command line argument to our host as the path to a managed binary whose `main` method will be executed.</span></span>

[!code-cpp[NetCoreHost#1](../../../samples/core/hosting/host.cpp#1)]

### <a name="step-2---find-and-load-coreclrdll"></a><span data-ttu-id="09e85-130">步骤 2 - 查找和加载 CoreCLR.dll</span><span class="sxs-lookup"><span data-stu-id="09e85-130">Step 2 - Find and load CoreCLR.dll</span></span>
<span data-ttu-id="09e85-131">.NET Core 运行时 API 位于 *CoreCLR.dll*（在 Windows 上）中。</span><span class="sxs-lookup"><span data-stu-id="09e85-131">The .NET Core runtime APIs are in *CoreCLR.dll* (on Windows).</span></span> <span data-ttu-id="09e85-132">若要获取托管接口 (`ICLRRuntimeHost2`)，就必须查找并加载 *CoreCLR.dll*。</span><span class="sxs-lookup"><span data-stu-id="09e85-132">To get our hosting interface (`ICLRRuntimeHost2`), it's necessary to find and load *CoreCLR.dll*.</span></span> <span data-ttu-id="09e85-133">由主机定义用于规定 *CoreCLR.dll* 查找方式的约定。</span><span class="sxs-lookup"><span data-stu-id="09e85-133">It is up to the host to define a convention for how it will locate *CoreCLR.dll*.</span></span> <span data-ttu-id="09e85-134">一些主机会预期文件位于一个常用的计算机范围内的位置（如 %programfiles%\dotnet\shared\Microsoft.NETCore.App\1.1.0）。</span><span class="sxs-lookup"><span data-stu-id="09e85-134">Some hosts expect the file to be present in a well-known machine-wide location (such as %programfiles%\dotnet\shared\Microsoft.NETCore.App\1.1.0).</span></span> <span data-ttu-id="09e85-135">其他主机会预期 *CoreCLR.dll* 从主机本身或要托管的应用旁的某个位置进行加载。</span><span class="sxs-lookup"><span data-stu-id="09e85-135">Others expect that *CoreCLR.dll* will be loaded from a location next to either the host itself or the app to be hosted.</span></span> <span data-ttu-id="09e85-136">还有一些主机可能会参考环境变量来查找库。</span><span class="sxs-lookup"><span data-stu-id="09e85-136">Still others might consult an environment variable to find the library.</span></span>

<span data-ttu-id="09e85-137">在 Linux 或 Mac 上，核心运行时库分别是 *libcoreclr.so* 或者 *libcoreclr.dylib*。</span><span class="sxs-lookup"><span data-stu-id="09e85-137">On Linux or Mac, the core runtime library is *libcoreclr.so* or *libcoreclr.dylib*, respectively.</span></span>

<span data-ttu-id="09e85-138">示例主机会为 *CoreCLR.dll* 探测几个常用位置。</span><span class="sxs-lookup"><span data-stu-id="09e85-138">Our sample host probes a few common locations for *CoreCLR.dll*.</span></span> <span data-ttu-id="09e85-139">找到后，必须通过 `LoadLibrary`（在 Linux/Mac 上通过 `dlopen`）进行加载。</span><span class="sxs-lookup"><span data-stu-id="09e85-139">Once found, it must be loaded via `LoadLibrary` (or `dlopen` on Linux/Mac).</span></span>

[!code-cpp[NetCoreHost#2](../../../samples/core/hosting/host.cpp#2)]

### <a name="step-3---get-an-iclrruntimehost2-instance"></a><span data-ttu-id="09e85-140">步骤 3 - 获取 ICLRRuntimeHost2 实例</span><span class="sxs-lookup"><span data-stu-id="09e85-140">Step 3 - Get an ICLRRuntimeHost2 Instance</span></span>
<span data-ttu-id="09e85-141">通过在 `GetCLRRuntimeHost` 上调用 `GetProcAddress`（或在 Linux/Mac 上调用 `dlsym`），然后再调用该函数来检索 `ICLRRuntimeHost2` 托管接口。</span><span class="sxs-lookup"><span data-stu-id="09e85-141">The `ICLRRuntimeHost2` hosting interface is retrieved by calling `GetProcAddress` (or `dlsym` on Linux/Mac) on `GetCLRRuntimeHost`, and then invoking that function.</span></span> 

[!code-cpp[NetCoreHost#3](../../../samples/core/hosting/host.cpp#3)]

### <a name="step-4---setting-startup-flags-and-starting-the-runtime"></a><span data-ttu-id="09e85-142">步骤 4 - 设置启动标志和启动运行时</span><span class="sxs-lookup"><span data-stu-id="09e85-142">Step 4 - Setting startup flags and starting the runtime</span></span>
<span data-ttu-id="09e85-143">有了 `ICLRRuntimeHost2`，现在便可指定运行时范围内的启动标志并启动该运行时。</span><span class="sxs-lookup"><span data-stu-id="09e85-143">With an `ICLRRuntimeHost2` in-hand, we can now specify runtime-wide startup flags and start the runtime.</span></span> <span data-ttu-id="09e85-144">启动标志决定要使用的垃圾回收器 (GC)（并发垃圾回收器或服务器）、是使用单个 AppDomain 还是多个 Appdomain，以及要使用的加载程序优化策略（对于非特定于域的程序集加载）。</span><span class="sxs-lookup"><span data-stu-id="09e85-144">Startup flags will determine which garbage collector (GC) to use (concurrent or server), whether we will use a single AppDomain or multiple AppDomains, and what loader optimization policy to use (for domain-neutral loading of assemblies).</span></span>

[!code-cpp[NetCoreHost#4](../../../samples/core/hosting/host.cpp#4)]

<span data-ttu-id="09e85-145">通过调用 `Start` 函数启动运行时。</span><span class="sxs-lookup"><span data-stu-id="09e85-145">The runtime is started with a call to the `Start` function.</span></span>

```C++
hr = runtimeHost->Start();
```

### <a name="step-5---preparing-appdomain-settings"></a><span data-ttu-id="09e85-146">步骤 5 - 准备 AppDomain 设置</span><span class="sxs-lookup"><span data-stu-id="09e85-146">Step 5 - Preparing AppDomain settings</span></span>
<span data-ttu-id="09e85-147">启动运行时后，将需要设置 AppDomain。</span><span class="sxs-lookup"><span data-stu-id="09e85-147">Once the runtime is started, we will want to set up an AppDomain.</span></span> <span data-ttu-id="09e85-148">但创建 .NET AppDomain 时必须指定大量选项，因此必须先准备这些选项。</span><span class="sxs-lookup"><span data-stu-id="09e85-148">There are a number of options that must be specified when creating a .NET AppDomain, however, so it's necessary to prepare those first.</span></span>

<span data-ttu-id="09e85-149">AppDomain 标志指定与安全性和互操作性相关的 AppDomain 行为。</span><span class="sxs-lookup"><span data-stu-id="09e85-149">AppDomain flags specify AppDomain behaviors related to security and interop.</span></span> <span data-ttu-id="09e85-150">早期 Silverlight 主机对沙盒用户代码使用这些设置，但大多数现代 .NET Core 主机以完全信任的方式运行用户代码并启用互操作。</span><span class="sxs-lookup"><span data-stu-id="09e85-150">Older Silverlight hosts used these settings to sandbox user code, but most modern .NET Core hosts run user code as full trust and enable interop.</span></span>

[!code-cpp[NetCoreHost#5](../../../samples/core/hosting/host.cpp#5)]

<span data-ttu-id="09e85-151">确定要使用的 AppDomain 标志后，必须定义 AppDomain 属性。</span><span class="sxs-lookup"><span data-stu-id="09e85-151">After deciding which AppDomain flags to use, AppDomain properties must be defined.</span></span> <span data-ttu-id="09e85-152">该属性是字符串的键/值对。</span><span class="sxs-lookup"><span data-stu-id="09e85-152">The properties are key/value pairs of strings.</span></span> <span data-ttu-id="09e85-153">这些属性中的许多与 AppDomain 程序集的加载方式相关。</span><span class="sxs-lookup"><span data-stu-id="09e85-153">Many of the properties relate to how the AppDomain will load assemblies.</span></span>

<span data-ttu-id="09e85-154">常见 AppDomain 属性包括：</span><span class="sxs-lookup"><span data-stu-id="09e85-154">Common AppDomain properties include:</span></span>

* <span data-ttu-id="09e85-155">`TRUSTED_PLATFORM_ASSEMBLIES` 这是一个程序集路径的列表（在 Windows 上以“;”分隔，在 Unix 上以“:”分隔），AppDomain 应优先加载它们并对其授予完全信任（甚至在部分受信任域中也一样）。</span><span class="sxs-lookup"><span data-stu-id="09e85-155">`TRUSTED_PLATFORM_ASSEMBLIES` This is a list of assembly paths (delimited by ';' on Windows and ':' on Unix) which the AppDomain should prioritize loading and give full trust to (even in partially-trusted domains).</span></span> <span data-ttu-id="09e85-156">此列表应包含“框架”程序集和其他受信任的模块，与 .NET Framework 方案中的 GAC 类似。</span><span class="sxs-lookup"><span data-stu-id="09e85-156">This list is meant to contain 'Framework' assemblies and other trusted modules, similar to the GAC in .NET Framework scenarios.</span></span> <span data-ttu-id="09e85-157">一些主机会将任何库置于此列表上的 *coreclr.dll* 旁，其他主机具有硬编码的清单，其中列出了用于所需用途的受信任程序集。</span><span class="sxs-lookup"><span data-stu-id="09e85-157">Some hosts will put any library next to *coreclr.dll* on this list, others have hard-coded manifests listing trusted assemblies for their purposes.</span></span>
* <span data-ttu-id="09e85-158">`APP_PATHS` 这是一个用来探测程序集的路径的列表（如果在受信任的平台程序集 (TPA) 列表中找不到程序集）。</span><span class="sxs-lookup"><span data-stu-id="09e85-158">`APP_PATHS` This is a list of paths to probe in for an assembly if it can't be found in the trusted platform assemblies (TPA) list.</span></span> <span data-ttu-id="09e85-159">这些路径应是可在其中找到用户的程序集的位置。</span><span class="sxs-lookup"><span data-stu-id="09e85-159">These paths are meant to be the locations where users' assemblies can be found.</span></span> <span data-ttu-id="09e85-160">在沙盒 AppDomain 中，从这些路径加载的程序集仅被授予部分信任。</span><span class="sxs-lookup"><span data-stu-id="09e85-160">In a sandboxed AppDomain, assemblies loaded from these paths will only be granted partial trust.</span></span> <span data-ttu-id="09e85-161">常见的 APP_PATH 路径包括加载目标应用的路径或其他已知存在用户资产的位置。</span><span class="sxs-lookup"><span data-stu-id="09e85-161">Common APP_PATH paths include the path the target app was loaded from or other locations where user assets are known to live.</span></span>
*  <span data-ttu-id="09e85-162">`APP_NI_PATHS` 此列表与 APP_PATHS 非常相似，不同之处在于其中的路径用于探测本机映像。</span><span class="sxs-lookup"><span data-stu-id="09e85-162">`APP_NI_PATHS` This list is very similar to APP_PATHS except that it's meant to be paths that will be probed for native images.</span></span>
*  <span data-ttu-id="09e85-163">`NATIVE_DLL_SEARCH_DIRECTORIES` 此属性是一个路径列表，加载程序在查找通过 p/invoke 调用的本机 DLL 时应使用这些路径进行探测。</span><span class="sxs-lookup"><span data-stu-id="09e85-163">`NATIVE_DLL_SEARCH_DIRECTORIES` This property is a list of paths the loader should probe when looking for native DLLs called via p/invoke.</span></span>
*  <span data-ttu-id="09e85-164">`PLATFORM_RESOURCE_ROOTS` 此列表包含的路径用于探测资源附属程序集（在区域性特定的子目录中）。</span><span class="sxs-lookup"><span data-stu-id="09e85-164">`PLATFORM_RESOURCE_ROOTS` This list includes paths to probe in for resource satellite assemblies (in culture-specific sub-directories).</span></span>

<span data-ttu-id="09e85-165">在[简单示例主机](https://github.com/dotnet/samples/tree/master/core/hosting)中，这些属性将进行如下设置：</span><span class="sxs-lookup"><span data-stu-id="09e85-165">In our [simple sample host](https://github.com/dotnet/samples/tree/master/core/hosting), these properties are set up as follows:</span></span>

[!code-cpp[NetCoreHost#6](../../../samples/core/hosting/host.cpp#6)]

### <a name="step-6---create-the-appdomain"></a><span data-ttu-id="09e85-166">步骤 6 - 创建 AppDomain</span><span class="sxs-lookup"><span data-stu-id="09e85-166">Step 6 - Create the AppDomain</span></span>
<span data-ttu-id="09e85-167">所有 AppDomain 标志和属性都准备都就绪后，可使用 `ICLRRuntimeHost2::CreateAppDomainWithManager` 设置 AppDomain。</span><span class="sxs-lookup"><span data-stu-id="09e85-167">Once all AppDomain flags and properties are prepared, `ICLRRuntimeHost2::CreateAppDomainWithManager` can be used to set up the AppDomain.</span></span> <span data-ttu-id="09e85-168">此函数选择性地采用完全限定的程序集名称和类型名称作为域的 AppDomain 管理器。</span><span class="sxs-lookup"><span data-stu-id="09e85-168">This function optionally takes a fully qualified assembly name and type name to use as the domain's AppDomain manager.</span></span> <span data-ttu-id="09e85-169">AppDomain 管理器可允许主机控制 AppDomain 行为的某些方面，并且如果主机不打算直接调用用户代码，它可能会提供用于启动托管代码的入口点。</span><span class="sxs-lookup"><span data-stu-id="09e85-169">An AppDomain manager can allow a host to control some aspects of AppDomain behavior and may provide entry points for launching managed code if the host doesn't intend to invoke user code directly.</span></span>   

[!code-cpp[NetCoreHost#7](../../../samples/core/hosting/host.cpp#7)]

### <a name="step-7---run-managed-code"></a><span data-ttu-id="09e85-170">步骤 7 - 运行托管代码！</span><span class="sxs-lookup"><span data-stu-id="09e85-170">Step 7 - Run managed code!</span></span>
<span data-ttu-id="09e85-171">现在 AppDomain 启动并运行后，主机可以开始执行托管的代码。</span><span class="sxs-lookup"><span data-stu-id="09e85-171">With an AppDomain up and running, the host can now start executing managed code.</span></span> <span data-ttu-id="09e85-172">执行此操作的最简单方法是使用 `ICLRRuntimeHost2::ExecuteAssembly` 调用托管程序集的入口点方法。</span><span class="sxs-lookup"><span data-stu-id="09e85-172">The easiest way to do this is to use `ICLRRuntimeHost2::ExecuteAssembly` to invoke a managed assembly's entry point method.</span></span> <span data-ttu-id="09e85-173">请注意，此函数仅适用于单一域方案。</span><span class="sxs-lookup"><span data-stu-id="09e85-173">Note that this function only works in single-domain scenarios.</span></span>

[!code-cpp[NetCoreHost#8](../../../samples/core/hosting/host.cpp#8)]

<span data-ttu-id="09e85-174">如果 `ExecuteAssembly` 不满足主机的需要，那么另一种方法是使用 `CreateDelegate` 创建指向静态托管方法的函数指针。</span><span class="sxs-lookup"><span data-stu-id="09e85-174">Another option, if `ExecuteAssembly` doesn't meet your host's needs, is to use `CreateDelegate` to create a function pointer to a static managed method.</span></span> <span data-ttu-id="09e85-175">这要求主机知道要调用的方法的签名（以创建函数指针类型），但允许主机调用代码而不是程序集的入口点。</span><span class="sxs-lookup"><span data-stu-id="09e85-175">This requires the host to know the signature of the method it is calling into (in order to create the function pointer type) but allows hosts the flexibility to invoke code other than an assembly's entry point.</span></span>

```C++
void *pfnDelegate = NULL;
hr = runtimeHost->CreateDelegate(
  domainId,
  L"HW, Version=1.0.0.0, Culture=neutral",  // Target managed assembly
  L"ConsoleApplication.Program",            // Target managed type
  L"Main",                                  // Target entry point (static method)
  (INT_PTR*)&pfnDelegate);

((MainMethodFp*)pfnDelegate)(NULL);
```

### <a name="step-8---clean-up"></a><span data-ttu-id="09e85-176">步骤 8 - 清理</span><span class="sxs-lookup"><span data-stu-id="09e85-176">Step 8 - Clean up</span></span>
<span data-ttu-id="09e85-177">最后，主机应随后通过卸载 Appdomain、停止运行时并释放 `ICLRRuntimeHost2` 引用来进行清理。</span><span class="sxs-lookup"><span data-stu-id="09e85-177">Finally, the host should clean up after itself by unloading AppDomains, stopping the runtime, and releasing the `ICLRRuntimeHost2` reference.</span></span>

[!code-cpp[NetCoreHost#9](../../../samples/core/hosting/host.cpp#9)]

## <a name="about-hosting-net-core-on-unix"></a><span data-ttu-id="09e85-178">关于在 Unix 上托管 .NET Core</span><span class="sxs-lookup"><span data-stu-id="09e85-178">About Hosting .NET Core on Unix</span></span>
<span data-ttu-id="09e85-179">.NET Core 是一款跨平台产品，可在 Windows、Linux 和 Mac 操作系统上运行。</span><span class="sxs-lookup"><span data-stu-id="09e85-179">.NET Core is a cross-platform product, running on Windows, Linux, and Mac operating systems.</span></span> <span data-ttu-id="09e85-180">但作为本机应用程序，用于不同平台的主机之间会有一些差异。</span><span class="sxs-lookup"><span data-stu-id="09e85-180">As native applications, though, hosts for different platforms will have some differences between them.</span></span> <span data-ttu-id="09e85-181">上述使用 `ICLRRuntimeHost2` 启动运行时、创建 AppDomain，然后执行托管代码的过程应适用于任何支持的操作系统。</span><span class="sxs-lookup"><span data-stu-id="09e85-181">The process described above of using `ICLRRuntimeHost2` to start the runtime, create an AppDomain, and execute managed code, should work on any supported operating system.</span></span> <span data-ttu-id="09e85-182">但是，在 Unix 平台上使用 mscoree.h 中定义的接口可能会很麻烦，因为 mscoree 进行了许多 Win32 假设。</span><span class="sxs-lookup"><span data-stu-id="09e85-182">However, the interfaces defined in mscoree.h can be cumbersome to work with on Unix platforms since mscoree makes many Win32 assumptions.</span></span>

<span data-ttu-id="09e85-183">为使在 Unix 平台上进行托管更简单，[coreclrhost.h ](https://github.com/dotnet/coreclr/blob/master/src/coreclr/hosts/inc/coreclrhost.h) 中又提供了一组非特定于平台的托管 API 包装器。</span><span class="sxs-lookup"><span data-stu-id="09e85-183">To make hosting on Unix platforms easier, a set of more platform-neutral hosting API wrappers are available in [coreclrhost.h](https://github.com/dotnet/coreclr/blob/master/src/coreclr/hosts/inc/coreclrhost.h).</span></span>

<span data-ttu-id="09e85-184">可在 [UnixCoreRun 主机](https://github.com/dotnet/coreclr/tree/master/src/coreclr/hosts)中查看一个使用 coreclrhost.h（而不是直接使用 mscoree.h）的示例。</span><span class="sxs-lookup"><span data-stu-id="09e85-184">An example of using coreclrhost.h (instead of mscoree.h directly) can be seen in the [UnixCoreRun host](https://github.com/dotnet/coreclr/tree/master/src/coreclr/hosts).</span></span> <span data-ttu-id="09e85-185">使用 coreclrhost.h 中的 API 来托管运行时的步骤与使用 mscoree.h 时的步骤类似：</span><span class="sxs-lookup"><span data-stu-id="09e85-185">The steps to use the APIs from coreclrhost.h to host the runtime are similar to the steps when using mscoree.h:</span></span>

1. <span data-ttu-id="09e85-186">确定要执行的托管代码（例如，从命令行参数）。</span><span class="sxs-lookup"><span data-stu-id="09e85-186">Identify the managed code to execute (from command line parameters, for example).</span></span> 
2. <span data-ttu-id="09e85-187">加载 CoreCLR 库。</span><span class="sxs-lookup"><span data-stu-id="09e85-187">Load the CoreCLR library.</span></span>
    1. `dlopen("./libcoreclr.so", RTLD_NOW | RTLD_LOCAL);` 
3. <span data-ttu-id="09e85-188">使用 `dlsym` 获取指向 CoreCLR 的 `coreclr_initialize`、`coreclr_create_delegate`、`coreclr_execute_assembly` 和 `coreclr_shutdown` 函数的函数指针</span><span class="sxs-lookup"><span data-stu-id="09e85-188">Get function pointers to CoreCLR's `coreclr_initialize`, `coreclr_create_delegate`, `coreclr_execute_assembly`, and `coreclr_shutdown` functions using `dlsym`</span></span>
    1. `coreclr_initialize_ptr coreclr_initialize = (coreclr_initialize_ptr)dlsym(coreclrLib, "coreclr_initialize");`
4. <span data-ttu-id="09e85-189">设置 AppDomain 属性（如 TPA 列表）。</span><span class="sxs-lookup"><span data-stu-id="09e85-189">Set up AppDomain properties (such as the TPA list).</span></span> <span data-ttu-id="09e85-190">这与上述 mscoree 工作流中的步骤 5 相同。</span><span class="sxs-lookup"><span data-stu-id="09e85-190">This is the same as step 5 from the mscoree workflow, above.</span></span>
5. <span data-ttu-id="09e85-191">使用 `coreclr_initialize` 启动运行时并创建 AppDomain。</span><span class="sxs-lookup"><span data-stu-id="09e85-191">Use `coreclr_initialize` to start the runtime and create an AppDomain.</span></span> <span data-ttu-id="09e85-192">这还将创建要在将来的托管调用中使用的 `hostHandle` 指针。</span><span class="sxs-lookup"><span data-stu-id="09e85-192">This will also create a `hostHandle` pointer that will be used in future hosting calls.</span></span>
    1. <span data-ttu-id="09e85-193">请注意，此函数同时执行上一工作流中步骤 4 和 6 的角色。</span><span class="sxs-lookup"><span data-stu-id="09e85-193">Note that this function performs the roles of both steps 4 and 6 from the previous workflow.</span></span> 
6. <span data-ttu-id="09e85-194">使用 `coreclr_execute_assembly` 或 `coreclr_create_delegate` 执行托管代码。</span><span class="sxs-lookup"><span data-stu-id="09e85-194">Use either `coreclr_execute_assembly` or `coreclr_create_delegate` to execute managed code.</span></span> <span data-ttu-id="09e85-195">这些函数类似于上一工作流步骤 7 中 mscoree 的 `ExecuteAssembly` 和 `CreateDelegate` 函数。</span><span class="sxs-lookup"><span data-stu-id="09e85-195">These functions are analogous to mscoree's `ExecuteAssembly` and `CreateDelegate` functions from step 7 of the previous workflow.</span></span>
7. <span data-ttu-id="09e85-196">使用 `coreclr_shutdown` 卸载 AppDomain 并关闭运行时。</span><span class="sxs-lookup"><span data-stu-id="09e85-196">Use `coreclr_shutdown` to unload the AppDomain and shut down the runtime.</span></span> 

## <a name="conclusion"></a><span data-ttu-id="09e85-197">结束语</span><span class="sxs-lookup"><span data-stu-id="09e85-197">Conclusion</span></span>
<span data-ttu-id="09e85-198">构建主机后，可以通过从命令行运行主机并传递其所需的任何参数（例如，要运行的托管应用）来对其进行测试。</span><span class="sxs-lookup"><span data-stu-id="09e85-198">Once your host is built, it can be tested by running it from the command line and passing any arguments (like the managed app to run) the host expects.</span></span> <span data-ttu-id="09e85-199">指定主机要运行的 .NET Core 应用时，请务必使用 `dotnet build` 生成的 .dll。</span><span class="sxs-lookup"><span data-stu-id="09e85-199">When specifying the .NET Core app for the host to run, be sure to use the .dll that is produced by `dotnet build`.</span></span> <span data-ttu-id="09e85-200">`dotnet publish` 为独立应用程序生成的可执行文件实际上是默认的 .NET Core 主机（以便可直接从主流方案中的命令行启动应用）；用户代码被编译为具有相同名称的 dll。</span><span class="sxs-lookup"><span data-stu-id="09e85-200">Executables produced by `dotnet publish` for self-contained applications are actually the default .NET Core host (so that the app can be launched directly from the command line in mainline scenarios); user code is compiled into a dll of the same name.</span></span> 

<span data-ttu-id="09e85-201">如果开始时操作不起作用，请再次检查 *coreclr.dll* 是否在主机预期的位置可用、是否 TPA 列表中包含了所有必需的框架库以及 CoreCLR 的位数（32 位或 64 位）是否匹配主机的构建方式。</span><span class="sxs-lookup"><span data-stu-id="09e85-201">If things don't work initially, double-check that *coreclr.dll* is available in the location expected by the host, that all necessary Framework libraries are in the TPA list, and that CoreCLR's bitness (32- or 64-bit) matches how the host was built.</span></span>

<span data-ttu-id="09e85-202">托管 .NET Core 运行时是高级方案，许多开发人员并不需要实施这一方案，但对于那些需要从本机进程启动托管代码的人员，或需要更好地控制 .NET Core 运行时的行为的人员而言，它会非常有用。</span><span class="sxs-lookup"><span data-stu-id="09e85-202">Hosting the .NET Core runtime is an advanced scenario that many developers won't require, but for those who need to launch managed code from a native process, or who need more control over the .NET Core runtime's behavior, it can be very useful.</span></span> <span data-ttu-id="09e85-203">因为 .NET Core 能够与其自身并行运行，甚至可以创建主机，这些主机能够初始化和启动多个 .NET Core 运行时版本并在同一进程中执行所有这些版本上的应用。</span><span class="sxs-lookup"><span data-stu-id="09e85-203">Because .NET Core is able to run side-by-side with itself, it's even possible to create hosts which initialize and start multiple versions of the .NET Core runtime and execute apps on all of them in the same process.</span></span> 
