---
title: 无服务器体系结构注意事项-无服务器应用
description: 了解面临的挑战的构建无服务器应用程序，从状态管理和持久存储进行缩放，日志记录、 跟踪和诊断。
author: JEREMYLIKNESS
ms.author: jeliknes
ms.date: 06/26/2018
ms.openlocfilehash: b12a09c0fcef7e7ff954a3f959fb9e3080a6e859
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/23/2019
ms.locfileid: "61940941"
---
# <a name="serverless-architecture-considerations"></a><span data-ttu-id="3a239-103">无服务器体系结构注意事项</span><span class="sxs-lookup"><span data-stu-id="3a239-103">Serverless architecture considerations</span></span>

<span data-ttu-id="3a239-104">采用无服务器体系结构却带来了一些难题。</span><span class="sxs-lookup"><span data-stu-id="3a239-104">Adopting a serverless architecture does come with certain challenges.</span></span> <span data-ttu-id="3a239-105">本部分探讨一些更为常见的注意事项需要注意。</span><span class="sxs-lookup"><span data-stu-id="3a239-105">This section explores some of the more common considerations to be aware of.</span></span> <span data-ttu-id="3a239-106">所有这些难题通过的解决方案。</span><span class="sxs-lookup"><span data-stu-id="3a239-106">All of these challenges have solutions.</span></span> <span data-ttu-id="3a239-107">与所有体系结构选项应仅在仔细考虑优点和缺点后做出的决定以无服务器。</span><span class="sxs-lookup"><span data-stu-id="3a239-107">As with all architecture choices, the decision to go serverless should be made only after carefully considering the pros and cons.</span></span> <span data-ttu-id="3a239-108">具体取决于你的应用程序的需要，您可以决定无服务器实现进行的某些组件的正确解决方案。</span><span class="sxs-lookup"><span data-stu-id="3a239-108">Depending on the needs of your application, you may decide a serverless implementation isn't the right solution for certain components.</span></span>

## <a name="managing-state"></a><span data-ttu-id="3a239-109">管理状态</span><span class="sxs-lookup"><span data-stu-id="3a239-109">Managing state</span></span>

<span data-ttu-id="3a239-110">无服务器函数，如同常规中的微服务是无状态默认情况下。</span><span class="sxs-lookup"><span data-stu-id="3a239-110">Serverless functions, as with microservices in general, are stateless by default.</span></span> <span data-ttu-id="3a239-111">避免状态后，可无服务器是临时的以横向扩展，并提供复原能力，而无需故障的中心点。</span><span class="sxs-lookup"><span data-stu-id="3a239-111">Avoiding state enables serverless to be ephemeral, to scale out, and to provide resiliency without a central point of failure.</span></span> <span data-ttu-id="3a239-112">在某些情况下，业务流程需要状态。</span><span class="sxs-lookup"><span data-stu-id="3a239-112">In some circumstances, business processes require state.</span></span> <span data-ttu-id="3a239-113">如果进程所需状态，您有两个选项。</span><span class="sxs-lookup"><span data-stu-id="3a239-113">If your process requires state, you have two options.</span></span> <span data-ttu-id="3a239-114">可以采用模型而非无服务器，也可以与单独的服务，提供状态进行交互。</span><span class="sxs-lookup"><span data-stu-id="3a239-114">You can adopt a model other than serverless, or interact with a separate service that provides state.</span></span> <span data-ttu-id="3a239-115">添加状态可以使解决方案变得复杂和难度缩放，并可能会创建单一故障点。</span><span class="sxs-lookup"><span data-stu-id="3a239-115">Adding state can complicate the solution and make it harder to scale, and potentially create a single point of failure.</span></span> <span data-ttu-id="3a239-116">请仔细考虑你函数是否绝对需要状态。</span><span class="sxs-lookup"><span data-stu-id="3a239-116">Carefully consider whether your function absolutely requires state.</span></span> <span data-ttu-id="3a239-117">如果回答是"yes"，确定是否仍有意义使用无服务器解决方案实现。</span><span class="sxs-lookup"><span data-stu-id="3a239-117">If the answer is "yes," determine whether it still makes sense to implement it with serverless.</span></span>

<span data-ttu-id="3a239-118">有几种解决方案采用状态而不会影响无服务器的优势。</span><span class="sxs-lookup"><span data-stu-id="3a239-118">There are several solutions to adopt state without compromising the benefits of serverless.</span></span> <span data-ttu-id="3a239-119">一些更受欢迎的解决方案包括：</span><span class="sxs-lookup"><span data-stu-id="3a239-119">Some of the more popular solutions include:</span></span>

* <span data-ttu-id="3a239-120">使用临时数据存储或分布式的缓存，如 Redis</span><span class="sxs-lookup"><span data-stu-id="3a239-120">Use a temporary data store or distributed cache, like Redis</span></span>
* <span data-ttu-id="3a239-121">将状态存储在数据库中，如 SQL 或 CosmosDB</span><span class="sxs-lookup"><span data-stu-id="3a239-121">Store state in a database, like SQL or CosmosDB</span></span>
* <span data-ttu-id="3a239-122">通过 durable functions 等工作流引擎处理状态</span><span class="sxs-lookup"><span data-stu-id="3a239-122">Handle state through a workflow engine like durable functions</span></span>

<span data-ttu-id="3a239-123">底线是需要的您应注意在你正在考虑实现使用无服务器解决方案的进程中的任何状态管理。</span><span class="sxs-lookup"><span data-stu-id="3a239-123">The bottom line is that you should be aware of the need for any state management within processes you're considering to implement with serverless.</span></span>

## <a name="long-running-processes"></a><span data-ttu-id="3a239-124">长时间运行的进程</span><span class="sxs-lookup"><span data-stu-id="3a239-124">Long-running processes</span></span>

<span data-ttu-id="3a239-125">很多优势的无服务器应用依赖于正在临时的进程。</span><span class="sxs-lookup"><span data-stu-id="3a239-125">Many benefits of serverless rely on the processes being ephemeral.</span></span> <span data-ttu-id="3a239-126">短的运行的时间简化无服务器的提供程序以释放资源，如跨主机函数结束和共享函数。</span><span class="sxs-lookup"><span data-stu-id="3a239-126">Short run times make it easier for the serverless provider to free up resources as functions end and share functions across hosts.</span></span> <span data-ttu-id="3a239-127">大多数云提供程序限制为大约 10 分钟可以运行你的函数的总时间。</span><span class="sxs-lookup"><span data-stu-id="3a239-127">Most cloud providers limit the total time your function can run to around 10 minutes.</span></span> <span data-ttu-id="3a239-128">如果你的过程可能要花费更长，则可以考虑替代实现。</span><span class="sxs-lookup"><span data-stu-id="3a239-128">If your process may take longer, you might consider an alternative implementation.</span></span>

<span data-ttu-id="3a239-129">有几个例外和解决方案。</span><span class="sxs-lookup"><span data-stu-id="3a239-129">There are a few exceptions and solutions.</span></span> <span data-ttu-id="3a239-130">一种解决方案可能是您的流程分为单独花费的时间运行的较小的组件。</span><span class="sxs-lookup"><span data-stu-id="3a239-130">One solution may be to break your process into smaller components that individually take less time to run.</span></span> <span data-ttu-id="3a239-131">如果您的进程运行的依赖关系由于长时间，还可以考虑使用持久函数类似的解决方案的异步工作流。</span><span class="sxs-lookup"><span data-stu-id="3a239-131">If your process runs long because of dependencies, you can also consider an asynchronous workflow using a solution like durable functions.</span></span> <span data-ttu-id="3a239-132">Durable functions 暂停并在等待外部进程完成时维护您的进程的状态。</span><span class="sxs-lookup"><span data-stu-id="3a239-132">Durable functions pause and maintain the state of your process while it's waiting on an external process to finish.</span></span> <span data-ttu-id="3a239-133">异步处理减少实际进程运行的时间。</span><span class="sxs-lookup"><span data-stu-id="3a239-133">Asynchronous handling reduces the time the actual process runs.</span></span>

## <a name="startup-time"></a><span data-ttu-id="3a239-134">启动时间</span><span class="sxs-lookup"><span data-stu-id="3a239-134">Startup time</span></span>

<span data-ttu-id="3a239-135">使用无服务器实现的一个潜在问题是启动时间。</span><span class="sxs-lookup"><span data-stu-id="3a239-135">One potential concern with serverless implementations is startup time.</span></span> <span data-ttu-id="3a239-136">若要节省资源，很多无服务器的提供程序创建基础结构"按需。"</span><span class="sxs-lookup"><span data-stu-id="3a239-136">To conserve resources, many serverless providers create infrastructure "on demand."</span></span> <span data-ttu-id="3a239-137">在一段时间后触发无服务器函数时，资源来承载该函数可能需要创建或重新启动。</span><span class="sxs-lookup"><span data-stu-id="3a239-137">When a serverless function is triggered after a period of time, the resources to host the function may need to be created or restarted.</span></span> <span data-ttu-id="3a239-138">在某些情况下，冷启动可能会导致几秒钟的延迟。</span><span class="sxs-lookup"><span data-stu-id="3a239-138">In some situations, cold starts may result in delays of several seconds.</span></span> <span data-ttu-id="3a239-139">启动时间不同提供程序和服务级别而异。</span><span class="sxs-lookup"><span data-stu-id="3a239-139">Startup time varies across providers and service levels.</span></span> <span data-ttu-id="3a239-140">如果很重要的应用程序成功的最小化，有了几种地址启动时间。</span><span class="sxs-lookup"><span data-stu-id="3a239-140">There are a few approaches to address startup time if it's important to minimize for the success of the app.</span></span>

* <span data-ttu-id="3a239-141">某些提供程序允许用户支付保证基础结构为"always on"的服务级别。</span><span class="sxs-lookup"><span data-stu-id="3a239-141">Some providers allow users to pay for service levels that guarantee infrastructure is "always on".</span></span>
* <span data-ttu-id="3a239-142">实现保持活动状态的机制 (ping 终结点以使其保持"唤醒")。</span><span class="sxs-lookup"><span data-stu-id="3a239-142">Implement a keep-alive mechanism (ping the endpoint to keep it "awake").</span></span>
* <span data-ttu-id="3a239-143">（已使启动新实例的旋转速度极快运行主机） 的容器化的函数方法中使用 Kubernetes 等业务流程。</span><span class="sxs-lookup"><span data-stu-id="3a239-143">Use orchestration like Kubernetes with a containerized function approach (the host is already running so spinning up new instances is extremely fast).</span></span>

## <a name="database-updates-and-migrations"></a><span data-ttu-id="3a239-144">数据库更新和迁移</span><span class="sxs-lookup"><span data-stu-id="3a239-144">Database updates and migrations</span></span>

<span data-ttu-id="3a239-145">无服务器代码的一个优点是，您可以释放新函数而无需重新部署整个应用程序。</span><span class="sxs-lookup"><span data-stu-id="3a239-145">An advantage of serverless code is that you can release new functions without having to redeploy the entire application.</span></span> <span data-ttu-id="3a239-146">当没有涉及到的关系数据库，这一优点就成为一个缺点。</span><span class="sxs-lookup"><span data-stu-id="3a239-146">This advantage can become a disadvantage when there's a relational database involved.</span></span> <span data-ttu-id="3a239-147">对数据库架构更改很难与无服务器的更新同步。</span><span class="sxs-lookup"><span data-stu-id="3a239-147">Changes to database schemas are difficult to synchronize with serverless updates.</span></span> <span data-ttu-id="3a239-148">时出现问题，而且必须回滚所做的更改会带来额外挑战。</span><span class="sxs-lookup"><span data-stu-id="3a239-148">Additional challenges are posed when things go wrong and the changes must be rolled back.</span></span> <span data-ttu-id="3a239-149">数据完整性是微服务和无服务器功能的最佳做法是他们自己拥有其自己的数据的原因之一。</span><span class="sxs-lookup"><span data-stu-id="3a239-149">Data integrity is one reason that a best practice for microservices and serverless functions is that they own their own data.</span></span> <span data-ttu-id="3a239-150">就可以将更改部署作为一个单元的计算和数据。</span><span class="sxs-lookup"><span data-stu-id="3a239-150">It is possible to deploy changes as a single unit of compute and data.</span></span> <span data-ttu-id="3a239-151">实际情况是许多旧系统功能必须是与无服务器体系结构进行对帐的大型后端数据库。</span><span class="sxs-lookup"><span data-stu-id="3a239-151">The reality is that many legacy systems feature a large back-end database that must be reconciled with the serverless architecture.</span></span>

<span data-ttu-id="3a239-152">若要解决架构版本控制的常用方法是永远不会修改现有属性和列，但改为添加新的信息。</span><span class="sxs-lookup"><span data-stu-id="3a239-152">A popular approach to solve schema versioning is to never modify existing properties and columns, but instead add new information.</span></span> <span data-ttu-id="3a239-153">例如，考虑将从一个布尔值的更改"已完成"标志的 todo 列表为"已完成日期"。</span><span class="sxs-lookup"><span data-stu-id="3a239-153">For example, consider a change to move from a Boolean "completed" flag for a todo list to a "completed date."</span></span> <span data-ttu-id="3a239-154">而不是删除旧字段，将数据库更改：</span><span class="sxs-lookup"><span data-stu-id="3a239-154">Instead of removing the old field, the database change will:</span></span>

1. <span data-ttu-id="3a239-155">添加新的"完成日期"字段。</span><span class="sxs-lookup"><span data-stu-id="3a239-155">Add a new "completed date" field.</span></span>
1. <span data-ttu-id="3a239-156">转换计算的函数的计算结果是否已完成的日期晚于当前日期的"已完成"布尔字段。</span><span class="sxs-lookup"><span data-stu-id="3a239-156">Transform the "completed" Boolean field to a computed function that evaluates whether the completed date is after the current date.</span></span>
1. <span data-ttu-id="3a239-157">添加一个触发器，用于将已完成的日期设置为当前日期时设置已完成的布尔值为 true。</span><span class="sxs-lookup"><span data-stu-id="3a239-157">Add a trigger to set the completed date to the current date when the completed Boolean is set to true.</span></span>

<span data-ttu-id="3a239-158">更改的顺序可确保旧代码继续运行"按原样"，而较新的无服务器函数可以充分利用新的字段。</span><span class="sxs-lookup"><span data-stu-id="3a239-158">The sequence of changes ensures that legacy code continues to run "as is" while newer serverless functions can take advantage of the new field.</span></span>

<span data-ttu-id="3a239-159">有关无服务器体系结构中的数据的详细信息，请参阅[分布式数据管理挑战和解决方案](../microservices-architecture/architect-microservice-container-applications/distributed-data-management.md)。</span><span class="sxs-lookup"><span data-stu-id="3a239-159">For more information about data in serverless architectures, see [Challenges and solutions for distributed data management](../microservices-architecture/architect-microservice-container-applications/distributed-data-management.md).</span></span>

## <a name="scaling"></a><span data-ttu-id="3a239-160">缩放</span><span class="sxs-lookup"><span data-stu-id="3a239-160">Scaling</span></span>

<span data-ttu-id="3a239-161">它是一个常见的误解，无服务器，则意味着"无服务器"。</span><span class="sxs-lookup"><span data-stu-id="3a239-161">It's a common misconception that serverless means "no server."</span></span> <span data-ttu-id="3a239-162">它实际上是"较少的服务器。"</span><span class="sxs-lookup"><span data-stu-id="3a239-162">It's in fact "less server."</span></span> <span data-ttu-id="3a239-163">这一事实是支持基础结构是必须了解当涉及到缩放。</span><span class="sxs-lookup"><span data-stu-id="3a239-163">The fact there is a backing infrastructure is important to understand when it comes to scaling.</span></span> <span data-ttu-id="3a239-164">最无服务器平台提供一组控件来处理基础结构应如何缩放时事件密度的提高。</span><span class="sxs-lookup"><span data-stu-id="3a239-164">Most serverless platforms provide a set of controls to handle how the infrastructure should scale when event density increases.</span></span> <span data-ttu-id="3a239-165">可以选择使用不同的选项，但您的策略可能会有所不同，具体取决于该函数。</span><span class="sxs-lookup"><span data-stu-id="3a239-165">You can choose from a variety of options, but your strategy may vary depending on the function.</span></span> <span data-ttu-id="3a239-166">此外，函数通常运行下相关的主机，以便在同一主机上的函数具有相同的缩放选项。</span><span class="sxs-lookup"><span data-stu-id="3a239-166">Furthermore, functions are typically run under a related host, so that functions on the same host have the same scale options.</span></span> <span data-ttu-id="3a239-167">因此有必要进行组织和制定战略托管哪些函数一起基于缩放要求。</span><span class="sxs-lookup"><span data-stu-id="3a239-167">Therefore it is necessary to organize and strategize which functions are hosted together based on scale requirements.</span></span>

<span data-ttu-id="3a239-168">规则通常指定如何向上扩展 （增加的主机资源） 和横向扩展 （增加的主机实例数） 基于不同的参数。</span><span class="sxs-lookup"><span data-stu-id="3a239-168">Rules often specify how to scale-up (increase the host resources) and scale-out (increase the number of host instances) based on varying parameters.</span></span> <span data-ttu-id="3a239-169">刻度的触发器可能包括计划、 请求速率、 CPU 使用率和内存使用情况。</span><span class="sxs-lookup"><span data-stu-id="3a239-169">Triggers for scales may include schedule, request rates, CPU utilization, and memory usage.</span></span> <span data-ttu-id="3a239-170">通常更高的性能为代价更高版本。</span><span class="sxs-lookup"><span data-stu-id="3a239-170">Higher performance often comes at a greater cost.</span></span> <span data-ttu-id="3a239-171">随着快速请求速率的请求突然增加时，不可能扩展成本较低的、 基于消耗的方法。</span><span class="sxs-lookup"><span data-stu-id="3a239-171">The less expensive, consumption-based approaches may not scale as quickly when the request rate suddenly increases.</span></span> <span data-ttu-id="3a239-172">支付得更清楚"保险成本"而不是支付之间进行权衡严格"作为你转到"并导致速度较慢的响应，由于突发性需求增加而存在风险。</span><span class="sxs-lookup"><span data-stu-id="3a239-172">There is a trade-off between paying up front "insurance cost" versus paying strictly "as you go" and risking slower responses due to sudden increases in demand.</span></span>

## <a name="monitoring-tracing-and-logging"></a><span data-ttu-id="3a239-173">监视、 跟踪和日志记录</span><span class="sxs-lookup"><span data-stu-id="3a239-173">Monitoring, tracing, and logging</span></span>

<span data-ttu-id="3a239-174">DevOps 的一个经常被忽略的方面监视一次部署的应用程序。</span><span class="sxs-lookup"><span data-stu-id="3a239-174">An often overlooked aspect of DevOps is monitoring applications once deployed.</span></span> <span data-ttu-id="3a239-175">请务必具有策略来监视无服务器函数。</span><span class="sxs-lookup"><span data-stu-id="3a239-175">It's important to have a strategy for monitoring serverless functions.</span></span> <span data-ttu-id="3a239-176">最大的挑战通常是相关的更多信息，或识别用户的多个函数调用的相同交互的一部分时。</span><span class="sxs-lookup"><span data-stu-id="3a239-176">The biggest challenge is often correlation, or recognizing when a user calls multiple functions as part of the same interaction.</span></span> <span data-ttu-id="3a239-177">最无服务器平台都允许控制台的日志记录，可以导入到第三方工具。</span><span class="sxs-lookup"><span data-stu-id="3a239-177">Most serverless platforms allow console logging that can be imported into third-party tools.</span></span> <span data-ttu-id="3a239-178">也有一些选项来自动执行收集遥测数据、 生成和跟踪相关 Id 和监视特定操作，以提供详细的见解。</span><span class="sxs-lookup"><span data-stu-id="3a239-178">There are also options to automate collection of telemetry, generate and track correlation IDs, and monitor specific actions to provide detailed insights.</span></span> <span data-ttu-id="3a239-179">Azure 提供了高级[Application Insights 平台](https://docs.microsoft.com/azure/azure-functions/functions-monitoring)用于监视和分析。</span><span class="sxs-lookup"><span data-stu-id="3a239-179">Azure provides the advanced [Application Insights platform](https://docs.microsoft.com/azure/azure-functions/functions-monitoring) for monitoring and analytics.</span></span>

## <a name="inter-service-dependencies"></a><span data-ttu-id="3a239-180">服务间的依赖项</span><span class="sxs-lookup"><span data-stu-id="3a239-180">Inter-service dependencies</span></span>

<span data-ttu-id="3a239-181">无服务器体系结构可能包含依赖于其他函数的函数。</span><span class="sxs-lookup"><span data-stu-id="3a239-181">A serverless architecture may include functions that rely on other functions.</span></span> <span data-ttu-id="3a239-182">实际上，也并不罕见在无服务器体系结构中具有多个相互交互或分布式的事务的一部分调用的服务。</span><span class="sxs-lookup"><span data-stu-id="3a239-182">In fact, it isn't uncommon in a serverless architecture to have multiple services call each other as part of an interaction or distributed transaction.</span></span> <span data-ttu-id="3a239-183">若要避免强耦合，建议服务不直接相互的引用。</span><span class="sxs-lookup"><span data-stu-id="3a239-183">To avoid strong coupling, it's recommended that services don't reference each other directly.</span></span> <span data-ttu-id="3a239-184">当服务的终结点需要更改时，可能导致的直接引用主要重构。</span><span class="sxs-lookup"><span data-stu-id="3a239-184">When the endpoint for a service needs to change, direct references could result in major refactoring.</span></span> <span data-ttu-id="3a239-185">建议的解决办法是提供服务发现机制，如注册表、 提供相应的终结点为请求类型。</span><span class="sxs-lookup"><span data-stu-id="3a239-185">A suggested solution is to provide a service discovery mechanism, such as a registry, that provides the appropriate end point for a request type.</span></span> <span data-ttu-id="3a239-186">另一种解决方案是利用等队列或主题的消息传送服务，服务之间进行通信。</span><span class="sxs-lookup"><span data-stu-id="3a239-186">Another solution is to leverage messaging services like queues or topics for communication between services.</span></span>

## <a name="managing-failure-and-providing-resiliency"></a><span data-ttu-id="3a239-187">管理失败和提供复原能力</span><span class="sxs-lookup"><span data-stu-id="3a239-187">Managing failure and providing resiliency</span></span>

<span data-ttu-id="3a239-188">还有一点需要考虑*断路器模式*:如果由于某种原因，服务仍然失败，不建议在重复调用该服务。</span><span class="sxs-lookup"><span data-stu-id="3a239-188">It's also important to consider the *circuit-breaker pattern*: If, for some reason, a service continues to fail, it isn't advisable to call that service repeatedly.</span></span> <span data-ttu-id="3a239-189">但是，调用备用服务或重新建立依赖服务的运行状况之前返回一条消息。</span><span class="sxs-lookup"><span data-stu-id="3a239-189">Instead, an alternative service is called or a message returned until the health of the dependent service is re-established.</span></span> <span data-ttu-id="3a239-190">无服务器体系结构必须考虑到解析和管理服务间的依赖项的策略。</span><span class="sxs-lookup"><span data-stu-id="3a239-190">The serverless architecture needs to take into account the strategy for resolving and managing inter-service dependencies.</span></span>

<span data-ttu-id="3a239-191">若要继续断路器模式，服务需要容错且可复原。</span><span class="sxs-lookup"><span data-stu-id="3a239-191">To continue the circuit-breaker pattern, services need to be fault tolerant and resilient.</span></span> <span data-ttu-id="3a239-192">容错能力是指应用程序，甚至意外的异常后继续运行或遇到无效状态。</span><span class="sxs-lookup"><span data-stu-id="3a239-192">Fault tolerance refers to the ability of your application to continue running even after unexpected exceptions or invalid states are encountered.</span></span> <span data-ttu-id="3a239-193">容错能力通常是代码本身的函数和已写入到方式来处理异常。</span><span class="sxs-lookup"><span data-stu-id="3a239-193">Fault tolerance is typically a function of the code itself and how it's written to handle exceptions.</span></span> <span data-ttu-id="3a239-194">复原能力是指从故障中恢复时是如何支持应用程序。</span><span class="sxs-lookup"><span data-stu-id="3a239-194">Resiliency refers to how capable the app is at recovering from failures.</span></span> <span data-ttu-id="3a239-195">复原能力通常由无服务器平台进行管理。</span><span class="sxs-lookup"><span data-stu-id="3a239-195">Resiliency is often managed by the serverless platform.</span></span> <span data-ttu-id="3a239-196">在平台应该能够启动新的无服务器函数实例的现有一个失败时。</span><span class="sxs-lookup"><span data-stu-id="3a239-196">The platform should be able to spin up a new serverless function instance when the existing one fails.</span></span> <span data-ttu-id="3a239-197">平台还应非常智能，可以停止旋转启动新实例，每个新的实例失败时。</span><span class="sxs-lookup"><span data-stu-id="3a239-197">The platform should also be intelligent enough to stop spinning up new instances when every new instance fails.</span></span>

<span data-ttu-id="3a239-198">有关详细信息，请参阅[实现断路器模式](../microservices-architecture/implement-resilient-applications/implement-circuit-breaker-pattern.md)。</span><span class="sxs-lookup"><span data-stu-id="3a239-198">For more information, see [Implementing the Circuit Breaker pattern](../microservices-architecture/implement-resilient-applications/implement-circuit-breaker-pattern.md).</span></span>

## <a name="versioning-and-greenblue-deployments"></a><span data-ttu-id="3a239-199">版本控制和绿/蓝部署</span><span class="sxs-lookup"><span data-stu-id="3a239-199">Versioning and green/blue deployments</span></span>

<span data-ttu-id="3a239-200">无服务器的主要优势是升级而无需重新部署整个应用程序的特定函数的功能。</span><span class="sxs-lookup"><span data-stu-id="3a239-200">A major benefit of serverless is the ability to upgrade a specific function without having to redeploy the entire application.</span></span> <span data-ttu-id="3a239-201">对于成功的升级，函数必须是代码的版本控制，以便服务调用它们路由到正确版本。</span><span class="sxs-lookup"><span data-stu-id="3a239-201">For upgrades to be successful, functions must be versioned so that services calling them are routed to the correct version of code.</span></span> <span data-ttu-id="3a239-202">部署新版本的策略也很重要。</span><span class="sxs-lookup"><span data-stu-id="3a239-202">A strategy for deploying new versions is also important.</span></span> <span data-ttu-id="3a239-203">一种常见方法是使用"绿/蓝部署。"</span><span class="sxs-lookup"><span data-stu-id="3a239-203">A common approach is to use "green/blue deployments."</span></span> <span data-ttu-id="3a239-204">绿色部署是当前函数。</span><span class="sxs-lookup"><span data-stu-id="3a239-204">The green deployment is the current function.</span></span> <span data-ttu-id="3a239-205">新的"蓝色"版本部署到生产环境，进行测试。</span><span class="sxs-lookup"><span data-stu-id="3a239-205">A new "blue" version is deployed to production and tested.</span></span> <span data-ttu-id="3a239-206">当测试通过，以便新版本提供实时将交换的绿色和蓝色版本。</span><span class="sxs-lookup"><span data-stu-id="3a239-206">When testing passes, the green and blue versions are swapped so the new version comes live.</span></span> <span data-ttu-id="3a239-207">如果遇到任何问题，可以返回交换它们。</span><span class="sxs-lookup"><span data-stu-id="3a239-207">If any issues are encountered, they can be swapped back.</span></span> <span data-ttu-id="3a239-208">支持的版本控制和绿/蓝部署需要创作函数以适应版本更改和使用无服务器平台，以处理部署的组合。</span><span class="sxs-lookup"><span data-stu-id="3a239-208">Supporting versioning and green/blue deployments requires a combination of authoring the functions to accommodate version changes and working with the serverless platform to handle deployments.</span></span> <span data-ttu-id="3a239-209">一种可行方法是使用代理中所述[Azure 无服务器平台](azure-functions.md#proxies)一章。</span><span class="sxs-lookup"><span data-stu-id="3a239-209">One possible approach is to use proxies, which are described in the [Azure serverless platform](azure-functions.md#proxies) chapter.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="3a239-210">[上一页](serverless-architecture.md)
>[下一页](serverless-design-examples.md)</span><span class="sxs-lookup"><span data-stu-id="3a239-210">[Previous](serverless-architecture.md)
[Next](serverless-design-examples.md)</span></span>