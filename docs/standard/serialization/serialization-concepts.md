---
title: 序列化概念
ms.date: 08/07/2017
ms.assetid: e1ff4740-20a1-4c76-a8ad-d857db307054
ms.openlocfilehash: 649c4475aa8dcfc657b7591a0068dbfa4af918ca
ms.sourcegitcommit: 40364ded04fa6cdcb2b6beca7f68412e2e12f633
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/28/2019
ms.locfileid: "56976533"
---
# <a name="serialization-concepts"></a><span data-ttu-id="34ab6-102">序列化概念</span><span class="sxs-lookup"><span data-stu-id="34ab6-102">Serialization concepts</span></span>
<span data-ttu-id="34ab6-103">为什么要使用序列化？</span><span class="sxs-lookup"><span data-stu-id="34ab6-103">Why would you want to use serialization?</span></span> <span data-ttu-id="34ab6-104">两个最重要的原因是将对象状态保存到存储媒体，以便可以在以后阶段重新创建精确副本；以及将对象按值从一个应用程序域发送至另一个应用程序域。</span><span class="sxs-lookup"><span data-stu-id="34ab6-104">The two most important reasons are to persist the state of an object to a storage medium so an exact copy can be re-created at a later stage, and to send the object by value from one application domain to another.</span></span> <span data-ttu-id="34ab6-105">例如，序列化用于在 ASP.NET 中保存会话状态，并将对象复制到 Windows 窗体的剪贴板中。</span><span class="sxs-lookup"><span data-stu-id="34ab6-105">For example, serialization is used to save session state in ASP.NET and to copy objects to the Clipboard in Windows Forms.</span></span> <span data-ttu-id="34ab6-106">它还可用于在远程处理中将对象按值从一个应用程序域传递至另一个应用程序域。</span><span class="sxs-lookup"><span data-stu-id="34ab6-106">It is also used by remoting to pass objects by value from one application domain to another.</span></span>

[!INCLUDE [binary-serialization-warning](../../../includes/binary-serialization-warning.md)]

## <a name="persistent-storage"></a><span data-ttu-id="34ab6-107">永久性存储</span><span class="sxs-lookup"><span data-stu-id="34ab6-107">Persistent storage</span></span>
<span data-ttu-id="34ab6-108">经常有必要将对象的字段值存储至磁盘，以后再检索此数据。</span><span class="sxs-lookup"><span data-stu-id="34ab6-108">It is often necessary to store the value of the fields of an object to disk and then, later, retrieve this data.</span></span> <span data-ttu-id="34ab6-109">尽管不依赖序列化也能很容易地实现这一点，但方法通常麻烦而容易出错，并且需要跟踪对象的层次结构时会逐渐变得更加复杂。</span><span class="sxs-lookup"><span data-stu-id="34ab6-109">Although this is easy to achieve without relying on serialization, this approach is often cumbersome and error prone, and becomes progressively more complex when you need to track a hierarchy of objects.</span></span> <span data-ttu-id="34ab6-110">假设要编写一个包含数千个对象的大型商务应用程序，并且必须为每个对象编写代码，以便将字段和属性保存至磁盘以及从磁盘进行还原。</span><span class="sxs-lookup"><span data-stu-id="34ab6-110">Imagine writing a large business application, that contains thousands of objects, and having to write code to save and restore the fields and properties to and from disk for each object.</span></span> <span data-ttu-id="34ab6-111">序列化为实现这一目标提供了方便的机制。</span><span class="sxs-lookup"><span data-stu-id="34ab6-111">Serialization provides a convenient mechanism for achieving this objective.</span></span>

<span data-ttu-id="34ab6-112">公共语言运行库可管理对象在内存中存储的方式，并通过使用[反射](../../../docs/framework/reflection-and-codedom/reflection.md)提供一种自动序列化机制。</span><span class="sxs-lookup"><span data-stu-id="34ab6-112">The common language runtime manages how objects are stored in memory and provides an automated serialization mechanism by using [reflection](../../../docs/framework/reflection-and-codedom/reflection.md).</span></span> <span data-ttu-id="34ab6-113">当序列化对象时，类的名称、程序集和类实例的所有数据成员被写入存储区。</span><span class="sxs-lookup"><span data-stu-id="34ab6-113">When an object is serialized, the name of the class, the assembly, and all the data members of the class instance are written to storage.</span></span> <span data-ttu-id="34ab6-114">对象经常以成员变量方式将引用存储至其他实例。</span><span class="sxs-lookup"><span data-stu-id="34ab6-114">Objects often store references to other instances in member variables.</span></span> <span data-ttu-id="34ab6-115">当序列化类时，序列化引擎跟踪被引用的对象（已序列化），以确保同一对象不会被多次序列化。</span><span class="sxs-lookup"><span data-stu-id="34ab6-115">When the class is serialized, the serialization engine tracks referenced objects, already serialized, to ensure that the same object is not serialized more than once.</span></span> <span data-ttu-id="34ab6-116">随 [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] 一起提供的序列化体系结构可自动正确地处理对象图和循环引用。</span><span class="sxs-lookup"><span data-stu-id="34ab6-116">The serialization architecture provided with the [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] correctly handles object graphs and circular references automatically.</span></span> <span data-ttu-id="34ab6-117">对于对象图的唯一要求是，必须将已序列化对象引用的所有对象也标记为 `Serializable`（有关详细信息，请参阅[基本序列化](basic-serialization.md)）。</span><span class="sxs-lookup"><span data-stu-id="34ab6-117">The only requirement placed on object graphs is that all objects, referenced by the serialized object, must also be marked as `Serializable` (for more information, see [Basic Serialization](basic-serialization.md)).</span></span> <span data-ttu-id="34ab6-118">如果未进行标记，序列化程序尝试序列化未标记的对象时将引发异常。</span><span class="sxs-lookup"><span data-stu-id="34ab6-118">If this is not done, an exception will be thrown when the serializer attempts to serialize the unmarked object.</span></span>

<span data-ttu-id="34ab6-119">反序列化已序列化的类时，将重新创建该类，并且将自动还原所有数据成员的值。</span><span class="sxs-lookup"><span data-stu-id="34ab6-119">When the serialized class is deserialized, the class is recreated and the values of all the data members are automatically restored.</span></span>

## <a name="marshal-by-value"></a><span data-ttu-id="34ab6-120">按值封送</span><span class="sxs-lookup"><span data-stu-id="34ab6-120">Marshal by value</span></span>
<span data-ttu-id="34ab6-121">对象仅在创建它们的应用程序域中有效。</span><span class="sxs-lookup"><span data-stu-id="34ab6-121">Objects are valid only in the application domain where they are created.</span></span> <span data-ttu-id="34ab6-122">除非对象从 `MarshalByRefObject` 派生或被标记为 `Serializable`，否则尝试将对象作为参数传递或者作为结果返回时都将失败。</span><span class="sxs-lookup"><span data-stu-id="34ab6-122">Any attempt to pass the object as a parameter or return it as a result will fail unless the object derives from `MarshalByRefObject` or is marked as `Serializable`.</span></span> <span data-ttu-id="34ab6-123">如果将对象标记为 `Serializable`，则会自动序列化该对象，将该对象从一个应用程序域传输至另一个应用程序域，然后反序列化，以便在第二个应用程序域中生成该对象的一个精确副本。</span><span class="sxs-lookup"><span data-stu-id="34ab6-123">If the object is marked as `Serializable`, the object will automatically be serialized, transported from the one application domain to the other, and then deserialized to produce an exact copy of the object in the second application domain.</span></span> <span data-ttu-id="34ab6-124">此过程通常称为按值封送。</span><span class="sxs-lookup"><span data-stu-id="34ab6-124">This process is typically referred to as marshal-by-value.</span></span>
 
<span data-ttu-id="34ab6-125">如果对象从 `MarshalByRefObject` 派生，则会将对象引用（而不是对象本身）从一个应用程序域传递至另一个应用程序域。</span><span class="sxs-lookup"><span data-stu-id="34ab6-125">When an object derives from `MarshalByRefObject`, an object reference is passed from one application domain to another, rather than the object itself.</span></span> <span data-ttu-id="34ab6-126">还可将派生自 `MarshalByRefObject` 的对象标记为 `Serializable`。</span><span class="sxs-lookup"><span data-stu-id="34ab6-126">You can also mark an object that derives from `MarshalByRefObject` as `Serializable`.</span></span> <span data-ttu-id="34ab6-127">此对象用于远程处理时，负责反序列化的格式化程序已通过代理项选择器 (`SurrogateSelector`) 预配置，该格式化程序控制序列化过程，并用代理替换从 `MarshalByRefObject` 派生的所有对象。</span><span class="sxs-lookup"><span data-stu-id="34ab6-127">When this object is used with remoting, the formatter responsible for serialization, which has been preconfigured with a surrogate selector (`SurrogateSelector`), takes control of the serialization process, and replaces all objects derived from `MarshalByRefObject` with a proxy.</span></span> <span data-ttu-id="34ab6-128">如果本地没有 `SurrogateSelector`，则序列化体系结构遵循[序列化过程中的步骤](steps-in-the-serialization-process.md)中所述的标准序列化规则。</span><span class="sxs-lookup"><span data-stu-id="34ab6-128">Without the `SurrogateSelector` in place, the serialization architecture follows the standard serialization rules described in [Steps in the Serialization Process](steps-in-the-serialization-process.md).</span></span>  

## <a name="related-sections"></a><span data-ttu-id="34ab6-129">相关章节</span><span class="sxs-lookup"><span data-stu-id="34ab6-129">Related sections</span></span>  
 [<span data-ttu-id="34ab6-130">二进制序列化</span><span class="sxs-lookup"><span data-stu-id="34ab6-130">Binary Serialization</span></span>](../../../docs/standard/serialization/binary-serialization.md)  
 <span data-ttu-id="34ab6-131">描述随公共语言运行库一起提供的二进制序列化机制。</span><span class="sxs-lookup"><span data-stu-id="34ab6-131">Describes the binary serialization mechanism that is included with the common language runtime.</span></span>  
  
 <span data-ttu-id="34ab6-132">[.NET 远程处理](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/72x4h507(v=vs.100))\\</span><span class="sxs-lookup"><span data-stu-id="34ab6-132">[.NET Remoting](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/72x4h507(v=vs.100))\\</span></span>
 <span data-ttu-id="34ab6-133">描述 .NET Framework 中为远程通信提供的多种通信方法。</span><span class="sxs-lookup"><span data-stu-id="34ab6-133">Describes the various communications methods available in the .NET Framework for remote communications.</span></span>  
  
 [<span data-ttu-id="34ab6-134">XML 和 SOAP 序列化</span><span class="sxs-lookup"><span data-stu-id="34ab6-134">XML and SOAP Serialization</span></span>](../../../docs/standard/serialization/xml-and-soap-serialization.md)  
 <span data-ttu-id="34ab6-135">描述随公共语言运行库一起提供的 XML 和 SOAP 序列化机制。</span><span class="sxs-lookup"><span data-stu-id="34ab6-135">Describes the XML and SOAP serialization mechanism that is included with the common language runtime.</span></span>
