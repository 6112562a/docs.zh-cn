---
title: Docker 应用程序的外部循环 DevOps 工作流中的步骤
description: 使用 Microsoft 平台和工具的容器化 Docker 应用程序的生命周期
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 09/10/2018
ms.openlocfilehash: 37dd5481da571be56f134a5e142b7ba46427d7d8
ms.sourcegitcommit: ccd8c36b0d74d99291d41aceb14cf98d74dc9d2b
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 12/10/2018
ms.locfileid: "53143644"
---
# <a name="steps-in-the-outer-loop-devops-workflow-for-a-docker-application"></a><span data-ttu-id="3e197-103">Docker 应用程序的外部循环 DevOps 工作流中的步骤</span><span class="sxs-lookup"><span data-stu-id="3e197-103">Steps in the outer-loop DevOps workflow for a Docker application</span></span>

<span data-ttu-id="3e197-104">图 5-1 提供了端到端描述的组成 DevOps 外部循环工作流的步骤。</span><span class="sxs-lookup"><span data-stu-id="3e197-104">Figure 5-1 presents an end-to-end depiction of the steps comprising the DevOps outer-loop workflow.</span></span>

![](./media/image1.png)

<span data-ttu-id="3e197-105">图 5-1:使用 Microsoft 工具的 Docker 应用程序的 DevOps 外部循环工作流</span><span class="sxs-lookup"><span data-stu-id="3e197-105">Figure 5-1: DevOps outer-loop workflow for Docker applications with Microsoft tools</span></span>

<span data-ttu-id="3e197-106">现在，让我们检查每个中更详细地介绍这些步骤。</span><span class="sxs-lookup"><span data-stu-id="3e197-106">Now, let's examine each of these steps in greater detail.</span></span>

## <a name="step-1-inner-loop-development-workflow"></a><span data-ttu-id="3e197-107">步骤 1：内部循环开发工作流</span><span class="sxs-lookup"><span data-stu-id="3e197-107">Step 1: Inner-loop development workflow</span></span>

<span data-ttu-id="3e197-108">第 4 章中详细介绍了此步骤，但概括来说，下面是其中外部循环开始时，开发人员将推送到源控件管理系统 （如 Git) 的代码启动 CI 管道操作的时刻。</span><span class="sxs-lookup"><span data-stu-id="3e197-108">This step is explained in detail in Chapter 4, but, to recap, here is where the outer-loop begins, the moment at which a developer pushes code to the source control management system (like Git) initiating CI pipeline actions.</span></span>

## <a name="step-2-source-code-control-integration-and-management-with-azure-devops-services-and-git"></a><span data-ttu-id="3e197-109">步骤 2：源代码管理集成和使用 Azure DevOps 服务和 Git 管理</span><span class="sxs-lookup"><span data-stu-id="3e197-109">Step 2: Source-Code Control integration and management with Azure DevOps Services and Git</span></span>

<span data-ttu-id="3e197-110">在此步骤中，您需要有了要收集来自不同的开发人员团队中的所有代码的合并的版本的版本控制系统。</span><span class="sxs-lookup"><span data-stu-id="3e197-110">At this step, you need to have a version-control system to gather a consolidated version of all the code coming from the different developers in the team.</span></span>

<span data-ttu-id="3e197-111">即使源代码管理 (SCC) 和源代码管理可能看起来得心应手周期的对大多数开发人员，开发运营生命周期中创建 Docker 应用程序时，务必强调必须提交与应用程序的 Docker 映像直接对全局 Docker 注册表 （如 Azure 容器注册表或 Docker Hub） 从开发人员的计算机。</span><span class="sxs-lookup"><span data-stu-id="3e197-111">Even though source-code control (SCC) and source-code management might seem second-nature to most developers, when creating Docker applications in a DevOps life cycle, it is critical to emphasize that you must not submit the Docker images with the application directly to the global Docker Registry (like Azure Container Registry or Docker Hub) from the developer's machine.</span></span> <span data-ttu-id="3e197-112">相反，必须全局生成或基于源代码存储库 （如 Git) 的 CI 管道中仅对集成的源代码创建 Docker 映像的发布和部署到生产环境。</span><span class="sxs-lookup"><span data-stu-id="3e197-112">On the contrary, the Docker images to be released and deployed to production environments must be created solely on the source code that is being integrated in your global build or CI pipeline based on your source-code repository (like Git).</span></span>

<span data-ttu-id="3e197-113">他们自己的计算机中测试时，应由开发人员只需使用由开发人员生成的本地映像。</span><span class="sxs-lookup"><span data-stu-id="3e197-113">The local images generated by the developers themselves should be used just by the developers when testing within their own machines.</span></span> <span data-ttu-id="3e197-114">这就是原因，当务之急 DevOps 管道从源代码管理代码激活。</span><span class="sxs-lookup"><span data-stu-id="3e197-114">This is why it is critical to have the DevOps pipeline activated from the SCC code.</span></span>

<span data-ttu-id="3e197-115">Azure DevOps 服务和 Team Foundation Server 支持 Git 和 Team Foundation 版本控制。</span><span class="sxs-lookup"><span data-stu-id="3e197-115">Azure DevOps Services and Team Foundation Server support Git and Team Foundation Version Control.</span></span> <span data-ttu-id="3e197-116">可以选择它们，并将其用于端到端 Microsoft 体验。</span><span class="sxs-lookup"><span data-stu-id="3e197-116">You can choose between them and use it for an end-to-end Microsoft experience.</span></span> <span data-ttu-id="3e197-117">但是，还可以管理外部存储库 （如 GitHub、 本地 Git 存储库或 Subversion） 中的代码和仍将能够连接到它并获取你的 DevOps CI 管道作为起始点的代码。</span><span class="sxs-lookup"><span data-stu-id="3e197-117">However, you also can manage your code in external repositories (like GitHub, on-premises Git repositories, or Subversion) and still be able to connect to it and get the code as the starting point for your DevOps CI pipeline.</span></span>

## <a name="step-3-build-ci-integrate-and-test-with-azure-devops-services-and-docker"></a><span data-ttu-id="3e197-118">步骤 3：构建 CI，集成和测试 Azure DevOps 服务和 Docker</span><span class="sxs-lookup"><span data-stu-id="3e197-118">Step 3: Build, CI, Integrate, and Test with Azure DevOps Services and Docker</span></span>

<span data-ttu-id="3e197-119">CI 已成为新式软件测试和交付的标准。</span><span class="sxs-lookup"><span data-stu-id="3e197-119">CI has emerged as a standard for modern software testing and delivery.</span></span> <span data-ttu-id="3e197-120">Docker 解决方案维护开发和运营团队之间明确地分离。</span><span class="sxs-lookup"><span data-stu-id="3e197-120">The Docker solution maintains a clear separation of concerns between the development and operations teams.</span></span> <span data-ttu-id="3e197-121">Docker 映像的不变性可确保内容已开发、 CI 使用，请通过测试和生产环境中运行之间的可重复部署。</span><span class="sxs-lookup"><span data-stu-id="3e197-121">The immutability of Docker images ensures a repeatable deployment between what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="3e197-122">在开发人员的便携式计算机中部署 docker 引擎，测试基础结构，使容器可移植跨环境。</span><span class="sxs-lookup"><span data-stu-id="3e197-122">Docker Engine deployed across the developer laptops and test infrastructure makes the containers portable across environments.</span></span>

<span data-ttu-id="3e197-123">在此情况下，使用正确的代码提交的版本控制系统后，你需要*构建的服务*选取代码并运行的全局生成和测试。</span><span class="sxs-lookup"><span data-stu-id="3e197-123">At this point, after you have a version-control system with the correct code submitted, you need a *build service* to pick up the code and run the global build and tests.</span></span>

<span data-ttu-id="3e197-124">此步骤中 （CI、 生成、 测试） 的内部工作流是构造的 CI 管道包含的代码存储库 （Git 等），您的生成服务器 （Azure DevOps 服务）、 Docker 引擎和 Docker 注册表。</span><span class="sxs-lookup"><span data-stu-id="3e197-124">The internal workflow for this step (CI, build, test) is about the construction of a CI pipeline consisting of your code repository (Git, etc.), your build server (Azure DevOps Services), Docker Engine, and a Docker Registry.</span></span>

<span data-ttu-id="3e197-125">您可以使用 Azure DevOps 服务为基础构建您的应用程序和设置 CI 管道，也会发布已生成的"项目"到"项目存储库，"下一步中进行介绍。</span><span class="sxs-lookup"><span data-stu-id="3e197-125">You can use Azure DevOps Services as the foundation for building your applications and setting your CI pipeline, and for publishing the built "artifacts" to an "artifacts repository," which is explained in the next step.</span></span>

<span data-ttu-id="3e197-126">使用 Docker 进行部署，"最后一个项目"时要部署应用程序或服务的 Docker 映像中嵌入它们。</span><span class="sxs-lookup"><span data-stu-id="3e197-126">When using Docker for the deployment, the "final artifacts" to be deployed are Docker images with your application or services embedded within them.</span></span> <span data-ttu-id="3e197-127">这些映像都推送或发布到*Docker 注册表*（私有等存储库可在 Azure 容器注册表中拥有的或公共 Docker 中心注册表，通常用于官方基础映像类似）。</span><span class="sxs-lookup"><span data-stu-id="3e197-127">Those images are pushed or published to a *Docker Registry* (a private repository like the ones you can have in Azure Container Registry, or a public one like Docker Hub Registry, which is commonly used for official base images).</span></span>

<span data-ttu-id="3e197-128">下面是一个基本概念：CI 管道将启动的情况下关闭状态提交到 Git 等源代码管理存储库。</span><span class="sxs-lookup"><span data-stu-id="3e197-128">Here is the basic concept: The CI pipeline will be kicked-off by a commit to an SCC repository like Git.</span></span> <span data-ttu-id="3e197-129">提交会导致 Azure DevOps 服务运行 Docker 容器中的生成作业，并该作业的成功完成后，将 Docker 映像推送到 Docker 注册表中，在图 5-2 所示。</span><span class="sxs-lookup"><span data-stu-id="3e197-129">The commit will cause Azure DevOps Services to run a build job within a Docker container and, upon successful completion of that job, push a Docker image to the Docker Registry, as illustrated in Figure 5-2.</span></span>

![](./media/image2.png)

<span data-ttu-id="3e197-130">图 5-2:在 CI 中所涉及的步骤</span><span class="sxs-lookup"><span data-stu-id="3e197-130">Figure 5-2: The steps involved in CI</span></span>

<span data-ttu-id="3e197-131">下面是使用 Docker 和 Azure DevOps 服务的基本 CI 工作流步骤：</span><span class="sxs-lookup"><span data-stu-id="3e197-131">Here are the basic CI workflow steps with Docker and Azure DevOps Services:</span></span>

1.  <span data-ttu-id="3e197-132">开发人员将提交推送到源代码管理存储库 （Git/Azure DevOps 服务、 GitHub 等）。</span><span class="sxs-lookup"><span data-stu-id="3e197-132">The developer pushes a commit to an SCC repository (Git/Azure DevOps Services, GitHub, etc.).</span></span>

2.  <span data-ttu-id="3e197-133">如果您使用的 Azure DevOps 服务或 Git，CI 生成中，这意味着它非常简单，Azure DevOps 服务中选择一个复选框。</span><span class="sxs-lookup"><span data-stu-id="3e197-133">If you're using Azure DevOps Services or Git, CI is built in, which means that it is as simple as selecting a check box in Azure DevOps Services.</span></span> <span data-ttu-id="3e197-134">如果使用的外部 （如 GitHub)，SCC *webhook*将通知更新的 Azure DevOps 服务或推送到 Git/GitHub。</span><span class="sxs-lookup"><span data-stu-id="3e197-134">If you're using an external SCC (like GitHub), a *webhook* will notify Azure DevOps Services of the update or push to Git/GitHub.</span></span>

3.  <span data-ttu-id="3e197-135">Azure DevOps 服务拉取源代码管理存储库，包括描述图像，以及应用程序和测试代码的 DockerFile。</span><span class="sxs-lookup"><span data-stu-id="3e197-135">Azure DevOps Services pulls the SCC repository, including the DockerFile describing the image as well as the application and test code.</span></span>

4.  <span data-ttu-id="3e197-136">Azure DevOps 服务生成 Docker 映像并使用生成号对其进行标记。</span><span class="sxs-lookup"><span data-stu-id="3e197-136">Azure DevOps Services builds a Docker image and labels it with a build number.</span></span>

5.  <span data-ttu-id="3e197-137">Azure DevOps 服务实例化中预配 Docker 主机的 Docker 容器，并运行适当的测试。</span><span class="sxs-lookup"><span data-stu-id="3e197-137">Azure DevOps Services instantiates the Docker container within the provisioned Docker Host, and runs the appropriate tests.</span></span>

6.  <span data-ttu-id="3e197-138">如果测试成功，将映像首先重新标记为有意义的名称，以便您知道它是"blessed 的生成"(如"/ 1.0.0"或任何其他标签)，然后推送到 Docker 注册表 （Docker 中心、 Azure 容器注册表、 DTR 等） 和</span><span class="sxs-lookup"><span data-stu-id="3e197-138">If the tests are successful, the image is first relabeled to a meaningful name so that you know it is a "blessed build" (like "/1.0.0" or any other label), and then pushed up to your Docker Registry (Docker Hub, Azure Container Registry, DTR, etc.)</span></span>

### <a name="implementing-the-ci-pipeline-with-azure-devops-services-and-the-docker-extension-for-azure-devops-services"></a><span data-ttu-id="3e197-139">适用于 Azure DevOps 服务实施 CI 管道中的使用 Azure DevOps 服务和 Docker 扩展</span><span class="sxs-lookup"><span data-stu-id="3e197-139">Implementing the CI pipeline with Azure DevOps Services and the Docker extension for Azure DevOps Services</span></span>

<span data-ttu-id="3e197-140">[Azure DevOps 服务 Docker 扩展](https://aka.ms/vstsdockerextension)将任务添加到你的 CI 管道与可生成 Docker 映像，将 Docker 映像推送到经过身份验证的 Docker 注册表、 运行 Docker 映像，或运行提供 Docker 的其他操作CLI。</span><span class="sxs-lookup"><span data-stu-id="3e197-140">The [Azure DevOps Services Docker extension](https://aka.ms/vstsdockerextension) adds a task to your CI pipeline with which you can build Docker images, push Docker images to an authenticated Docker registry, run Docker images, or run other operations offered by the Docker CLI.</span></span> <span data-ttu-id="3e197-141">它还添加了 Docker Compose，可用于生成、 推送和运行多容器 Docker 应用程序，或在图 5-3 所示运行提供的 Docker Compose CLI 其他操作的任务。</span><span class="sxs-lookup"><span data-stu-id="3e197-141">It also adds a Docker Compose task that you can use to build, push, and run multicontainer Docker applications, or run other operations offered by the Docker Compose CLI, as shown in Figure 5-3.</span></span>

![](./media/image3.png)

<span data-ttu-id="3e197-142">图 5-3:Azure DevOps 服务中的 Docker CI 管道</span><span class="sxs-lookup"><span data-stu-id="3e197-142">Figure 5-3: The Docker CI pipeline in Azure DevOps Services</span></span>

<span data-ttu-id="3e197-143">Docker 扩展可以使用服务终结点，为 Docker 主机和容器或映像注册表。</span><span class="sxs-lookup"><span data-stu-id="3e197-143">The Docker extension can use service endpoints for Docker hosts and for container or image registries.</span></span> <span data-ttu-id="3e197-144">任务默认为使用本地 Docker 主机如果可用 （这当前需要自定义的 Azure DevOps 服务代理）;否则，它们需要你提供 Docker 主机连接。</span><span class="sxs-lookup"><span data-stu-id="3e197-144">The tasks default to using a local Docker host if available (this currently requires a custom Azure DevOps Services agent); otherwise, they require that you provide a Docker host connection.</span></span> <span data-ttu-id="3e197-145">操作依赖于进行身份验证与 Docker 注册表，例如将推送一个映像，需要提供 Docker 注册表连接。</span><span class="sxs-lookup"><span data-stu-id="3e197-145">Actions that depend on being authenticated with a Docker registry, such as pushing an image, require that you provide a Docker registry connection.</span></span>

<span data-ttu-id="3e197-146">Azure DevOps 服务 Docker 扩展 Azure DevOps 服务帐户中安装以下组件：</span><span class="sxs-lookup"><span data-stu-id="3e197-146">The Azure DevOps Services Docker extension installs the following components in your Azure DevOps Services account:</span></span>

-   <span data-ttu-id="3e197-147">用于连接到 Docker 注册表的服务终结点</span><span class="sxs-lookup"><span data-stu-id="3e197-147">A service endpoint for connecting to a Docker registry</span></span>

-   <span data-ttu-id="3e197-148">用于连接到 Docker 容器主机的服务终结点</span><span class="sxs-lookup"><span data-stu-id="3e197-148">A service endpoint for connecting to a Docker Container Host</span></span>

-   <span data-ttu-id="3e197-149">Docker 可执行以下任务：</span><span class="sxs-lookup"><span data-stu-id="3e197-149">A Docker task to do the following:</span></span>

-   <span data-ttu-id="3e197-150">生成映像</span><span class="sxs-lookup"><span data-stu-id="3e197-150">Build an image</span></span>

-   <span data-ttu-id="3e197-151">将图像或存储库推送到注册表</span><span class="sxs-lookup"><span data-stu-id="3e197-151">Push an image or a repository to a registry</span></span>

-   <span data-ttu-id="3e197-152">在容器中运行映像</span><span class="sxs-lookup"><span data-stu-id="3e197-152">Run an image in a container</span></span>

-   <span data-ttu-id="3e197-153">运行 Docker 命令</span><span class="sxs-lookup"><span data-stu-id="3e197-153">Run a Docker command</span></span>

-   <span data-ttu-id="3e197-154">要运行 Docker Compose 命令的 Docker Compose 任务</span><span class="sxs-lookup"><span data-stu-id="3e197-154">A Docker Compose task to run a Docker Compose command</span></span>

<span data-ttu-id="3e197-155">这些 Azure DevOps 服务任务，生成 Linux Docker 主机/VM 在 Azure 中设置和您首选的 Docker 注册表 （Azure 容器注册表、 Docker 中心、 私有 Docker DTR 或任何其他 Docker 注册表） 来组合 Docker CI 管道中的非常一致的方式。</span><span class="sxs-lookup"><span data-stu-id="3e197-155">With these Azure DevOps Services tasks, a build Linux-Docker Host/VM provisioned in Azure and your preferred Docker registry (Azure Container Registry, Docker Hub, private Docker DTR, or any other Docker registry) you can assemble your Docker CI pipeline in a very consistent way.</span></span>

<span data-ttu-id="3e197-156">***要求：***</span><span class="sxs-lookup"><span data-stu-id="3e197-156">***Requirements:***</span></span>

-   <span data-ttu-id="3e197-157">Azure DevOps 服务，或对于在本地安装，Team Foundation Server 2015 Update 3 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="3e197-157">Azure DevOps Services, or for on-premises installations, Team Foundation Server 2015 Update 3 or later.</span></span>

-   <span data-ttu-id="3e197-158">Azure DevOps 服务代理具有 Docker 二进制文件。</span><span class="sxs-lookup"><span data-stu-id="3e197-158">An Azure DevOps Services agent that has the Docker binaries.</span></span>

<span data-ttu-id="3e197-159">若要创建其中一种简单方法是使用 Docker 运行基于 Azure DevOps 服务代理 Docker 映像的容器。</span><span class="sxs-lookup"><span data-stu-id="3e197-159">An easy way to create one of these is to use Docker to run a container based on the Azure DevOps Services agent Docker image.</span></span>

<span data-ttu-id="3e197-160">**详细信息** 读取更多有关组成 Azure DevOps 服务 Docker CI 管道和要查看的演练，请访问以下站点：</span><span class="sxs-lookup"><span data-stu-id="3e197-160">**More info** To read more about assembling a Azure DevOps Services Docker CI pipeline and to view walkthroughs, visit the following sites:</span></span>

<span data-ttu-id="3e197-161">作为 Docker 容器中运行 Azure DevOps 服务代理： [ https://hub.docker.com/r/\ microsoft/vsts 代理 /](https://hub.docker.com/r/microsoft/vsts-agent/)</span><span class="sxs-lookup"><span data-stu-id="3e197-161">Running an Azure DevOps Services agent as a Docker container: [https://hub.docker.com/r/\ microsoft/vsts-agent/](https://hub.docker.com/r/microsoft/vsts-agent/)</span></span>

<span data-ttu-id="3e197-162">Azure DevOps 服务 Docker 扩展： <https://aka.ms/vstsdockerextension></span><span class="sxs-lookup"><span data-stu-id="3e197-162">Azure DevOps Services Docker extension: <https://aka.ms/vstsdockerextension></span></span>

<span data-ttu-id="3e197-163">构建使用 Azure DevOps 服务的.NET Core Linux Docker 映像： <https://blogs.msdn.microsoft.com/stevelasker/2016/06/13/building-net-core-linux-docker-images-with-visual-studio-team-services/></span><span class="sxs-lookup"><span data-stu-id="3e197-163">Building .NET Core Linux Docker images with Azure DevOps Services: <https://blogs.msdn.microsoft.com/stevelasker/2016/06/13/building-net-core-linux-docker-images-with-visual-studio-team-services/></span></span>

<span data-ttu-id="3e197-164">构建具有 Docker 支持在基于 Linux 的 Visual Studio Team Service 生成计算机： <http://donovanbrown.com/post/2016/06/03/Building-a-Linux-Based-Visual-Studio-Team-Service-Build-Machine-with-Docker-Support></span><span class="sxs-lookup"><span data-stu-id="3e197-164">Building a Linux-based Visual Studio Team Service build machine with Docker support: <http://donovanbrown.com/post/2016/06/03/Building-a-Linux-Based-Visual-Studio-Team-Service-Build-Machine-with-Docker-Support></span></span>

### <a name="integrate-test-and-validate-multicontainer-docker-applications"></a><span data-ttu-id="3e197-165">将集成、 测试和验证多容器 Docker 应用程序</span><span class="sxs-lookup"><span data-stu-id="3e197-165">Integrate, test, and validate multicontainer Docker applications</span></span>

<span data-ttu-id="3e197-166">通常情况下，大多数 Docker 应用程序组成的多个容器而不是单个容器。</span><span class="sxs-lookup"><span data-stu-id="3e197-166">Typically, most Docker applications are composed of multiple containers rather than a single container.</span></span> <span data-ttu-id="3e197-167">一个很好示例是一个面向微服务的应用程序，您将有每个微服务的一个容器。</span><span class="sxs-lookup"><span data-stu-id="3e197-167">A good example is a microservices-oriented application for which you would have one container per microservice.</span></span> <span data-ttu-id="3e197-168">但是，即使没有严格遵循微服务方法模式，则很可能 Docker 应用程序将构成多个容器或服务。</span><span class="sxs-lookup"><span data-stu-id="3e197-168">But, even without strictly following the microservices approach patterns, it is very probable that your Docker application would be composed of multiple containers or services.</span></span>

<span data-ttu-id="3e197-169">因此，生成后 CI 管道中的应用程序容器，您还需要部署、 集成和测试应用程序作为一个整体与所有其容器内集成 Docker 主机或甚至到你的容器是一个测试群集分发。</span><span class="sxs-lookup"><span data-stu-id="3e197-169">Therefore, after building the application containers in the CI pipeline, you also need to deploy, integrate, and test the application as a whole with all of its containers within an integration Docker host or even into a test cluster to which your containers are distributed.</span></span>

<span data-ttu-id="3e197-170">如果你使用单个主机，可以使用 Docker 命令，如 docker-compose 来生成和部署相关的容器来测试和验证单个 VM 中的 Docker 环境。</span><span class="sxs-lookup"><span data-stu-id="3e197-170">If you're using a single host, you can use Docker commands such as docker-compose to build and deploy related containers to test and validate the Docker environment in a single VM.</span></span> <span data-ttu-id="3e197-171">但是，如果您正在使用如 DC/OS、 Kubernetes 或 Docker Swarm 的业务流程协调程序群集，则需要将通过不同的机制或业务流程协调程序，具体取决于你所选群集/计划程序将容器部署。</span><span class="sxs-lookup"><span data-stu-id="3e197-171">But, if you are working with an orchestrator cluster like DC/OS, Kubernetes, or Docker Swarm, you need to deploy your containers through a different mechanism or orchestrator, depending on your selected cluster/scheduler.</span></span>

<span data-ttu-id="3e197-172">以下是几种可以针对 Docker 容器运行的测试类型：</span><span class="sxs-lookup"><span data-stu-id="3e197-172">Following are several types of tests that you can run against Docker containers:</span></span>

-   <span data-ttu-id="3e197-173">Docker 容器的单元测试</span><span class="sxs-lookup"><span data-stu-id="3e197-173">Unit tests for Docker containers</span></span>

-   <span data-ttu-id="3e197-174">测试组又彼此相关的应用程序或微服务</span><span class="sxs-lookup"><span data-stu-id="3e197-174">Testing groups of interrelated applications or microservices</span></span>

-   <span data-ttu-id="3e197-175">在生产环境和"canary，"版本中测试</span><span class="sxs-lookup"><span data-stu-id="3e197-175">Test in production and "canary" releases</span></span>

<span data-ttu-id="3e197-176">重要的一点是，运行时集成和功能测试，必须运行从容器外部这些测试。</span><span class="sxs-lookup"><span data-stu-id="3e197-176">The important point is that when running integration and functional tests, you must run those tests from outside of the containers.</span></span> <span data-ttu-id="3e197-177">测试必须不定义和部署，在容器内运行，因为容器基于应与那些你将部署到生产环境完全相同的静态图像。</span><span class="sxs-lookup"><span data-stu-id="3e197-177">Tests must not be defined and run within the containers that you are deploying, because the containers are based on static images that should be exactly like those that you will be deploying into production.</span></span>

<span data-ttu-id="3e197-178">测试等测试 （测试群集、 临时群集和生产群集） 的多个群集的更高级的方案时是非常可行的选项是将映像发布到注册表中各种群集测试。</span><span class="sxs-lookup"><span data-stu-id="3e197-178">A very feasible option when testing more advanced scenarios like testing several clusters (test cluster, staging cluster, and production cluster) is to publish the images to a registry to test in various clusters.</span></span>

### <a name="push-the-custom-application-docker-image-into-your-global-docker-registry"></a><span data-ttu-id="3e197-179">将自定义应用程序 Docker 映像推送到全局 Docker 注册表</span><span class="sxs-lookup"><span data-stu-id="3e197-179">Push the custom application Docker image into your global Docker Registry</span></span>

<span data-ttu-id="3e197-180">Docker 映像已测试并验证后，你将想要标记并将其发布到 Docker 注册表。</span><span class="sxs-lookup"><span data-stu-id="3e197-180">After the Docker images have been tested and validated, you'll want to tag and publish them to your Docker registry.</span></span> <span data-ttu-id="3e197-181">Docker 注册表是 Docker 应用程序生命周期中一项重要，因为它是你在其中存储自定义测试 （也称为"blessed 映像"） 以便将部署到 QA 和生产环境的中心位置。</span><span class="sxs-lookup"><span data-stu-id="3e197-181">The Docker registry is a critical piece in the Docker application life cycle because it is the central place where you store your custom test (aka "blessed images") to be deployed into QA and production environments.</span></span>

<span data-ttu-id="3e197-182">与存储在源代码管理存储库 （Git 等） 的应用程序代码的"事实来源"的方式类似，Docker 注册表是"事实来源"二进制应用程序或 bits 要部署到 QA 或生产环境。</span><span class="sxs-lookup"><span data-stu-id="3e197-182">Similar to how the application code stored in your SCC repository (Git, etc.) is your "source of truth," the Docker registry is your "source of truth" for your binary application or bits to be deployed to the QA or production environments.</span></span>

<span data-ttu-id="3e197-183">通常情况下，你可能想要自定义映像的专用存储库在专用存储库中 Azure 容器注册表或 Docker 受信任注册表，如在本地注册表中或在具有受限访问权限 （如公共云注册表中Docker 中心），尽管在此最后一个的情况下，如果你的代码不是开放源代码，您必须信任很多供应商的安全。</span><span class="sxs-lookup"><span data-stu-id="3e197-183">Typically, you might want to have your private repositories for your custom images either in a private repository in Azure Container Registry or in an on-premises registry like Docker Trusted Registry, or in a public-cloud registry with restricted access (like Docker Hub), although in this last case if your code is not open source, you must trust the vendor's security.</span></span> <span data-ttu-id="3e197-184">无论哪种方式，依据你执行此操作的方法是非常相似，并且最终基于 docker push 命令，同时在图 5-4 所示。</span><span class="sxs-lookup"><span data-stu-id="3e197-184">Either way, the method by which you do this is pretty similar and ultimately based on the docker push command, as depicted in Figure 5-4.</span></span>

![](./media/image4.png)

<span data-ttu-id="3e197-185">图 5-4:正在自定义映像发布到 Docker 注册表</span><span class="sxs-lookup"><span data-stu-id="3e197-185">Figure 5-4: Publishing custom images to Docker Registry</span></span>

<span data-ttu-id="3e197-186">有多个产品/服务的 Azure 容器注册表、 Amazon Web 服务容器注册表、 Google 容器注册表、 Quay 注册表等云供应商提供 Docker 注册表。</span><span class="sxs-lookup"><span data-stu-id="3e197-186">There are multiple offerings of Docker registries from cloud vendors like Azure Container Registry, Amazon Web Services Container Registry, Google Container Registry, Quay Registry, and so on.</span></span>

<span data-ttu-id="3e197-187">使用 Azure DevOps 服务 Docker 扩展插件，您可以将推送服务映像由的 docker-compose.yml 文件，使用多个标记，向一个已经过身份验证的 Docker 注册表 （如 Azure 容器注册表），定义一组在图 5-5 所示。</span><span class="sxs-lookup"><span data-stu-id="3e197-187">Using the Azure DevOps Services Docker extension, you can push a set of service images defined by a docker-compose.yml file, with multiple tags, to an authenticated Docker registry (like Azure Container Registry), as shown in Figure 5-5.</span></span>

![](./media/image5.png)

<span data-ttu-id="3e197-188">图 5-5:使用 Azure DevOps 服务为发布到 Docker 注册表的自定义映像</span><span class="sxs-lookup"><span data-stu-id="3e197-188">Figure 5-5: Using Azure DevOps Services to publishing custom images to a Docker Registry</span></span>

<span data-ttu-id="3e197-189">**详细信息** 若要了解有关 Azure DevOps 服务的 Docker 扩展，请转到<https://aka.ms/vstsdockerextension>。</span><span class="sxs-lookup"><span data-stu-id="3e197-189">**More info** To read more about the Docker extension for Azure DevOps Services, go to <https://aka.ms/vstsdockerextension>.</span></span> <span data-ttu-id="3e197-190">若要了解有关 Azure 容器注册表的详细信息，请转到<https://aka.ms/azurecontainerregistry>。</span><span class="sxs-lookup"><span data-stu-id="3e197-190">To learn more about Azure Container Registry, go to <https://aka.ms/azurecontainerregistry>.</span></span>

## <a name="step-4-cd-deploy"></a><span data-ttu-id="3e197-191">步骤 4：CD，部署</span><span class="sxs-lookup"><span data-stu-id="3e197-191">Step 4: CD, Deploy</span></span>

<span data-ttu-id="3e197-192">Docker 映像的不可变性可以确保具有什么开发、 CI 使用，请通过测试并在生产环境中运行的可重复部署。</span><span class="sxs-lookup"><span data-stu-id="3e197-192">The immutability of Docker images ensures a repeatable deployment with what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="3e197-193">在 Docker 注册表 （专用或公用） 中发布的应用程序 Docker 映像后，您可以将其部署到你可能有多个环境 (生产、 QA、 暂存、 等) 从 CD 管道通过使用 Azure DevOps 服务管道任务或 Azure DevOps 服务版本管理。</span><span class="sxs-lookup"><span data-stu-id="3e197-193">After you have the application Docker images published in your Docker registry (either private or public), you can deploy them to the several environments that you might have (production, QA, staging, etc.) from your CD pipeline by using Azure DevOps Services pipeline tasks or Azure DevOps Services Release Management.</span></span>

<span data-ttu-id="3e197-194">但是，现在它取决于要部署哪些类型的 Docker 应用程序。</span><span class="sxs-lookup"><span data-stu-id="3e197-194">However, at this point it depends on what kind of Docker application you are deploying.</span></span> <span data-ttu-id="3e197-195">部署简单的应用程序 （组合和部署的角度来看） 等一个单片包含几个容器或服务应用程序和已部署到少量服务器或 Vm 有很大差异部署等更复杂的应用程序面向微服务的应用程序与超大规模的功能。</span><span class="sxs-lookup"><span data-stu-id="3e197-195">Deploying a simple application (from a composition and deployment point of view) like a monolithic application comprising a few containers or services and deployed to a few servers or VMs is very different from deploying a more complex application like a microservices-oriented application with hyperscale capabilities.</span></span> <span data-ttu-id="3e197-196">以下各节中介绍了这两种方案。</span><span class="sxs-lookup"><span data-stu-id="3e197-196">These two scenarios are explained in the following sections.</span></span>

### <a name="deploying-composed-docker-applications-to-multiple-docker-environments"></a><span data-ttu-id="3e197-197">部署包含 Docker 应用程序到多个 Docker 环境</span><span class="sxs-lookup"><span data-stu-id="3e197-197">Deploying composed Docker applications to multiple Docker environments</span></span>

<span data-ttu-id="3e197-198">让我们来看第一个在不太复杂方案： 部署到单个环境或多个环境中的简单 Docker 主机 （Vm 或服务器） (QA、 过渡和生产)。</span><span class="sxs-lookup"><span data-stu-id="3e197-198">Let's look first at the less-complex scenario: deploying to simple Docker hosts (VMs or servers) in a single environment or multiple environments (QA, staging, and production).</span></span> <span data-ttu-id="3e197-199">在此方案中，在内部 CD 管道可以使用 docker-compose （从 Azure DevOps 服务部署任务） 来部署 Docker 应用程序使用其相关的一组的容器或服务，如图 5-6 所示。</span><span class="sxs-lookup"><span data-stu-id="3e197-199">In this scenario, internally your CD pipeline can use docker-compose (from your Azure DevOps Services deployment tasks) to deploy the Docker applications with its related set of containers or services, as illustrated in Figure 5-6.</span></span>

![](./media/image6.png)

<span data-ttu-id="3e197-200">图 5-6:将应用程序的容器部署到简单的 Docker 主机环境注册表</span><span class="sxs-lookup"><span data-stu-id="3e197-200">Figure 5-6: Deploying application containers to simple Docker host environments registry</span></span>

<span data-ttu-id="3e197-201">图 5-7 突出显示了如何连接生成 CI QA/测试环境，通过 Azure DevOps 服务通过单击添加任务对话框中的 Docker Compose。</span><span class="sxs-lookup"><span data-stu-id="3e197-201">Figure 5-7 highlights how you can connect your build CI to QA/test environments via Azure DevOps Services by clicking Docker Compose in the Add Task dialog box.</span></span> <span data-ttu-id="3e197-202">但是，部署到过渡或生产环境时，你通常将处理多个环境的发布管理功能 (如 QA、 过渡和生产)。</span><span class="sxs-lookup"><span data-stu-id="3e197-202">However, when deploying to staging or production environments, you would usually use Release Management features handling multiple environments (like QA, staging, and production).</span></span> <span data-ttu-id="3e197-203">如果你正在部署到单个 Docker 主机，它使用 Azure DevOps 服务"Docker Compose"任务 (这调用 docker-compose up 实质上的命令)。</span><span class="sxs-lookup"><span data-stu-id="3e197-203">If you're deploying to single Docker hosts, it is using the Azure DevOps Services "Docker Compose" task (which is invoking the docker-compose up command under the hood).</span></span> <span data-ttu-id="3e197-204">如果你正在部署到 Azure 容器服务，它使用 Docker 部署任务，如后面的部分中所述。</span><span class="sxs-lookup"><span data-stu-id="3e197-204">If you're deploying to Azure Container Service, it uses the Docker Deployment task, as explained in the section that follows.</span></span>

![](./media/image7.png)

<span data-ttu-id="3e197-205">图 5-7:Azure DevOps 服务管道中添加 Docker Compose 任务</span><span class="sxs-lookup"><span data-stu-id="3e197-205">Figure 5-7: Adding a Docker Compose task in a Azure DevOps Services pipeline</span></span>

<span data-ttu-id="3e197-206">当在 Azure DevOps 服务中创建发布时，花了一套输入项目。</span><span class="sxs-lookup"><span data-stu-id="3e197-206">When you create a release in Azure DevOps Services, it takes a set of input artifacts.</span></span> <span data-ttu-id="3e197-207">用于在多个环境是不可变的整个生存期内发布。</span><span class="sxs-lookup"><span data-stu-id="3e197-207">These are intended to be immutable throughout the lifetime of the release across multiple environments.</span></span> <span data-ttu-id="3e197-208">在引入容器时，输入的项目标识注册表部署中的映像。</span><span class="sxs-lookup"><span data-stu-id="3e197-208">When you introduce containers, the input artifacts identify images in a registry to deploy.</span></span> <span data-ttu-id="3e197-209">具体取决于如何标识这些，不保证保持不变，则整个发布，最明显的情况下，docker-compose 文件中引用"myimage:latest"时的持续时间。</span><span class="sxs-lookup"><span data-stu-id="3e197-209">Depending on how these are identified, they are not guaranteed to remain the same throughout the duration of the release, the most obvious case being when you reference "myimage:latest" from a docker-compose file.</span></span>

<span data-ttu-id="3e197-210">适用于 Azure DevOps 服务的 Docker 扩展可以生成包含特定的注册表的映像的生成项目的功能摘要可保证能唯一标识同一图像二进制文件。</span><span class="sxs-lookup"><span data-stu-id="3e197-210">The Docker extension for Azure DevOps Services gives you the ability to generate build artifacts that contain specific registry image digests that are guaranteed to uniquely identify the same image binary.</span></span> <span data-ttu-id="3e197-211">这些是你确实要用作输入到发行版。</span><span class="sxs-lookup"><span data-stu-id="3e197-211">These are what you really want to use as input to a release.</span></span>

### <a name="managing-releases-to-docker-environments-by-using-azure-devops-services-release-management"></a><span data-ttu-id="3e197-212">通过使用 Azure DevOps 服务 Release Management 管理发布到 Docker 环境</span><span class="sxs-lookup"><span data-stu-id="3e197-212">Managing releases to Docker environments by using Azure DevOps Services Release Management</span></span>

<span data-ttu-id="3e197-213">通过 Azure DevOps 服务扩展，可以生成新映像、 将其发布到 Docker 注册表、 Linux 或 Windows 主机上运行和使用 docker 等命令-compose 来将多个容器部署为整个应用程序，作为 Azure DevOps 后盾服务的多个环境的发布管理功能，在图 5-8 所示。</span><span class="sxs-lookup"><span data-stu-id="3e197-213">Through the Azure DevOps Services extensions, you can build a new image, publish it to a Docker registry, run it on Linux or Windows hosts, and use commands such as docker-compose to deploy multiple containers as an entire application, all through the Azure DevOps Services Release Management capabilities intended for multiple environments, as shown in Figure 5-8.</span></span>

![](./media/image8.png)

<span data-ttu-id="3e197-214">图 5-8:Azure DevOps 服务 Docker Compose 通过 Azure DevOps 服务版本管理的任务的配置</span><span class="sxs-lookup"><span data-stu-id="3e197-214">Figure 5-8: Configuring Azure DevOps Services Docker Compose tasks from Azure DevOps Services Release Management</span></span>

<span data-ttu-id="3e197-215">但是，请记住在图 5-6 所示和实现图 5-8 中的方案是相当基本的 （它部署简单的 Docker 主机和 Vm，并且将单个容器或每个映像的实例），并且可能仅应该用于开发或测试 scenarios。</span><span class="sxs-lookup"><span data-stu-id="3e197-215">However, keep in mind that the scenario shown in Figure 5-6 and implemented in Figure 5-8 is pretty basic (it is deploying to simple Docker hosts and VMs, and there will be a single container or instance per image) and probably should be used only for development or test scenarios.</span></span> <span data-ttu-id="3e197-216">在大多数企业生产方案中，你会想要具有高可用性 (HA) 和易于管理可伸缩性的负载平衡跨多个节点、 服务器和 Vm，以及"智能故障转移"因此，如果服务器或节点发生故障，其服务和容器将移到另一个主机服务器或 VM。</span><span class="sxs-lookup"><span data-stu-id="3e197-216">In most enterprise production scenarios, you would want to have High Availability (HA) and easy-to-manage scalability by load balancing across multiple nodes, servers, and VMs, plus "intelligent failovers" so that if a server or node fails, its services and containers will be moved to another host server or VM.</span></span> <span data-ttu-id="3e197-217">在这种情况下，您需要更高级的技术，如容器群集、 业务流程协调程序和计划程序。</span><span class="sxs-lookup"><span data-stu-id="3e197-217">In that case, you need more advanced technologies like container clusters, orchestrators, and schedulers.</span></span> <span data-ttu-id="3e197-218">因此，将部署到这些群集的方法是精确地通过下一节中所述的高级方案。</span><span class="sxs-lookup"><span data-stu-id="3e197-218">Thus, the way to deploy to those clusters is precisely through the advanced scenarios explained in the next section.</span></span>

### <a name="deploying-complex-docker-applications-to-docker-clusters-dcos-kubernetes-and-docker-swarm"></a><span data-ttu-id="3e197-219">复杂 Docker 应用程序部署到 Docker 群集 （DC/OS、 Kubernetes 和 Docker Swarm）</span><span class="sxs-lookup"><span data-stu-id="3e197-219">Deploying complex Docker applications to Docker clusters (DC/OS, Kubernetes, and Docker Swarm)</span></span>

<span data-ttu-id="3e197-220">分布式应用程序的性质要求，还将分散的计算资源。</span><span class="sxs-lookup"><span data-stu-id="3e197-220">The nature of distributed applications requires compute resources that are also distributed.</span></span> <span data-ttu-id="3e197-221">若要具备生产级功能，您必须具备群集提供高可伸缩性的功能和高可用性根据共用资源。</span><span class="sxs-lookup"><span data-stu-id="3e197-221">To have production-scale capabilities, you need to have clustering capabilities that provide high scalability and HA based on pooled resources.</span></span>

<span data-ttu-id="3e197-222">您可以将容器部署手动到这些群集从 Docker Swarm 之类的 CLI 工具 (如使用[docker 服务创建](https://docs.docker.com/engine/swarm/swarm-tutorial/deploy-service/)) 或 web UI 如[Mesosphere Marathon](https://mesosphere.github.io/marathon/docs/marathon-ui.html)对于 DC/OS 群集，但您应保留的仅供测试 punctual 部署或管理目的，例如向外扩展或监视目的。</span><span class="sxs-lookup"><span data-stu-id="3e197-222">You could deploy containers manually to those clusters from a CLI tool such as Docker Swarm (like using [docker service create](https://docs.docker.com/engine/swarm/swarm-tutorial/deploy-service/)) or a web UI such as [Mesosphere Marathon](https://mesosphere.github.io/marathon/docs/marathon-ui.html) for DC/OS clusters, but you should reserve that only for punctual deployment testing or for management purposes like scaling-out or monitoring purposes.</span></span>

<span data-ttu-id="3e197-223">从 CD 的角度来看，Azure DevOps 服务具体而言，您可以运行和精心制作的部署任务从你的 Azure DevOps 服务发布管理环境这会将部署到容器中的分布式群集你容器化应用程序服务，如图 5-9 所示。</span><span class="sxs-lookup"><span data-stu-id="3e197-223">From a CD point of view, and Azure DevOps Services specifically, you can run specially made deployment tasks from your Azure DevOps Services Release Management environments which will deploy your containerized applications to distributed clusters in Container Service, as illustrated in Figure 5-9.</span></span>

![](./media/image9.png)

<span data-ttu-id="3e197-224">图 5-9:分布式应用程序部署到容器服务</span><span class="sxs-lookup"><span data-stu-id="3e197-224">Figure 5-9: Deploying distributed applications to Container Service</span></span>

<span data-ttu-id="3e197-225">最初，部署到特定群集或业务流程协调程序时，您将传统上使用特定的部署脚本和机制按每个业务流程协调程序 （即，Mesosphere DC/OS 或 Kubernetes 具有不同的部署机制比 Docker 和 DockerSwarm) 而不是更简单、 易于使用 docker compose 根据的 docker-compose.yml 定义文件的工具。</span><span class="sxs-lookup"><span data-stu-id="3e197-225">Initially, when deploying to certain clusters or orchestrators, you would traditionally use specific deployment scripts and mechanisms per each orchestrator (that is, Mesosphere DC/OS or Kubernetes have different deployment mechanisms than Docker and Docker Swarm) instead of the simpler and easy-to-use docker-compose tool based on the docker-compose.yml definition file.</span></span> <span data-ttu-id="3e197-226">但是，得益于 Microsoft Azure DevOps 服务 Docker 部署任务中，显示在图 5-10，你现在还可以部署到 DC/OS 通过只使用熟悉的 docker-compose.yml 文件，因为 Microsoft 会为您执行该"转换"(从你docker-compose.yml 文件为其他格式所需的 DC/OS）。</span><span class="sxs-lookup"><span data-stu-id="3e197-226">However, thanks to the Microsoft Azure DevOps Services Docker Deploy task, shown in Figure 5-10, you now also can deploy to DC/OS by just using your familiar docker-compose.yml file because Microsoft performs that "translation" for you (from your docker-compose.yml file to other formats needed by DC/OS).</span></span>

![](./media/image10.png)

<span data-ttu-id="3e197-227">图 5-10:将 Docker 部署任务添加到环境 RM</span><span class="sxs-lookup"><span data-stu-id="3e197-227">Figure 5-10: Adding the Docker Deploy task to your Environment RM</span></span>

<span data-ttu-id="3e197-228">图 5-11 演示了如何编辑 Docker 部署任务和指定目标类型 (Azure 容器服务 DC/OS，在此情况下)、 在 Docker Compose 文件，以及 （如 Azure 容器注册表或 Docker 中心） 的 Docker 注册表连接。</span><span class="sxs-lookup"><span data-stu-id="3e197-228">Figure 5-11 demonstrates how you can edit the Docker Deploy task and specify the Target Type (Azure Container Service DC/OS, in this case), your Docker Compose File, and the Docker Registry connection (like Azure Container Registry or Docker Hub).</span></span> <span data-ttu-id="3e197-229">这是该任务将在其中检索随时可用自定义 Docker 映像部署为 DC/OS 群集中的容器。</span><span class="sxs-lookup"><span data-stu-id="3e197-229">This is where the task will retrieve your ready-to-use custom Docker images to be deployed as containers in the DC/OS cluster.</span></span>

![](./media/image11.png)

<span data-ttu-id="3e197-230">图 5-11:Docker 部署任务定义部署到 Azure 容器服务 DC/OS</span><span class="sxs-lookup"><span data-stu-id="3e197-230">Figure 5-11: Docker Deploy task definition deploying to Azure Container Service DC/OS</span></span>

<span data-ttu-id="3e197-231">**详细信息** 若要了解更多有关使用 Azure DevOps 服务和 Docker 在 CD 管道，请访问以下站点：</span><span class="sxs-lookup"><span data-stu-id="3e197-231">**More info** To read more about the CD pipeline with Azure DevOps Services and Docker, visit the following sites:</span></span>

<span data-ttu-id="3e197-232">适用于 Docker 和 Azure 容器服务的 azure DevOps 服务扩展： [ https://aka.ms/\ vstsdockerextension](https://aka.ms/vstsdockerextension)</span><span class="sxs-lookup"><span data-stu-id="3e197-232">Azure DevOps Services extension for Docker and Azure Container Service: [https://aka.ms/\ vstsdockerextension](https://aka.ms/vstsdockerextension)</span></span>

<span data-ttu-id="3e197-233">Azure 容器服务： <https://aka.ms/azurecontainerservice></span><span class="sxs-lookup"><span data-stu-id="3e197-233">Azure Container Service: <https://aka.ms/azurecontainerservice></span></span>

<span data-ttu-id="3e197-234">Mesosphere DC/OS: <https://mesosphere.com/product/></span><span class="sxs-lookup"><span data-stu-id="3e197-234">Mesosphere DC/OS: <https://mesosphere.com/product/></span></span>

## <a name="step-5-run-and-manage"></a><span data-ttu-id="3e197-235">步骤 5：运行和管理</span><span class="sxs-lookup"><span data-stu-id="3e197-235">Step 5: Run and manage</span></span>

<span data-ttu-id="3e197-236">因为运行和管理应用程序在企业生产级别为主要使用者在和的本身，并由于操作的类型，并且在该级别 （IT 操作） 以及此区域的大范围的人员，我们另辟整个接下来为解释它的一章。</span><span class="sxs-lookup"><span data-stu-id="3e197-236">Because running and managing applications at enterprise-production level is a major subject in and of itself, and due to the type of operations and people working at that level (IT operations) as well as the large scope of this area, we have devoted the entire next chapter to explaining it.</span></span>

## <a name="step-6-monitor-and-diagnose"></a><span data-ttu-id="3e197-237">步骤 6:监视和诊断</span><span class="sxs-lookup"><span data-stu-id="3e197-237">Step 6: Monitor and diagnose</span></span>

<span data-ttu-id="3e197-238">本主题还介绍了下一步一章中的 IT 操作在生产系统; 执行的任务的一部分但是，务必要突出显示在此步骤中获得的见解必须馈送回到开发团队，以便应用程序不断得到改进。</span><span class="sxs-lookup"><span data-stu-id="3e197-238">This topic also is covered in the next chapter as part of the tasks that IT operations performs in production systems; however, is important to highlight that the insights obtained in this step must feed back to the development team so that the application is constantly improved.</span></span> <span data-ttu-id="3e197-239">从该角度来看，它也是一部分的 DevOps，尽管任务和操作通常由执行 IT。</span><span class="sxs-lookup"><span data-stu-id="3e197-239">From that point of view, it is also part of DevOps, although the tasks and operations are usually performed by IT.</span></span>

<span data-ttu-id="3e197-240">仅监视和诊断在 DevOps 领域中的 100%时，监视进程和由开发团队针对测试或 beta 环境执行的分析。</span><span class="sxs-lookup"><span data-stu-id="3e197-240">Only when monitoring and diagnostics are 100 percent within the realm of DevOps are the monitoring processes and analytics performed by the development team against testing or beta environments.</span></span> <span data-ttu-id="3e197-241">这是通过执行负载测试或只需通过监视 beta 或 QA 环境，beta 版测试人员正在新版本。</span><span class="sxs-lookup"><span data-stu-id="3e197-241">This is done either by performing load testing or simply by monitoring beta or QA environments, where beta testers are trying the new versions.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="3e197-242">[上一页](index.md)
>[下一页](../run-manage-monitor-docker-environments/index.md)</span><span class="sxs-lookup"><span data-stu-id="3e197-242">[Previous](index.md)
[Next](../run-manage-monitor-docker-environments/index.md)</span></span>