---
title: Docker 应用程序的外部循环 DevOps 工作流步骤
description: 了解 DevOps 工作流的"外部循环"的步骤
ms.date: 02/15/2019
ms.openlocfilehash: 194786a90fc02801211c7614eb632392d67f0109
ms.sourcegitcommit: 8699383914c24a0df033393f55db3369db728a7b
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 05/15/2019
ms.locfileid: "65641056"
---
# <a name="steps-in-the-outer-loop-devops-workflow-for-a-docker-application"></a><span data-ttu-id="1f93b-103">Docker 应用程序的外部循环 DevOps 工作流步骤</span><span class="sxs-lookup"><span data-stu-id="1f93b-103">Steps in the outer-loop DevOps workflow for a Docker application</span></span>

<span data-ttu-id="1f93b-104">图 5-1 提供了端到端描述的组成 DevOps 外部循环工作流的步骤。</span><span class="sxs-lookup"><span data-stu-id="1f93b-104">Figure 5-1 presents an end-to-end depiction of the steps comprising the DevOps outer-loop workflow.</span></span>

![下图显示了 DevOps 的"外部循环"。](./media/image1.png)

<span data-ttu-id="1f93b-108">**图 5-1**。</span><span class="sxs-lookup"><span data-stu-id="1f93b-108">**Figure 5-1**.</span></span> <span data-ttu-id="1f93b-109">使用 Microsoft 工具的 Docker 应用程序的 DevOps 外部循环工作流</span><span class="sxs-lookup"><span data-stu-id="1f93b-109">DevOps outer-loop workflow for Docker applications with Microsoft tools</span></span>

<span data-ttu-id="1f93b-110">现在，让我们检查每个中更详细地介绍这些步骤。</span><span class="sxs-lookup"><span data-stu-id="1f93b-110">Now, let's examine each of these steps in greater detail.</span></span>

## <a name="step-1-inner-loop-development-workflow"></a><span data-ttu-id="1f93b-111">步骤 1：内部循环开发工作流</span><span class="sxs-lookup"><span data-stu-id="1f93b-111">Step 1: Inner-loop development workflow</span></span>

<span data-ttu-id="1f93b-112">第 4 章中详细介绍了此步骤，但概括来说，下面是其中外部循环开始时，开发人员将推送到源控件管理系统 （如 Git) 的代码启动 CI 管道操作的时刻。</span><span class="sxs-lookup"><span data-stu-id="1f93b-112">This step is explained in detail in Chapter 4, but, to recap, here is where the outer-loop begins, the moment at which a developer pushes code to the source control management system (like Git) initiating CI pipeline actions.</span></span>

## <a name="step-2-source-code-control-integration-and-management-with-azure-devops-services-and-git"></a><span data-ttu-id="1f93b-113">步骤 2：源代码管理集成和使用 Azure DevOps 服务和 Git 管理</span><span class="sxs-lookup"><span data-stu-id="1f93b-113">Step 2: Source-Code Control integration and management with Azure DevOps Services and Git</span></span>

<span data-ttu-id="1f93b-114">在此步骤中，您需要有了要收集来自不同的开发人员团队中的所有代码的合并的版本的版本控制系统。</span><span class="sxs-lookup"><span data-stu-id="1f93b-114">At this step, you need to have a version-control system to gather a consolidated version of all the code coming from the different developers in the team.</span></span>

<span data-ttu-id="1f93b-115">即使源代码管理 (SCC) 和源代码管理可能看起来得心应手周期的对大多数开发人员，开发运营生命周期中创建 Docker 应用程序时，务必强调必须提交与应用程序的 Docker 映像直接对全局 Docker 注册表 （如 Azure 容器注册表或 Docker Hub） 从开发人员的计算机。</span><span class="sxs-lookup"><span data-stu-id="1f93b-115">Even though source-code control (SCC) and source-code management might seem second-nature to most developers, when creating Docker applications in a DevOps life cycle, it's critical to emphasize that you must not submit the Docker images with the application directly to the global Docker Registry (like Azure Container Registry or Docker Hub) from the developer's machine.</span></span> <span data-ttu-id="1f93b-116">相反，必须全局生成或基于源代码存储库 （如 Git) 的 CI 管道中仅对集成的源代码创建 Docker 映像的发布和部署到生产环境。</span><span class="sxs-lookup"><span data-stu-id="1f93b-116">On the contrary, the Docker images to be released and deployed to production environments must be created solely on the source code that's being integrated in your global build or CI pipeline based on your source-code repository (like Git).</span></span>

<span data-ttu-id="1f93b-117">通过它们应只使用本地映像，生成的开发人员，他们自己的计算机中测试时。</span><span class="sxs-lookup"><span data-stu-id="1f93b-117">The local images, generated by developers, should just be used by them when testing within their own machines.</span></span> <span data-ttu-id="1f93b-118">这就是为什么很重要已从源代码管理代码激活在 DevOps 管道。</span><span class="sxs-lookup"><span data-stu-id="1f93b-118">That's why it's critical to have the DevOps pipeline activated from the SCC code.</span></span>

<span data-ttu-id="1f93b-119">Azure DevOps 服务和 Team Foundation Server 支持 Git 和 Team Foundation 版本控制。</span><span class="sxs-lookup"><span data-stu-id="1f93b-119">Azure DevOps Services and Team Foundation Server support Git and Team Foundation Version Control.</span></span> <span data-ttu-id="1f93b-120">可以选择它们，并将其用于端到端 Microsoft 体验。</span><span class="sxs-lookup"><span data-stu-id="1f93b-120">You can choose between them and use it for an end-to-end Microsoft experience.</span></span> <span data-ttu-id="1f93b-121">但是，还可以管理外部存储库 （如 GitHub、 本地 Git 存储库或 Subversion） 中的代码和仍将能够连接到它并获取你的 DevOps CI 管道作为起始点的代码。</span><span class="sxs-lookup"><span data-stu-id="1f93b-121">However, you also can manage your code in external repositories (like GitHub, on-premises Git repositories, or Subversion) and still be able to connect to it and get the code as the starting point for your DevOps CI pipeline.</span></span>

## <a name="step-3-build-ci-integrate-and-test-with-azure-devops-services-and-docker"></a><span data-ttu-id="1f93b-122">步骤 3：构建 CI，集成和测试 Azure DevOps 服务和 Docker</span><span class="sxs-lookup"><span data-stu-id="1f93b-122">Step 3: Build, CI, Integrate, and Test with Azure DevOps Services and Docker</span></span>

<span data-ttu-id="1f93b-123">CI 已成为新式软件测试和交付的标准。</span><span class="sxs-lookup"><span data-stu-id="1f93b-123">CI has emerged as a standard for modern software testing and delivery.</span></span> <span data-ttu-id="1f93b-124">Docker 解决方案维护开发和运营团队之间明确地分离。</span><span class="sxs-lookup"><span data-stu-id="1f93b-124">The Docker solution maintains a clear separation of concerns between the development and operations teams.</span></span> <span data-ttu-id="1f93b-125">Docker 映像的不变性可确保内容已开发、 CI 使用，请通过测试和生产环境中运行之间的可重复部署。</span><span class="sxs-lookup"><span data-stu-id="1f93b-125">The immutability of Docker images ensures a repeatable deployment between what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="1f93b-126">在开发人员的便携式计算机中部署 docker 引擎，测试基础结构，使容器可移植跨环境。</span><span class="sxs-lookup"><span data-stu-id="1f93b-126">Docker Engine deployed across the developer laptops and test infrastructure makes the containers portable across environments.</span></span>

<span data-ttu-id="1f93b-127">在此情况下，使用正确的代码提交的版本控制系统后，你需要*构建的服务*选取代码并运行的全局生成和测试。</span><span class="sxs-lookup"><span data-stu-id="1f93b-127">At this point, after you have a version-control system with the correct code submitted, you need a *build service* to pick up the code and run the global build and tests.</span></span>

<span data-ttu-id="1f93b-128">此步骤中 （CI、 生成、 测试） 的内部工作流是构造的 CI 管道包含的代码存储库 （Git 等），您的生成服务器 （Azure DevOps 服务）、 Docker 引擎和 Docker 注册表。</span><span class="sxs-lookup"><span data-stu-id="1f93b-128">The internal workflow for this step (CI, build, test) is about the construction of a CI pipeline consisting of your code repository (Git, etc.), your build server (Azure DevOps Services), Docker Engine, and a Docker Registry.</span></span>

<span data-ttu-id="1f93b-129">您可以使用 Azure DevOps 服务为基础构建您的应用程序和设置 CI 管道，也会发布已生成的"项目"到"项目存储库，"下一步中进行介绍。</span><span class="sxs-lookup"><span data-stu-id="1f93b-129">You can use Azure DevOps Services as the foundation for building your applications and setting your CI pipeline, and for publishing the built "artifacts" to an "artifacts repository," which is explained in the next step.</span></span>

<span data-ttu-id="1f93b-130">使用 Docker 进行部署，"最后一个项目"时要部署应用程序或服务的 Docker 映像中嵌入它们。</span><span class="sxs-lookup"><span data-stu-id="1f93b-130">When using Docker for the deployment, the "final artifacts" to be deployed are Docker images with your application or services embedded within them.</span></span> <span data-ttu-id="1f93b-131">这些映像都推送或发布到*Docker 注册表*（私有等存储库可在 Azure 容器注册表中拥有的或公共 Docker 中心注册表，通常用于官方基础映像类似）。</span><span class="sxs-lookup"><span data-stu-id="1f93b-131">Those images are pushed or published to a *Docker Registry* (a private repository like the ones you can have in Azure Container Registry, or a public one like Docker Hub Registry, which is commonly used for official base images).</span></span>

<span data-ttu-id="1f93b-132">下面是一个基本概念：CI 管道将启动的情况下关闭状态提交到 Git 等源代码管理存储库。</span><span class="sxs-lookup"><span data-stu-id="1f93b-132">Here is the basic concept: The CI pipeline will be kicked-off by a commit to an SCC repository like Git.</span></span> <span data-ttu-id="1f93b-133">提交会导致 Azure DevOps 服务运行 Docker 容器中的生成作业，并该作业的成功完成后，将 Docker 映像推送到 Docker 注册表中，在图 5-2 所示。</span><span class="sxs-lookup"><span data-stu-id="1f93b-133">The commit will cause Azure DevOps Services to run a build job within a Docker container and, upon successful completion of that job, push a Docker image to the Docker Registry, as illustrated in Figure 5-2.</span></span>

![外部循环的第一部分涉及到步骤 1 到 3，从代码中运行、 调试和验证，然后生成和测试 CI 步骤的代码存储库](./media/image2.png)

<span data-ttu-id="1f93b-135">**图 5-2**。</span><span class="sxs-lookup"><span data-stu-id="1f93b-135">**Figure 5-2**.</span></span> <span data-ttu-id="1f93b-136">在 CI 中所涉及的步骤</span><span class="sxs-lookup"><span data-stu-id="1f93b-136">The steps involved in CI</span></span>

<span data-ttu-id="1f93b-137">下面是使用 Docker 和 Azure DevOps 服务的基本 CI 工作流步骤：</span><span class="sxs-lookup"><span data-stu-id="1f93b-137">Here are the basic CI workflow steps with Docker and Azure DevOps Services:</span></span>

1. <span data-ttu-id="1f93b-138">开发人员将提交推送到源代码管理存储库 （Git/Azure DevOps 服务、 GitHub 等）。</span><span class="sxs-lookup"><span data-stu-id="1f93b-138">The developer pushes a commit to an SCC repository (Git/Azure DevOps Services, GitHub, etc.).</span></span>

2. <span data-ttu-id="1f93b-139">如果您使用的 Azure DevOps 服务或 Git，CI 生成中，这意味着它非常简单，Azure DevOps 服务中选择一个复选框。</span><span class="sxs-lookup"><span data-stu-id="1f93b-139">If you're using Azure DevOps Services or Git, CI is built in, which means that it's as simple as selecting a check box in Azure DevOps Services.</span></span> <span data-ttu-id="1f93b-140">如果使用的外部 （如 GitHub)，SCC`webhook`将通知更新的 Azure DevOps 服务或推送到 Git/GitHub。</span><span class="sxs-lookup"><span data-stu-id="1f93b-140">If you're using an external SCC (like GitHub), a `webhook` will notify Azure DevOps Services of the update or push to Git/GitHub.</span></span>

3. <span data-ttu-id="1f93b-141">Azure DevOps 服务拉取源代码管理存储库，包括描述图像，以及应用程序和测试代码的 Dockerfile。</span><span class="sxs-lookup"><span data-stu-id="1f93b-141">Azure DevOps Services pulls the SCC repository, including the Dockerfile describing the image, as well as the application and test code.</span></span>

4. <span data-ttu-id="1f93b-142">Azure DevOps 服务生成 Docker 映像并使用生成号对其进行标记。</span><span class="sxs-lookup"><span data-stu-id="1f93b-142">Azure DevOps Services builds a Docker image and labels it with a build number.</span></span>

5. <span data-ttu-id="1f93b-143">Azure DevOps 服务实例化中预配 Docker 主机的 Docker 容器，并运行适当的测试。</span><span class="sxs-lookup"><span data-stu-id="1f93b-143">Azure DevOps Services instantiates the Docker container within the provisioned Docker Host, and runs the appropriate tests.</span></span>

6. <span data-ttu-id="1f93b-144">如果测试成功，将映像首先重新标记为有意义的名称，以便您知道它是"blessed 的生成"(如"/ 1.0.0"或任何其他标签)，然后推送到 Docker 注册表 （Docker 中心、 Azure 容器注册表、 DTR 等） 和</span><span class="sxs-lookup"><span data-stu-id="1f93b-144">If the tests are successful, the image is first relabeled to a meaningful name so that you know it's a "blessed build" (like "/1.0.0" or any other label), and then pushed up to your Docker Registry (Docker Hub, Azure Container Registry, DTR, etc.)</span></span>

### <a name="implementing-the-ci-pipeline-with-azure-devops-services-and-the-docker-extension-for-azure-devops-services"></a><span data-ttu-id="1f93b-145">适用于 Azure DevOps 服务实施 CI 管道中的使用 Azure DevOps 服务和 Docker 扩展</span><span class="sxs-lookup"><span data-stu-id="1f93b-145">Implementing the CI pipeline with Azure DevOps Services and the Docker extension for Azure DevOps Services</span></span>

<span data-ttu-id="1f93b-146">Visual Studio Azure DevOps 服务包含生成和发布模板，可在 CI/CD 管道与可生成 Docker 映像，将 Docker 映像推送到经过身份验证的 Docker 注册表、 运行 Docker 映像，或运行提供的其他操作Docker CLI。</span><span class="sxs-lookup"><span data-stu-id="1f93b-146">Visual Studio Azure DevOps Services contains Build & Release Templates that you can use in your CI/CD pipeline with which you can build Docker images, push Docker images to an authenticated Docker registry, run Docker images, or run other operations offered by the Docker CLI.</span></span> <span data-ttu-id="1f93b-147">它还添加了 Docker Compose，可用于生成、 推送和运行多容器 Docker 应用程序，或在图 5-3 所示运行提供的 Docker Compose CLI 其他操作的任务。</span><span class="sxs-lookup"><span data-stu-id="1f93b-147">It also adds a Docker Compose task that you can use to build, push, and run multi-container Docker applications, or run other operations offered by the Docker Compose CLI, as shown in Figure 5-3.</span></span>

![Azure DevOps 中的 Docker CI 管道的浏览器视图](./media/image3.png)

<span data-ttu-id="1f93b-149">**图 5-3**。</span><span class="sxs-lookup"><span data-stu-id="1f93b-149">**Figure 5-3**.</span></span> <span data-ttu-id="1f93b-150">Azure DevOps 服务，包括生成和发布模板和相关联的任务中的 Docker CI 管道。</span><span class="sxs-lookup"><span data-stu-id="1f93b-150">The Docker CI pipeline in Azure DevOps Services including Build & Release Templates and associated tasks.</span></span>

<span data-ttu-id="1f93b-151">可以使用这些模板和任务来构造你的 CI/CD 的项目生成 / 测试和部署 Azure Service Fabric、 Azure Kubernetes 服务和类似的产品/服务中。</span><span class="sxs-lookup"><span data-stu-id="1f93b-151">You can use these templates and tasks to construct your CI/CD artifacts to Build / Test and Deploy in Azure Service Fabric, Azure Kubernetes Service, and similar offerings.</span></span>

<span data-ttu-id="1f93b-152">这些 Visual Studio Team Services 任务，生成 Linux Docker 主机/VM 在 Azure 中设置和您首选的 Docker 注册表 （Azure 容器注册表、 Docker 中心、 私有 Docker DTR 或任何其他 Docker 注册表） 来组合 Docker CI 管道中的非常一致的方式。</span><span class="sxs-lookup"><span data-stu-id="1f93b-152">With these Visual Studio Team Services tasks, a build Linux-Docker Host/VM provisioned in Azure and your preferred Docker registry (Azure Container Registry, Docker Hub, private Docker DTR, or any other Docker registry) you can assemble your Docker CI pipeline in a very consistent way.</span></span>

<span data-ttu-id="1f93b-153">***要求：***</span><span class="sxs-lookup"><span data-stu-id="1f93b-153">***Requirements:***</span></span>

- <span data-ttu-id="1f93b-154">Azure DevOps 服务，或对于在本地安装，Team Foundation Server 2015 Update 3 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="1f93b-154">Azure DevOps Services, or for on-premises installations, Team Foundation Server 2015 Update 3 or later.</span></span>

- <span data-ttu-id="1f93b-155">Azure DevOps 服务代理具有 Docker 二进制文件。</span><span class="sxs-lookup"><span data-stu-id="1f93b-155">An Azure DevOps Services agent that has the Docker binaries.</span></span>

  <span data-ttu-id="1f93b-156">创建一个这些代理的简单方法是使用 Docker 来运行基于 Azure DevOps 服务代理 Docker 映像的容器。</span><span class="sxs-lookup"><span data-stu-id="1f93b-156">An easy way to create one of these agents is to use Docker to run a container based on the Azure DevOps Services agent Docker image.</span></span>

> [!信息]<span data-ttu-id="1f93b-157"> 若要阅读更多有关组成 Azure DevOps 服务 Docker CI 管道和查看演练，请访问这些站点：</span><span class="sxs-lookup"><span data-stu-id="1f93b-157"> To read more about assembling an Azure DevOps Services Docker CI pipeline and view the walkthroughs, visit these sites:</span></span>
>
> - <span data-ttu-id="1f93b-158">作为 Docker 容器中运行 Visual Studio Team Services （现在 Azure DevOps 服务） 代理: \\</span><span class="sxs-lookup"><span data-stu-id="1f93b-158">Running a Visual Studio Team Services (Now Azure DevOps Services) agent as a Docker container: \\</span></span>
>   <https://hub.docker.com/_/microsoft-azure-pipelines-vsts-agent>
>
> - <span data-ttu-id="1f93b-159">构建使用 Azure DevOps 服务的.NET Core Linux Docker 映像: \\</span><span class="sxs-lookup"><span data-stu-id="1f93b-159">Building .NET Core Linux Docker images with Azure DevOps Services: \\</span></span>
>   <https://blogs.msdn.microsoft.com/stevelasker/2016/06/13/building-net-core-linux-docker-images-with-visual-studio-team-services/>
>
> - <span data-ttu-id="1f93b-160">构建基于 Linux 的 Visual Studio Team Service 生成具有 Docker 支持的计算机: \\</span><span class="sxs-lookup"><span data-stu-id="1f93b-160">Building a Linux-based Visual Studio Team Service build machine with Docker support: \\</span></span>
>   <http://donovanbrown.com/post/2016/06/03/Building-a-Linux-Based-Visual-Studio-Team-Service-Build-Machine-with-Docker-Support>

### <a name="integrate-test-and-validate-multi-container-docker-applications"></a><span data-ttu-id="1f93b-161">将集成、 测试和验证多容器 Docker 应用程序</span><span class="sxs-lookup"><span data-stu-id="1f93b-161">Integrate, test, and validate multi-container Docker applications</span></span>

<span data-ttu-id="1f93b-162">通常情况下，大多数 Docker 应用程序组成的多个容器而不是单个容器。</span><span class="sxs-lookup"><span data-stu-id="1f93b-162">Typically, most Docker applications are composed of multiple containers rather than a single container.</span></span> <span data-ttu-id="1f93b-163">一个很好示例是一个面向微服务的应用程序，您将有每个微服务的一个容器。</span><span class="sxs-lookup"><span data-stu-id="1f93b-163">A good example is a microservices-oriented application for which you would have one container per microservice.</span></span> <span data-ttu-id="1f93b-164">但是，即使没有严格遵循微服务方法模式，很可能 Docker 应用程序将构成多个容器或服务。</span><span class="sxs-lookup"><span data-stu-id="1f93b-164">But, even without strictly following the microservices approach patterns, it's probable that your Docker application would be composed of multiple containers or services.</span></span>

<span data-ttu-id="1f93b-165">因此，生成后 CI 管道中的应用程序容器，您还需要部署、 集成和测试应用程序作为一个整体与所有其容器内集成 Docker 主机或甚至到你的容器是一个测试群集分发。</span><span class="sxs-lookup"><span data-stu-id="1f93b-165">Therefore, after building the application containers in the CI pipeline, you also need to deploy, integrate, and test the application as a whole with all of its containers within an integration Docker host or even into a test cluster to which your containers are distributed.</span></span>

<span data-ttu-id="1f93b-166">如果你使用单个主机，可以使用 Docker 命令，如 docker-compose 来生成和部署相关的容器来测试和验证单个 VM 中的 Docker 环境。</span><span class="sxs-lookup"><span data-stu-id="1f93b-166">If you're using a single host, you can use Docker commands such as docker-compose to build and deploy related containers to test and validate the Docker environment in a single VM.</span></span> <span data-ttu-id="1f93b-167">但是，如果您正在使用如 DC/OS、 Kubernetes 或 Docker Swarm 的业务流程协调程序群集，则需要将通过不同的机制或业务流程协调程序，具体取决于你所选群集/计划程序将容器部署。</span><span class="sxs-lookup"><span data-stu-id="1f93b-167">But, if you're working with an orchestrator cluster like DC/OS, Kubernetes, or Docker Swarm, you need to deploy your containers through a different mechanism or orchestrator, depending on your selected cluster/scheduler.</span></span>

<span data-ttu-id="1f93b-168">以下是几种可以针对 Docker 容器运行的测试类型：</span><span class="sxs-lookup"><span data-stu-id="1f93b-168">Following are several types of tests that you can run against Docker containers:</span></span>

- <span data-ttu-id="1f93b-169">Docker 容器的单元测试</span><span class="sxs-lookup"><span data-stu-id="1f93b-169">Unit tests for Docker containers</span></span>

- <span data-ttu-id="1f93b-170">测试组又彼此相关的应用程序或微服务</span><span class="sxs-lookup"><span data-stu-id="1f93b-170">Testing groups of interrelated applications or microservices</span></span>

- <span data-ttu-id="1f93b-171">在生产环境和"canary，"版本中测试</span><span class="sxs-lookup"><span data-stu-id="1f93b-171">Test in production and "canary" releases</span></span>

<span data-ttu-id="1f93b-172">重要的一点是，运行时集成和功能测试，必须运行从容器外部这些测试。</span><span class="sxs-lookup"><span data-stu-id="1f93b-172">The important point is that when running integration and functional tests, you must run those tests from outside of the containers.</span></span> <span data-ttu-id="1f93b-173">不包含或因为容器基于应与您要部署到生产环境的完全相同的静态图像在要部署的容器中运行的测试。</span><span class="sxs-lookup"><span data-stu-id="1f93b-173">Tests are not contained or run in the containers you're deploying, because the containers are based on static images that should be exactly like the ones you'll be deploying to production.</span></span>

<span data-ttu-id="1f93b-174">将映像发布到注册表，以便可以在不同群集中对其进行测试时测试更高级的方案，如包括多个群集 （群集、 临时群集和生产群集测试） 的可行选项。</span><span class="sxs-lookup"><span data-stu-id="1f93b-174">A practical option when testing more advanced scenarios, like including several clusters (test cluster, staging cluster, and production cluster) is to publish the images to a registry, so it can be tested in various clusters.</span></span>

### <a name="push-the-custom-application-docker-image-into-your-global-docker-registry"></a><span data-ttu-id="1f93b-175">将自定义应用程序 Docker 映像推送到全局 Docker 注册表</span><span class="sxs-lookup"><span data-stu-id="1f93b-175">Push the custom application Docker image into your global Docker Registry</span></span>

<span data-ttu-id="1f93b-176">Docker 映像已测试并验证后，你将想要标记并将其发布到 Docker 注册表。</span><span class="sxs-lookup"><span data-stu-id="1f93b-176">After the Docker images have been tested and validated, you'll want to tag and publish them to your Docker registry.</span></span> <span data-ttu-id="1f93b-177">Docker 注册表是 Docker 应用程序生命周期中一项重要，因为它是你在其中存储自定义测试 （也称为"blessed 映像"） 以便将部署到 QA 和生产环境的中心位置。</span><span class="sxs-lookup"><span data-stu-id="1f93b-177">The Docker registry is a critical piece in the Docker application life cycle because it's the central place where you store your custom test (also known as "blessed images") to be deployed into QA and production environments.</span></span>

<span data-ttu-id="1f93b-178">与存储在源代码管理存储库 （Git 等） 的应用程序代码的"事实来源"的方式类似，Docker 注册表是"事实来源"二进制应用程序或 bits 要部署到 QA 或生产环境。</span><span class="sxs-lookup"><span data-stu-id="1f93b-178">Similar to how the application code stored in your SCC repository (Git, etc.) is your "source of truth," the Docker registry is your "source of truth" for your binary application or bits to be deployed to the QA or production environments.</span></span>

<span data-ttu-id="1f93b-179">通常情况下，你可能想要自定义映像的专用存储库在专用存储库中 Azure 容器注册表或 Docker 受信任注册表，如在本地注册表中或在具有受限访问权限 （如公共云注册表中Docker 中心），尽管在此最后一个的情况下，如果你的代码不是开放源代码，您必须信任很多供应商的安全。</span><span class="sxs-lookup"><span data-stu-id="1f93b-179">Typically, you might want to have your private repositories for your custom images either in a private repository in Azure Container Registry or in an on-premises registry like Docker Trusted Registry, or in a public-cloud registry with restricted access (like Docker Hub), although in this last case if your code is not open source, you must trust the vendor's security.</span></span> <span data-ttu-id="1f93b-180">无论哪种方式，所使用的方法类似，并且基于`docker push`命令，在图 5-4 所示。</span><span class="sxs-lookup"><span data-stu-id="1f93b-180">Either way, the method you use is similar and is based on the `docker push` command, as shown in Figure 5-4.</span></span>

![步骤 3 中，为构建集成和测试 (CI) 中可能会将生成的 docker 映像发布到专用或公共注册表。](./media/image4.png)

<span data-ttu-id="1f93b-182">**图 5-4**。</span><span class="sxs-lookup"><span data-stu-id="1f93b-182">**Figure 5-4**.</span></span> <span data-ttu-id="1f93b-183">正在自定义映像发布到 Docker 注册表</span><span class="sxs-lookup"><span data-stu-id="1f93b-183">Publishing custom images to Docker Registry</span></span>

<span data-ttu-id="1f93b-184">有多个产品/服务的 Azure 容器注册表、 Amazon Web 服务容器注册表、 Google 容器注册表、 Quay 注册表等云供应商提供 Docker 注册表。</span><span class="sxs-lookup"><span data-stu-id="1f93b-184">There are multiple offerings of Docker registries from cloud vendors like Azure Container Registry, Amazon Web Services Container Registry, Google Container Registry, Quay Registry, and so on.</span></span>

<span data-ttu-id="1f93b-185">使用 Docker 任务，可以请求服务映像由定义一组`docker-compose.yml`文件，使用多个标记，向一个已经过身份验证的 Docker 注册表 （如 Azure 容器注册表），在图 5-5 所示。</span><span class="sxs-lookup"><span data-stu-id="1f93b-185">Using the Docker tasks, you can push a set of service images defined by a `docker-compose.yml` file, with multiple tags, to an authenticated Docker registry (like Azure Container Registry), as shown in Figure 5-5.</span></span>

![要从 Azure DevOps 发布到注册表的映像的步骤的浏览器视图。](./media/image5.png)

<span data-ttu-id="1f93b-187">**图 5-5**。</span><span class="sxs-lookup"><span data-stu-id="1f93b-187">**Figure 5-5**.</span></span> <span data-ttu-id="1f93b-188">使用 Azure DevOps 服务为发布到 Docker 注册表的自定义映像</span><span class="sxs-lookup"><span data-stu-id="1f93b-188">Using Azure DevOps Services to publishing custom images to a Docker Registry</span></span>

> [!信息]<span data-ttu-id="1f93b-189"> 了解 Azure 容器注册表的详细信息，请参阅<https://aka.ms/azurecontainerregistry>。</span><span class="sxs-lookup"><span data-stu-id="1f93b-189"> For more information about Azure Container Registry, see <https://aka.ms/azurecontainerregistry>.</span></span>

## <a name="step-4-cd-deploy"></a><span data-ttu-id="1f93b-190">步骤 4：CD，部署</span><span class="sxs-lookup"><span data-stu-id="1f93b-190">Step 4: CD, Deploy</span></span>

<span data-ttu-id="1f93b-191">Docker 映像的不可变性可以确保具有什么开发、 CI 使用，请通过测试并在生产环境中运行的可重复部署。</span><span class="sxs-lookup"><span data-stu-id="1f93b-191">The immutability of Docker images ensures a repeatable deployment with what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="1f93b-192">在 Docker 注册表 （专用或公用） 中发布的应用程序 Docker 映像后，您可以将其部署到你可能有多个环境 (生产、 QA、 暂存、 等) 从 CD 管道通过使用 Azure DevOps 服务管道任务或 Azure DevOps 服务版本管理。</span><span class="sxs-lookup"><span data-stu-id="1f93b-192">After you have the application Docker images published in your Docker registry (either private or public), you can deploy them to the several environments that you might have (production, QA, staging, etc.) from your CD pipeline by using Azure DevOps Services pipeline tasks or Azure DevOps Services Release Management.</span></span>

<span data-ttu-id="1f93b-193">但是，现在它取决于要部署哪些类型的 Docker 应用程序。</span><span class="sxs-lookup"><span data-stu-id="1f93b-193">However, at this point it depends on what kind of Docker application you're deploying.</span></span> <span data-ttu-id="1f93b-194">部署简单的应用程序 （组合和部署的角度来看） 等一个单片包含几个容器或服务应用程序和已部署到少量服务器或 Vm 是不同于部署等更复杂的应用程序面向微服务的应用程序与超大规模的功能。</span><span class="sxs-lookup"><span data-stu-id="1f93b-194">Deploying a simple application (from a composition and deployment point of view) like a monolithic application comprising a few containers or services and deployed to a few servers or VMs is different from deploying a more complex application like a microservices-oriented application with hyperscale capabilities.</span></span> <span data-ttu-id="1f93b-195">以下各节中介绍了这两种方案。</span><span class="sxs-lookup"><span data-stu-id="1f93b-195">These two scenarios are explained in the following sections.</span></span>

### <a name="deploying-composed-docker-applications-to-multiple-docker-environments"></a><span data-ttu-id="1f93b-196">部署包含 Docker 应用程序到多个 Docker 环境</span><span class="sxs-lookup"><span data-stu-id="1f93b-196">Deploying composed Docker applications to multiple Docker environments</span></span>

<span data-ttu-id="1f93b-197">让我们来看第一个在不太复杂方案： 部署到单个环境或多个环境中的简单 Docker 主机 （Vm 或服务器） (QA、 过渡和生产)。</span><span class="sxs-lookup"><span data-stu-id="1f93b-197">Let's look first at the less-complex scenario: deploying to simple Docker hosts (VMs or servers) in a single environment or multiple environments (QA, staging, and production).</span></span> <span data-ttu-id="1f93b-198">在此方案中，在内部 CD 管道可以使用 docker-compose （从 Azure DevOps 服务部署任务） 来部署 Docker 应用程序使用其相关的一组的容器或服务，如图 5-6 所示。</span><span class="sxs-lookup"><span data-stu-id="1f93b-198">In this scenario, internally your CD pipeline can use docker-compose (from your Azure DevOps Services deployment tasks) to deploy the Docker applications with its related set of containers or services, as illustrated in Figure 5-6.</span></span>

![CD 部署步骤 (4) 可以将发布到不同的环境，如 q & a、 过渡和生产。](./media/image6.png)

<span data-ttu-id="1f93b-200">**图 5-6**。</span><span class="sxs-lookup"><span data-stu-id="1f93b-200">**Figure 5-6**.</span></span> <span data-ttu-id="1f93b-201">将应用程序的容器部署到简单的 Docker 主机环境注册表</span><span class="sxs-lookup"><span data-stu-id="1f93b-201">Deploying application containers to simple Docker host environments registry</span></span>

<span data-ttu-id="1f93b-202">图 5-7 突出显示了如何连接生成 CI QA/测试环境，通过 Azure DevOps 服务通过单击添加任务对话框中的 Docker Compose。</span><span class="sxs-lookup"><span data-stu-id="1f93b-202">Figure 5-7 highlights how you can connect your build CI to QA/test environments via Azure DevOps Services by clicking Docker Compose in the Add Task dialog box.</span></span> <span data-ttu-id="1f93b-203">但是，部署到过渡或生产环境时，你通常将处理多个环境的发布管理功能 (如 QA、 过渡和生产)。</span><span class="sxs-lookup"><span data-stu-id="1f93b-203">However, when deploying to staging or production environments, you would usually use Release Management features handling multiple environments (like QA, staging, and production).</span></span> <span data-ttu-id="1f93b-204">如果你正在部署到单个 Docker 主机，它使用 Azure DevOps 服务"Docker Compose"任务 (这调用`docker-compose up`命令实质上)。</span><span class="sxs-lookup"><span data-stu-id="1f93b-204">If you're deploying to single Docker hosts, it is using the Azure DevOps Services "Docker Compose" task (which is invoking the `docker-compose up` command under the hood).</span></span> <span data-ttu-id="1f93b-205">如果你正在部署到 Azure 容器服务，它使用 Docker 部署任务，如后面的部分中所述。</span><span class="sxs-lookup"><span data-stu-id="1f93b-205">If you're deploying to Azure Container Service, it uses the Docker Deployment task, as explained in the section that follows.</span></span>

![添加 Docker Compose 的任务的浏览器视图。](./media/image7.png)

<span data-ttu-id="1f93b-207">**图 5-7**。</span><span class="sxs-lookup"><span data-stu-id="1f93b-207">**Figure 5-7**.</span></span> <span data-ttu-id="1f93b-208">Azure DevOps 服务管道中添加 Docker Compose 任务</span><span class="sxs-lookup"><span data-stu-id="1f93b-208">Adding a Docker Compose task in an Azure DevOps Services pipeline</span></span>

<span data-ttu-id="1f93b-209">当在 Azure DevOps 服务中创建发布时，花了一套输入项目。</span><span class="sxs-lookup"><span data-stu-id="1f93b-209">When you create a release in Azure DevOps Services, it takes a set of input artifacts.</span></span> <span data-ttu-id="1f93b-210">这些项目旨在是固定不变的版本中，生存期内所有环境中。</span><span class="sxs-lookup"><span data-stu-id="1f93b-210">These artifacts are intended to be immutable for the lifetime of the release, across all environments.</span></span> <span data-ttu-id="1f93b-211">在引入容器时，输入的项目标识注册表部署中的映像。</span><span class="sxs-lookup"><span data-stu-id="1f93b-211">When you introduce containers, the input artifacts identify images in a registry to deploy.</span></span> <span data-ttu-id="1f93b-212">具体取决于如何标识这些映像，它们不保证能够保持不变的版本中，最明显事例被引用时期间`myimage:latest`从`docker-compose`文件。</span><span class="sxs-lookup"><span data-stu-id="1f93b-212">Depending on how these images are identified, they are not guaranteed to remain the same throughout the duration of the release, the most obvious case being when you reference `myimage:latest` from a `docker-compose` file.</span></span>

<span data-ttu-id="1f93b-213">Azure DevOps 服务模板，您生成包含特定的注册表的映像的生成项目的功能摘要，可保证能唯一标识同一图像二进制文件。</span><span class="sxs-lookup"><span data-stu-id="1f93b-213">The Azure DevOps Services templates give you the ability to generate build artifacts that contain specific registry image digests that are guaranteed to uniquely identify the same image binary.</span></span> <span data-ttu-id="1f93b-214">这些是你确实要用作输入到发行版。</span><span class="sxs-lookup"><span data-stu-id="1f93b-214">These are what you really want to use as input to a release.</span></span>

### <a name="managing-releases-to-docker-environments-by-using-azure-devops-services-release-management"></a><span data-ttu-id="1f93b-215">通过使用 Azure DevOps 服务 Release Management 管理发布到 Docker 环境</span><span class="sxs-lookup"><span data-stu-id="1f93b-215">Managing releases to Docker environments by using Azure DevOps Services Release Management</span></span>

<span data-ttu-id="1f93b-216">通过 Azure DevOps 服务模板，可以生成新映像、 将其发布到 Docker 注册表、 Linux 或 Windows 主机上运行和使用如下所示命令`docker-compose`将多个容器部署为整个应用程序，作为 Azure DevOps 后盾服务的多个环境的发布管理功能，在图 5-8 所示。</span><span class="sxs-lookup"><span data-stu-id="1f93b-216">Through the Azure DevOps Services templates, you can build a new image, publish it to a Docker registry, run it on Linux or Windows hosts, and use commands such as `docker-compose` to deploy multiple containers as an entire application, all through the Azure DevOps Services Release Management capabilities intended for multiple environments, as shown in Figure 5-8.</span></span>

![浏览器视图的 Azure DevOps，配置 Docker compose 版本。](./media/image8.png)

<span data-ttu-id="1f93b-218">**图 5-8**。</span><span class="sxs-lookup"><span data-stu-id="1f93b-218">**Figure 5-8**.</span></span> <span data-ttu-id="1f93b-219">Azure DevOps 服务 Docker Compose 通过 Azure DevOps 服务版本管理的任务的配置</span><span class="sxs-lookup"><span data-stu-id="1f93b-219">Configuring Azure DevOps Services Docker Compose tasks from Azure DevOps Services Release Management</span></span>

<span data-ttu-id="1f93b-220">但是，请记住在图 5-6 所示和实现图 5-8 中的方案是一个简单 （它部署到单个 Docker 主机和虚拟机，并且将单个容器或每个映像的实例） 和可能应仅用于开发或测试 scenarios。</span><span class="sxs-lookup"><span data-stu-id="1f93b-220">However, keep in mind that the scenario shown in Figure 5-6 and implemented in Figure 5-8 is a simple one (it's deploying to single Docker hosts and VMs, and there will be a single container or instance per image) and probably should be used only for development or test scenarios.</span></span> <span data-ttu-id="1f93b-221">在大多数企业生产方案中，你会想要情况下跨多个节点、 服务器和 Vm，以及"智能故障转移"负载平衡，具有高可用性 (HA) 和易于管理的可伸缩性，如果服务器或节点发生故障，其服务和容器将移动到另一个主机服务器或 VM。</span><span class="sxs-lookup"><span data-stu-id="1f93b-221">In most enterprise production scenarios, you would want to have High Availability (HA) and easy-to-manage scalability by load balancing across multiple nodes, servers, and VMs, plus "intelligent failovers" so if a server or node fails, its services and containers will be moved to another host server or VM.</span></span> <span data-ttu-id="1f93b-222">在这种情况下，您需要更高级的技术，例如容器群集、 业务流程协调程序和计划程序。</span><span class="sxs-lookup"><span data-stu-id="1f93b-222">In that case, you need more advanced technologies such as container clusters, orchestrators, and schedulers.</span></span> <span data-ttu-id="1f93b-223">因此，将部署到这些群集的方法是通过处理的高级的方案中所述在下一节。</span><span class="sxs-lookup"><span data-stu-id="1f93b-223">Thus, the way to deploy to those clusters is by handling the advanced scenarios explained in the next section.</span></span>

### <a name="deploying-docker-applications-to-docker-clusters"></a><span data-ttu-id="1f93b-224">Docker 应用程序部署到 Docker 群集</span><span class="sxs-lookup"><span data-stu-id="1f93b-224">Deploying Docker applications to Docker clusters</span></span>

<span data-ttu-id="1f93b-225">分布式应用程序的性质要求，还将分散的计算资源。</span><span class="sxs-lookup"><span data-stu-id="1f93b-225">The nature of distributed applications requires compute resources that are also distributed.</span></span> <span data-ttu-id="1f93b-226">若要让生产规模的功能，需要具有群集提供高可伸缩性和高可用性根据共用资源的功能。</span><span class="sxs-lookup"><span data-stu-id="1f93b-226">To have production-scale capabilities, you need to have clustering capabilities that provide high scalability and high availability based on pooled resources.</span></span>

<span data-ttu-id="1f93b-227">您可以将容器部署手动到这些群集从 CLI 工具或 web UI，但应保留这种手动找出部署测试工作或管理目的，例如向外扩展或监视。</span><span class="sxs-lookup"><span data-stu-id="1f93b-227">You could deploy containers manually to those clusters from a CLI tool or a web UI, but you should reserve that kind of manual work to spot deployment testing or management purposes like scaling-out or monitoring.</span></span>

<span data-ttu-id="1f93b-228">从 CD 的角度来看，Azure DevOps 服务具体而言，您可以运行和精心制作的部署任务从你将部署容器化应用程序在容器中的分布式群集的 Azure DevOps 服务发布管理环境服务，如图 5-9 所示。</span><span class="sxs-lookup"><span data-stu-id="1f93b-228">From a CD point of view, and Azure DevOps Services specifically, you can run specially made deployment tasks from your Azure DevOps Services Release Management environments that will deploy your containerized applications to distributed clusters in Container Service, as illustrated in Figure 5-9.</span></span>

![CD 部署步骤 (4) 还可以发布到通过业务流程协调程序群集。](./media/image9.png)

<span data-ttu-id="1f93b-230">**图 5-9**。</span><span class="sxs-lookup"><span data-stu-id="1f93b-230">**Figure 5-9**.</span></span> <span data-ttu-id="1f93b-231">分布式应用程序部署到容器服务</span><span class="sxs-lookup"><span data-stu-id="1f93b-231">Deploying distributed applications to Container Service</span></span>

<span data-ttu-id="1f93b-232">最初，部署到特定群集或业务流程协调程序时，您将传统上使用特定的部署脚本和每个每个业务流程协调程序 （即 Kubernetes 和 Service Fabric 具有不同的部署机制） 的机制而不是更简单和易于使用`docker-compose`工具基于`docker-compose.yml`定义文件。</span><span class="sxs-lookup"><span data-stu-id="1f93b-232">Initially, when deploying to certain clusters or orchestrators, you would traditionally use specific deployment scripts and mechanisms per each orchestrator (that is, Kubernetes and Service Fabric have different deployment mechanisms) instead of the simpler and easy-to-use `docker-compose` tool based on the `docker-compose.yml` definition file.</span></span> <span data-ttu-id="1f93b-233">但是，借助 Azure DevOps 服务 Docker 部署任务中，显示在图 5-10，你现在还可以部署到受支持的业务流程协调程序通过只使用你熟悉`docker-compose.yml`文件为您，因为该工具执行该"转换"(从你`docker-compose.yml`业务流程协调程序所需的格式的文件)。</span><span class="sxs-lookup"><span data-stu-id="1f93b-233">However, thanks to the Azure DevOps Services Docker Deploy task, shown in Figure 5-10, you now also can deploy to the supported orchestrators by just using your familiar `docker-compose.yml` file because the tool performs that “translation” for you (from your `docker-compose.yml` file to the format needed by the orchestrator).</span></span>

![浏览器视图中的任务目录中 Azure DevOps，以显示 Docker 的部署任务。](./media/image10.png)

<span data-ttu-id="1f93b-235">**图 5-10**。</span><span class="sxs-lookup"><span data-stu-id="1f93b-235">**Figure 5-10**.</span></span> <span data-ttu-id="1f93b-236">将 Docker 部署任务添加到环境 RM</span><span class="sxs-lookup"><span data-stu-id="1f93b-236">Adding the Docker Deploy task to your Environment RM</span></span>

<span data-ttu-id="1f93b-237">图 5-11 演示了如何编辑 Docker 部署任务和指定目标类型 (Azure 容器服务 DC/OS，在此情况下)、 在 Docker Compose 文件，以及 （如 Azure 容器注册表或 Docker 中心） 的 Docker 注册表连接。</span><span class="sxs-lookup"><span data-stu-id="1f93b-237">Figure 5-11 demonstrates how you can edit the Docker Deploy task and specify the Target Type (Azure Container Service DC/OS, in this case), your Docker Compose File, and the Docker Registry connection (like Azure Container Registry or Docker Hub).</span></span> <span data-ttu-id="1f93b-238">这是将检索随时可用自定义 Docker 映像部署为群集中容器的任务。</span><span class="sxs-lookup"><span data-stu-id="1f93b-238">This is the task that will retrieve your ready-to-use custom Docker images to be deployed as containers in the cluster.</span></span>

![Azure DevOps 的浏览器视图将部署到业务流程协调程序任务定义。](./media/image11.png)

<span data-ttu-id="1f93b-240">**图 5-11**。</span><span class="sxs-lookup"><span data-stu-id="1f93b-240">**Figure 5-11**.</span></span> <span data-ttu-id="1f93b-241">Docker 部署任务定义部署到 Azure 容器服务 DC/OS</span><span class="sxs-lookup"><span data-stu-id="1f93b-241">Docker Deploy task definition deploying to Azure Container Service DC/OS</span></span>

> [!信息]<span data-ttu-id="1f93b-242"> 若要了解更多有关使用 Azure DevOps 服务和 Docker 在 CD 管道，请访问 <https://azure.microsoft.com/services/devops/pipelines></span><span class="sxs-lookup"><span data-stu-id="1f93b-242"> To read more about the CD pipeline with Azure DevOps Services and Docker, visit <https://azure.microsoft.com/services/devops/pipelines></span></span>

## <a name="step-5-run-and-manage"></a><span data-ttu-id="1f93b-243">步骤 5：运行和管理</span><span class="sxs-lookup"><span data-stu-id="1f93b-243">Step 5: Run and manage</span></span>

<span data-ttu-id="1f93b-244">因为运行和管理应用程序在企业生产级别是主要使用者在和的本身，并由于操作的类型和在该级别 （IT 操作） 以及此区域的大范围的人员，整个的下一章专门介绍解释了它。</span><span class="sxs-lookup"><span data-stu-id="1f93b-244">Because running and managing applications at enterprise-production level is a major subject in and of itself, and due to the type of operations and people working at that level (IT operations) as well as the large scope of this area, the entire next chapter is devoted to explaining it.</span></span>

## <a name="step-6-monitor-and-diagnose"></a><span data-ttu-id="1f93b-245">步骤 6：监视和诊断</span><span class="sxs-lookup"><span data-stu-id="1f93b-245">Step 6: Monitor and diagnose</span></span>

<span data-ttu-id="1f93b-246">本主题还介绍了在接下来的任务的一章它执行在生产系统;但是，务必要突出显示在此步骤中获得的见解必须馈送回到开发团队，以便应用程序不断得到改进。</span><span class="sxs-lookup"><span data-stu-id="1f93b-246">This topic also is covered in the next chapter as part of the tasks that IT performs in production systems; however, is important to highlight that the insights obtained in this step must feed back to the development team so that the application is constantly improved.</span></span> <span data-ttu-id="1f93b-247">从该角度来看，它也是一部分的 DevOps，尽管通常执行的任务和操作 IT。</span><span class="sxs-lookup"><span data-stu-id="1f93b-247">From that point of view, it's also part of DevOps, although the tasks and operations are commonly performed by IT.</span></span>

<span data-ttu-id="1f93b-248">仅监视和诊断在 DevOps 领域中的 100%时，监视进程和由开发团队针对测试或 beta 环境执行的分析。</span><span class="sxs-lookup"><span data-stu-id="1f93b-248">Only when monitoring and diagnostics are 100% within the realm of DevOps are the monitoring processes and analytics performed by the development team against testing or beta environments.</span></span> <span data-ttu-id="1f93b-249">这是通过执行负载测试或通过监视 beta 或 QA 环境，beta 版测试人员正在新版本。</span><span class="sxs-lookup"><span data-stu-id="1f93b-249">This is done either by performing load testing or by monitoring beta or QA environments, where beta testers are trying the new versions.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="1f93b-250">[上一页](index.md)
>[下一页](create-ci-cd-pipelines-azure-devops-services-aspnetcore-kubernetes.md)</span><span class="sxs-lookup"><span data-stu-id="1f93b-250">[Previous](index.md)
[Next](create-ci-cd-pipelines-azure-devops-services-aspnetcore-kubernetes.md)</span></span>
