---
title: .NET 正则表达式中的回溯
description: 了解如何在正则表达式模式匹配中控制回溯的使用。
ms.date: 11/12/2018
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- .NET Framework regular expressions, backtracking
- alternative matching patterns
- optional matching patterns
- searching with regular expressions, backtracking
- pattern-matching with regular expressions, backtracking
- backtracking
- regular expressions [.NET Framework], backtracking
- strings [.NET Framework], regular expressions
- parsing text with regular expressions, backtracking
ms.assetid: 34df1152-0b22-4a1c-a76c-3c28c47b70d8
author: rpetrusha
ms.author: ronpet
ms.custom: seodec18
ms.openlocfilehash: 0831a22b0c1d3333cc37f86a764006c934597390
ms.sourcegitcommit: 68653db98c5ea7744fd438710248935f70020dfb
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 08/22/2019
ms.locfileid: "69968562"
---
# <a name="backtracking-in-regular-expressions"></a><span data-ttu-id="353b1-103">正则表达式中的回溯</span><span class="sxs-lookup"><span data-stu-id="353b1-103">Backtracking in Regular Expressions</span></span>
<a name="top"></a> <span data-ttu-id="353b1-104">当正则表达式模式包含可选 [限定符](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md) 或 [替换构造](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md)时，会发生回溯，并且正则表达式引擎会返回以前保存的状态，以继续搜索匹配项。</span><span class="sxs-lookup"><span data-stu-id="353b1-104">Backtracking occurs when a regular expression pattern contains optional [quantifiers](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md) or [alternation constructs](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md), and the regular expression engine returns to a previous saved state to continue its search for a match.</span></span> <span data-ttu-id="353b1-105">回溯是正则表达式的强大功能的中心；它使得表达式强大、灵活，可以匹配非常复杂的模式。</span><span class="sxs-lookup"><span data-stu-id="353b1-105">Backtracking is central to the power of regular expressions; it makes it possible for expressions to be powerful and flexible, and to match very complex patterns.</span></span> <span data-ttu-id="353b1-106">同时，这种强大功能需要付出一定代价。</span><span class="sxs-lookup"><span data-stu-id="353b1-106">At the same time, this power comes at a cost.</span></span> <span data-ttu-id="353b1-107">通常，回溯是影响正则表达式引擎性能的单个最重要的因素。</span><span class="sxs-lookup"><span data-stu-id="353b1-107">Backtracking is often the single most important factor that affects the performance of the regular expression engine.</span></span> <span data-ttu-id="353b1-108">幸运的是，开发人员可以控制正则表达式引擎的行为及其使用回溯的方式。</span><span class="sxs-lookup"><span data-stu-id="353b1-108">Fortunately, the developer has control over the behavior of the regular expression engine and how it uses backtracking.</span></span> <span data-ttu-id="353b1-109">本主题说明回溯的工作方式以及如何对其进行控制。</span><span class="sxs-lookup"><span data-stu-id="353b1-109">This topic explains how backtracking works and how it can be controlled.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="353b1-110">通常情况下，非确定性有限自动机 (NFA) 引擎（如 .NET 正则表达式引擎）会将构造快速高效的正则表达式的职责交给开发人员。</span><span class="sxs-lookup"><span data-stu-id="353b1-110">In general, a Nondeterministic Finite Automaton (NFA) engine like .NET regular expression engine places the responsibility for crafting efficient, fast regular expressions on the developer.</span></span>  
  
 <span data-ttu-id="353b1-111">本主题包含以下各节：</span><span class="sxs-lookup"><span data-stu-id="353b1-111">This topic contains the following sections:</span></span>  
  
- [<span data-ttu-id="353b1-112">不使用回溯的线性比较</span><span class="sxs-lookup"><span data-stu-id="353b1-112">Linear Comparison Without Backtracking</span></span>](#linear_comparison_without_backtracking)  
  
- [<span data-ttu-id="353b1-113">使用可选限定符或替换构造的回溯</span><span class="sxs-lookup"><span data-stu-id="353b1-113">Backtracking with Optional Quantifiers or Alternation Constructs</span></span>](#backtracking_with_optional_quantifiers_or_alternation_constructs)  
  
- [<span data-ttu-id="353b1-114">使用嵌套的可选限定符的回溯</span><span class="sxs-lookup"><span data-stu-id="353b1-114">Backtracking with Nested Optional Quantifiers</span></span>](#backtracking_with_nested_optional_quantifiers)  
  
- [<span data-ttu-id="353b1-115">控制回溯</span><span class="sxs-lookup"><span data-stu-id="353b1-115">Controlling Backtracking</span></span>](#controlling_backtracking)  
  
<a name="linear_comparison_without_backtracking"></a>   
## <a name="linear-comparison-without-backtracking"></a><span data-ttu-id="353b1-116">不使用回溯的线性比较</span><span class="sxs-lookup"><span data-stu-id="353b1-116">Linear Comparison Without Backtracking</span></span>  
 <span data-ttu-id="353b1-117">如果正则表达式模式没有可选限定符或替换构造，正则表达式引擎将以线性时间执行。</span><span class="sxs-lookup"><span data-stu-id="353b1-117">If a regular expression pattern has no optional quantifiers or alternation constructs, the regular expression engine executes in linear time.</span></span> <span data-ttu-id="353b1-118">也就是说，在正则表达式引擎将模式中的第一个语言元素与输入字符串中的文本匹配后，它尝试将模式中的下一个语言元素与输入字符串中的下一个字符或字符组匹配。</span><span class="sxs-lookup"><span data-stu-id="353b1-118">That is, after the regular expression engine matches the first language element in the pattern with text in the input string, it tries to match the next language element in the pattern with the next character or group of characters in the input string.</span></span> <span data-ttu-id="353b1-119">此操作将继续，直至匹配成功或失败。</span><span class="sxs-lookup"><span data-stu-id="353b1-119">This continues until the match either succeeds or fails.</span></span> <span data-ttu-id="353b1-120">在任何一种情况下，在同一时间，正则表达式引擎都比输入字符串中提前一个字符。</span><span class="sxs-lookup"><span data-stu-id="353b1-120">In either case, the regular expression engine advances by one character at a time in the input string.</span></span>  
  
 <span data-ttu-id="353b1-121">下面的示例进行了这方面的演示。</span><span class="sxs-lookup"><span data-stu-id="353b1-121">The following example provides an illustration.</span></span> <span data-ttu-id="353b1-122">正则表达式 `e{2}\w\b` 查找字母 "e" 后跟任意单词字符再后跟单词边界的两个匹配项。</span><span class="sxs-lookup"><span data-stu-id="353b1-122">The regular expression `e{2}\w\b` looks for two occurrences of the letter "e" followed by any word character followed by a word boundary.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking1.cs#1)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking1.vb#1)]  
  
 <span data-ttu-id="353b1-123">尽管此正则表达式包括限定符 `{2}`，但它仍以线性方式进行计算。</span><span class="sxs-lookup"><span data-stu-id="353b1-123">Although this regular expression includes the quantifier `{2}`, it is evaluated in a linear manner.</span></span> <span data-ttu-id="353b1-124">由于 `{2}` 不是可选限定符，因此该正则表达式引擎不回溯；它指定确切数字，而不是前一个子表达式必须匹配的可变次数。</span><span class="sxs-lookup"><span data-stu-id="353b1-124">The regular expression engine does not backtrack because `{2}` is not an optional quantifier; it specifies an exact number and not a variable number of times that the previous subexpression must match.</span></span> <span data-ttu-id="353b1-125">因此，正则表达式引擎尝试使正则表达式模式与输入字符串匹配，如下表所示。</span><span class="sxs-lookup"><span data-stu-id="353b1-125">As a result, the regular expression engine tries to match the regular expression pattern with the input string as shown in the following table.</span></span>  
  
|<span data-ttu-id="353b1-126">操作</span><span class="sxs-lookup"><span data-stu-id="353b1-126">Operation</span></span>|<span data-ttu-id="353b1-127">在模式中的位置</span><span class="sxs-lookup"><span data-stu-id="353b1-127">Position in pattern</span></span>|<span data-ttu-id="353b1-128">在字符串中的位置</span><span class="sxs-lookup"><span data-stu-id="353b1-128">Position in string</span></span>|<span data-ttu-id="353b1-129">结果</span><span class="sxs-lookup"><span data-stu-id="353b1-129">Result</span></span>|  
|---------------|-------------------------|------------------------|------------|  
|<span data-ttu-id="353b1-130">1</span><span class="sxs-lookup"><span data-stu-id="353b1-130">1</span></span>|<span data-ttu-id="353b1-131">e</span><span class="sxs-lookup"><span data-stu-id="353b1-131">e</span></span>|<span data-ttu-id="353b1-132">“needing a reed”（索引 0）</span><span class="sxs-lookup"><span data-stu-id="353b1-132">"needing a reed" (index 0)</span></span>|<span data-ttu-id="353b1-133">无匹配。</span><span class="sxs-lookup"><span data-stu-id="353b1-133">No match.</span></span>|  
|<span data-ttu-id="353b1-134">2</span><span class="sxs-lookup"><span data-stu-id="353b1-134">2</span></span>|<span data-ttu-id="353b1-135">e</span><span class="sxs-lookup"><span data-stu-id="353b1-135">e</span></span>|<span data-ttu-id="353b1-136">“eeding a reed”（索引 1）</span><span class="sxs-lookup"><span data-stu-id="353b1-136">"eeding a reed" (index 1)</span></span>|<span data-ttu-id="353b1-137">可能匹配。</span><span class="sxs-lookup"><span data-stu-id="353b1-137">Possible match.</span></span>|  
|<span data-ttu-id="353b1-138">3</span><span class="sxs-lookup"><span data-stu-id="353b1-138">3</span></span>|<span data-ttu-id="353b1-139">e{2}</span><span class="sxs-lookup"><span data-stu-id="353b1-139">e{2}</span></span>|<span data-ttu-id="353b1-140">“eding a reed”（索引 2）</span><span class="sxs-lookup"><span data-stu-id="353b1-140">"eding a reed" (index 2)</span></span>|<span data-ttu-id="353b1-141">可能匹配。</span><span class="sxs-lookup"><span data-stu-id="353b1-141">Possible match.</span></span>|  
|<span data-ttu-id="353b1-142">4</span><span class="sxs-lookup"><span data-stu-id="353b1-142">4</span></span>|<span data-ttu-id="353b1-143">\w</span><span class="sxs-lookup"><span data-stu-id="353b1-143">\w</span></span>|<span data-ttu-id="353b1-144">“ding a reed”（索引 3）</span><span class="sxs-lookup"><span data-stu-id="353b1-144">"ding a reed" (index 3)</span></span>|<span data-ttu-id="353b1-145">可能匹配。</span><span class="sxs-lookup"><span data-stu-id="353b1-145">Possible match.</span></span>|  
|<span data-ttu-id="353b1-146">5</span><span class="sxs-lookup"><span data-stu-id="353b1-146">5</span></span>|<span data-ttu-id="353b1-147">\b</span><span class="sxs-lookup"><span data-stu-id="353b1-147">\b</span></span>|<span data-ttu-id="353b1-148">“ing a reed”（索引 4）</span><span class="sxs-lookup"><span data-stu-id="353b1-148">"ing a reed" (index 4)</span></span>|<span data-ttu-id="353b1-149">可能的匹配失败。</span><span class="sxs-lookup"><span data-stu-id="353b1-149">Possible match fails.</span></span>|  
|<span data-ttu-id="353b1-150">6</span><span class="sxs-lookup"><span data-stu-id="353b1-150">6</span></span>|<span data-ttu-id="353b1-151">e</span><span class="sxs-lookup"><span data-stu-id="353b1-151">e</span></span>|<span data-ttu-id="353b1-152">“eding a reed”（索引 2）</span><span class="sxs-lookup"><span data-stu-id="353b1-152">"eding a reed" (index 2)</span></span>|<span data-ttu-id="353b1-153">可能匹配。</span><span class="sxs-lookup"><span data-stu-id="353b1-153">Possible match.</span></span>|  
|<span data-ttu-id="353b1-154">7</span><span class="sxs-lookup"><span data-stu-id="353b1-154">7</span></span>|<span data-ttu-id="353b1-155">e{2}</span><span class="sxs-lookup"><span data-stu-id="353b1-155">e{2}</span></span>|<span data-ttu-id="353b1-156">“ding a reed”（索引 3）</span><span class="sxs-lookup"><span data-stu-id="353b1-156">"ding a reed" (index 3)</span></span>|<span data-ttu-id="353b1-157">可能的匹配失败。</span><span class="sxs-lookup"><span data-stu-id="353b1-157">Possible match fails.</span></span>|  
|<span data-ttu-id="353b1-158">8</span><span class="sxs-lookup"><span data-stu-id="353b1-158">8</span></span>|<span data-ttu-id="353b1-159">e</span><span class="sxs-lookup"><span data-stu-id="353b1-159">e</span></span>|<span data-ttu-id="353b1-160">“ding a reed”（索引 3）</span><span class="sxs-lookup"><span data-stu-id="353b1-160">"ding a reed" (index 3)</span></span>|<span data-ttu-id="353b1-161">匹配失败。</span><span class="sxs-lookup"><span data-stu-id="353b1-161">Match fails.</span></span>|  
|<span data-ttu-id="353b1-162">9</span><span class="sxs-lookup"><span data-stu-id="353b1-162">9</span></span>|<span data-ttu-id="353b1-163">e</span><span class="sxs-lookup"><span data-stu-id="353b1-163">e</span></span>|<span data-ttu-id="353b1-164">“ing a reed”（索引 4）</span><span class="sxs-lookup"><span data-stu-id="353b1-164">"ing a reed" (index 4)</span></span>|<span data-ttu-id="353b1-165">无匹配。</span><span class="sxs-lookup"><span data-stu-id="353b1-165">No match.</span></span>|  
|<span data-ttu-id="353b1-166">10</span><span class="sxs-lookup"><span data-stu-id="353b1-166">10</span></span>|<span data-ttu-id="353b1-167">e</span><span class="sxs-lookup"><span data-stu-id="353b1-167">e</span></span>|<span data-ttu-id="353b1-168">“ng a reed”（索引 5）</span><span class="sxs-lookup"><span data-stu-id="353b1-168">"ng a reed" (index 5)</span></span>|<span data-ttu-id="353b1-169">无匹配。</span><span class="sxs-lookup"><span data-stu-id="353b1-169">No match.</span></span>|  
|<span data-ttu-id="353b1-170">11</span><span class="sxs-lookup"><span data-stu-id="353b1-170">11</span></span>|<span data-ttu-id="353b1-171">e</span><span class="sxs-lookup"><span data-stu-id="353b1-171">e</span></span>|<span data-ttu-id="353b1-172">“g a reed”（索引 6）</span><span class="sxs-lookup"><span data-stu-id="353b1-172">"g a reed" (index 6)</span></span>|<span data-ttu-id="353b1-173">无匹配。</span><span class="sxs-lookup"><span data-stu-id="353b1-173">No match.</span></span>|  
|<span data-ttu-id="353b1-174">12</span><span class="sxs-lookup"><span data-stu-id="353b1-174">12</span></span>|<span data-ttu-id="353b1-175">e</span><span class="sxs-lookup"><span data-stu-id="353b1-175">e</span></span>|<span data-ttu-id="353b1-176">“a reed”（索引 7）</span><span class="sxs-lookup"><span data-stu-id="353b1-176">" a reed" (index 7)</span></span>|<span data-ttu-id="353b1-177">无匹配。</span><span class="sxs-lookup"><span data-stu-id="353b1-177">No match.</span></span>|  
|<span data-ttu-id="353b1-178">13</span><span class="sxs-lookup"><span data-stu-id="353b1-178">13</span></span>|<span data-ttu-id="353b1-179">e</span><span class="sxs-lookup"><span data-stu-id="353b1-179">e</span></span>|<span data-ttu-id="353b1-180">“a reed”（索引 8）</span><span class="sxs-lookup"><span data-stu-id="353b1-180">"a reed" (index 8)</span></span>|<span data-ttu-id="353b1-181">无匹配。</span><span class="sxs-lookup"><span data-stu-id="353b1-181">No match.</span></span>|  
|<span data-ttu-id="353b1-182">14</span><span class="sxs-lookup"><span data-stu-id="353b1-182">14</span></span>|<span data-ttu-id="353b1-183">e</span><span class="sxs-lookup"><span data-stu-id="353b1-183">e</span></span>|<span data-ttu-id="353b1-184">“reed”（索引 9）</span><span class="sxs-lookup"><span data-stu-id="353b1-184">" reed" (index 9)</span></span>|<span data-ttu-id="353b1-185">无匹配。</span><span class="sxs-lookup"><span data-stu-id="353b1-185">No match.</span></span>|  
|<span data-ttu-id="353b1-186">15</span><span class="sxs-lookup"><span data-stu-id="353b1-186">15</span></span>|<span data-ttu-id="353b1-187">e</span><span class="sxs-lookup"><span data-stu-id="353b1-187">e</span></span>|<span data-ttu-id="353b1-188">“reed”（索引 10）</span><span class="sxs-lookup"><span data-stu-id="353b1-188">"reed" (index 10)</span></span>|<span data-ttu-id="353b1-189">无匹配</span><span class="sxs-lookup"><span data-stu-id="353b1-189">No match</span></span>|  
|<span data-ttu-id="353b1-190">16</span><span class="sxs-lookup"><span data-stu-id="353b1-190">16</span></span>|<span data-ttu-id="353b1-191">e</span><span class="sxs-lookup"><span data-stu-id="353b1-191">e</span></span>|<span data-ttu-id="353b1-192">“eed”（索引 11）</span><span class="sxs-lookup"><span data-stu-id="353b1-192">"eed" (index 11)</span></span>|<span data-ttu-id="353b1-193">可能匹配。</span><span class="sxs-lookup"><span data-stu-id="353b1-193">Possible match.</span></span>|  
|<span data-ttu-id="353b1-194">17</span><span class="sxs-lookup"><span data-stu-id="353b1-194">17</span></span>|<span data-ttu-id="353b1-195">e{2}</span><span class="sxs-lookup"><span data-stu-id="353b1-195">e{2}</span></span>|<span data-ttu-id="353b1-196">“ed”（索引 12）</span><span class="sxs-lookup"><span data-stu-id="353b1-196">"ed" (index 12)</span></span>|<span data-ttu-id="353b1-197">可能匹配。</span><span class="sxs-lookup"><span data-stu-id="353b1-197">Possible match.</span></span>|  
|<span data-ttu-id="353b1-198">18</span><span class="sxs-lookup"><span data-stu-id="353b1-198">18</span></span>|<span data-ttu-id="353b1-199">\w</span><span class="sxs-lookup"><span data-stu-id="353b1-199">\w</span></span>|<span data-ttu-id="353b1-200">“d”（索引 13）</span><span class="sxs-lookup"><span data-stu-id="353b1-200">"d" (index 13)</span></span>|<span data-ttu-id="353b1-201">可能匹配。</span><span class="sxs-lookup"><span data-stu-id="353b1-201">Possible match.</span></span>|  
|<span data-ttu-id="353b1-202">19</span><span class="sxs-lookup"><span data-stu-id="353b1-202">19</span></span>|<span data-ttu-id="353b1-203">\b</span><span class="sxs-lookup"><span data-stu-id="353b1-203">\b</span></span>|<span data-ttu-id="353b1-204">“”(索引 14)</span><span class="sxs-lookup"><span data-stu-id="353b1-204">"" (index 14)</span></span>|<span data-ttu-id="353b1-205">匹配。</span><span class="sxs-lookup"><span data-stu-id="353b1-205">Match.</span></span>|  
  
 <span data-ttu-id="353b1-206">如果正则表达式模式中不包括可选限定符或替换构造，则将正则表达式模式与输入字符串匹配所需要的最大比较数大致等于输入字符串中的字符数。</span><span class="sxs-lookup"><span data-stu-id="353b1-206">If a regular expression pattern includes no optional quantifiers or alternation constructs, the maximum number of comparisons required to match the regular expression pattern with the input string is roughly equivalent to the number of characters in the input string.</span></span> <span data-ttu-id="353b1-207">在这种情况下，正则表达式引擎通过 19 次比较来标识该 13 个字符的字符串中可能的匹配项。</span><span class="sxs-lookup"><span data-stu-id="353b1-207">In this case, the regular expression engine uses 19 comparisons to identify possible matches in this 13-character string.</span></span>  <span data-ttu-id="353b1-208">换句话说，如果正则表达式引擎不包含可选限定符或替换构造，则正则表达式引擎将以近线性时间运行。</span><span class="sxs-lookup"><span data-stu-id="353b1-208">In other words, the regular expression engine runs in near-linear time if it contains no optional quantifiers or alternation constructs.</span></span>  
  
 [<span data-ttu-id="353b1-209">返回页首</span><span class="sxs-lookup"><span data-stu-id="353b1-209">Back to top</span></span>](#top)  
  
<a name="backtracking_with_optional_quantifiers_or_alternation_constructs"></a>   
## <a name="backtracking-with-optional-quantifiers-or-alternation-constructs"></a><span data-ttu-id="353b1-210">使用可选限定符或替换构造的回溯</span><span class="sxs-lookup"><span data-stu-id="353b1-210">Backtracking with Optional Quantifiers or Alternation Constructs</span></span>  
 <span data-ttu-id="353b1-211">当正则表达式模式包含可选限定符或替换构造时，输入字符串的计算将不再为线性。</span><span class="sxs-lookup"><span data-stu-id="353b1-211">When a regular expression includes optional quantifiers or alternation constructs, the evaluation of the input string is no longer linear.</span></span> <span data-ttu-id="353b1-212">使用 NFA 引擎的模式匹配由正则表达式中的语言元素驱动，而不是由输入字符串中要匹配的字符驱动。</span><span class="sxs-lookup"><span data-stu-id="353b1-212">Pattern matching with an NFA engine is driven by the language elements in the regular expression and not by the characters to be matched in the input string.</span></span> <span data-ttu-id="353b1-213">因此，正则表达式引擎将尝试完全匹配可选或可替换的子表达式。</span><span class="sxs-lookup"><span data-stu-id="353b1-213">Therefore, the regular expression engine tries to fully match optional or alternative subexpressions.</span></span> <span data-ttu-id="353b1-214">当它前进到子表达式中的下一个语言元素并且匹配不成功时，正则表达式引擎可放弃其成功匹配的一部分，并返回以前保存的与将正则表达式作为一个整体与输入字符串匹配有关的状态。</span><span class="sxs-lookup"><span data-stu-id="353b1-214">When it advances to the next language element in the subexpression and the match is unsuccessful, the regular expression engine can abandon a portion of its successful match and return to an earlier saved state in the interest of matching the regular expression as a whole with the input string.</span></span> <span data-ttu-id="353b1-215">返回到以前保存状态以查找匹配的这一过程称为回溯。</span><span class="sxs-lookup"><span data-stu-id="353b1-215">This process of returning to a previous saved state to find a match is known as backtracking.</span></span>  
  
 <span data-ttu-id="353b1-216">例如，考虑正则表达式模式 `.*(es)`，它匹配字符“es”以及它前面的所有字符。</span><span class="sxs-lookup"><span data-stu-id="353b1-216">For example, consider the regular expression pattern `.*(es)`, which matches the characters "es" and all the characters that precede it.</span></span> <span data-ttu-id="353b1-217">如下面的示例所示，如果输入字符串为“Essential services are provided by regular expressions.”，模式将匹配“expressions”之前且包括“es”在内的整个字符串。</span><span class="sxs-lookup"><span data-stu-id="353b1-217">As the following example shows, if the input string is "Essential services are provided by regular expressions.", the pattern matches the whole string up to and including the "es" in "expressions".</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking2.cs#2)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking2.vb#2)]  
  
 <span data-ttu-id="353b1-218">为此，正则表达式引擎按如下所示使用回溯：</span><span class="sxs-lookup"><span data-stu-id="353b1-218">To do this, the regular expression engine uses backtracking as follows:</span></span>  
  
- <span data-ttu-id="353b1-219">它将 `.*` （它对应于出现零次、一次或多次任意字符）与整个输入字符串匹配。</span><span class="sxs-lookup"><span data-stu-id="353b1-219">It matches the `.*` (which matches zero, one, or more occurrences of any character) with the whole input string.</span></span>  
  
- <span data-ttu-id="353b1-220">它尝试在正则表达式模式中匹配“e”。</span><span class="sxs-lookup"><span data-stu-id="353b1-220">It attempts to match "e" in the regular expression pattern.</span></span> <span data-ttu-id="353b1-221">但是，输入字符串没有剩余的可用字符来匹配。</span><span class="sxs-lookup"><span data-stu-id="353b1-221">However, the input string has no remaining characters available to match.</span></span>  
  
- <span data-ttu-id="353b1-222">它回溯到上一次成功的匹配“Essential services are provided by regular expressions”，并尝试将“e”与句尾的句号匹配。</span><span class="sxs-lookup"><span data-stu-id="353b1-222">It backtracks to its last successful match, "Essential services are provided by regular expressions", and attempts to match "e" with the period at the end of the sentence.</span></span> <span data-ttu-id="353b1-223">匹配失败。</span><span class="sxs-lookup"><span data-stu-id="353b1-223">The match fails.</span></span>  
  
- <span data-ttu-id="353b1-224">它继续回溯到上一个成功匹配，一次一个字符，直至临时匹配的子字符串为“Essential services are provided by regular expr”。</span><span class="sxs-lookup"><span data-stu-id="353b1-224">It continues to backtrack to a previous successful match one character at a time until the tentatively matched substring is "Essential services are provided by regular expr".</span></span> <span data-ttu-id="353b1-225">然后，它将模式中的“e”与“expressions”中的第二个“e”进行比较，并找到匹配。</span><span class="sxs-lookup"><span data-stu-id="353b1-225">It then compares the "e" in the pattern to the second "e" in "expressions" and finds a match.</span></span>  
  
- <span data-ttu-id="353b1-226">它将模式中的“s”与匹配的“e”字符之后的“s”（“expressions”中的第一个“s”）进行比较。</span><span class="sxs-lookup"><span data-stu-id="353b1-226">It compares "s" in the pattern to the "s" that follows the matched "e" character (the first "s" in "expressions").</span></span> <span data-ttu-id="353b1-227">匹配成功。</span><span class="sxs-lookup"><span data-stu-id="353b1-227">The match is successful.</span></span>  
  
 <span data-ttu-id="353b1-228">当您使用回溯将正则表达式模式与输入字符串（长度为 55 个字符）匹配时，需要执行 67 次比较操作。</span><span class="sxs-lookup"><span data-stu-id="353b1-228">When you use backtracking, matching the regular expression pattern with the input string, which is 55 characters long, requires 67 comparison operations.</span></span> <span data-ttu-id="353b1-229">通常，如果正则表达式模式包括单个替换构造或单个可选限定符，则匹配模式所需要的比较操作数大于输入字符串中字符数的两倍。</span><span class="sxs-lookup"><span data-stu-id="353b1-229">Generally, if a regular expression pattern has a single alternation construct or a single optional quantifier, the number of comparison operations required to match the pattern is more than twice the number of characters in the input string.</span></span>  
  
 [<span data-ttu-id="353b1-230">返回页首</span><span class="sxs-lookup"><span data-stu-id="353b1-230">Back to top</span></span>](#top)  
  
<a name="backtracking_with_nested_optional_quantifiers"></a>   
## <a name="backtracking-with-nested-optional-quantifiers"></a><span data-ttu-id="353b1-231">使用嵌套的可选限定符的回溯</span><span class="sxs-lookup"><span data-stu-id="353b1-231">Backtracking with Nested Optional Quantifiers</span></span>  
 <span data-ttu-id="353b1-232">如果模式中包括大量替换构造、嵌套的替换构造（或最常见的是嵌套的可选限定符），则匹配正则表达式模式所需要的比较操作数会成指数增加。</span><span class="sxs-lookup"><span data-stu-id="353b1-232">The number of comparison operations required to match a regular expression pattern can increase exponentially if the pattern includes a large number of alternation constructs, if it includes nested alternation constructs, or, most commonly, if it includes nested optional quantifiers.</span></span> <span data-ttu-id="353b1-233">例如，正则表达式模式 `^(a+)+$` 用于匹配包含一个或多个“a”字符的完整字符串。</span><span class="sxs-lookup"><span data-stu-id="353b1-233">For example, the regular expression pattern `^(a+)+$` is designed to match a complete string that contains one or more "a" characters.</span></span> <span data-ttu-id="353b1-234">该示例提供了两个长度相同的输入字符串，但只有第一个字符串与模式匹配。</span><span class="sxs-lookup"><span data-stu-id="353b1-234">The example provides two input strings of identical length, but only the first string matches the pattern.</span></span> <span data-ttu-id="353b1-235"><xref:System.Diagnostics.Stopwatch?displayProperty=nameWithType> 类用于确定匹配操作所需的时间。</span><span class="sxs-lookup"><span data-stu-id="353b1-235">The <xref:System.Diagnostics.Stopwatch?displayProperty=nameWithType> class is used to determine how long the match operation takes.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking3.cs#3)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking3.vb#3)]  
  
 <span data-ttu-id="353b1-236">正如示例输出所示，正则表达式引擎查找输入字符串与模式不匹配所需的时间大约为标识匹配字符串所需时间的两倍。</span><span class="sxs-lookup"><span data-stu-id="353b1-236">As the output from the example shows, the regular expression engine took about twice as long to find that an input string did not match the pattern as it did to identify a matching string.</span></span> <span data-ttu-id="353b1-237">这是因为，不成功的匹配始终表示最糟糕的情况。</span><span class="sxs-lookup"><span data-stu-id="353b1-237">This is because an unsuccessful match always represents a worst-case scenario.</span></span> <span data-ttu-id="353b1-238">正则表达式引擎必须使用正则表达式来遵循通过数据的所有可能路径，然后才能得出匹配不成功的结论，嵌套的括号会创建通过数据的许多其他路径。</span><span class="sxs-lookup"><span data-stu-id="353b1-238">The regular expression engine must use the regular expression to follow all possible paths through the data before it can conclude that the match is unsuccessful, and the nested parentheses create many additional paths through the data.</span></span> <span data-ttu-id="353b1-239">正则表达式引擎通过执行以下操作来确定第二个字符串与模式不匹配：</span><span class="sxs-lookup"><span data-stu-id="353b1-239">The regular expression engine concludes that the second string did not match the pattern by doing the following:</span></span>  
  
- <span data-ttu-id="353b1-240">它检查到正位于字符串开头，然后将字符串中的前五个字符与模式 `a+`匹配。</span><span class="sxs-lookup"><span data-stu-id="353b1-240">It checks that it was at the beginning of the string, and then matches the first five characters in the string with the pattern `a+`.</span></span> <span data-ttu-id="353b1-241">然后确定字符串中没有其他成组的“a”字符。</span><span class="sxs-lookup"><span data-stu-id="353b1-241">It then determines that there are no additional groups of "a" characters in the string.</span></span> <span data-ttu-id="353b1-242">最后，它测试是否位于字符串结尾。</span><span class="sxs-lookup"><span data-stu-id="353b1-242">Finally, it tests for the end of the string.</span></span> <span data-ttu-id="353b1-243">由于还有一个附加字符保留在字符串中，所以匹配失败。</span><span class="sxs-lookup"><span data-stu-id="353b1-243">Because one additional character remains in the string, the match fails.</span></span> <span data-ttu-id="353b1-244">这一失败的匹配需要进行 9 次比较。</span><span class="sxs-lookup"><span data-stu-id="353b1-244">This failed match requires 9 comparisons.</span></span> <span data-ttu-id="353b1-245">正则表达式引擎也从其“a”（我们将其称为匹配 1）、“aa”（匹配 2）、“aaa”（匹配 3）和“aaaa”（匹配 4）的匹配中保存状态信息。</span><span class="sxs-lookup"><span data-stu-id="353b1-245">The regular expression engine also saves state information from its matches of "a" (which we will call match 1), "aa" (match 2), "aaa" (match 3), and "aaaa" (match 4).</span></span>  
  
- <span data-ttu-id="353b1-246">它返回到以前保存的匹配 4。</span><span class="sxs-lookup"><span data-stu-id="353b1-246">It returns to the previously saved match 4.</span></span> <span data-ttu-id="353b1-247">它确定没有一个附加的“a”字符可分配给其他捕获的组。</span><span class="sxs-lookup"><span data-stu-id="353b1-247">It determines that there is one additional "a" character to assign to an additional captured group.</span></span> <span data-ttu-id="353b1-248">最后，它测试是否位于字符串结尾。</span><span class="sxs-lookup"><span data-stu-id="353b1-248">Finally, it tests for the end of the string.</span></span> <span data-ttu-id="353b1-249">由于还有一个附加字符保留在字符串中，所以匹配失败。</span><span class="sxs-lookup"><span data-stu-id="353b1-249">Because one additional character remains in the string, the match fails.</span></span> <span data-ttu-id="353b1-250">该失败的匹配需要进行 4 次比较。</span><span class="sxs-lookup"><span data-stu-id="353b1-250">This failed match requires 4 comparisons.</span></span> <span data-ttu-id="353b1-251">到目前为止，总共执行了 13 次比较。</span><span class="sxs-lookup"><span data-stu-id="353b1-251">So far, a total of 13 comparisons have been performed.</span></span>  
  
- <span data-ttu-id="353b1-252">它返回到以前保存的匹配 3。</span><span class="sxs-lookup"><span data-stu-id="353b1-252">It returns to the previously saved match 3.</span></span> <span data-ttu-id="353b1-253">它确定有两个附加的“a”字符可分配给其他捕获的组。</span><span class="sxs-lookup"><span data-stu-id="353b1-253">It determines that there are two additional "a" characters to assign to an additional captured group.</span></span> <span data-ttu-id="353b1-254">但是，字符串末尾测试失败。</span><span class="sxs-lookup"><span data-stu-id="353b1-254">However, the end-of-string test fails.</span></span> <span data-ttu-id="353b1-255">然后，它返回 match3 并尝试在两个附加的捕获组中匹配两个附加的“a”字符。</span><span class="sxs-lookup"><span data-stu-id="353b1-255">It then returns to match3 and tries to match the two additional "a" characters in two additional captured groups.</span></span> <span data-ttu-id="353b1-256">字符串末尾测试仍失败。</span><span class="sxs-lookup"><span data-stu-id="353b1-256">The end-of-string test still fails.</span></span> <span data-ttu-id="353b1-257">这些失败的匹配需要进行 12 次比较。</span><span class="sxs-lookup"><span data-stu-id="353b1-257">These failed matches require 12 comparisons.</span></span> <span data-ttu-id="353b1-258">到目前为止，总共执行了 25 次比较。</span><span class="sxs-lookup"><span data-stu-id="353b1-258">So far, a total of 25 comparisons have been performed.</span></span>  
  
 <span data-ttu-id="353b1-259">输入字符串与正则表达式的比较将以此方式继续，直到正则表达式引擎已尝试所有可能的匹配组合然后得出无匹配的结论。</span><span class="sxs-lookup"><span data-stu-id="353b1-259">Comparison of the input string with the regular expression continues in this way until the regular expression engine has tried all possible combinations of matches, and then concludes that there is no match.</span></span> <span data-ttu-id="353b1-260">因为存在嵌套的限定符，所以此比较为 O(2<sup>n</sup>) 或指数操作，其中 n 是输入字符串中的字符数  。</span><span class="sxs-lookup"><span data-stu-id="353b1-260">Because of the nested quantifiers, this comparison is an O(2<sup>n</sup>) or an exponential operation, where *n* is the number of characters in the input string.</span></span> <span data-ttu-id="353b1-261">这意味着在最糟糕的情况下，包含 30 个字符的输入字符串大约需要进行 1,073,741,824 次比较，包含 40 个字符的输入字符串大约需要进行 1,099,511,627,776 次比较。</span><span class="sxs-lookup"><span data-stu-id="353b1-261">This means that in the worst case, an input string of 30 characters requires approximately 1,073,741,824 comparisons, and an input string of 40 characters requires approximately 1,099,511,627,776 comparisons.</span></span> <span data-ttu-id="353b1-262">如果使用上述长度甚至更长的字符串，则正则表达式方法在处理与正则表达式模式不匹配的输入时，会需要超长的时间来完成。</span><span class="sxs-lookup"><span data-stu-id="353b1-262">If you use strings of these or even greater lengths, regular expression methods can take an extremely long time to complete when they process input that does not match the regular expression pattern.</span></span>  
  
 [<span data-ttu-id="353b1-263">返回页首</span><span class="sxs-lookup"><span data-stu-id="353b1-263">Back to top</span></span>](#top)  
  
<a name="controlling_backtracking"></a>   
## <a name="controlling-backtracking"></a><span data-ttu-id="353b1-264">控制回溯</span><span class="sxs-lookup"><span data-stu-id="353b1-264">Controlling Backtracking</span></span>  
 <span data-ttu-id="353b1-265">通过回溯可以创建强大、灵活的正则表达式。</span><span class="sxs-lookup"><span data-stu-id="353b1-265">Backtracking lets you create powerful, flexible regular expressions.</span></span> <span data-ttu-id="353b1-266">但如上一节所示，回溯在提供这些优点的同时，可能也会使性能差的无法接受。</span><span class="sxs-lookup"><span data-stu-id="353b1-266">However, as the previous section showed, these benefits may be coupled with unacceptably poor performance.</span></span> <span data-ttu-id="353b1-267">若要防止过度回溯，则应在实例化 <xref:System.Text.RegularExpressions.Regex> 对象或调用静态正则表达式匹配方法时定义超时间隔。</span><span class="sxs-lookup"><span data-stu-id="353b1-267">To prevent excessive backtracking, you should define a time-out interval when you instantiate a <xref:System.Text.RegularExpressions.Regex> object or call a static regular expression matching method.</span></span> <span data-ttu-id="353b1-268">下一节中将对此进行讨论。</span><span class="sxs-lookup"><span data-stu-id="353b1-268">This is discussed in the next section.</span></span> <span data-ttu-id="353b1-269">此外，.NET 还支持以下三个正则表达式语言元素，这些元素限制或禁止回溯，并支持几乎不会或完全不会导致性能损失的复杂正则表达式：[非回溯子表达式](#Nonbacktracking)、[回顾断言](#Lookbehind)和[预测先行断言](#Lookahead)。</span><span class="sxs-lookup"><span data-stu-id="353b1-269">In addition, .NET supports three regular expression language elements that limit or suppress backtracking and that support complex regular expressions with little or no performance penalty: [nonbacktracking subexpressions](#Nonbacktracking), [lookbehind assertions](#Lookbehind), and [lookahead assertions](#Lookahead).</span></span> <span data-ttu-id="353b1-270">有关每个语言元素的详细信息，请参见 [分组构造](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md)。</span><span class="sxs-lookup"><span data-stu-id="353b1-270">For more information about each language element, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
<a name="Timeout"></a>   
### <a name="defining-a-time-out-interval"></a><span data-ttu-id="353b1-271">定义超时间隔</span><span class="sxs-lookup"><span data-stu-id="353b1-271">Defining a Time-out Interval</span></span>  
 <span data-ttu-id="353b1-272">从 .NET Framework 4.5 开始，可以设置超时值，该值表示正则表达式引擎在放弃尝试并引发 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 异常之前将搜索单个匹配项的最长间隔。</span><span class="sxs-lookup"><span data-stu-id="353b1-272">Starting with the .NET Framework 4.5, you can set a time-out value that represents the longest interval the regular expression engine will search for a single match before it abandons the attempt and throws a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception.</span></span> <span data-ttu-id="353b1-273">你可以通过向实例正则表达式的 <xref:System.TimeSpan> 构造函数提供 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 值来指定超时间隔。</span><span class="sxs-lookup"><span data-stu-id="353b1-273">You specify the time-out interval by supplying a <xref:System.TimeSpan> value to the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor for instance regular expressions.</span></span> <span data-ttu-id="353b1-274">此外，每种静态模式匹配方法都具有带 <xref:System.TimeSpan> 参数的重载，该参数允许你指定超时值。</span><span class="sxs-lookup"><span data-stu-id="353b1-274">In addition, each static pattern matching method has an overload with a <xref:System.TimeSpan> parameter that allows you to specify a time-out value.</span></span> <span data-ttu-id="353b1-275">默认情况下，超时间隔设置为 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> 且正则表达式引擎不会超时。</span><span class="sxs-lookup"><span data-stu-id="353b1-275">By default, the time-out interval is set to <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> and the regular expression engine does not time out.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="353b1-276">如果正则表达式依赖回溯，建议你始终设置超时间隔。</span><span class="sxs-lookup"><span data-stu-id="353b1-276">We recommend that you always set a time-out interval if your regular expression relies on backtracking.</span></span>  
  
 <span data-ttu-id="353b1-277"><xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 异常指示正则表达式引擎无法在指定的超时间隔内找到匹配项，但不指示引发异常的原因。</span><span class="sxs-lookup"><span data-stu-id="353b1-277">A <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception indicates that the regular expression engine was unable to find a match within the specified time-out interval but does not indicate why the exception was thrown.</span></span> <span data-ttu-id="353b1-278">原因可能是过度回溯，但也可能是超时间隔设置得过小（在引发异常时产生系统负载）。</span><span class="sxs-lookup"><span data-stu-id="353b1-278">The reason might be excessive backtracking, but it is also possible that the time-out interval was set too low given the system load at the time the exception was thrown.</span></span> <span data-ttu-id="353b1-279">在处理异常时，你可以选择放弃与输入字符串的进一步匹配或增大超时间隔，然后重试匹配操作。</span><span class="sxs-lookup"><span data-stu-id="353b1-279">When you handle the exception, you can choose to abandon further matches with the input string or increase the time-out interval and retry the matching operation.</span></span>  
  
 <span data-ttu-id="353b1-280">例如，下面的代码调用 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 构造函数来实例化超时值为 1 秒的 <xref:System.Text.RegularExpressions.Regex> 对象。</span><span class="sxs-lookup"><span data-stu-id="353b1-280">For example, the following code calls the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor to instantiate a <xref:System.Text.RegularExpressions.Regex> object with a time-out value of one second.</span></span> <span data-ttu-id="353b1-281">正则表达式模式 `(a+)+$`（与行尾的一个或多个“a”字符的一个或多个序列匹配）受过度回溯的约束。</span><span class="sxs-lookup"><span data-stu-id="353b1-281">The regular expression pattern `(a+)+$`, which matches one or more sequences of one or more "a" characters at the end of a line, is subject to excessive backtracking.</span></span> <span data-ttu-id="353b1-282">如果引发 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 异常，该示例会将超时值增大到三秒最长间隔。</span><span class="sxs-lookup"><span data-stu-id="353b1-282">If a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> is thrown, the example increases the time-out value up to a maximum interval of three seconds.</span></span> <span data-ttu-id="353b1-283">之后，它放弃尝试匹配模式。</span><span class="sxs-lookup"><span data-stu-id="353b1-283">After that, it abandons the attempt to match the pattern.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.ctor#1](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.ctor#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/vb/ctor1.vb#1)]  
  
<a name="Nonbacktracking"></a>   
### <a name="nonbacktracking-subexpression"></a><span data-ttu-id="353b1-284">非回溯子表达式</span><span class="sxs-lookup"><span data-stu-id="353b1-284">Nonbacktracking Subexpression</span></span>  
 <span data-ttu-id="353b1-285">`(?>` *subexpression*`)` 语言元素禁止在子表达式中使用回溯。</span><span class="sxs-lookup"><span data-stu-id="353b1-285">The `(?>` *subexpression*`)` language element suppresses backtracking in a subexpression.</span></span> <span data-ttu-id="353b1-286">它可用于预防与匹配失败关联的性能问题。</span><span class="sxs-lookup"><span data-stu-id="353b1-286">It is useful for preventing the performance problems associated with failed matches.</span></span>  
  
 <span data-ttu-id="353b1-287">下面的示例演示在使用嵌套的限定符时禁止回溯如何改进性能。</span><span class="sxs-lookup"><span data-stu-id="353b1-287">The following example illustrates how suppressing backtracking improves performance when using nested quantifiers.</span></span> <span data-ttu-id="353b1-288">它测量正则表达式引擎确定输入字符串与两个正则表达式不匹配所需要的时间。</span><span class="sxs-lookup"><span data-stu-id="353b1-288">It measures the time required for the regular expression engine to determine that an input string does not match two regular expressions.</span></span> <span data-ttu-id="353b1-289">第一个正则表达式使用回溯尝试匹配一个字符串，在该字符串中，一个或多个十六进制数出现了一次或多次，然后依次为冒号、一个或多个十六进制数、两个冒号。</span><span class="sxs-lookup"><span data-stu-id="353b1-289">The first regular expression uses backtracking to attempt to match a string that contains one or more occurrences of one or more hexadecimal digits, followed by a colon, followed by one or more hexadecimal digits, followed by two colons.</span></span> <span data-ttu-id="353b1-290">第二个正则表达式与第一个相同，不同之处是它禁用了回溯。</span><span class="sxs-lookup"><span data-stu-id="353b1-290">The second regular expression is identical to the first, except that it disables backtracking.</span></span> <span data-ttu-id="353b1-291">如该示例输出所示，禁用回溯对性能的改进非常显著。</span><span class="sxs-lookup"><span data-stu-id="353b1-291">As the output from the example shows, the performance improvement from disabling backtracking is significant.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking4.cs#4)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking4.vb#4)]  
  
<a name="Lookbehind"></a>   
### <a name="lookbehind-assertions"></a><span data-ttu-id="353b1-292">回顾断言</span><span class="sxs-lookup"><span data-stu-id="353b1-292">Lookbehind Assertions</span></span>  
 <span data-ttu-id="353b1-293">.NET 包括两个语言元素（`(?<=`subexpression  `)` 和 `(?<!`subexpression  `)`），它们与输入字符串中之前的一个或多个字符匹配。</span><span class="sxs-lookup"><span data-stu-id="353b1-293">.NET includes two language elements, `(?<=`*subexpression*`)` and `(?<!`*subexpression*`)`, that match the previous character or characters in the input string.</span></span> <span data-ttu-id="353b1-294">这两个语言元素都是零宽度断言；也就是说，它们通过 *subexpression*而不是前移或回溯来确定当前字符之前紧挨着的一个或多个字符是否匹配。</span><span class="sxs-lookup"><span data-stu-id="353b1-294">Both language elements are zero-width assertions; that is, they determine whether the character or characters that immediately precede the current character can be matched by *subexpression*, without advancing or backtracking.</span></span>  
  
 <span data-ttu-id="353b1-295">`(?<=` *subexpression* `)` 是正回顾断言；也就是说，当前位置之前的一个或多个字符必须与 *subexpression*匹配。</span><span class="sxs-lookup"><span data-stu-id="353b1-295">`(?<=` *subexpression* `)` is a positive lookbehind assertion; that is, the character or characters before the current position must match *subexpression*.</span></span> <span data-ttu-id="353b1-296">`(?<!`*subexpression*`)` 是负回顾断言；也就是说，当前位置之前的一个或多个字符不得与 *subexpression*匹配。</span><span class="sxs-lookup"><span data-stu-id="353b1-296">`(?<!`*subexpression*`)` is a negative lookbehind assertion; that is, the character or characters before the current position must not match *subexpression*.</span></span> <span data-ttu-id="353b1-297">当 *subexpression* 为前一个子表达式的子集时，正回顾断言和负回顾断言都最为有用。</span><span class="sxs-lookup"><span data-stu-id="353b1-297">Both positive and negative lookbehind assertions are most useful when *subexpression* is a subset of the previous subexpression.</span></span>  
  
 <span data-ttu-id="353b1-298">下面的示例使用两个相当的正则表达式模式，验证电子邮件地址中的用户名。</span><span class="sxs-lookup"><span data-stu-id="353b1-298">The following example uses two equivalent regular expression patterns that validate the user name in an email address.</span></span> <span data-ttu-id="353b1-299">第一个模式由于过多使用回溯，性能极差。</span><span class="sxs-lookup"><span data-stu-id="353b1-299">The first pattern is subject to poor performance because of excessive backtracking.</span></span> <span data-ttu-id="353b1-300">第二个模式通过将嵌套的限定符替换为正回顾断言来修改第一个正则表达式。</span><span class="sxs-lookup"><span data-stu-id="353b1-300">The second pattern modifies the first regular expression by replacing a nested quantifier with a positive lookbehind assertion.</span></span> <span data-ttu-id="353b1-301">该示例的输出显示 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> 方法的执行时间。</span><span class="sxs-lookup"><span data-stu-id="353b1-301">The output from the example displays the execution time of the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking5.cs#5)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking5.vb#5)]  
  
 <span data-ttu-id="353b1-302">第一个正则表达式模式 `^[0-9A-Z]([-.\w]*[0-9A-Z])*@`的定义如下表所示。</span><span class="sxs-lookup"><span data-stu-id="353b1-302">The first regular expression pattern, `^[0-9A-Z]([-.\w]*[0-9A-Z])*@`, is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="353b1-303">模式</span><span class="sxs-lookup"><span data-stu-id="353b1-303">Pattern</span></span>|<span data-ttu-id="353b1-304">说明</span><span class="sxs-lookup"><span data-stu-id="353b1-304">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="353b1-305">从字符串开头开始匹配。</span><span class="sxs-lookup"><span data-stu-id="353b1-305">Start the match at the beginning of the string.</span></span>|  
|`[0-9A-Z]`|<span data-ttu-id="353b1-306">匹配字母数字字符。</span><span class="sxs-lookup"><span data-stu-id="353b1-306">Match an alphanumeric character.</span></span> <span data-ttu-id="353b1-307">因为 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> 方法是使用 <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> 选项调用的，所以此比较不区分大小写。</span><span class="sxs-lookup"><span data-stu-id="353b1-307">This comparison is case-insensitive, because the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option.</span></span>|  
|`[-.\w]*`|<span data-ttu-id="353b1-308">匹配零个、一个或多个连字符、句号或单词字符。</span><span class="sxs-lookup"><span data-stu-id="353b1-308">Match zero, one, or more occurrences of a hyphen, period, or word character.</span></span>|  
|`[0-9A-Z]`|<span data-ttu-id="353b1-309">匹配字母数字字符。</span><span class="sxs-lookup"><span data-stu-id="353b1-309">Match an alphanumeric character.</span></span>|  
|`([-.\w]*[0-9A-Z])*`|<span data-ttu-id="353b1-310">匹配以下零个或多个事例：即零个或多个连字符、句号或单词字符后跟一个字母数字字符的组合。</span><span class="sxs-lookup"><span data-stu-id="353b1-310">Match zero or more occurrences of the combination of zero or more hyphens, periods, or word characters, followed by an alphanumeric character.</span></span> <span data-ttu-id="353b1-311">这是第一个捕获组。</span><span class="sxs-lookup"><span data-stu-id="353b1-311">This is the first capturing group.</span></span>|  
|`@`|<span data-ttu-id="353b1-312">匹配 at 符号（“\@”）。</span><span class="sxs-lookup"><span data-stu-id="353b1-312">Match an at sign ("\@").</span></span>|  
  
 <span data-ttu-id="353b1-313">第二个正则表达式模式 `^[0-9A-Z][-.\w]*(?<=[0-9A-Z])@`使用正回顾断言。</span><span class="sxs-lookup"><span data-stu-id="353b1-313">The second regular expression pattern, `^[0-9A-Z][-.\w]*(?<=[0-9A-Z])@`, uses a positive lookbehind assertion.</span></span> <span data-ttu-id="353b1-314">其定义如下表所示。</span><span class="sxs-lookup"><span data-stu-id="353b1-314">It is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="353b1-315">模式</span><span class="sxs-lookup"><span data-stu-id="353b1-315">Pattern</span></span>|<span data-ttu-id="353b1-316">说明</span><span class="sxs-lookup"><span data-stu-id="353b1-316">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="353b1-317">从字符串开头开始匹配。</span><span class="sxs-lookup"><span data-stu-id="353b1-317">Start the match at the beginning of the string.</span></span>|  
|`[0-9A-Z]`|<span data-ttu-id="353b1-318">匹配字母数字字符。</span><span class="sxs-lookup"><span data-stu-id="353b1-318">Match an alphanumeric character.</span></span> <span data-ttu-id="353b1-319">因为 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> 方法是使用 <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> 选项调用的，所以此比较不区分大小写。</span><span class="sxs-lookup"><span data-stu-id="353b1-319">This comparison is case-insensitive, because the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option.</span></span>|  
|`[-.\w]*`|<span data-ttu-id="353b1-320">匹配零个或多个连字符、句号或单词字符。</span><span class="sxs-lookup"><span data-stu-id="353b1-320">Match zero or more occurrences of a hyphen, period, or word character.</span></span>|  
|`(?<=[0-9A-Z])`|<span data-ttu-id="353b1-321">回顾最后一个匹配的字符，如果该字符是字母数字字符，则继续匹配。</span><span class="sxs-lookup"><span data-stu-id="353b1-321">Look back at the last matched character and continue the match if it is alphanumeric.</span></span> <span data-ttu-id="353b1-322">请注意，字母数字字符是由句号、连字符和所有单词字符构成的集合的子集。</span><span class="sxs-lookup"><span data-stu-id="353b1-322">Note that alphanumeric characters are a subset of the set that consists of periods, hyphens, and all word characters.</span></span>|  
|`@`|<span data-ttu-id="353b1-323">匹配 at 符号（“\@”）。</span><span class="sxs-lookup"><span data-stu-id="353b1-323">Match an at sign ("\@").</span></span>|  
  
<a name="Lookahead"></a>   
### <a name="lookahead-assertions"></a><span data-ttu-id="353b1-324">预测先行断言</span><span class="sxs-lookup"><span data-stu-id="353b1-324">Lookahead Assertions</span></span>  
 <span data-ttu-id="353b1-325">.NET 包括两个语言元素（`(?=`subexpression  `)` 和 `(?!`subexpression  `)`），它们与输入字符串中接下来的一个或多个字符匹配。</span><span class="sxs-lookup"><span data-stu-id="353b1-325">.NET includes two language elements, `(?=`*subexpression*`)` and `(?!`*subexpression*`)`, that match the next character or characters in the input string.</span></span> <span data-ttu-id="353b1-326">这两个语言元素都是零宽度断言；也就是说，它们通过 *subexpression*而不是前移或回溯来确定当前字符之后紧挨着的一个或多个字符是否匹配。</span><span class="sxs-lookup"><span data-stu-id="353b1-326">Both language elements are zero-width assertions; that is, they determine whether the character or characters that immediately follow the current character can be matched by *subexpression*, without advancing or backtracking.</span></span>  
  
 <span data-ttu-id="353b1-327">`(?=` *subexpression* `)` 是正预测先行断言；也就是说，当前位置之后的一个或多个字符必须与 *subexpression*匹配。</span><span class="sxs-lookup"><span data-stu-id="353b1-327">`(?=` *subexpression* `)` is a positive lookahead assertion; that is, the character or characters after the current position must match *subexpression*.</span></span> <span data-ttu-id="353b1-328">`(?!`*subexpression*`)` 是负预测先行断言；也就是说，当前位置之后的一个或多个字符不得与 *subexpression*匹配。</span><span class="sxs-lookup"><span data-stu-id="353b1-328">`(?!`*subexpression*`)` is a negative lookahead assertion; that is, the character or characters after the current position must not match *subexpression*.</span></span> <span data-ttu-id="353b1-329">当 *subexpression* 为下一个子表达式的子集时，正预测先行断言和负预测先行断言都最为有用。</span><span class="sxs-lookup"><span data-stu-id="353b1-329">Both positive and negative lookahead assertions are most useful when *subexpression* is a subset of the next subexpression.</span></span>  
  
 <span data-ttu-id="353b1-330">下面的示例使用两个可验证完全限定的类型名称的等效正则表达式模式。</span><span class="sxs-lookup"><span data-stu-id="353b1-330">The following example uses two equivalent regular expression patterns that validate a fully qualified type name.</span></span> <span data-ttu-id="353b1-331">第一个模式由于过多使用回溯，性能极差。</span><span class="sxs-lookup"><span data-stu-id="353b1-331">The first pattern is subject to poor performance because of excessive backtracking.</span></span> <span data-ttu-id="353b1-332">第二个模式通过将嵌套的限定符替换为正预测先行断言来修改第一个正则表达式。</span><span class="sxs-lookup"><span data-stu-id="353b1-332">The second modifies the first regular expression by replacing a nested quantifier with a positive lookahead assertion.</span></span> <span data-ttu-id="353b1-333">该示例的输出显示 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> 方法的执行时间。</span><span class="sxs-lookup"><span data-stu-id="353b1-333">The output from the example displays the execution time of the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking6.cs#6)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking6.vb#6)]  
  
 <span data-ttu-id="353b1-334">第一个正则表达式模式 `^(([A-Z]\w*)+\.)*[A-Z]\w*$`的定义如下表所示。</span><span class="sxs-lookup"><span data-stu-id="353b1-334">The first regular expression pattern, `^(([A-Z]\w*)+\.)*[A-Z]\w*$`, is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="353b1-335">模式</span><span class="sxs-lookup"><span data-stu-id="353b1-335">Pattern</span></span>|<span data-ttu-id="353b1-336">说明</span><span class="sxs-lookup"><span data-stu-id="353b1-336">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="353b1-337">从字符串开头开始匹配。</span><span class="sxs-lookup"><span data-stu-id="353b1-337">Start the match at the beginning of the string.</span></span>|  
|`([A-Z]\w*)+\.`|<span data-ttu-id="353b1-338">对后跟零个或多个单词字符、句点的字母字符 (A-Z) 匹配一次或多次。</span><span class="sxs-lookup"><span data-stu-id="353b1-338">Match an alphabetical character (A-Z) followed by zero or more word characters one or more times, followed by a period.</span></span> <span data-ttu-id="353b1-339">因为 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> 方法是使用 <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> 选项调用的，所以此比较不区分大小写。</span><span class="sxs-lookup"><span data-stu-id="353b1-339">This comparison is case-insensitive, because the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option.</span></span>|  
|`(([A-Z]\w*)+\.)*`|<span data-ttu-id="353b1-340">对前一个模式匹配一次或多次。</span><span class="sxs-lookup"><span data-stu-id="353b1-340">Match the previous pattern zero or more times.</span></span>|  
|`[A-Z]\w*`|<span data-ttu-id="353b1-341">匹配后跟零个或多个单词字符的字母字符。</span><span class="sxs-lookup"><span data-stu-id="353b1-341">Match an alphabetical character followed by zero or more word characters.</span></span>|  
|`$`|<span data-ttu-id="353b1-342">在输入字符串末尾结束匹配。</span><span class="sxs-lookup"><span data-stu-id="353b1-342">End the match at the end of the input string.</span></span>|  
  
 <span data-ttu-id="353b1-343">第二个正则表达式模式 `^((?=[A-Z])\w+\.)*[A-Z]\w*$`使用正预测先行断言。</span><span class="sxs-lookup"><span data-stu-id="353b1-343">The second regular expression pattern, `^((?=[A-Z])\w+\.)*[A-Z]\w*$`, uses a positive lookahead assertion.</span></span> <span data-ttu-id="353b1-344">其定义如下表所示。</span><span class="sxs-lookup"><span data-stu-id="353b1-344">It is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="353b1-345">模式</span><span class="sxs-lookup"><span data-stu-id="353b1-345">Pattern</span></span>|<span data-ttu-id="353b1-346">说明</span><span class="sxs-lookup"><span data-stu-id="353b1-346">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="353b1-347">从字符串开头开始匹配。</span><span class="sxs-lookup"><span data-stu-id="353b1-347">Start the match at the beginning of the string.</span></span>|  
|`(?=[A-Z])`|<span data-ttu-id="353b1-348">预测先行到第一个字符，如果它是字母 (A-Z)，则继续匹配。</span><span class="sxs-lookup"><span data-stu-id="353b1-348">Look ahead to the first character and continue the match if it is alphabetical (A-Z).</span></span> <span data-ttu-id="353b1-349">因为 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> 方法是使用 <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> 选项调用的，所以此比较不区分大小写。</span><span class="sxs-lookup"><span data-stu-id="353b1-349">This comparison is case-insensitive, because the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option.</span></span>|  
|`\w+\.`|<span data-ttu-id="353b1-350">匹配后跟句号的一个或多个单词字符。</span><span class="sxs-lookup"><span data-stu-id="353b1-350">Match one or more word characters followed by a period.</span></span>|  
|`((?=[A-Z])\w+\.)*`|<span data-ttu-id="353b1-351">对一个或多个单词字符后跟句号的模式进行一次或多次匹配。</span><span class="sxs-lookup"><span data-stu-id="353b1-351">Match the pattern of one or more word characters followed by a period zero or more times.</span></span> <span data-ttu-id="353b1-352">初始单词字符必须为字母字符。</span><span class="sxs-lookup"><span data-stu-id="353b1-352">The initial word character must be alphabetical.</span></span>|  
|`[A-Z]\w*`|<span data-ttu-id="353b1-353">匹配后跟零个或多个单词字符的字母字符。</span><span class="sxs-lookup"><span data-stu-id="353b1-353">Match an alphabetical character followed by zero or more word characters.</span></span>|  
|`$`|<span data-ttu-id="353b1-354">在输入字符串末尾结束匹配。</span><span class="sxs-lookup"><span data-stu-id="353b1-354">End the match at the end of the input string.</span></span>|  
  
 [<span data-ttu-id="353b1-355">返回页首</span><span class="sxs-lookup"><span data-stu-id="353b1-355">Back to top</span></span>](#top)  
  
## <a name="see-also"></a><span data-ttu-id="353b1-356">请参阅</span><span class="sxs-lookup"><span data-stu-id="353b1-356">See also</span></span>

- [<span data-ttu-id="353b1-357">.NET 正则表达式</span><span class="sxs-lookup"><span data-stu-id="353b1-357">.NET Regular Expressions</span></span>](../../../docs/standard/base-types/regular-expressions.md)
- [<span data-ttu-id="353b1-358">正则表达式语言 - 快速参考</span><span class="sxs-lookup"><span data-stu-id="353b1-358">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)
- [<span data-ttu-id="353b1-359">数量词</span><span class="sxs-lookup"><span data-stu-id="353b1-359">Quantifiers</span></span>](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md)
- [<span data-ttu-id="353b1-360">替换构造</span><span class="sxs-lookup"><span data-stu-id="353b1-360">Alternation Constructs</span></span>](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md)
- [<span data-ttu-id="353b1-361">Grouping Constructs</span><span class="sxs-lookup"><span data-stu-id="353b1-361">Grouping Constructs</span></span>](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md)
