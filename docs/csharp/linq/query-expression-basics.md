---
title: 查询表达式基础（C# 中的 LINQ）
description: 与查询表达式相关的概念介绍
ms.date: 11/30/2016
ms.assetid: 027db1f8-346f-44d2-a16e-043fcea3a4e0
ms.openlocfilehash: 83beaa82d4b4b42ff9da5230edddd391b33a0717
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/14/2020
ms.locfileid: "79173349"
---
# <a name="query-expression-basics"></a><span data-ttu-id="f0bd3-103">查询表达式基础</span><span class="sxs-lookup"><span data-stu-id="f0bd3-103">Query expression basics</span></span>

<span data-ttu-id="f0bd3-104">本文介绍与 C# 中的查询表达式相关的基本概念。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-104">This article introduces the basic concepts related to query expressions in C#.</span></span>

## <a name="what-is-a-query-and-what-does-it-do"></a><span data-ttu-id="f0bd3-105">查询是什么及其作用是什么？</span><span class="sxs-lookup"><span data-stu-id="f0bd3-105">What is a query and what does it do?</span></span>

<span data-ttu-id="f0bd3-106">查询  是一组指令，描述要从给定数据源（或源）检索的数据以及返回的数据应具有的形状和组织。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-106">A *query* is a set of instructions that describes what data to retrieve from a given data source (or sources) and what shape and organization the returned data should have.</span></span> <span data-ttu-id="f0bd3-107">查询与它生成的结果不同。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-107">A query is distinct from the results that it produces.</span></span>

<span data-ttu-id="f0bd3-108">通常情况下，源数据按逻辑方式组织为相同类型的元素的序列。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-108">Generally, the source data is organized logically as a sequence of elements of the same kind.</span></span> <span data-ttu-id="f0bd3-109">例如，SQL 数据库表包含行的序列。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-109">For example, a SQL database table contains a sequence of rows.</span></span> <span data-ttu-id="f0bd3-110">在 XML 文件中，存在 XML 元素的“序列”（尽管这些元素在树结构按层次结构进行组织）。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-110">In an XML file, there is a "sequence" of XML elements (although these are organized hierarchically in a tree structure).</span></span> <span data-ttu-id="f0bd3-111">内存中集合包含对象的序列。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-111">An in-memory collection contains a sequence of objects.</span></span>

<span data-ttu-id="f0bd3-112">从应用程序的角度来看，原始源数据的特定类型和结构并不重要。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-112">From an application's viewpoint, the specific type and structure of the original source data is not important.</span></span> <span data-ttu-id="f0bd3-113">应用程序始终将源数据视为 <xref:System.Collections.Generic.IEnumerable%601> 或 <xref:System.Linq.IQueryable%601> 集合。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-113">The application always sees the source data as an <xref:System.Collections.Generic.IEnumerable%601> or <xref:System.Linq.IQueryable%601> collection.</span></span> <span data-ttu-id="f0bd3-114">例如在 LINQ to XML 中，源数据显示为 `IEnumerable`\<<xref:System.Xml.Linq.XElement>>。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-114">For example, in LINQ to XML, the source data is made visible as an `IEnumerable`\<<xref:System.Xml.Linq.XElement>>.</span></span>

<span data-ttu-id="f0bd3-115">对于此源序列，查询可能会执行三种操作之一：</span><span class="sxs-lookup"><span data-stu-id="f0bd3-115">Given this source sequence, a query may do one of three things:</span></span>

- <span data-ttu-id="f0bd3-116">检索元素的子集以生成新序列，而不修改各个元素。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-116">Retrieve a subset of the elements to produce a new sequence without modifying the individual elements.</span></span> <span data-ttu-id="f0bd3-117">查询然后可能以各种方式对返回的序列进行排序或分组，如下面的示例所示（假定 `scores` 是 `int[]`）：</span><span class="sxs-lookup"><span data-stu-id="f0bd3-117">The query may then sort or group the returned sequence in various ways, as shown in the following example (assume `scores` is an `int[]`):</span></span>

    [!code-csharp[csrefQueryExpBasics#45](~/samples/snippets/csharp/concepts/linq/query-expression-basics_1.cs)]

- <span data-ttu-id="f0bd3-118">如前面的示例所示检索元素的序列，但是将它们转换为新类型的对象。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-118">Retrieve a sequence of elements as in the previous example but transform them to a new type of object.</span></span> <span data-ttu-id="f0bd3-119">例如，查询可以只从数据源中的某些客户记录检索姓氏。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-119">For example, a query may retrieve only the last names from certain customer records in a data source.</span></span> <span data-ttu-id="f0bd3-120">或者可以检索完整记录，然后用于构造其他内存中对象类型甚至是 XML 数据，再生成最终的结果序列。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-120">Or it may retrieve the complete record and then use it to construct another in-memory object type or even XML data before generating the final result sequence.</span></span> <span data-ttu-id="f0bd3-121">下面的示例演示从 `int` 到 `string` 的投影。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-121">The following example shows a projection from an `int` to a `string`.</span></span> <span data-ttu-id="f0bd3-122">请注意 `highScoresQuery` 的新类型。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-122">Note the new type of `highScoresQuery`.</span></span>

    [!code-csharp[csrefQueryExpBasics#46](~/samples/snippets/csharp/concepts/linq/query-expression-basics_2.cs)]

- <span data-ttu-id="f0bd3-123">检索有关源数据的单独值，如：</span><span class="sxs-lookup"><span data-stu-id="f0bd3-123">Retrieve a singleton value about the source data, such as:</span></span>

  - <span data-ttu-id="f0bd3-124">与特定条件匹配的元素数。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-124">The number of elements that match a certain condition.</span></span>

  - <span data-ttu-id="f0bd3-125">具有最大或最小值的元素。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-125">The element that has the greatest or least value.</span></span>

  - <span data-ttu-id="f0bd3-126">与某个条件匹配的第一个元素，或指定元素集中特定值的总和。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-126">The first element that matches a condition, or the sum of particular values in a specified set of elements.</span></span> <span data-ttu-id="f0bd3-127">例如，下面的查询从 `scores` 整数数组返回大于 80 的分数的数量：</span><span class="sxs-lookup"><span data-stu-id="f0bd3-127">For example, the following query returns the number of scores greater than 80 from the `scores` integer array:</span></span>

    [!code-csharp[csrefQueryExpBasics#47](~/samples/snippets/csharp/concepts/linq/query-expression-basics_3.cs)]

    <span data-ttu-id="f0bd3-128">在前面的示例中，请注意在调用 `Count` 方法之前，在查询表达式两边使用了括号。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-128">In the previous example, note the use of parentheses around the query expression before the call to the `Count` method.</span></span> <span data-ttu-id="f0bd3-129">也可以通过使用新变量存储具体结果，来表示此行为。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-129">You can also express this by using a new variable to store the concrete result.</span></span> <span data-ttu-id="f0bd3-130">这种方法更具可读性，因为它使存储查询的变量与存储结果的查询分开。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-130">This technique is more readable because it keeps the variable that stores the query separate from the query that stores a result.</span></span>

    [!code-csharp[csrefQueryExpBasics#48](~/samples/snippets/csharp/concepts/linq/query-expression-basics_4.cs)]

<span data-ttu-id="f0bd3-131">在上面的示例中，查询在 `Count` 调用中执行，因为 `Count` 必须循环访问结果才能确定 `highScoresQuery` 返回的元素数。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-131">In the previous example, the query is executed in the call to `Count`, because `Count` must iterate over the results in order to determine the number of elements returned by `highScoresQuery`.</span></span>

## <a name="what-is-a-query-expression"></a><span data-ttu-id="f0bd3-132">查询表达式是什么？</span><span class="sxs-lookup"><span data-stu-id="f0bd3-132">What is a query expression?</span></span>

<span data-ttu-id="f0bd3-133">查询表达式  是以查询语法表示的查询。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-133">A *query expression* is a query expressed in query syntax.</span></span> <span data-ttu-id="f0bd3-134">查询表达式是一流的语言构造。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-134">A query expression is a first-class language construct.</span></span> <span data-ttu-id="f0bd3-135">它如同任何其他表达式一样，可以在 C# 表达式有效的任何上下文中使用。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-135">It is just like any other expression and can be used in any context in which a C# expression is valid.</span></span> <span data-ttu-id="f0bd3-136">查询表达式由一组用类似于 SQL 或 XQuery 的声明性语法所编写的子句组成。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-136">A query expression consists of a set of clauses written in a declarative syntax similar to SQL or XQuery.</span></span> <span data-ttu-id="f0bd3-137">每个子句进而包含一个或多个 C# 表达式，而这些表达式可能本身是查询表达式或包含查询表达式。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-137">Each clause in turn contains one or more C# expressions, and these expressions may themselves be either a query expression or contain a query expression.</span></span>

<span data-ttu-id="f0bd3-138">查询表达式必须以 [from](../language-reference/keywords/from-clause.md) 子句开头，且必须以 [select](../language-reference/keywords/select-clause.md) 或 [group](../language-reference/keywords/group-clause.md) 子句结尾。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-138">A query expression must begin with a [from](../language-reference/keywords/from-clause.md) clause and must end with a [select](../language-reference/keywords/select-clause.md) or [group](../language-reference/keywords/group-clause.md) clause.</span></span> <span data-ttu-id="f0bd3-139">在第一个 `from` 子句与最后一个 `select` 或 `group` 子句之间，可以包含以下这些可选子句中的一个或多个：[where](../language-reference/keywords/where-clause.md)、[orderby](../language-reference/keywords/orderby-clause.md)、[join](../language-reference/keywords/join-clause.md)、[let](../language-reference/keywords/let-clause.md)，甚至是其他 [from](../language-reference/keywords/from-clause.md) 子句。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-139">Between the first `from` clause and the last `select` or `group` clause, it can contain one or more of these optional clauses: [where](../language-reference/keywords/where-clause.md), [orderby](../language-reference/keywords/orderby-clause.md), [join](../language-reference/keywords/join-clause.md), [let](../language-reference/keywords/let-clause.md) and even additional [from](../language-reference/keywords/from-clause.md) clauses.</span></span> <span data-ttu-id="f0bd3-140">还可以使用 [into](../language-reference/keywords/into.md) 关键字，使 `join` 或 `group` 子句的结果可以充当相同查询表达式中的其他查询子句的源。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-140">You can also use the [into](../language-reference/keywords/into.md) keyword to enable the result of a `join` or `group` clause to serve as the source for additional query clauses in the same query expression.</span></span>

### <a name="query-variable"></a><span data-ttu-id="f0bd3-141">查询变量</span><span class="sxs-lookup"><span data-stu-id="f0bd3-141">Query variable</span></span>

<span data-ttu-id="f0bd3-142">在 LINQ 中，查询变量是存储查询  而不是查询结果  的任何变量。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-142">In LINQ, a query variable is any variable that stores a *query* instead of the *results* of a query.</span></span> <span data-ttu-id="f0bd3-143">更具体地说，查询变量始终是可枚举类型，在 `foreach` 语句或对其 `IEnumerator.MoveNext` 方法的直接调用中循环访问时会生成元素序列。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-143">More specifically, a query variable is always an enumerable type that will produce a sequence of elements when it is iterated over in a `foreach` statement or a direct call to its `IEnumerator.MoveNext` method.</span></span>

<span data-ttu-id="f0bd3-144">下面的代码示例演示一个简单查询表达式，它具有一个数据源、一个筛选子句、一个排序子句并且不转换源元素。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-144">The following code example shows a simple query expression with one data source, one filtering clause, one ordering clause, and no transformation of the source elements.</span></span> <span data-ttu-id="f0bd3-145">该查询以 `select` 子句结尾。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-145">The `select` clause ends the query.</span></span>

[!code-csharp[csrefQueryExpBasics#49](~/samples/snippets/csharp/concepts/linq/query-expression-basics_5.cs)]

<span data-ttu-id="f0bd3-146">在上面的示例中，`scoreQuery` 是查询变量  ，它有时仅仅称为查询  。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-146">In the previous example, `scoreQuery` is a *query variable,* which is sometimes referred to as just a *query*.</span></span> <span data-ttu-id="f0bd3-147">查询变量不存储在 `foreach` 循环生成中的任何实际结果数据。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-147">The query variable stores no actual result data, which is produced in the `foreach` loop.</span></span> <span data-ttu-id="f0bd3-148">并且当 `foreach` 语句执行时，查询结果不会通过查询变量 `scoreQuery` 返回。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-148">And when the `foreach` statement executes, the query results are not returned through the query variable `scoreQuery`.</span></span> <span data-ttu-id="f0bd3-149">而是通过迭代变量 `testScore` 返回。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-149">Rather, they are returned through the iteration variable `testScore`.</span></span> <span data-ttu-id="f0bd3-150">`scoreQuery` 变量可以在另一个 `foreach` 循环中进行循环访问。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-150">The `scoreQuery` variable can be iterated in a second `foreach` loop.</span></span> <span data-ttu-id="f0bd3-151">只要既没有修改它，也没有修改数据源，便会生成相同结果。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-151">It will produce the same results as long as neither it nor the data source has been modified.</span></span>

<span data-ttu-id="f0bd3-152">查询变量可以存储采用查询语法、方法语法或是两者的组合进行表示的查询。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-152">A query variable may store a query that is expressed in query syntax or method syntax, or a combination of the two.</span></span> <span data-ttu-id="f0bd3-153">在以下示例中，`queryMajorCities` 和 `queryMajorCities2` 都是查询变量：</span><span class="sxs-lookup"><span data-stu-id="f0bd3-153">In the following examples, both `queryMajorCities` and `queryMajorCities2` are query variables:</span></span>

[!code-csharp[csrefQueryExpBasics#50](~/samples/snippets/csharp/concepts/linq/query-expression-basics_6.cs)]

<span data-ttu-id="f0bd3-154">另一方面，以下两个示例演示不是查询变量的变量（即使各自使用查询进行初始化）。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-154">On the other hand, the following two examples show variables that are not query variables even though each is initialized with a query.</span></span> <span data-ttu-id="f0bd3-155">它们不是查询变量，因为它们存储结果：</span><span class="sxs-lookup"><span data-stu-id="f0bd3-155">They are not query variables because they store results:</span></span>

[!code-csharp[csrefQueryExpBasics#51](~/samples/snippets/csharp/concepts/linq/query-expression-basics_7.cs)]

<span data-ttu-id="f0bd3-156">有关表示查询的不同方式的详细信息，请参阅 [LINQ 中的查询语法和方法语法](../programming-guide/concepts/linq/query-syntax-and-method-syntax-in-linq.md)。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-156">For more information about the different ways to express queries, see [Query syntax and method syntax in LINQ](../programming-guide/concepts/linq/query-syntax-and-method-syntax-in-linq.md).</span></span>

#### <a name="explicit-and-implicit-typing-of-query-variables"></a><span data-ttu-id="f0bd3-157">查询变量的显式和隐式类型化</span><span class="sxs-lookup"><span data-stu-id="f0bd3-157">Explicit and implicit typing of query variables</span></span>

<span data-ttu-id="f0bd3-158">本文档通常提供查询变量的显式类型以便显示查询变量与 [select 子句](../language-reference/keywords/select-clause.md)之间的类型关系。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-158">This documentation usually provides the explicit type of the query variable in order to show the type relationship between the query variable and the [select clause](../language-reference/keywords/select-clause.md).</span></span> <span data-ttu-id="f0bd3-159">但是，还可以使用 [var](../language-reference/keywords/var.md) 关键字指示编译器在编译时推断查询变量（或任何其他局部变量）的类型。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-159">However, you can also use the [var](../language-reference/keywords/var.md) keyword to instruct the compiler to infer the type of a query variable (or any other local variable) at compile time.</span></span> <span data-ttu-id="f0bd3-160">例如，本主题中前面演示的查询示例也可以使用隐式类型化进行表示：</span><span class="sxs-lookup"><span data-stu-id="f0bd3-160">For example, the query example that was shown previously in this topic can also be expressed by using implicit typing:</span></span>

[!code-csharp[csrefQueryExpBasics#52](~/samples/snippets/csharp/concepts/linq/query-expression-basics_8.cs)]

<span data-ttu-id="f0bd3-161">有关详细信息，请参阅[隐式类型化局部变量](../programming-guide/classes-and-structs/implicitly-typed-local-variables.md)和 [LINQ 查询操作中的类型关系](../programming-guide/concepts/linq/type-relationships-in-linq-query-operations.md)。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-161">For more information, see [Implicitly typed local variables](../programming-guide/classes-and-structs/implicitly-typed-local-variables.md) and [Type relationships in LINQ query operations](../programming-guide/concepts/linq/type-relationships-in-linq-query-operations.md).</span></span>

### <a name="starting-a-query-expression"></a><span data-ttu-id="f0bd3-162">开始查询表达式</span><span class="sxs-lookup"><span data-stu-id="f0bd3-162">Starting a query expression</span></span>

<span data-ttu-id="f0bd3-163">查询表达式必须以 `from` 子句开头。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-163">A query expression must begin with a `from` clause.</span></span> <span data-ttu-id="f0bd3-164">它指定数据源以及范围变量。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-164">It specifies a data source together with a range variable.</span></span> <span data-ttu-id="f0bd3-165">范围变量表示遍历源序列时，源序列中的每个连续元素。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-165">The range variable represents each successive element in the source sequence as the source sequence is being traversed.</span></span> <span data-ttu-id="f0bd3-166">范围变量基于数据源中元素的类型进行强类型化。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-166">The range variable is strongly typed based on the type of elements in the data source.</span></span> <span data-ttu-id="f0bd3-167">在下面的示例中，因为 `countries` 是 `Country` 对象的数组，所以范围变量也类型化为 `Country`。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-167">In the following example, because `countries` is an array of `Country` objects, the range variable is also typed as `Country`.</span></span> <span data-ttu-id="f0bd3-168">因为范围变量是强类型，所以可以使用点运算符访问该类型的任何可用成员。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-168">Because the range variable is strongly typed, you can use the dot operator to access any available members of the type.</span></span>

[!code-csharp[csrefQueryExpBasics#53](~/samples/snippets/csharp/concepts/linq/query-expression-basics_9.cs)]

<span data-ttu-id="f0bd3-169">范围变量一直处于范围中，直到查询使用分号或 continuation  子句退出。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-169">The range variable is in scope until the query is exited either with a semicolon or with a *continuation* clause.</span></span>

<span data-ttu-id="f0bd3-170">查询表达式可能会包含多个 `from` 子句。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-170">A query expression may contain multiple `from` clauses.</span></span> <span data-ttu-id="f0bd3-171">在源序列中的每个元素本身是集合或包含集合时，可使用其他 `from` 子句。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-171">Use additional `from` clauses when each element in the source sequence is itself a collection or contains a collection.</span></span> <span data-ttu-id="f0bd3-172">例如，假设具有 `Country` 对象的集合，其中每个对象都包含名为 `Cities` 的 `City` 对象集合。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-172">For example, assume that you have a collection of `Country` objects, each of which contains a collection of `City` objects named `Cities`.</span></span> <span data-ttu-id="f0bd3-173">若要查询每个 `Country` 中的 `City` 对象，请使用两个 `from` 子句，如下所示：</span><span class="sxs-lookup"><span data-stu-id="f0bd3-173">To query the `City` objects in each `Country`, use two `from` clauses as shown here:</span></span>

[!code-csharp[csrefQueryExpBasics#54](~/samples/snippets/csharp/concepts/linq/query-expression-basics_10.cs)]

<span data-ttu-id="f0bd3-174">有关详细信息，请参阅 [from 子句](../language-reference/keywords/from-clause.md)。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-174">For more information, see [from clause](../language-reference/keywords/from-clause.md).</span></span>

### <a name="ending-a-query-expression"></a><span data-ttu-id="f0bd3-175">结束查询表达式</span><span class="sxs-lookup"><span data-stu-id="f0bd3-175">Ending a query expression</span></span>

<span data-ttu-id="f0bd3-176">查询表达式必须以 `group` 子句或 `select` 子句结尾。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-176">A query expression must end with either a `group` clause or a `select` clause.</span></span>

#### <a name="group-clause"></a><span data-ttu-id="f0bd3-177">group 子句</span><span class="sxs-lookup"><span data-stu-id="f0bd3-177">group clause</span></span>

<span data-ttu-id="f0bd3-178">使用 `group` 子句可生成按指定键组织的组的序列。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-178">Use the `group` clause to produce a sequence of groups organized by a key that you specify.</span></span> <span data-ttu-id="f0bd3-179">键可以是任何数据类型。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-179">The key can be any data type.</span></span> <span data-ttu-id="f0bd3-180">例如，下面的查询会创建包含一个或多个 `Country` 对象并且其键是 `char` 值的组的序列。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-180">For example, the following query creates a sequence of groups that contains one or more `Country` objects and whose key is a `char` value.</span></span>

[!code-csharp[csrefQueryExpBasics#55](~/samples/snippets/csharp/concepts/linq/query-expression-basics_11.cs)]

<span data-ttu-id="f0bd3-181">有关分组的详细信息，请参阅 [group 子句](../language-reference/keywords/group-clause.md)。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-181">For more information about grouping, see [group clause](../language-reference/keywords/group-clause.md).</span></span>

#### <a name="select-clause"></a><span data-ttu-id="f0bd3-182">select 子句</span><span class="sxs-lookup"><span data-stu-id="f0bd3-182">select clause</span></span>

<span data-ttu-id="f0bd3-183">使用 `select` 子句可生成所有其他类型的序列。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-183">Use the `select` clause to produce all other types of sequences.</span></span> <span data-ttu-id="f0bd3-184">简单 `select` 子句只生成类型与数据源中包含的对象相同的对象的序列。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-184">A simple `select` clause just produces a sequence of the same type of objects as the objects that are contained in the data source.</span></span> <span data-ttu-id="f0bd3-185">在此示例中，数据源包含 `Country` 对象。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-185">In this example, the data source contains `Country` objects.</span></span> <span data-ttu-id="f0bd3-186">`orderby` 子句只按新顺序对元素进行排序，而 `select` 子句生成重新排序的 `Country` 对象的序列。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-186">The `orderby` clause just sorts the elements into a new order and the `select` clause produces a sequence of the reordered `Country` objects.</span></span>

[!code-csharp[csrefQueryExpBasics#56](~/samples/snippets/csharp/concepts/linq/query-expression-basics_12.cs)]

<span data-ttu-id="f0bd3-187">`select` 子句可以用于将源数据转换为新类型的序列。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-187">The `select` clause can be used to transform source data into sequences of new types.</span></span> <span data-ttu-id="f0bd3-188">此转换也称为投影  。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-188">This transformation is also named a *projection*.</span></span> <span data-ttu-id="f0bd3-189">在下面的示例中，`select` 子句对只包含原始元素中的字段子集的匿名类型序列进行投影  。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-189">In the following example, the `select` clause *projects* a sequence of anonymous types which contains only a subset of the fields in the original element.</span></span> <span data-ttu-id="f0bd3-190">请注意，新对象使用对象初始值设定项进行初始化。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-190">Note that the new objects are initialized by using an object initializer.</span></span>

[!code-csharp[csrefQueryExpBasics#57](~/samples/snippets/csharp/concepts/linq/query-expression-basics_13.cs)]

<span data-ttu-id="f0bd3-191">有关可以使用 `select` 子句转换源数据的所有方法的详细信息，请参阅 [select 子句](../language-reference/keywords/select-clause.md)。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-191">For more information about all the ways that a `select` clause can be used to transform source data, see [select clause](../language-reference/keywords/select-clause.md).</span></span>

#### <a name="continuations-with-into"></a><span data-ttu-id="f0bd3-192">使用“into”进行延续</span><span class="sxs-lookup"><span data-stu-id="f0bd3-192">Continuations with "into"</span></span>

<span data-ttu-id="f0bd3-193">可以在 `select` 或 `group` 子句中使用 `into` 关键字创建存储查询的临时标识符。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-193">You can use the `into` keyword in a `select` or `group` clause to create a temporary identifier that stores a query.</span></span> <span data-ttu-id="f0bd3-194">如果在分组或选择操作之后必须对查询执行其他查询操作，则可以这样做。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-194">Do this when you must perform additional query operations on a query after a grouping or select operation.</span></span> <span data-ttu-id="f0bd3-195">在下面的示例中，`countries` 按 1000 万范围，根据人口进行分组。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-195">In the following example `countries` are grouped according to population in ranges of 10 million.</span></span> <span data-ttu-id="f0bd3-196">创建这些组之后，附加子句会筛选出一些组，然后按升序对组进行排序。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-196">After these groups are created, additional clauses filter out some groups, and then to sort the groups in ascending order.</span></span> <span data-ttu-id="f0bd3-197">若要执行这些附加操作，需要由 `countryGroup` 表示的延续。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-197">To perform those additional operations, the continuation represented by `countryGroup` is required.</span></span>

[!code-csharp[csrefQueryExpBasics#58](~/samples/snippets/csharp/concepts/linq/query-expression-basics_14.cs)]

<span data-ttu-id="f0bd3-198">有关详细信息，请参阅 [into](../language-reference/keywords/into.md)。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-198">For more information, see [into](../language-reference/keywords/into.md).</span></span>

### <a name="filtering-ordering-and-joining"></a><span data-ttu-id="f0bd3-199">筛选、排序和联接</span><span class="sxs-lookup"><span data-stu-id="f0bd3-199">Filtering, ordering, and joining</span></span>

<span data-ttu-id="f0bd3-200">在开头 `from` 子句与结尾 `select` 或 `group` 子句之间，所有其他子句（`where`、`join`、`orderby`、`from`、`let`）都是可选的。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-200">Between the starting `from` clause, and the ending `select` or `group` clause, all other clauses (`where`, `join`, `orderby`, `from`, `let`) are optional.</span></span> <span data-ttu-id="f0bd3-201">任何可选子句都可以在查询正文中使用零次或多次。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-201">Any of the optional clauses may be used zero times or multiple times in a query body.</span></span>

#### <a name="where-clause"></a><span data-ttu-id="f0bd3-202">where 子句</span><span class="sxs-lookup"><span data-stu-id="f0bd3-202">where clause</span></span>

<span data-ttu-id="f0bd3-203">使用 `where` 子句可基于一个或多个谓词表达式，从源数据中筛选出元素。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-203">Use the `where` clause to filter out elements from the source data based on one or more predicate expressions.</span></span> <span data-ttu-id="f0bd3-204">以下示例中的 `where` 子句具有一个谓词及两个条件。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-204">The `where` clause in the following example has one predicate with two conditions.</span></span>

[!code-csharp[csrefQueryExpBasics#59](~/samples/snippets/csharp/concepts/linq/query-expression-basics_15.cs)]

<span data-ttu-id="f0bd3-205">有关详细信息，请参阅 [where 子句](../language-reference/keywords/where-clause.md)。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-205">For more information, see [where clause](../language-reference/keywords/where-clause.md).</span></span>

#### <a name="orderby-clause"></a><span data-ttu-id="f0bd3-206">orderby 子句</span><span class="sxs-lookup"><span data-stu-id="f0bd3-206">orderby clause</span></span>

<span data-ttu-id="f0bd3-207">使用 `orderby` 子句可按升序或降序对结果进行排序。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-207">Use the `orderby` clause to sort the results in either ascending or descending order.</span></span> <span data-ttu-id="f0bd3-208">还可以指定次要排序顺序。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-208">You can also specify secondary sort orders.</span></span> <span data-ttu-id="f0bd3-209">下面的示例使用 `Area` 属性对 `country` 对象执行主要排序。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-209">The following example performs a primary sort on the `country` objects by using the `Area` property.</span></span> <span data-ttu-id="f0bd3-210">然后使用 `Population` 属性执行次要排序。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-210">It then performs a secondary sort by using the `Population` property.</span></span>

[!code-csharp[csrefQueryExpBasics#60](~/samples/snippets/csharp/concepts/linq/query-expression-basics_16.cs)]

<span data-ttu-id="f0bd3-211">`ascending` 关键字是可选的；如果未指定任何顺序，则它是默认排序顺序。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-211">The `ascending` keyword is optional; it is the default sort order if no order is specified.</span></span> <span data-ttu-id="f0bd3-212">有关详细信息，请参阅 [orderby 子句](../language-reference/keywords/orderby-clause.md)。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-212">For more information, see [orderby clause](../language-reference/keywords/orderby-clause.md).</span></span>

#### <a name="join-clause"></a><span data-ttu-id="f0bd3-213">join 子句</span><span class="sxs-lookup"><span data-stu-id="f0bd3-213">join clause</span></span>

<span data-ttu-id="f0bd3-214">使用 `join` 子句可基于每个元素中指定的键之间的相等比较，将一个数据源中的元素与另一个数据源中的元素进行关联和/或合并。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-214">Use the `join` clause to associate and/or combine elements from one data source with elements from another data source based on an equality comparison between specified keys in each element.</span></span> <span data-ttu-id="f0bd3-215">在 LINQ 中，联接操作是对元素属于不同类型的对象序列执行。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-215">In LINQ, join operations are performed on sequences of objects whose elements are different types.</span></span> <span data-ttu-id="f0bd3-216">联接了两个序列之后，必须使用 `select` 或 `group` 语句指定要存储在输出序列中的元素。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-216">After you have joined two sequences, you must use a `select` or `group` statement to specify which element to store in the output sequence.</span></span> <span data-ttu-id="f0bd3-217">还可以使用匿名类型将每组关联元素中的属性合并到输出序列的新类型中。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-217">You can also use an anonymous type to combine properties from each set of associated elements into a new type for the output sequence.</span></span> <span data-ttu-id="f0bd3-218">下面的示例关联其 `Category` 属性与 `categories` 字符串数组中一个类别匹配的 `prod` 对象。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-218">The following example associates `prod` objects whose `Category` property matches one of the categories in the `categories` string array.</span></span> <span data-ttu-id="f0bd3-219">筛选出其 `Category` 不与 `categories` 中的任何字符串匹配的产品。`select` 语句会投影其属性取自 `cat` 和 `prod` 的新类型。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-219">Products whose `Category` does not match any string in `categories` are filtered out. The `select` statement projects a new type whose properties are taken from both `cat` and `prod`.</span></span>

[!code-csharp[csrefQueryExpBasics#61](~/samples/snippets/csharp/concepts/linq/query-expression-basics_17.cs)]

<span data-ttu-id="f0bd3-220">还可以通过使用 [into](../language-reference/keywords/into.md) 关键字将 `join` 操作的结果存储到临时变量中来执行分组联接。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-220">You can also perform a group join by storing the results of the `join` operation into a temporary variable by using the [into](../language-reference/keywords/into.md) keyword.</span></span> <span data-ttu-id="f0bd3-221">有关详细信息，请参阅 [join 子句](../language-reference/keywords/join-clause.md)。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-221">For more information, see [join clause](../language-reference/keywords/join-clause.md).</span></span>

#### <a name="let-clause"></a><span data-ttu-id="f0bd3-222">let 子句</span><span class="sxs-lookup"><span data-stu-id="f0bd3-222">let clause</span></span>

<span data-ttu-id="f0bd3-223">使用 `let` 子句可将表达式（如方法调用）的结果存储在新范围变量中。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-223">Use the `let` clause to store the result of an expression, such as a method call, in a new range variable.</span></span> <span data-ttu-id="f0bd3-224">在下面的示例中，范围变量 `firstName` 存储 `Split` 返回的字符串数组的第一个元素。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-224">In the following example, the range variable `firstName` stores the first element of the array of strings that is returned by `Split`.</span></span>

[!code-csharp[csrefQueryExpBasics#62](~/samples/snippets/csharp/concepts/linq/query-expression-basics_18.cs)]

<span data-ttu-id="f0bd3-225">有关详细信息，请参阅 [let 子句](../language-reference/keywords/let-clause.md)。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-225">For more information, see [let clause](../language-reference/keywords/let-clause.md).</span></span>

### <a name="subqueries-in-a-query-expression"></a><span data-ttu-id="f0bd3-226">查询表达式中的子查询</span><span class="sxs-lookup"><span data-stu-id="f0bd3-226">Subqueries in a query expression</span></span>

<span data-ttu-id="f0bd3-227">查询子句本身可能包含查询表达式，这有时称为子查询  。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-227">A query clause may itself contain a query expression, which is sometimes referred to as a *subquery*.</span></span> <span data-ttu-id="f0bd3-228">每个子查询都以自己的 `from` 子句开头，该子句不一定指向第一个 `from` 子句中的相同数据源。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-228">Each subquery starts with its own `from` clause that does not necessarily point to the same data source in the first `from` clause.</span></span> <span data-ttu-id="f0bd3-229">例如，下面的查询演示在 select 语句用于检索分组操作结果的查询表达式。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-229">For example, the following query shows a query expression that is used in the select statement to retrieve the results of a grouping operation.</span></span>

[!code-csharp[csrefQueryExpBasics#63](~/samples/snippets/csharp/concepts/linq/query-expression-basics_19.cs)]

<span data-ttu-id="f0bd3-230">有关详细信息，请参阅[对分组操作执行子查询](perform-a-subquery-on-a-grouping-operation.md)。</span><span class="sxs-lookup"><span data-stu-id="f0bd3-230">For more information, see [Perform a subquery on a grouping operation](perform-a-subquery-on-a-grouping-operation.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="f0bd3-231">请参阅</span><span class="sxs-lookup"><span data-stu-id="f0bd3-231">See also</span></span>

- [<span data-ttu-id="f0bd3-232">C# 编程指南</span><span class="sxs-lookup"><span data-stu-id="f0bd3-232">C# programming guide</span></span>](../programming-guide/index.md)
- [<span data-ttu-id="f0bd3-233">语言集成查询 (LINQ)</span><span class="sxs-lookup"><span data-stu-id="f0bd3-233">Language Integrated Query (LINQ)</span></span>](index.md)
- [<span data-ttu-id="f0bd3-234">查询关键字 (LINQ)</span><span class="sxs-lookup"><span data-stu-id="f0bd3-234">Query keywords (LINQ)</span></span>](../language-reference/keywords/query-keywords.md)
- [<span data-ttu-id="f0bd3-235">标准查询运算符概述</span><span class="sxs-lookup"><span data-stu-id="f0bd3-235">Standard query operators overview</span></span>](../programming-guide/concepts/linq/standard-query-operators-overview.md)
