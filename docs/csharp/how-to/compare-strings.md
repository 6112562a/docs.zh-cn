---
title: 如何：比较字符串 - C# 指南
description: 了解在区分或不区分大小写以及使用或不使用区域性特定的排序情况下，如何对字符串值进行比较和排序
ms.date: 10/03/2018
helpviewer_keywords:
- strings [C#], comparison
- comparing strings [C#]
ms.openlocfilehash: 479e6d9250c546943da3ddd837f2f03a5c4e7b1e
ms.sourcegitcommit: 6b308cf6d627d78ee36dbbae8972a310ac7fd6c8
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 01/23/2019
ms.locfileid: "54563985"
---
# <a name="how-to-compare-strings-in-c"></a><span data-ttu-id="c3390-103">如何：比较 C\# 中的字符串</span><span class="sxs-lookup"><span data-stu-id="c3390-103">How to compare strings in C\#</span></span>

<span data-ttu-id="c3390-104">通过比较字符串可以回答两个问题，一个是：“这两个字符串相等吗？”</span><span class="sxs-lookup"><span data-stu-id="c3390-104">You compare strings to answer one of two questions: "Are these two strings equal?"</span></span> <span data-ttu-id="c3390-105">另一个是“排序时，应该按什么顺序排列这些字符串？”</span><span class="sxs-lookup"><span data-stu-id="c3390-105">or "In what order should these strings be placed when sorting them?"</span></span>

<span data-ttu-id="c3390-106">这两个问题非常复杂，因为字符串比较受很多因素的影响：</span><span class="sxs-lookup"><span data-stu-id="c3390-106">Those two questions are complicated by factors that affect string comparisons:</span></span>

- <span data-ttu-id="c3390-107">可以选择序号比较或语义比较。</span><span class="sxs-lookup"><span data-stu-id="c3390-107">You can choose an ordinal or linguistic comparison.</span></span>
- <span data-ttu-id="c3390-108">可以选择是否区分大小写。</span><span class="sxs-lookup"><span data-stu-id="c3390-108">You can choose if case matters.</span></span>
- <span data-ttu-id="c3390-109">可以选择区域性特定的比较。</span><span class="sxs-lookup"><span data-stu-id="c3390-109">You can choose culture-specific comparisons.</span></span>
- <span data-ttu-id="c3390-110">语义比较取决于区域性和平台。</span><span class="sxs-lookup"><span data-stu-id="c3390-110">Linguistic comparisons are culture and platform-dependent.</span></span>

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

<span data-ttu-id="c3390-111">在比较字符串时定义它们的顺序。</span><span class="sxs-lookup"><span data-stu-id="c3390-111">When you compare strings, you define an order among them.</span></span> <span data-ttu-id="c3390-112">通过比较决定字符串的序列。</span><span class="sxs-lookup"><span data-stu-id="c3390-112">Comparisons are used to sort a sequence of strings.</span></span> <span data-ttu-id="c3390-113">确定序列顺序后，软件和人工都可以更轻松地进行搜索。</span><span class="sxs-lookup"><span data-stu-id="c3390-113">Once the sequence is in a known order, it is easier to search, both for software and for humans.</span></span> <span data-ttu-id="c3390-114">其他比较可能会检查字符串是否相同。</span><span class="sxs-lookup"><span data-stu-id="c3390-114">Other comparisons may check if strings are the same.</span></span> <span data-ttu-id="c3390-115">这种一致性检查与相等性检查类似，但是也有一些不同之处，例如可能会忽略大小写的差异。</span><span class="sxs-lookup"><span data-stu-id="c3390-115">These sameness checks are similar to equality, but some differences, such as case differences, may be ignored.</span></span>

## <a name="default-ordinal-comparisons"></a><span data-ttu-id="c3390-116">默认的序号比较</span><span class="sxs-lookup"><span data-stu-id="c3390-116">Default ordinal comparisons</span></span>

<span data-ttu-id="c3390-117">最常见的操作：</span><span class="sxs-lookup"><span data-stu-id="c3390-117">The most common operations:</span></span>

- <xref:System.String.CompareTo%2A?displayProperty=nameWithType>
- <xref:System.String.Equals%2A?displayProperty=nameWithType>
- <xref:System.String.op_Equality%2A?displayProperty=nameWithType> 

<span data-ttu-id="c3390-118">使用序号比较（一种区分大小写的比较）并使用当前区域性。</span><span class="sxs-lookup"><span data-stu-id="c3390-118">use an ordinal comparison, a case-sensitive comparison, and use the current culture.</span></span> <span data-ttu-id="c3390-119">结果如下例所示：</span><span class="sxs-lookup"><span data-stu-id="c3390-119">The results are shown in the following example:</span></span>

[!code-csharp-interactive[Comparing strings using an ordinal comparison](../../../samples/snippets/csharp/how-to/strings/CompareStrings.cs#1)]

<span data-ttu-id="c3390-120">默认序号比较在比较字符串时不会考虑语义规则。</span><span class="sxs-lookup"><span data-stu-id="c3390-120">The default ordinal comparison does not take linguistic rules into account when comparing strings.</span></span> <span data-ttu-id="c3390-121">它会比较两个字符串中每个 <xref:System.Char> 对象的二进制值。</span><span class="sxs-lookup"><span data-stu-id="c3390-121">It compares the binary value of each <xref:System.Char> object in two strings.</span></span> <span data-ttu-id="c3390-122">因此，默认的序号比较也是区分大小写的。</span><span class="sxs-lookup"><span data-stu-id="c3390-122">As a result, the default ordinal comparison is also case-sensitive.</span></span> 

<span data-ttu-id="c3390-123">请注意，使用 <xref:System.String.Equals%2A?displayProperty=nameWithType> 和 <xref:System.String.op_Equality%2A?displayProperty=nameWithType> 的相等性测试不同于使用 <xref:System.String.CompareTo%2A?displayProperty=nameWithType> 和 <xref:System.String.Compare(System.String,System.String)?displayProperty=nameWithType)> 方法的字符串比较。</span><span class="sxs-lookup"><span data-stu-id="c3390-123">Note that the test for equality with <xref:System.String.Equals%2A?displayProperty=nameWithType> and <xref:System.String.op_Equality%2A?displayProperty=nameWithType> differs from string comparison using the <xref:System.String.CompareTo%2A?displayProperty=nameWithType> and <xref:System.String.Compare(System.String,System.String)?displayProperty=nameWithType)> methods.</span></span> <span data-ttu-id="c3390-124">虽然相等性测试执行区分大小写的序号比较，但比较方法使用当前区域性执行区分大小写、区分区域性的比较。</span><span class="sxs-lookup"><span data-stu-id="c3390-124">While the tests for equality perform a case-sensitive ordinal comparison, the comparison method perform a case-sensitive, culture-sensitive comparison using the current culture.</span></span> <span data-ttu-id="c3390-125">由于默认比较方法通常执行不同类型的比较，因此建议始终调用显式指定要执行的比较类型的重载，确保代码意图明确。</span><span class="sxs-lookup"><span data-stu-id="c3390-125">Because the default comparison methods often perform different types of comparisons, we recommend that you always make the intent of your code clear by calling an overload that explicitly specifies the type of comparison to perform.</span></span>

## <a name="case-insensitive-ordinal-comparisons"></a><span data-ttu-id="c3390-126">不区分大小写的序号比较</span><span class="sxs-lookup"><span data-stu-id="c3390-126">Case-insensitive ordinal comparisons</span></span>

<span data-ttu-id="c3390-127"><xref:System.String.Equals(System.String,System.StringComparison)?displayProperty=nameWithType> 方法允许指定 <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> 的 <xref:System.StringComparison> 值</span><span class="sxs-lookup"><span data-stu-id="c3390-127">The <xref:System.String.Equals(System.String,System.StringComparison)?displayProperty=nameWithType> method enables you to specify a <xref:System.StringComparison> value of <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType></span></span>
<span data-ttu-id="c3390-128">对于不区分大小写的序号比较。</span><span class="sxs-lookup"><span data-stu-id="c3390-128">for a case-insensitive ordinal comparison.</span></span> <span data-ttu-id="c3390-129">此外还有静态 <xref:System.String.Compare(System.String,System.String,System.StringComparison)?displayProperty=nameWithType> 方法，该方法执行不区分大小写的序号比较，前提是你指定 <xref:System.StringComparison> 参数的 <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> 值。</span><span class="sxs-lookup"><span data-stu-id="c3390-129">There is also a static <xref:System.String.Compare(System.String,System.String,System.StringComparison)?displayProperty=nameWithType> method that performs a case-insensitive ordinal comparison if you specify a value of <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> for the <xref:System.StringComparison> argument.</span></span> <span data-ttu-id="c3390-130">如以下代码所示：</span><span class="sxs-lookup"><span data-stu-id="c3390-130">These are shown in the following code:</span></span>

[!code-csharp-interactive[Comparing strings ignoring case](../../../samples/snippets/csharp/how-to/strings/CompareStrings.cs#2)]

<span data-ttu-id="c3390-131">执行不区分大小写的序号比较时，这些方法使用[固定区域性](xref:System.Globalization.CultureInfo.InvariantCulture)的大小写约定。</span><span class="sxs-lookup"><span data-stu-id="c3390-131">When performing a case-insensitive ordinal comparison, these methods use the casing conventions of the [invariant culture](xref:System.Globalization.CultureInfo.InvariantCulture).</span></span>

## <a name="linguistic-comparisons"></a><span data-ttu-id="c3390-132">语义比较</span><span class="sxs-lookup"><span data-stu-id="c3390-132">Linguistic comparisons</span></span>

<span data-ttu-id="c3390-133">可以使用当前区域性的语义规则来对字符串进行排序。</span><span class="sxs-lookup"><span data-stu-id="c3390-133">Strings can also be ordered using linguistic rules for the current culture.</span></span>
<span data-ttu-id="c3390-134">这有时被称为“文字排序顺序”。</span><span class="sxs-lookup"><span data-stu-id="c3390-134">This is sometimes referred to as "word sort order."</span></span> <span data-ttu-id="c3390-135">在执行语义比较时，一些非字母数字的 Unicode 字符可能分配有特殊的权重。</span><span class="sxs-lookup"><span data-stu-id="c3390-135">When you perform a linguistic comparison, some nonalphanumeric Unicode characters might have special weights assigned.</span></span> <span data-ttu-id="c3390-136">例如，连字符“-”分配的权重可能很小，所以“co-op”和“coop”在排序顺序中会彼此相邻。</span><span class="sxs-lookup"><span data-stu-id="c3390-136">For example, the hyphen "-" may have a very small weight assigned to it so that "co-op" and "coop" appear next to each other in sort order.</span></span> <span data-ttu-id="c3390-137">此外，一些 Unicode 字符可能与一系列 <xref:System.Char> 实例等效。</span><span class="sxs-lookup"><span data-stu-id="c3390-137">In addition, some Unicode characters may be equivalent to a sequence of <xref:System.Char> instances.</span></span> <span data-ttu-id="c3390-138">下面以德语短句“他们在街上跳舞。”为例，</span><span class="sxs-lookup"><span data-stu-id="c3390-138">The following example uses the phrase "They dance in the street."</span></span> <span data-ttu-id="c3390-139">在德语中，一个字符串中有“ss”(U+0073 U+0073)，另一个字符串中有“ß”(U+00DF)。</span><span class="sxs-lookup"><span data-stu-id="c3390-139">in German with the "ss" (U+0073 U+0073) in one string and 'ß' (U+00DF) in another.</span></span> <span data-ttu-id="c3390-140">（在 Windows 系统中）从语义上说，“ss”在“en-US”和“de-DE”区域性中都等同于德语中的“'ß”。</span><span class="sxs-lookup"><span data-stu-id="c3390-140">Linguistically (in Windows), "ss" is equal to the German Essetz: 'ß' character in both the "en-US" and "de-DE" cultures.</span></span>

[!code-csharp-interactive[Comparing strings using linguistic rules](../../../samples/snippets/csharp/how-to/strings/CompareStrings.cs#3)]

<span data-ttu-id="c3390-141">此示例说明了语义比较是依赖于操作系统的。</span><span class="sxs-lookup"><span data-stu-id="c3390-141">This sample demonstrates the operating system-dependent nature of linguistic comparisons.</span></span> <span data-ttu-id="c3390-142">交互式窗口的主机为 Linux 主机。</span><span class="sxs-lookup"><span data-stu-id="c3390-142">The host for the interactive window is a Linux host.</span></span> <span data-ttu-id="c3390-143">语义比较和序号比较的结果是一样的。</span><span class="sxs-lookup"><span data-stu-id="c3390-143">The linguistic and ordinal comparisons produce the same results.</span></span> <span data-ttu-id="c3390-144">如果在 Windows 主机上运行同样的示例，会看到如下输出内容：</span><span class="sxs-lookup"><span data-stu-id="c3390-144">If you ran this same sample on a Windows host, you would see the following output:</span></span>

```console
<coop> is less than <co-op> using invariant culture
<coop> is greater than <co-op> using ordinal comparison
<coop> is less than <cop> using invariant culture
<coop> is less than <cop> using ordinal comparison
<co-op> is less than <cop> using invariant culture
<co-op> is less than <cop> using ordinal comparison
```

<span data-ttu-id="c3390-145">在 Windows 上，从语义比较改为序号比较时，“cop”、“coop”和“co-op”的排序顺序产生了变化。</span><span class="sxs-lookup"><span data-stu-id="c3390-145">On Windows, the sort order of "cop", "coop", and "co-op" change when you change from a linguistic comparison to an ordinal comparison.</span></span> <span data-ttu-id="c3390-146">使用不同的比较类型时，这两个德语句子的比较结果也就不同了。</span><span class="sxs-lookup"><span data-stu-id="c3390-146">The two German sentences also compare differently using the different comparison types.</span></span>

## <a name="comparisons-using-specific-cultures"></a><span data-ttu-id="c3390-147">使用特定区域性的比较</span><span class="sxs-lookup"><span data-stu-id="c3390-147">Comparisons using specific cultures</span></span>

<span data-ttu-id="c3390-148">此示例为 en-US 和 de-DE 区域性存储 <xref:System.Globalization.CultureInfo> 对象。</span><span class="sxs-lookup"><span data-stu-id="c3390-148">This sample stores <xref:System.Globalization.CultureInfo> objects for the en-US and de-DE cultures.</span></span>
<span data-ttu-id="c3390-149">使用 <xref:System.Globalization.CultureInfo> 对象执行比较以确保执行的是特定于区域性的比较。</span><span class="sxs-lookup"><span data-stu-id="c3390-149">The comparisons are performed using a <xref:System.Globalization.CultureInfo> object to ensure a culture-specific comparison.</span></span>

<span data-ttu-id="c3390-150">所用的区域性会对语义比较产生影响。</span><span class="sxs-lookup"><span data-stu-id="c3390-150">The culture used affects linguistic comparisons.</span></span> <span data-ttu-id="c3390-151">以下示例展示使用“en-US”区域性和“de-DE”区域性对两个德语句子进行比较的结果：</span><span class="sxs-lookup"><span data-stu-id="c3390-151">The following example shows the results of comparing the two German sentences using the "en-US" culture and the "de-DE" culture:</span></span>

[!code-csharp-interactive[Comparing strings across cultures](../../../samples/snippets/csharp/how-to/strings/CompareStrings.cs#4)]

<span data-ttu-id="c3390-152">区分区域性的比较通常用于对用户输入的字符串以及用户输入的其他字符串进行比较和排序。</span><span class="sxs-lookup"><span data-stu-id="c3390-152">Culture-sensitive comparisons are typically used to compare and sort strings input by users with other strings input by users.</span></span> <span data-ttu-id="c3390-153">字符和这些字符的排序约定可能会根据用户计算机的区域设置而有所不同。</span><span class="sxs-lookup"><span data-stu-id="c3390-153">The characters and sorting conventions of these strings might vary depending on the locale of the user's computer.</span></span> <span data-ttu-id="c3390-154">即使是包含相同字符的字符串，也可能因当前线程的区域性而具有不同的排序。</span><span class="sxs-lookup"><span data-stu-id="c3390-154">Even strings that contain identical characters might sort differently depending on the culture of the current thread.</span></span> <span data-ttu-id="c3390-155">此外，请在本地 Windows 计算机上尝试下列示例代码，将得到下列结果：</span><span class="sxs-lookup"><span data-stu-id="c3390-155">In addition, try this sample code locally on a Windows machine, and you will the following results:</span></span>

```console
<coop> is less than <co-op> using en-US culture
<coop> is greater than <co-op> using ordinal comparison
<coop> is less than <cop> using en-US culture
<coop> is less than <cop> using ordinal comparison
<co-op> is less than <cop> using en-US culture
<co-op> is less than <cop> using ordinal comparison
```

<span data-ttu-id="c3390-156">语义比较取决于当前区域性以及操作系统。</span><span class="sxs-lookup"><span data-stu-id="c3390-156">Linguistic comparisons are dependent on the current culture, and are OS dependent.</span></span> <span data-ttu-id="c3390-157">在进行字符串比较时，需要考虑这些内容。</span><span class="sxs-lookup"><span data-stu-id="c3390-157">You must take that into account when you work with string comparisons.</span></span>

## <a name="linguistic-sorting-and-searching-strings-in-arrays"></a><span data-ttu-id="c3390-158">数组中的语义排序和字符串搜索</span><span class="sxs-lookup"><span data-stu-id="c3390-158">Linguistic sorting and searching strings in arrays</span></span>

<span data-ttu-id="c3390-159">以下示例演示如何在数组中使用依赖当前区域性的语义比较对字符串进行排序和搜索。</span><span class="sxs-lookup"><span data-stu-id="c3390-159">The following examples show how to sort and search for strings in an array using a linguistic comparison dependent on the current culture.</span></span> <span data-ttu-id="c3390-160">使用采用 <xref:System.StringComparer?displayProperty=nameWithType> 参数的静态 <xref:System.Array> 方法。</span><span class="sxs-lookup"><span data-stu-id="c3390-160">You use the static <xref:System.Array> methods that take a <xref:System.StringComparer?displayProperty=nameWithType> parameter.</span></span>

<span data-ttu-id="c3390-161">此示例演示如何使用当前区域性对字符串数组进行排序：</span><span class="sxs-lookup"><span data-stu-id="c3390-161">This example shows how to sort an array of strings using the current culture:</span></span>

[!code-csharp-interactive[Sorting an array of strings](../../../samples/snippets/csharp/how-to/strings/CompareStrings.cs#5)]

<span data-ttu-id="c3390-162">对数组进行排序后，可以使用二分搜索法搜索条目。</span><span class="sxs-lookup"><span data-stu-id="c3390-162">Once the array is sorted, you can search for entries using a binary search.</span></span> <span data-ttu-id="c3390-163">二分搜索法从集合的中间开始搜索，判断集合的哪一半包含所找字符串。</span><span class="sxs-lookup"><span data-stu-id="c3390-163">A binary search starts in the middle of the collection to determine which half of the collection would contain the sought string.</span></span> <span data-ttu-id="c3390-164">后续的每个比较都将集合的剩余部分再次对半分开。</span><span class="sxs-lookup"><span data-stu-id="c3390-164">Each subsequent comparison subdivides the remaining part of the collection in half.</span></span>  <span data-ttu-id="c3390-165">使用 <xref:System.StringComparer.CurrentCulture?displayProperty=nameWithType> 存储数组。</span><span class="sxs-lookup"><span data-stu-id="c3390-165">The array is sorted using the <xref:System.StringComparer.CurrentCulture?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c3390-166">本地函数 `ShowWhere` 显示发现字符串所在位置的信息。</span><span class="sxs-lookup"><span data-stu-id="c3390-166">The local function `ShowWhere` displays information about where the string was found.</span></span> <span data-ttu-id="c3390-167">如果未找到字符串，返回的值会指示它可能会在的位置（如果找到）。</span><span class="sxs-lookup"><span data-stu-id="c3390-167">If the string was not found, the returned value indicates where it would be if it were found.</span></span>

[!code-csharp-interactive[Searching in a sorted array](../../../samples/snippets/csharp/how-to/strings/CompareStrings.cs#6)]

## <a name="ordinal-sorting-and-searching-in-collections"></a><span data-ttu-id="c3390-168">集合中的序号排序和搜索</span><span class="sxs-lookup"><span data-stu-id="c3390-168">Ordinal sorting and searching in collections</span></span>

<span data-ttu-id="c3390-169">以下代码使用 <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> 集合类存储字符串。</span><span class="sxs-lookup"><span data-stu-id="c3390-169">The following code uses the <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> collection class to store strings.</span></span> <span data-ttu-id="c3390-170">字符串是通过 <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType> 方法排序的。</span><span class="sxs-lookup"><span data-stu-id="c3390-170">The strings are sorted using the <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c3390-171">此方法需要对两个字符串进行比较和排序的委托。</span><span class="sxs-lookup"><span data-stu-id="c3390-171">This method needs a delegate that compares and orders two strings.</span></span> <span data-ttu-id="c3390-172"><xref:System.String.CompareTo%2A?displayProperty=nameWithType> 方法提供该比较函数。</span><span class="sxs-lookup"><span data-stu-id="c3390-172">The <xref:System.String.CompareTo%2A?displayProperty=nameWithType> method provides that comparison function.</span></span> <span data-ttu-id="c3390-173">请运行示例并观察顺序。</span><span class="sxs-lookup"><span data-stu-id="c3390-173">Run the sample and observe the order.</span></span> <span data-ttu-id="c3390-174">此排序操作使用区分大小写的序号排序。</span><span class="sxs-lookup"><span data-stu-id="c3390-174">This sort operation uses an ordinal case sensitive sort.</span></span> <span data-ttu-id="c3390-175">你要使用静态 <xref:System.String.Compare%2A?displayProperty=nameWithType> 方法指定不同的比较规则。</span><span class="sxs-lookup"><span data-stu-id="c3390-175">You would use the static <xref:System.String.Compare%2A?displayProperty=nameWithType> methods to specify different comparison rules.</span></span>

[!code-csharp-interactive[Sorting a list of strings](../../../samples/snippets/csharp/how-to/strings/CompareStrings.cs#7)]

<span data-ttu-id="c3390-176">排序后，可以使用二分搜索法对字符串列表进行搜索。</span><span class="sxs-lookup"><span data-stu-id="c3390-176">Once sorted, the list of strings can be searched using a binary search.</span></span> <span data-ttu-id="c3390-177">以下示例演示如何使用相同的比较函数搜索排序列表。</span><span class="sxs-lookup"><span data-stu-id="c3390-177">The following sample shows how to search the sorted listed using the same comparison function.</span></span> <span data-ttu-id="c3390-178">本地函数 `ShowWhere` 显示所查找的文本所在的位置或可能会在位置：</span><span class="sxs-lookup"><span data-stu-id="c3390-178">The local function `ShowWhere` shows where the sought text is or would be:</span></span>

[!code-csharp-interactive[csProgGuideStrings#11](../../../samples/snippets/csharp/how-to/strings/CompareStrings.cs#8)]

<span data-ttu-id="c3390-179">在排序和搜索过程中，请始终确保使用相同的比较类型。</span><span class="sxs-lookup"><span data-stu-id="c3390-179">Always make sure to use the same type of comparison for sorting and searching.</span></span> <span data-ttu-id="c3390-180">使用不同的比较类型进行排序和搜索会产生意外的结果。</span><span class="sxs-lookup"><span data-stu-id="c3390-180">Using different comparison types for sorting and searching produces unexpected results.</span></span>

<span data-ttu-id="c3390-181">元素或键的类型为 `string` 时，<xref:System.Collections.Hashtable?displayProperty=nameWithType>、<xref:System.Collections.Generic.Dictionary%602?displayProperty=nameWithType> 和 <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> 等集合类的构造函数具有 <xref:System.StringComparer?displayProperty=nameWithType> 参数。</span><span class="sxs-lookup"><span data-stu-id="c3390-181">Collection classes such as <xref:System.Collections.Hashtable?displayProperty=nameWithType>, <xref:System.Collections.Generic.Dictionary%602?displayProperty=nameWithType>, and <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> have constructors that take a <xref:System.StringComparer?displayProperty=nameWithType> parameter when the type of the elements or keys is `string`.</span></span> <span data-ttu-id="c3390-182">通常，应尽可能使用这些构造函数，并指定 <xref:System.StringComparer.Ordinal?displayProperty=nameWithType> 或 <xref:System.StringComparer.OrdinalIgnoreCase?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="c3390-182">In general, you should use these constructors whenever possible, and specify either <xref:System.StringComparer.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparer.OrdinalIgnoreCase?displayProperty=nameWithType>.</span></span>

## <a name="reference-equality-and-string-interning"></a><span data-ttu-id="c3390-183">引用相等性和字符串集中</span><span class="sxs-lookup"><span data-stu-id="c3390-183">Reference equality and string interning</span></span>

<span data-ttu-id="c3390-184">这些示例都没有使用 <xref:System.Object.ReferenceEquals%2A>。</span><span class="sxs-lookup"><span data-stu-id="c3390-184">None of the samples have used <xref:System.Object.ReferenceEquals%2A>.</span></span> <span data-ttu-id="c3390-185">此方法确定两个字符串是否为相同的对象。</span><span class="sxs-lookup"><span data-stu-id="c3390-185">This method determines if two strings are the same object.</span></span> <span data-ttu-id="c3390-186">这可能会在字符串比较中产生不一致的结果。</span><span class="sxs-lookup"><span data-stu-id="c3390-186">This can lead to inconsistent results in string comparisons.</span></span> <span data-ttu-id="c3390-187">以下示例演示了 C# 中的字符串集中功能。</span><span class="sxs-lookup"><span data-stu-id="c3390-187">The following example demonstrates the *string interning* feature of C#.</span></span> <span data-ttu-id="c3390-188">如果程序声明了 2 个或多个相同的字符串变量，则编译器会将其存储在同一位置。</span><span class="sxs-lookup"><span data-stu-id="c3390-188">When a program declares two or more identical string variables, the compiler stores them all in the same location.</span></span> <span data-ttu-id="c3390-189">通过调用 <xref:System.Object.ReferenceEquals%2A> 方法，可以看到这两个字符串实际上引用的是内存中的同一对象。</span><span class="sxs-lookup"><span data-stu-id="c3390-189">By calling the <xref:System.Object.ReferenceEquals%2A> method, you can see that the two strings actually refer to the same object in memory.</span></span> <span data-ttu-id="c3390-190">使用 <xref:System.String.Copy%2A?displayProperty=nameWithType> 方法可避免集中。</span><span class="sxs-lookup"><span data-stu-id="c3390-190">Use the <xref:System.String.Copy%2A?displayProperty=nameWithType> method to avoid interning.</span></span> <span data-ttu-id="c3390-191">创建副本后，两个字符串存储在不同位置（即使它们具有相同的值）。</span><span class="sxs-lookup"><span data-stu-id="c3390-191">After the copy has been made, the two strings have different storage locations, even though they have the same value.</span></span> <span data-ttu-id="c3390-192">运行下列示例以显示字符串 `a` 和 `b` 是集中的，也就是说它们共享相同的存储。</span><span class="sxs-lookup"><span data-stu-id="c3390-192">Run the following sample to show that strings `a` and `b` are *interned* meaning they share the same storage.</span></span> <span data-ttu-id="c3390-193">字符串 `a` 和 `c` 不是。</span><span class="sxs-lookup"><span data-stu-id="c3390-193">The strings `a` and `c` are not.</span></span>

[!code-csharp-interactive[Demonstrating string interning](../../../samples/snippets/csharp/how-to/strings/CompareStrings.cs#9)]

> [!NOTE]
> <span data-ttu-id="c3390-194">测试字符串是否相等时，使用的方法应显式指定要执行的比较类型。</span><span class="sxs-lookup"><span data-stu-id="c3390-194">When you test for equality of strings, you should use the methods that explicitly specify what kind of comparison you intend to perform.</span></span> <span data-ttu-id="c3390-195">你的代码具备更强的可维护性和可读性。</span><span class="sxs-lookup"><span data-stu-id="c3390-195">Your code is much more maintainable and readable.</span></span> <span data-ttu-id="c3390-196">重载采用了 <xref:System.StringComparison> 枚举参数的 <xref:System.String?displayProperty=nameWithType> 和 <xref:System.Array?displayProperty=nameWithType> 类的方法。</span><span class="sxs-lookup"><span data-stu-id="c3390-196">Use the overloads of the methods of the <xref:System.String?displayProperty=nameWithType> and <xref:System.Array?displayProperty=nameWithType> classes that take a <xref:System.StringComparison> enumeration parameter.</span></span> <span data-ttu-id="c3390-197">指定要执行的比较类型。</span><span class="sxs-lookup"><span data-stu-id="c3390-197">You specify which type of comparison to perform.</span></span> <span data-ttu-id="c3390-198">在测试相等性时，请避免使用 `==` 和 `!=` 运算符。</span><span class="sxs-lookup"><span data-stu-id="c3390-198">Avoid using the `==` and `!=` operators when you test for equality.</span></span> <span data-ttu-id="c3390-199"><xref:System.String.CompareTo%2A?displayProperty=nameWithType> 实例方法始终执行区分大小写的序号比较。</span><span class="sxs-lookup"><span data-stu-id="c3390-199">The <xref:System.String.CompareTo%2A?displayProperty=nameWithType> instance methods always perform an ordinal case-sensitive comparison.</span></span> <span data-ttu-id="c3390-200">它们主要适用于按字母顺序进行的字符串排序。</span><span class="sxs-lookup"><span data-stu-id="c3390-200">They are primarily suited for ordering strings alphabetically.</span></span>

<span data-ttu-id="c3390-201">可以通过调用 <xref:System.String.Intern%2A?displayProperty=nameWithType> 方法暂存字符串或检索对现有暂存字符串的引用。</span><span class="sxs-lookup"><span data-stu-id="c3390-201">You can intern a string or retrieve a reference to an existing interned string by calling the <xref:System.String.Intern%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c3390-202">要确定字符串是否暂存，请调用 <xref:System.String.IsInterned%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="c3390-202">To determine whether a string is interned, call the <xref:System.String.IsInterned%2A?displayProperty=nameWithType> method.</span></span>

## <a name="see-also"></a><span data-ttu-id="c3390-203">请参阅</span><span class="sxs-lookup"><span data-stu-id="c3390-203">See also</span></span>

- <xref:System.Globalization.CultureInfo?displayProperty=nameWithType>
- <xref:System.StringComparer?displayProperty=nameWithType>
- [<span data-ttu-id="c3390-204">字符串</span><span class="sxs-lookup"><span data-stu-id="c3390-204">Strings</span></span>](../programming-guide/strings/index.md)
- [<span data-ttu-id="c3390-205">比较字符串</span><span class="sxs-lookup"><span data-stu-id="c3390-205">Comparing Strings</span></span>](../../standard/base-types/comparing.md)
- [<span data-ttu-id="c3390-206">对应用程序进行全球化和本地化</span><span class="sxs-lookup"><span data-stu-id="c3390-206">Globalizing and Localizing Applications</span></span>](/visualstudio/ide/globalizing-and-localizing-applications)
