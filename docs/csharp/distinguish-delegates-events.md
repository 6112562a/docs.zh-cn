---
title: 区别委托和事件
description: 了解委托和事件的区别，以及何时使用 .NET Core 的这两种功能。
ms.date: 06/20/2016
ms.technology: csharp-fundamentals
ms.assetid: 0fdc8629-2fdb-4a7c-a433-5b9d04eaf911
ms.openlocfilehash: 04738ac2dd82da9c577e88598d0bb737a93333c1
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/14/2020
ms.locfileid: "79146173"
---
# <a name="distinguishing-delegates-and-events"></a><span data-ttu-id="a3113-103">区别委托和事件</span><span class="sxs-lookup"><span data-stu-id="a3113-103">Distinguishing Delegates and Events</span></span>

[<span data-ttu-id="a3113-104">上一页</span><span class="sxs-lookup"><span data-stu-id="a3113-104">Previous</span></span>](modern-events.md)

<span data-ttu-id="a3113-105">对不熟悉 .NET Core 平台的开发人员而言，在基于 `delegates` 的设计和基于 `events` 的设计之间做出选择是困难的。</span><span class="sxs-lookup"><span data-stu-id="a3113-105">Developers that are new to the .NET Core platform often struggle when deciding between a design based on `delegates` and a design based on `events`.</span></span> <span data-ttu-id="a3113-106">这是一个困难的选择，因为这两种语言功能非常相似。</span><span class="sxs-lookup"><span data-stu-id="a3113-106">This is a difficult concept, because the two language features are very similar.</span></span> <span data-ttu-id="a3113-107">事件甚至是使用委托的语言支持构建的。</span><span class="sxs-lookup"><span data-stu-id="a3113-107">Events are even built using the language support for delegates.</span></span>

<span data-ttu-id="a3113-108">它们都提供了一个后期绑定方案：在该方案中，组件通过调用仅在运行时识别的方法进行通信。</span><span class="sxs-lookup"><span data-stu-id="a3113-108">They both offer a late binding scenario: they enable scenarios where a component communicates by calling a method that is only known at runtime.</span></span> <span data-ttu-id="a3113-109">它们都支持单个和多个订阅服务器方法。</span><span class="sxs-lookup"><span data-stu-id="a3113-109">They both support single and multiple subscriber methods.</span></span> <span data-ttu-id="a3113-110">这称为单播和多播支持。</span><span class="sxs-lookup"><span data-stu-id="a3113-110">You may find this referred to as singlecast and multicast support.</span></span> <span data-ttu-id="a3113-111">二者均支持用于添加和删除处理程序的类似语法。</span><span class="sxs-lookup"><span data-stu-id="a3113-111">They both support similar syntax for adding and removing handlers.</span></span> <span data-ttu-id="a3113-112">最后，引发事件和调用委托使用完全相同的方法调用语法。</span><span class="sxs-lookup"><span data-stu-id="a3113-112">Finally, raising an event and calling a delegate use exactly the same method call syntax.</span></span> <span data-ttu-id="a3113-113">它们甚至都支持与 `Invoke()` 运算符一起使用的相同的 `?.` 方法语法。</span><span class="sxs-lookup"><span data-stu-id="a3113-113">They even both support the same `Invoke()` method syntax for use with the `?.` operator.</span></span>

<span data-ttu-id="a3113-114">鉴于所有这些相似之处，很难确定何时使用何种语法。</span><span class="sxs-lookup"><span data-stu-id="a3113-114">With all those similarities, it is easy to have trouble determining when to use which.</span></span>

## <a name="listening-to-events-is-optional"></a><span data-ttu-id="a3113-115">侦听事件是可选的</span><span class="sxs-lookup"><span data-stu-id="a3113-115">Listening to Events is Optional</span></span>

<span data-ttu-id="a3113-116">在确定要使用的语言功能时，最重要的考虑因素为是否必须具有附加的订阅服务器。</span><span class="sxs-lookup"><span data-stu-id="a3113-116">The most important consideration in determining which language feature to use is whether or not there must be an attached subscriber.</span></span> <span data-ttu-id="a3113-117">如果你的代码必须调用由订阅服务器提供的代码，则应使用基于委托的设计。</span><span class="sxs-lookup"><span data-stu-id="a3113-117">If your code must call the code supplied by the subscriber, you should use a design based on delegates.</span></span> <span data-ttu-id="a3113-118">如果你的代码在不调用任何订阅服务器的情况下可完成其所有工作，则应使用基于事件的设计。</span><span class="sxs-lookup"><span data-stu-id="a3113-118">If your code can complete all its work without calling any subscribers, you should use a design based on events.</span></span>

<span data-ttu-id="a3113-119">请考虑本部分中生成的示例。</span><span class="sxs-lookup"><span data-stu-id="a3113-119">Consider the examples built during this section.</span></span> <span data-ttu-id="a3113-120">必须为使用 `List.Sort()` 生成的代码提供 comparer 函数，以便对元素进行正确排序。</span><span class="sxs-lookup"><span data-stu-id="a3113-120">The code you built using `List.Sort()` must be given a comparer function in order to properly sort the elements.</span></span> <span data-ttu-id="a3113-121">必须与委托一起提供 LINQ 查询，以便确定要返回的元素。</span><span class="sxs-lookup"><span data-stu-id="a3113-121">LINQ queries must be supplied with delegates in order to determine what elements to return.</span></span> <span data-ttu-id="a3113-122">二者均使用与委托一起生成的设计。</span><span class="sxs-lookup"><span data-stu-id="a3113-122">Both used a design built with delegates.</span></span>

<span data-ttu-id="a3113-123">请考虑 `Progress` 事件。</span><span class="sxs-lookup"><span data-stu-id="a3113-123">Consider the `Progress` event.</span></span> <span data-ttu-id="a3113-124">它会报告任务进度。</span><span class="sxs-lookup"><span data-stu-id="a3113-124">It reports progress on a task.</span></span>
<span data-ttu-id="a3113-125">无论是否具有侦听器，该任务将继续进行。</span><span class="sxs-lookup"><span data-stu-id="a3113-125">The task continues to proceed whether or not there are any listeners.</span></span>
<span data-ttu-id="a3113-126">`FileSearcher` 是另一个示例。</span><span class="sxs-lookup"><span data-stu-id="a3113-126">The `FileSearcher` is another example.</span></span> <span data-ttu-id="a3113-127">即使没有附加事件订阅服务器，它仍将搜索和查找已找到的所有文件。</span><span class="sxs-lookup"><span data-stu-id="a3113-127">It would still search and find all the files that were sought, even with no event subscribers attached.</span></span>
<span data-ttu-id="a3113-128">即使没有任何订阅服务器侦听事件，UX 控件仍正常工作。</span><span class="sxs-lookup"><span data-stu-id="a3113-128">UX controls still work correctly, even when there are no subscribers listening to the events.</span></span> <span data-ttu-id="a3113-129">它们都使用基于事件的设计。</span><span class="sxs-lookup"><span data-stu-id="a3113-129">They both use designs based on events.</span></span>

## <a name="return-values-require-delegates"></a><span data-ttu-id="a3113-130">返回值需要委托</span><span class="sxs-lookup"><span data-stu-id="a3113-130">Return Values Require Delegates</span></span>

<span data-ttu-id="a3113-131">另一个注意事项是委托方法所需的方法原型。</span><span class="sxs-lookup"><span data-stu-id="a3113-131">Another consideration is the method prototype you would want for your delegate method.</span></span> <span data-ttu-id="a3113-132">如你所见，用于事件的委托均具有无效的返回类型。</span><span class="sxs-lookup"><span data-stu-id="a3113-132">As you've seen, the delegates used for events all have a void return type.</span></span> <span data-ttu-id="a3113-133">你还看到，存在创建事件处理程序的惯用语，该事件处理程序通过修改事件参数对象的属性将信息传回到事件源。</span><span class="sxs-lookup"><span data-stu-id="a3113-133">You've also seen that there are idioms to create event handlers that do pass information back to event sources through modifying properties of the event argument object.</span></span> <span data-ttu-id="a3113-134">虽然这些惯用语可发挥作用，但它们不像从方法返回值那样自然。</span><span class="sxs-lookup"><span data-stu-id="a3113-134">While these idioms do work, they are not as natural as returning a value from a method.</span></span>

<span data-ttu-id="a3113-135">请注意，通常可能会同时存在这两种试探法：如果委托方法返回一个值，则它可能会以某种方式影响算法。</span><span class="sxs-lookup"><span data-stu-id="a3113-135">Notice that these two heuristics may often both be present: If your delegate method returns a value, it will likely impact the algorithm in some way.</span></span>

## <a name="event-listeners-often-have-longer-lifetimes"></a><span data-ttu-id="a3113-136">事件侦听器通常具有较长的生存期</span><span class="sxs-lookup"><span data-stu-id="a3113-136">Event Listeners Often Have Longer Lifetimes</span></span>

<span data-ttu-id="a3113-137">这是一种略弱的对齐方式。</span><span class="sxs-lookup"><span data-stu-id="a3113-137">This is a slightly weaker justification.</span></span> <span data-ttu-id="a3113-138">但是，你可能会发现，当事件源将在很长一段时间内引发事件时，基于事件的设计会更加自然。</span><span class="sxs-lookup"><span data-stu-id="a3113-138">However, you may find that event-based designs are more natural when the event source will be raising events over a long period of time.</span></span> <span data-ttu-id="a3113-139">可以在许多系统上看到针对 UX 控件的此操作的示例。</span><span class="sxs-lookup"><span data-stu-id="a3113-139">You can see examples of this for UX controls on many systems.</span></span> <span data-ttu-id="a3113-140">订阅事件后，事件源可能会在程序的整个生存期内引发事件。</span><span class="sxs-lookup"><span data-stu-id="a3113-140">Once you subscribe to an event, the event source may raise events throughout the lifetime of the program.</span></span>
<span data-ttu-id="a3113-141">（当不再需要事件时，可以取消订阅事件。）</span><span class="sxs-lookup"><span data-stu-id="a3113-141">(You can unsubscribe from events when you no longer need them.)</span></span>

<span data-ttu-id="a3113-142">将其与许多基于委托的设计（其中委托用作方法的参数，且在返回该方法后不再使用此委托）进行比较。</span><span class="sxs-lookup"><span data-stu-id="a3113-142">Contrast that with many delegate-based designs, where a delegate is used as an argument to a method, and the delegate is not used after that method returns.</span></span>

## <a name="evaluate-carefully"></a><span data-ttu-id="a3113-143">仔细评估</span><span class="sxs-lookup"><span data-stu-id="a3113-143">Evaluate Carefully</span></span>

<span data-ttu-id="a3113-144">以上考虑因素并非固定不变的规则。</span><span class="sxs-lookup"><span data-stu-id="a3113-144">The above considerations are not hard and fast rules.</span></span> <span data-ttu-id="a3113-145">相反，它们代表可帮助决定针对特定使用情况的最佳选择的指南。</span><span class="sxs-lookup"><span data-stu-id="a3113-145">Instead, they represent guidance that can help you decide which choice is best for your particular usage.</span></span> <span data-ttu-id="a3113-146">因为两者类似，所以甚至可以将两者作为原型，并考虑使用更加自然的一种。</span><span class="sxs-lookup"><span data-stu-id="a3113-146">Because they are similar, you can even prototype both, and consider which would be more natural to work with.</span></span> <span data-ttu-id="a3113-147">两者均能很好地处理后期绑定方案。</span><span class="sxs-lookup"><span data-stu-id="a3113-147">They both handle late binding scenarios well.</span></span> <span data-ttu-id="a3113-148">使用能与设计进行最佳通讯的一种。</span><span class="sxs-lookup"><span data-stu-id="a3113-148">Use the one that communicates your design the best.</span></span>
