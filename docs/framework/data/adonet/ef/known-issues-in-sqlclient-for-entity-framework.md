---
title: SqlClient 中的已知问题（实体框架）
ms.date: 03/30/2017
ms.assetid: 48fe4912-4d0f-46b6-be96-3a42c54780f6
ms.openlocfilehash: a3df5a42b40e1851875c35165301af082f5d3269
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/23/2019
ms.locfileid: "61607721"
---
# <a name="known-issues-in-sqlclient-for-entity-framework"></a><span data-ttu-id="1abe8-102">SqlClient 中的已知问题（实体框架）</span><span class="sxs-lookup"><span data-stu-id="1abe8-102">Known Issues in SqlClient for Entity Framework</span></span>
<span data-ttu-id="1abe8-103">本节介绍与 SQL Server .NET Framework 数据提供程序 (SqlClient) 有关的已知问题。</span><span class="sxs-lookup"><span data-stu-id="1abe8-103">This section describes known issues related to the .NET Framework Data Provider for SQL Server (SqlClient).</span></span>  
  
## <a name="trailing-spaces-in-string-functions"></a><span data-ttu-id="1abe8-104">字符串函数中的尾随空格</span><span class="sxs-lookup"><span data-stu-id="1abe8-104">Trailing Spaces in String Functions</span></span>  
 <span data-ttu-id="1abe8-105">SQL Server 将忽略字符串值中的尾随空格。</span><span class="sxs-lookup"><span data-stu-id="1abe8-105">SQL Server ignores trailing spaces in string values.</span></span> <span data-ttu-id="1abe8-106">因此，传递字符串中的尾随空格可能导致不可预知的结果，甚至会导致失败。</span><span class="sxs-lookup"><span data-stu-id="1abe8-106">Therefore, passing trailing spaces in the string can lead to unpredictable results, even failures.</span></span>  
  
 <span data-ttu-id="1abe8-107">如果您必须具有在字符串中的尾随空格，您应考虑追加在结束时，使用空白字符，以便 SQL Server 不会修整字符串。</span><span class="sxs-lookup"><span data-stu-id="1abe8-107">If you have to have trailing spaces in your string, you should consider appending a white space character at the end, so that SQL Server does not trim the string.</span></span> <span data-ttu-id="1abe8-108">如果尾随空格不是必需的，应在传递给查询管道之前进行修整。</span><span class="sxs-lookup"><span data-stu-id="1abe8-108">If the trailing spaces are not required, they should be trimmed before they are passed down the query pipeline.</span></span>  
  
## <a name="right-function"></a><span data-ttu-id="1abe8-109">RIGHT 函数</span><span class="sxs-lookup"><span data-stu-id="1abe8-109">RIGHT Function</span></span>  
 <span data-ttu-id="1abe8-110">如果将非 `null` 值和 0 分别作为第一个自变量和第二个自变量传递给 `RIGHT(nvarchar(max)`, 0`)` 或 `RIGHT(varchar(max)`, 0`)`，将返回 `NULL` 值，而不是 `empty` 字符串。</span><span class="sxs-lookup"><span data-stu-id="1abe8-110">If a non-`null` value is passed as a first argument and 0 is passed as a second argument to `RIGHT(nvarchar(max)`, 0`)` or `RIGHT(varchar(max)`, 0`)`, a `NULL` value will be returned instead of an `empty` string.</span></span>  
  
## <a name="cross-and-outer-apply-operators"></a><span data-ttu-id="1abe8-111">CROSS 和 OUTER APPLY 运算符</span><span class="sxs-lookup"><span data-stu-id="1abe8-111">CROSS and OUTER APPLY Operators</span></span>  
 <span data-ttu-id="1abe8-112">[!INCLUDE[ssVersion2005](../../../../../includes/ssversion2005-md.md)] 引入了 CROSS 和 OUTER APPLY 运算符。</span><span class="sxs-lookup"><span data-stu-id="1abe8-112">CROSS and OUTER APPLY operators were introduced in [!INCLUDE[ssVersion2005](../../../../../includes/ssversion2005-md.md)].</span></span> <span data-ttu-id="1abe8-113">在某些情况下查询管道可能生成包含 CROSS APPLY 和/或 OUTER APPLY 运算符的 TRANSACT-SQL 语句。</span><span class="sxs-lookup"><span data-stu-id="1abe8-113">In some cases the query pipeline might produce a Transact-SQL statement that contains CROSS APPLY and/or OUTER APPLY operators.</span></span> <span data-ttu-id="1abe8-114">因为某些后端提供程序，包括 SQL Server 的版本早于[!INCLUDE[ssVersion2005](../../../../../includes/ssversion2005-md.md)]、 不支持这些运算符，不能对这些后端提供程序执行此类查询。</span><span class="sxs-lookup"><span data-stu-id="1abe8-114">Because some backend providers, including versions of SQL Server earlier than [!INCLUDE[ssVersion2005](../../../../../includes/ssversion2005-md.md)], do not support these operators, such queries cannot be executed on these backend providers.</span></span>  
  
 <span data-ttu-id="1abe8-115">下面是一些可能导致输出查询中出现 CROSS APPLY 和/或 OUTER APPLY 运算符的典型情况：</span><span class="sxs-lookup"><span data-stu-id="1abe8-115">The following are some typical scenarios that might lead to the presence of CROSS APPLY and/or OUTER APPLY operators in the output query:</span></span>  
  
- <span data-ttu-id="1abe8-116">带分页的相关子查询。</span><span class="sxs-lookup"><span data-stu-id="1abe8-116">A correlated subquery with paging.</span></span>  
  
- <span data-ttu-id="1abe8-117">相关子查询或导航所生成的集合上的 `AnyElement`。</span><span class="sxs-lookup"><span data-stu-id="1abe8-117">An `AnyElement` over a correlated sub-query, or over a collection produced by navigation.</span></span>  
  
- <span data-ttu-id="1abe8-118">使用接受元素选择器的分组方法的 LINQ 查询。</span><span class="sxs-lookup"><span data-stu-id="1abe8-118">LINQ queries that use grouping methods that accept an element selector.</span></span>  
  
- <span data-ttu-id="1abe8-119">显式指定了 CROSS APPLY 或 OUTER APPLY 的查询</span><span class="sxs-lookup"><span data-stu-id="1abe8-119">A query in which a CROSS APPLY or an OUTER APPLY is explicitly specified</span></span>  
  
- <span data-ttu-id="1abe8-120">在 REF 构造上具有 DEREF 构造的查询。</span><span class="sxs-lookup"><span data-stu-id="1abe8-120">A query that has a DEREF construct over a REF construct.</span></span>  
  
## <a name="skip-operator"></a><span data-ttu-id="1abe8-121">SKIP 运算符</span><span class="sxs-lookup"><span data-stu-id="1abe8-121">SKIP Operator</span></span>  
 <span data-ttu-id="1abe8-122">如果使用的是 [!INCLUDE[ssVersion2000](../../../../../includes/ssversion2000-md.md)]，则对非键列同时使用 SKIP 和 ORDER BY 可能会返回不正确的结果。</span><span class="sxs-lookup"><span data-stu-id="1abe8-122">If you are using [!INCLUDE[ssVersion2000](../../../../../includes/ssversion2000-md.md)], using SKIP with ORDER BY on non-key columns might return incorrect results.</span></span> <span data-ttu-id="1abe8-123">如果非键列中有重复数据，那么跳过的行数可能多于指定的行数。</span><span class="sxs-lookup"><span data-stu-id="1abe8-123">More than the specified number of rows might be skipped if the non-key column has duplicate data in it.</span></span> <span data-ttu-id="1abe8-124">这是由于 [!INCLUDE[ssVersion2000](../../../../../includes/ssversion2000-md.md)]对 SKIP 的解释方式造成的。</span><span class="sxs-lookup"><span data-stu-id="1abe8-124">This is due to how SKIP is translated for [!INCLUDE[ssVersion2000](../../../../../includes/ssversion2000-md.md)].</span></span> <span data-ttu-id="1abe8-125">例如，在下面的查询中，如果 `E.NonKeyColumn` 有重复值，则跳过的行可能超过 5 行：</span><span class="sxs-lookup"><span data-stu-id="1abe8-125">For example, in the following query, more than five rows might be skipped if `E.NonKeyColumn` has duplicate values:</span></span>  
  
```  
SELECT [E] FROM Container.EntitySet AS [E] ORDER BY [E].[NonKeyColumn] DESC SKIP 5L  
```  
  
## <a name="targeting-the-correct-sql-server-version"></a><span data-ttu-id="1abe8-126">以正确的 SQL Server 版本为目标</span><span class="sxs-lookup"><span data-stu-id="1abe8-126">Targeting the Correct SQL Server Version</span></span>  
 <span data-ttu-id="1abe8-127">[!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)]目标[!INCLUDE[tsql](../../../../../includes/tsql-md.md)]查询中指定的 SQL Server 版本上基于`ProviderManifestToken`存储模型 (.ssdl) 文件中的架构元素的属性。</span><span class="sxs-lookup"><span data-stu-id="1abe8-127">The [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] targets the [!INCLUDE[tsql](../../../../../includes/tsql-md.md)] query based on the SQL Server version that is specified in the `ProviderManifestToken` attribute of the Schema element in the storage model (.ssdl) file.</span></span> <span data-ttu-id="1abe8-128">您实际连接到的 SQL Server 的版本可能不是这一版本。</span><span class="sxs-lookup"><span data-stu-id="1abe8-128">This version might differ from the version of the actual SQL Server you are connected to.</span></span> <span data-ttu-id="1abe8-129">例如，如果您使用的是 SQL Server 2005，但 `ProviderManifestToken` 特性设置为 2008，则可能无法在服务器上执行生成的 [!INCLUDE[tsql](../../../../../includes/tsql-md.md)] 查询。</span><span class="sxs-lookup"><span data-stu-id="1abe8-129">For example, if you are using SQL Server 2005, but your `ProviderManifestToken` attribute is set to 2008, the generated [!INCLUDE[tsql](../../../../../includes/tsql-md.md)] query might not execute on the server.</span></span> <span data-ttu-id="1abe8-130">例如，在 SQL Server 的早期版本上，无法执行使用了 SQL Server 2008 所引入的新日期时间类型的查询。</span><span class="sxs-lookup"><span data-stu-id="1abe8-130">For example, a query that uses the new date time types that were introduced in SQL Server 2008 will not execute on earlier versions of the SQL Server.</span></span> <span data-ttu-id="1abe8-131">如果您使用的是 SQL Server 2005，但 `ProviderManifestToken` 属性设置为 2000，则生成的 [!INCLUDE[tsql](../../../../../includes/tsql-md.md)] 查询可能不是最佳的，您也可能收到指出该查询不受支持的异常消息。</span><span class="sxs-lookup"><span data-stu-id="1abe8-131">If you are using SQL Server 2005, but your `ProviderManifestToken` attribute is set to 2000, the generated [!INCLUDE[tsql](../../../../../includes/tsql-md.md)] query might be less optimized, or you might get an exception that says that the query is not supported.</span></span> <span data-ttu-id="1abe8-132">有关详细信息，请参阅 CROSS 和 OUTER APPLY 运算符前面的部分，本主题。</span><span class="sxs-lookup"><span data-stu-id="1abe8-132">For more information, see the CROSS and OUTER APPLY Operators section, earlier in this topic.</span></span>  
  
 <span data-ttu-id="1abe8-133">某些数据库行为取决于为数据库设置的兼容级别。</span><span class="sxs-lookup"><span data-stu-id="1abe8-133">Certain database behaviors depend on the compatibility level set to the database.</span></span> <span data-ttu-id="1abe8-134">如果 `ProviderManifestToken` 属性设置为 2005 并且 SQL Server 版本为 2005，但数据库的兼容级别设置为“80”(SQL Server 2000)，则生成的 [!INCLUDE[tsql](../../../../../includes/tsql-md.md)] 将以 SQL Server 2005 为目标，但可能会因兼容级别设置而无法正常执行。</span><span class="sxs-lookup"><span data-stu-id="1abe8-134">If your `ProviderManifestToken` attribute is set to 2005 and your SQL Server version is 2005, but the compatibility level of a database is set to "80" (SQL Server 2000), the generated [!INCLUDE[tsql](../../../../../includes/tsql-md.md)] will be targeting SQL Server 2005, but might not execute as expected due to the compatibility level setting.</span></span> <span data-ttu-id="1abe8-135">例如，如果 ORDER BY 列表中的列名与选择器中的列名相同，则可能会丢失排序信息。</span><span class="sxs-lookup"><span data-stu-id="1abe8-135">For example, you might lose ordering information if a column name in the ORDER BY list matches a column name in the selector.</span></span>  
  
## <a name="nested-queries-in-projection"></a><span data-ttu-id="1abe8-136">投影中的嵌套查询</span><span class="sxs-lookup"><span data-stu-id="1abe8-136">Nested Queries in Projection</span></span>  
 <span data-ttu-id="1abe8-137">投影子句中的嵌套查询可在服务器上转换为笛卡尔积查询。</span><span class="sxs-lookup"><span data-stu-id="1abe8-137">Nested queries in a projection clause might get translated into Cartesian product queries on the server.</span></span> <span data-ttu-id="1abe8-138">在某些后端服务器，包括 SLQ Server，这会导致 TempDB 表变得非常庞大。</span><span class="sxs-lookup"><span data-stu-id="1abe8-138">On some back-end servers, including SLQ Server, this can cause the TempDB table to get quite large.</span></span> <span data-ttu-id="1abe8-139">这样会降低服务器性能。</span><span class="sxs-lookup"><span data-stu-id="1abe8-139">This can decrease server performance.</span></span>  
  
 <span data-ttu-id="1abe8-140">下面是投影子句中嵌套查询的示例：</span><span class="sxs-lookup"><span data-stu-id="1abe8-140">The following is an example of  a nested query in a projection clause:</span></span>  
  
```  
SELECT c, (SELECT c, (SELECT c FROM AdventureWorksModel.Vendor AS c  ) As Inner2 FROM AdventureWorksModel.JobCandidate AS c  ) As Inner1 FROM AdventureWorksModel.EmployeeDepartmentHistory AS c  
```  
  
## <a name="server-generated-guid-identity-values"></a><span data-ttu-id="1abe8-141">服务器生成的 GUID 标识值</span><span class="sxs-lookup"><span data-stu-id="1abe8-141">Server Generated GUID Identity Values</span></span>  
 <span data-ttu-id="1abe8-142">[!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)]支持服务器生成的 GUID 类型标识值，但提供程序必须支持在插入行后返回服务器生成的标识值。</span><span class="sxs-lookup"><span data-stu-id="1abe8-142">The [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] supports server-generated GUID type identity values, but the provider must support returning the server-generated identity value after a row was inserted.</span></span> <span data-ttu-id="1abe8-143">从 SQL Server 2005 开始，你可以通过 SQL Server 数据库中返回服务器生成的 GUID 类型[OUTPUT 子句](https://go.microsoft.com/fwlink/?LinkId=169400)。</span><span class="sxs-lookup"><span data-stu-id="1abe8-143">Starting with SQL Server 2005, you can return the server-generated GUID type in a SQL Server database through the [OUTPUT clause](https://go.microsoft.com/fwlink/?LinkId=169400) .</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="1abe8-144">请参阅</span><span class="sxs-lookup"><span data-stu-id="1abe8-144">See also</span></span>

- [<span data-ttu-id="1abe8-145">用于实体框架的 SqlClient</span><span class="sxs-lookup"><span data-stu-id="1abe8-145">SqlClient for the Entity Framework</span></span>](../../../../../docs/framework/data/adonet/ef/sqlclient-for-the-entity-framework.md)
- [<span data-ttu-id="1abe8-146">LINQ to Entities 中的已知问题和注意事项</span><span class="sxs-lookup"><span data-stu-id="1abe8-146">Known Issues and Considerations in LINQ to Entities</span></span>](../../../../../docs/framework/data/adonet/ef/language-reference/known-issues-and-considerations-in-linq-to-entities.md)
