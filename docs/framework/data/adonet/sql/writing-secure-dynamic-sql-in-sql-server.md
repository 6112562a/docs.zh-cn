---
title: 在 SQL Server 中编写安全的动态 SQL
ms.date: 03/30/2017
ms.assetid: df5512b0-c249-40d2-82f9-f9a2ce6665bc
ms.openlocfilehash: 236fd925740d37c2cccabfcebfb7fcb46361489d
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/23/2019
ms.locfileid: "61757711"
---
# <a name="writing-secure-dynamic-sql-in-sql-server"></a><span data-ttu-id="77859-102">在 SQL Server 中编写安全的动态 SQL</span><span class="sxs-lookup"><span data-stu-id="77859-102">Writing Secure Dynamic SQL in SQL Server</span></span>
<span data-ttu-id="77859-103">SQL 注入是恶意用户输入 Transact-SQL 语句来取代有效输入的过程。</span><span class="sxs-lookup"><span data-stu-id="77859-103">SQL Injection is the process by which a malicious user enters Transact-SQL statements instead of valid input.</span></span> <span data-ttu-id="77859-104">如果输入的语句没有经过验证直接传递到服务器，并且应用程序不慎执行了注入的代码，这种攻击有可能损坏或毁坏数据。</span><span class="sxs-lookup"><span data-stu-id="77859-104">If the input is passed directly to the server without being validated and if the application inadvertently executes the injected code, the attack has the potential to damage or destroy data.</span></span>  
  
 <span data-ttu-id="77859-105">任何构造 SQL 语句的过程都应该针对注入漏洞进行审核，因为 SQL Server 将执行它扪收到的所有语法上有效的查询。</span><span class="sxs-lookup"><span data-stu-id="77859-105">Any procedure that constructs SQL statements should be reviewed for injection vulnerabilities because SQL Server will execute all syntactically valid queries that it receives.</span></span> <span data-ttu-id="77859-106">技术熟练的蓄意攻击者甚至可以操作参数化数据。</span><span class="sxs-lookup"><span data-stu-id="77859-106">Even parameterized data can be manipulated by a skilled and determined attacker.</span></span> <span data-ttu-id="77859-107">如果您使用动态 SQL，请确保将命令参数化，绝不要在查询字符串中直接包括参数值。</span><span class="sxs-lookup"><span data-stu-id="77859-107">If you use dynamic SQL, be sure to parameterize your commands, and never include parameter values directly into the query string.</span></span>  
  
## <a name="anatomy-of-a-sql-injection-attack"></a><span data-ttu-id="77859-108">SQL 注入攻击剖析</span><span class="sxs-lookup"><span data-stu-id="77859-108">Anatomy of a SQL Injection Attack</span></span>  
 <span data-ttu-id="77859-109">注入过程的工作原理是过早终止某一文本字符串并追加一个新命令。</span><span class="sxs-lookup"><span data-stu-id="77859-109">The injection process works by prematurely terminating a text string and appending a new command.</span></span> <span data-ttu-id="77859-110">因为插入的命令可能在执行之前已追加了其他字符串，攻击者可以使用注释标记“--”终止注入的字符串。</span><span class="sxs-lookup"><span data-stu-id="77859-110">Because the inserted command may have additional strings appended to it before it is executed, the malefactor terminates the injected string with a comment mark "--".</span></span> <span data-ttu-id="77859-111">执行时会忽略后续的文本。</span><span class="sxs-lookup"><span data-stu-id="77859-111">Subsequent text is ignored at execution time.</span></span> <span data-ttu-id="77859-112">通过使用分号 (;) 分隔符可以插入多个命令。</span><span class="sxs-lookup"><span data-stu-id="77859-112">Multiple commands can be inserted using a semicolon (;) delimiter.</span></span>  
  
 <span data-ttu-id="77859-113">只要注入的 SQL 代码在语法上正确，就无法通过编程方式检测到这种篡改。</span><span class="sxs-lookup"><span data-stu-id="77859-113">As long as injected SQL code is syntactically correct, tampering cannot be detected programmatically.</span></span> <span data-ttu-id="77859-114">因此，您必须验证所有用户输入并仔细评审将在您使用的服务器上执行构造的 SQL 命令的代码。</span><span class="sxs-lookup"><span data-stu-id="77859-114">Therefore, you must validate all user input and carefully review code that executes constructed SQL commands in the server that you are using.</span></span> <span data-ttu-id="77859-115">切勿连接未经验证的用户输入。</span><span class="sxs-lookup"><span data-stu-id="77859-115">Never concatenate user input that is not validated.</span></span> <span data-ttu-id="77859-116">字符串连接是脚本注入的主要入口点。</span><span class="sxs-lookup"><span data-stu-id="77859-116">String concatenation is the primary point of entry for script injection.</span></span>  
  
 <span data-ttu-id="77859-117">下面是几条有帮助的准则：</span><span class="sxs-lookup"><span data-stu-id="77859-117">Here are some helpful guidelines:</span></span>  
  
- <span data-ttu-id="77859-118">切勿直接从用户输入生成 Transact-SQL 语句，应使用存储过程来验证用户输入。</span><span class="sxs-lookup"><span data-stu-id="77859-118">Never build Transact-SQL statements directly from user input; use stored procedures to validate user input.</span></span>  
  
- <span data-ttu-id="77859-119">通过测试类型、长度、格式和范围来验证用户输入。</span><span class="sxs-lookup"><span data-stu-id="77859-119">Validate user input by testing type, length, format, and range.</span></span> <span data-ttu-id="77859-120">使用 Transact-SQL QUOTENAME() 函数转义系统名称，或使用 REPLACE() 函数转义字符串中的任何字符。</span><span class="sxs-lookup"><span data-stu-id="77859-120">Use the Transact-SQL QUOTENAME() function to escape system names or the REPLACE() function to escape any character in a string.</span></span>  
  
- <span data-ttu-id="77859-121">在您的应用程序的每个层中实现多层验证。</span><span class="sxs-lookup"><span data-stu-id="77859-121">Implement multiple layers of validation in each tier of your application.</span></span>  
  
- <span data-ttu-id="77859-122">测试输入内容的大小和数据类型并实施适当的限制。</span><span class="sxs-lookup"><span data-stu-id="77859-122">Test the size and data type of input and enforce appropriate limits.</span></span> <span data-ttu-id="77859-123">这有助于防止故意的缓冲区溢出。</span><span class="sxs-lookup"><span data-stu-id="77859-123">This can help prevent deliberate buffer overruns.</span></span>  
  
- <span data-ttu-id="77859-124">测试字符串变量的内容，并只接受预期值。</span><span class="sxs-lookup"><span data-stu-id="77859-124">Test the content of string variables and accept only expected values.</span></span> <span data-ttu-id="77859-125">拒绝包含二进制数据、转义序列和注释字符的输入。</span><span class="sxs-lookup"><span data-stu-id="77859-125">Reject entries that contain binary data, escape sequences, and comment characters.</span></span>  
  
- <span data-ttu-id="77859-126">如果使用 XML 文档，则在输入时对照其架构验证所有数据。</span><span class="sxs-lookup"><span data-stu-id="77859-126">When you are working with XML documents, validate all data against its schema as it is entered.</span></span>  
  
- <span data-ttu-id="77859-127">在多层环境中，在允许数据进入受信任区域之前所有数据都应该进行验证。</span><span class="sxs-lookup"><span data-stu-id="77859-127">In multi-tiered environments, all data should be validated before admission to the trusted zone.</span></span>  
  
- <span data-ttu-id="77859-128">在可以构造文件名的字段中不要接受以下字符串：AUX、CLOCK$、COM1 至 COM8、CON、CONFIG$、LPT1 至 LPT8、NUL 和 PRN。</span><span class="sxs-lookup"><span data-stu-id="77859-128">Do not accept the following strings in fields from which file names can be constructed: AUX, CLOCK$, COM1 through COM8, CON, CONFIG$, LPT1 through LPT8, NUL, and PRN.</span></span>  
  
- <span data-ttu-id="77859-129">使用带有存储过程和命令的 <xref:System.Data.SqlClient.SqlParameter> 对象以提供类型检查和长度验证。</span><span class="sxs-lookup"><span data-stu-id="77859-129">Use <xref:System.Data.SqlClient.SqlParameter> objects with stored procedures and commands to provide type checking and length validation.</span></span>  
  
- <span data-ttu-id="77859-130">在客户端代码中使用 <xref:System.Text.RegularExpressions.Regex> 表达式以筛选无效字符。</span><span class="sxs-lookup"><span data-stu-id="77859-130">Use <xref:System.Text.RegularExpressions.Regex> expressions in client code to filter invalid characters.</span></span>  
  
## <a name="dynamic-sql-strategies"></a><span data-ttu-id="77859-131">动态 SQL 策略</span><span class="sxs-lookup"><span data-stu-id="77859-131">Dynamic SQL Strategies</span></span>  
 <span data-ttu-id="77859-132">在过程代码中动态执行已创建的 SQL 语句会中断所属权链，使 SQL Server 按照由动态 SQL 访问的对象检查调用方的权限。</span><span class="sxs-lookup"><span data-stu-id="77859-132">Executing dynamically created SQL statements in your procedural code breaks the ownership chain, causing SQL Server to check the permissions of the caller against the objects being accessed by the dynamic SQL.</span></span>  
  
 <span data-ttu-id="77859-133">SQL Server 提供了使用存储过程和可执行动态 SQL 的用户定义函数来授予用户对数据的访问权限的方法。</span><span class="sxs-lookup"><span data-stu-id="77859-133">SQL Server has methods for granting users access to data using stored procedures and user-defined functions that execute dynamic SQL.</span></span>  
  
- <span data-ttu-id="77859-134">如[在 SQL Server 中使用模拟自定义权限](../../../../../docs/framework/data/adonet/sql/customizing-permissions-with-impersonation-in-sql-server.md)中所述，将模拟用于 Transact-SQL EXECUTE AS 子句。</span><span class="sxs-lookup"><span data-stu-id="77859-134">Using impersonation with the Transact-SQL EXECUTE AS clause, as described in [Customizing Permissions with Impersonation in SQL Server](../../../../../docs/framework/data/adonet/sql/customizing-permissions-with-impersonation-in-sql-server.md).</span></span>  
  
- <span data-ttu-id="77859-135">使用证书对存储过程签名，如[在 SQL Server 中对存储过程签名](../../../../../docs/framework/data/adonet/sql/signing-stored-procedures-in-sql-server.md)中所述。</span><span class="sxs-lookup"><span data-stu-id="77859-135">Signing stored procedures with certificates, as described in [Signing Stored Procedures in SQL Server](../../../../../docs/framework/data/adonet/sql/signing-stored-procedures-in-sql-server.md).</span></span>  
  
### <a name="execute-as"></a><span data-ttu-id="77859-136">EXECUTE AS</span><span class="sxs-lookup"><span data-stu-id="77859-136">EXECUTE AS</span></span>  
 <span data-ttu-id="77859-137">EXECUTE AS 子句用 EXECUTE AS 子句中指定的用户的权限替换调用方的权限。</span><span class="sxs-lookup"><span data-stu-id="77859-137">The EXECUTE AS clause replaces the permissions of the caller with that of the user specified in the EXECUTE AS clause.</span></span> <span data-ttu-id="77859-138">嵌套的存储过程或触发器在代理用户的安全上下文下执行。</span><span class="sxs-lookup"><span data-stu-id="77859-138">Nested stored procedures or triggers execute under the security context of the proxy user.</span></span> <span data-ttu-id="77859-139">这可能会中断依赖于行级安全性或要求审核的应用程序。</span><span class="sxs-lookup"><span data-stu-id="77859-139">This can break applications that rely on row-level security or require auditing.</span></span> <span data-ttu-id="77859-140">某些可返回用户标识的函数会返回 EXECUTE AS 子句中指定的用户的标识，而不是原始调用方的标识。</span><span class="sxs-lookup"><span data-stu-id="77859-140">Some functions that return the identity of the user return the user specified in the EXECUTE AS clause, not the original caller.</span></span> <span data-ttu-id="77859-141">只有在执行该过程或发出 REVERT 语句后，执行上下文才会恢复到原始调用方。</span><span class="sxs-lookup"><span data-stu-id="77859-141">Execution context is reverted to the original caller only after execution of the procedure or when a REVERT statement is issued.</span></span>  
  
### <a name="certificate-signing"></a><span data-ttu-id="77859-142">证书签名</span><span class="sxs-lookup"><span data-stu-id="77859-142">Certificate Signing</span></span>  
 <span data-ttu-id="77859-143">在执行使用证书进行签名的存储过程时，授予给证书用户的权限会与调用方的权限合并。</span><span class="sxs-lookup"><span data-stu-id="77859-143">When a stored procedure that has been signed with a certificate executes, the permissions granted to the certificate user are merged with those of the caller.</span></span> <span data-ttu-id="77859-144">执行上下文保持不变，证书用户不模拟调用方。</span><span class="sxs-lookup"><span data-stu-id="77859-144">The execution context remains the same; the certificate user does not impersonate the caller.</span></span> <span data-ttu-id="77859-145">为存储过程签名需要执行多个步骤才能实现。</span><span class="sxs-lookup"><span data-stu-id="77859-145">Signing stored procedures requires several steps to implement.</span></span> <span data-ttu-id="77859-146">每次修改过程时，都必须重新签名。</span><span class="sxs-lookup"><span data-stu-id="77859-146">Each time the procedure is modified, it must be re-signed.</span></span>  
  
### <a name="cross-database-access"></a><span data-ttu-id="77859-147">跨数据库访问</span><span class="sxs-lookup"><span data-stu-id="77859-147">Cross Database Access</span></span>  
 <span data-ttu-id="77859-148">在执行动态创建的 SQL 语句时，跨数据库的所属权链接不起作用。</span><span class="sxs-lookup"><span data-stu-id="77859-148">Cross-database ownership chaining does not work in cases where dynamically created SQL statements are executed.</span></span> <span data-ttu-id="77859-149">在 SQL Server 中，可以通过创建一个可访问另一个数据库中数据的存储过程并用两个数据库中都存在的证书为此过程签名来解决这个问题。</span><span class="sxs-lookup"><span data-stu-id="77859-149">You can work around this in SQL Server by creating a stored procedure that accesses data in another database and signing the procedure with a certificate that exists in both databases.</span></span> <span data-ttu-id="77859-150">这可为用户提供访问该过程所使用的数据库资源的权限，而不必向他们授予数据库访问权或权限。</span><span class="sxs-lookup"><span data-stu-id="77859-150">This gives users access to the database resources used by the procedure without granting them database access or permissions.</span></span>  
  
## <a name="external-resources"></a><span data-ttu-id="77859-151">外部资源</span><span class="sxs-lookup"><span data-stu-id="77859-151">External Resources</span></span>  
 <span data-ttu-id="77859-152">有关更多信息，请参见以下资源。</span><span class="sxs-lookup"><span data-stu-id="77859-152">For more information, see the following resources.</span></span>  
  
|<span data-ttu-id="77859-153">资源</span><span class="sxs-lookup"><span data-stu-id="77859-153">Resource</span></span>|<span data-ttu-id="77859-154">描述</span><span class="sxs-lookup"><span data-stu-id="77859-154">Description</span></span>|  
|--------------|-----------------|  
|<span data-ttu-id="77859-155">SQL Server 联机丛书中的[存储过程](/sql/relational-databases/stored-procedures/stored-procedures-database-engine)和 [SQL 注入](/sql/relational-databases/security/sql-injection)</span><span class="sxs-lookup"><span data-stu-id="77859-155">[Stored Procedures](/sql/relational-databases/stored-procedures/stored-procedures-database-engine) and [SQL Injection](/sql/relational-databases/security/sql-injection) in SQL Server Books Online</span></span>|<span data-ttu-id="77859-156">说明如何创建存储过程和 SQL 注入工作原理的主题。</span><span class="sxs-lookup"><span data-stu-id="77859-156">Topics describe how to create stored procedures and how SQL Injection works.</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="77859-157">请参阅</span><span class="sxs-lookup"><span data-stu-id="77859-157">See also</span></span>

- [<span data-ttu-id="77859-158">保证 ADO.NET 应用程序的安全</span><span class="sxs-lookup"><span data-stu-id="77859-158">Securing ADO.NET Applications</span></span>](../../../../../docs/framework/data/adonet/securing-ado-net-applications.md)
- [<span data-ttu-id="77859-159">SQL Server 安全性概述</span><span class="sxs-lookup"><span data-stu-id="77859-159">Overview of SQL Server Security</span></span>](../../../../../docs/framework/data/adonet/sql/overview-of-sql-server-security.md)
- [<span data-ttu-id="77859-160">SQL Server 中的应用程序安全性方案</span><span class="sxs-lookup"><span data-stu-id="77859-160">Application Security Scenarios in SQL Server</span></span>](../../../../../docs/framework/data/adonet/sql/application-security-scenarios-in-sql-server.md)
- [<span data-ttu-id="77859-161">在 SQL Server 中使用存储过程管理权限</span><span class="sxs-lookup"><span data-stu-id="77859-161">Managing Permissions with Stored Procedures in SQL Server</span></span>](../../../../../docs/framework/data/adonet/sql/managing-permissions-with-stored-procedures-in-sql-server.md)
- [<span data-ttu-id="77859-162">在 SQL Server 中对存储过程签名</span><span class="sxs-lookup"><span data-stu-id="77859-162">Signing Stored Procedures in SQL Server</span></span>](../../../../../docs/framework/data/adonet/sql/signing-stored-procedures-in-sql-server.md)
- [<span data-ttu-id="77859-163">在 SQL Server 中使用模拟自定义权限</span><span class="sxs-lookup"><span data-stu-id="77859-163">Customizing Permissions with Impersonation in SQL Server</span></span>](../../../../../docs/framework/data/adonet/sql/customizing-permissions-with-impersonation-in-sql-server.md)
- [<span data-ttu-id="77859-164">ADO.NET 托管提供程序和数据集开发人员中心</span><span class="sxs-lookup"><span data-stu-id="77859-164">ADO.NET Managed Providers and DataSet Developer Center</span></span>](https://go.microsoft.com/fwlink/?LinkId=217917)
