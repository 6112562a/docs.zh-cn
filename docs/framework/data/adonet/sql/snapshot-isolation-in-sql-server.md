---
title: SQL Server 中的快照隔离
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 43ae5dd3-50f5-43a8-8d01-e37a61664176
ms.openlocfilehash: 6d85cc041850300d1d079b227dcb8ed9201a0502
ms.sourcegitcommit: 3094dcd17141b32a570a82ae3f62a331616e2c9c
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 10/01/2019
ms.locfileid: "71699062"
---
# <a name="snapshot-isolation-in-sql-server"></a><span data-ttu-id="15172-102">SQL Server 中的快照隔离</span><span class="sxs-lookup"><span data-stu-id="15172-102">Snapshot Isolation in SQL Server</span></span>
<span data-ttu-id="15172-103">快照隔离可增强 OLTP 应用程序的并发性。</span><span class="sxs-lookup"><span data-stu-id="15172-103">Snapshot isolation enhances concurrency for OLTP applications.</span></span>  
  
## <a name="understanding-snapshot-isolation-and-row-versioning"></a><span data-ttu-id="15172-104">了解快照隔离和行版本控制</span><span class="sxs-lookup"><span data-stu-id="15172-104">Understanding Snapshot Isolation and Row Versioning</span></span>  
 <span data-ttu-id="15172-105">启用快照隔离后，必须维护每个事务的更新行版本。</span><span class="sxs-lookup"><span data-stu-id="15172-105">Once snapshot isolation is enabled, updated row versions for each transaction must be maintained.</span></span>  <span data-ttu-id="15172-106">在 SQL Server 2019 之前，这些版本存储在**tempdb**中。</span><span class="sxs-lookup"><span data-stu-id="15172-106">Prior to SQL Server 2019, these versions were stored in **tempdb**.</span></span> <span data-ttu-id="15172-107">SQL Server 2019 引入了一项新功能，即加速数据库恢复（ADR），该功能需要自己的行版本集。</span><span class="sxs-lookup"><span data-stu-id="15172-107">SQL Server 2019 introduces a new feature, Accelerated Database Recovery (ADR) which requires its own set of row versions.</span></span>  <span data-ttu-id="15172-108">因此，在 SQL Server 2019 的情况下，如果未启用 ADR，则行版本将始终保留在**tempdb**中。</span><span class="sxs-lookup"><span data-stu-id="15172-108">So, as of SQL Server 2019, if ADR is not enabled, row versions are kept in **tempdb** as always.</span></span>  <span data-ttu-id="15172-109">如果启用了 ADR，则与快照隔离和 ADR 相关的所有行版本都将保留在 ADR 的持久性版本存储区（PVS）中，该存储区位于用户指定的文件组的用户数据库中。</span><span class="sxs-lookup"><span data-stu-id="15172-109">If ADR is enabled, then all row versions, both related to snapshot isolation and ADR, are kept in ADR's Persistent Version Store (PVS), which is located in the user database in a filegroup which the user specifies.</span></span> <span data-ttu-id="15172-110">唯一的事务序列号标识每个事务，并且为每个行版本记录这些唯一的编号。</span><span class="sxs-lookup"><span data-stu-id="15172-110">A unique transaction sequence number identifies each transaction, and these unique numbers are recorded for each row version.</span></span> <span data-ttu-id="15172-111">事务使用序列号在事务序列号之前的最新行版本。</span><span class="sxs-lookup"><span data-stu-id="15172-111">The transaction works with the most recent row versions having a sequence number before the sequence number of the transaction.</span></span> <span data-ttu-id="15172-112">事务将忽略在事务开始之后创建的更新的行版本。</span><span class="sxs-lookup"><span data-stu-id="15172-112">Newer row versions created after the transaction has begun are ignored by the transaction.</span></span>  
  
 <span data-ttu-id="15172-113">“快照”一词反映的情况是：事务中的所有查询根据事务开始那一刻数据库的状态，看到数据库的相同版本（即快照）。</span><span class="sxs-lookup"><span data-stu-id="15172-113">The term "snapshot" reflects the fact that all queries in the transaction see the same version, or snapshot, of the database, based on the state of the database at the moment in time when the transaction begins.</span></span> <span data-ttu-id="15172-114">不会在快照事务中的基础数据行或数据页上获取锁，这样可以执行其他事务，而不会被以前未完成的事务所阻止。</span><span class="sxs-lookup"><span data-stu-id="15172-114">No locks are acquired on the underlying data rows or data pages in a snapshot transaction, which permits other transactions to execute without being blocked by a prior uncompleted transaction.</span></span> <span data-ttu-id="15172-115">修改数据的事务不会阻止读取数据的事务，读取数据的事务不会阻止写入数据的事务，就好像通常情况下在 SQL Server 中使用默认的 READ COMMITTED 隔离级别一样。</span><span class="sxs-lookup"><span data-stu-id="15172-115">Transactions that modify data do not block transactions that read data, and transactions that read data do not block transactions that write data, as they normally would under the default READ COMMITTED isolation level in SQL Server.</span></span> <span data-ttu-id="15172-116">这种无阻止的行为也大大降低了复杂事务出现死锁的可能性。</span><span class="sxs-lookup"><span data-stu-id="15172-116">This non-blocking behavior also significantly reduces the likelihood of deadlocks for complex transactions.</span></span>  
  
 <span data-ttu-id="15172-117">快照隔离使用开放式并发模型。</span><span class="sxs-lookup"><span data-stu-id="15172-117">Snapshot isolation uses an optimistic concurrency model.</span></span> <span data-ttu-id="15172-118">如果快照事务尝试提交对事务开始后更改过的数据的修改，事务将回滚并将引发错误。</span><span class="sxs-lookup"><span data-stu-id="15172-118">If a snapshot transaction attempts to commit modifications to data that has changed since the transaction began, the transaction will roll back and an error will be raised.</span></span> <span data-ttu-id="15172-119">对访问要修改的数据的 SELECT 语句使用 UPDLOCK 提示，可以避免此问题。</span><span class="sxs-lookup"><span data-stu-id="15172-119">You can avoid this by using UPDLOCK hints for SELECT statements that access data to be modified.</span></span> <span data-ttu-id="15172-120">有关更多信息，请参见“SQL Server 联机图书”中的“锁定提示”。</span><span class="sxs-lookup"><span data-stu-id="15172-120">See "Locking Hints" in SQL Server Books Online for more information.</span></span>  
  
 <span data-ttu-id="15172-121">在事务中使用快照隔离之前，必须先通过设置 ALLOW_SNAPSHOT_ISOLATION ON 数据库选项来启用快照隔离。</span><span class="sxs-lookup"><span data-stu-id="15172-121">Snapshot isolation must be enabled by setting the ALLOW_SNAPSHOT_ISOLATION ON database option before it is used in transactions.</span></span> <span data-ttu-id="15172-122">这会激活用于存储临时数据库（**tempdb**）中的行版本的机制。</span><span class="sxs-lookup"><span data-stu-id="15172-122">This activates the mechanism for storing row versions in the temporary database (**tempdb**).</span></span> <span data-ttu-id="15172-123">在每个要将快照隔离与 Transact-SQL ALTER DATABASE 语句一起使用的数据库中，必须启用快照隔离。</span><span class="sxs-lookup"><span data-stu-id="15172-123">You must enable snapshot isolation in each database that uses it with the Transact-SQL ALTER DATABASE statement.</span></span> <span data-ttu-id="15172-124">从这个方面来说，快照隔离与传统的隔离级别 READ COMMITTED、REPEATABLE READ、SERIALIZABLE 和 READ UNCOMMITTED 不同，这些传统的隔离级别不需要任何配置。</span><span class="sxs-lookup"><span data-stu-id="15172-124">In this respect, snapshot isolation differs from the traditional isolation levels of READ COMMITTED, REPEATABLE READ, SERIALIZABLE, and READ UNCOMMITTED, which require no configuration.</span></span> <span data-ttu-id="15172-125">下列语句激活快照隔离，并将默认的 READ COMMITTED 行为替换为 SNAPSHOT：</span><span class="sxs-lookup"><span data-stu-id="15172-125">The following statements activate snapshot isolation and replace the default READ COMMITTED behavior with SNAPSHOT:</span></span>  
  
```sql  
ALTER DATABASE MyDatabase  
SET ALLOW_SNAPSHOT_ISOLATION ON  
  
ALTER DATABASE MyDatabase  
SET READ_COMMITTED_SNAPSHOT ON  
```  
  
 <span data-ttu-id="15172-126">设置 READ_COMMITTED_SNAPSHOT ON 选项后，可以使用默认的 READ COMMITTED 隔离级别访问版本化的行。</span><span class="sxs-lookup"><span data-stu-id="15172-126">Setting the READ_COMMITTED_SNAPSHOT ON option allows access to versioned rows under the default READ COMMITTED isolation level.</span></span> <span data-ttu-id="15172-127">如果 READ_COMMITTED_SNAPSHOT 选项设置为 OFF，必须为每个会话显式设置 Snapshot 隔离级别，以便访问版本化的行。</span><span class="sxs-lookup"><span data-stu-id="15172-127">If the READ_COMMITTED_SNAPSHOT option is set to OFF, you must explicitly set the Snapshot isolation level for each session in order to access versioned rows.</span></span>  
  
## <a name="managing-concurrency-with-isolation-levels"></a><span data-ttu-id="15172-128">使用隔离级别管理并发性</span><span class="sxs-lookup"><span data-stu-id="15172-128">Managing Concurrency with Isolation Levels</span></span>  
 <span data-ttu-id="15172-129">执行 Transact-SQL 语句所使用的隔离级别确定其锁定行为和行版本化行为。</span><span class="sxs-lookup"><span data-stu-id="15172-129">The isolation level under which a Transact-SQL statement executes determines its locking and row versioning behavior.</span></span> <span data-ttu-id="15172-130">隔离级别的作用域为整个连接，使用 SET TRANSACTION ISOLATION LEVEL 语句为连接设置了隔离级别后，在连接关闭或设置了另一个隔离级别之前，该隔离级别将一直生效。</span><span class="sxs-lookup"><span data-stu-id="15172-130">An isolation level has connection-wide scope, and once set for a connection with the SET TRANSACTION ISOLATION LEVEL statement, it remains in effect until the connection is closed or another isolation level is set.</span></span> <span data-ttu-id="15172-131">当连接关闭并返回到池时，会保留上一个 SET TRANSACTION ISOLATION LEVEL 语句设置的隔离级别。</span><span class="sxs-lookup"><span data-stu-id="15172-131">When a connection is closed and returned to the pool, the isolation level from the last SET TRANSACTION ISOLATION LEVEL statement is retained.</span></span> <span data-ttu-id="15172-132">重复使用池连接的后续连接会使用连接被汇集时起作用的隔离级别。</span><span class="sxs-lookup"><span data-stu-id="15172-132">Subsequent connections reusing a pooled connection use the isolation level that was in effect at the time the connection is pooled.</span></span>  
  
 <span data-ttu-id="15172-133">连接中发出的个别查询可包含修改单个语句或事务的隔离，但不会影响该连接的隔离级别的锁提示。</span><span class="sxs-lookup"><span data-stu-id="15172-133">Individual queries issued within a connection can contain lock hints that modify the isolation for a single statement or transaction but do not affect the isolation level of the connection.</span></span> <span data-ttu-id="15172-134">在存储过程或函数中设置的隔离级别或锁提示不会更改调用这些存储过程或函数的连接的隔离级别，并且只在存储过程或函数调用期间生效。</span><span class="sxs-lookup"><span data-stu-id="15172-134">Isolation levels or lock hints set in stored procedures or functions do not change the isolation level of the connection that calls them and are in effect only for the duration of the stored procedure or function call.</span></span>  
  
 <span data-ttu-id="15172-135">SQL Server 的早期版本支持 SQL-92 标准中定义的四个隔离级别：</span><span class="sxs-lookup"><span data-stu-id="15172-135">Four isolation levels defined in the SQL-92 standard were supported in early versions of SQL Server:</span></span>  
  
- <span data-ttu-id="15172-136">READ UNCOMMITTED 是限制性最弱的隔离级别，因为该级别忽略其他事务放置的锁。</span><span class="sxs-lookup"><span data-stu-id="15172-136">READ UNCOMMITTED is the least restrictive isolation level because it ignores locks placed by other transactions.</span></span> <span data-ttu-id="15172-137">使用 READ UNCOMMITTED 级别执行的事务，可以读取尚未由其他事务提交的修改后的数据值；这些行为称为“脏”读。</span><span class="sxs-lookup"><span data-stu-id="15172-137">Transactions executing under READ UNCOMMITTED can read modified data values that have not yet been committed by other transactions; these are called "dirty" reads.</span></span>  
  
- <span data-ttu-id="15172-138">READ COMMITTED 是 SQL Server 默认的隔离级别。</span><span class="sxs-lookup"><span data-stu-id="15172-138">READ COMMITTED is the default isolation level for SQL Server.</span></span> <span data-ttu-id="15172-139">该级别通过指定语句不能读取其他事务已修改但是尚未提交的数据值，禁止执行脏读。</span><span class="sxs-lookup"><span data-stu-id="15172-139">It prevents dirty reads by specifying that statements cannot read data values that have been modified but not yet committed by other transactions.</span></span> <span data-ttu-id="15172-140">在当前事务中的各个语句执行之间，其他事务仍可以修改、插入或删除数据，从而产生无法重复的读操作，或“影子”数据。</span><span class="sxs-lookup"><span data-stu-id="15172-140">Other transactions can still modify, insert, or delete data between executions of individual statements within the current transaction, resulting in non-repeatable reads, or "phantom" data.</span></span>  
  
- <span data-ttu-id="15172-141">REPEATABLE READ 是比 READ COMMITTED 限制性更强的隔离级别。</span><span class="sxs-lookup"><span data-stu-id="15172-141">REPEATABLE READ is a more restrictive isolation level than READ COMMITTED.</span></span> <span data-ttu-id="15172-142">该级别包括 READ COMMITTED，并且另外指定了在当前事务提交之前，其他任何事务均不可以修改或删除当前事务已读取的数据。</span><span class="sxs-lookup"><span data-stu-id="15172-142">It encompasses READ COMMITTED and additionally specifies that no other transactions can modify or delete data that has been read by the current transaction until the current transaction commits.</span></span> <span data-ttu-id="15172-143">并发性低于 READ COMMITTED，因为已读数据的共享锁在整个事务期间持有，而不是在每个语句结束时释放。</span><span class="sxs-lookup"><span data-stu-id="15172-143">Concurrency is lower than for READ COMMITTED because shared locks on read data are held for the duration of the transaction instead of being released at the end of each statement.</span></span>  
  
- <span data-ttu-id="15172-144">SERIALIZABLE 是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。</span><span class="sxs-lookup"><span data-stu-id="15172-144">SERIALIZABLE is the most restrictive isolation level, because it locks entire ranges of keys and holds the locks until the transaction is complete.</span></span> <span data-ttu-id="15172-145">该级别包括 REPEATABLE READ，并增加了在事务完成之前，其他事务不能向事务已读取的范围插入新行的限制。</span><span class="sxs-lookup"><span data-stu-id="15172-145">It encompasses REPEATABLE READ and adds the restriction that other transactions cannot insert new rows into ranges that have been read by the transaction until the transaction is complete.</span></span>  
  
 <span data-ttu-id="15172-146">有关详细信息，请参阅[事务锁定和行版本控制指南](/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide)。</span><span class="sxs-lookup"><span data-stu-id="15172-146">For more information, refer to the [Transaction Locking and Row Versioning Guide](/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide).</span></span>  
  
### <a name="snapshot-isolation-level-extensions"></a><span data-ttu-id="15172-147">快照隔离级别扩展</span><span class="sxs-lookup"><span data-stu-id="15172-147">Snapshot Isolation Level Extensions</span></span>  
 <span data-ttu-id="15172-148">SQL Server 通过引入 SNAPSHOT 隔离级别并另外实现 READ COMMITTED 而引入了对 SQL-92 隔离级别的扩展。</span><span class="sxs-lookup"><span data-stu-id="15172-148">SQL Server introduced extensions to the SQL-92 isolation levels with the introduction of the SNAPSHOT isolation level and an additional implementation of READ COMMITTED.</span></span> <span data-ttu-id="15172-149">READ_COMMITTED_SNAPSHOT 隔离级别可以透明地替换所有事务的 READ COMMITTED。</span><span class="sxs-lookup"><span data-stu-id="15172-149">The READ_COMMITTED_SNAPSHOT isolation level can transparently replace READ COMMITTED for all transactions.</span></span>  
  
- <span data-ttu-id="15172-150">SNAPSHOT 隔离指定在一个事务中读取的数据永远不会反映其他同时进行的事务所作的更改。</span><span class="sxs-lookup"><span data-stu-id="15172-150">SNAPSHOT isolation specifies that data read within a transaction will never reflect changes made by other simultaneous transactions.</span></span> <span data-ttu-id="15172-151">事务使用事务开始时存在的数据行版本。</span><span class="sxs-lookup"><span data-stu-id="15172-151">The transaction uses the data row versions that exist when the transaction begins.</span></span> <span data-ttu-id="15172-152">在读取数据时不会对数据放置任何锁，所以，SNAPSHOT 事务不会阻止其他事务写入数据。</span><span class="sxs-lookup"><span data-stu-id="15172-152">No locks are placed on the data when it is read, so SNAPSHOT transactions do not block other transactions from writing data.</span></span> <span data-ttu-id="15172-153">写入数据的事务不会阻止快照事务读取数据。</span><span class="sxs-lookup"><span data-stu-id="15172-153">Transactions that write data do not block snapshot transactions from reading data.</span></span> <span data-ttu-id="15172-154">您需要通过设置 ALLOW_SNAPSHOT_ISOLATION 数据库选项启用快照隔离后，才可以使用快照隔离。</span><span class="sxs-lookup"><span data-stu-id="15172-154">You need to enable snapshot isolation by setting the ALLOW_SNAPSHOT_ISOLATION database option in order to use it.</span></span>  
  
- <span data-ttu-id="15172-155">在数据库中启用快照隔离时，READ_COMMITTED_SNAPSHOT 数据库选项确定默认 READ COMMITTED 隔离级别的行为。</span><span class="sxs-lookup"><span data-stu-id="15172-155">The READ_COMMITTED_SNAPSHOT database option determines the behavior of the default READ COMMITTED isolation level when snapshot isolation is enabled in a database.</span></span> <span data-ttu-id="15172-156">如果不显式指定 READ_COMMITTED_SNAPSHOT ON，READ COMMITTED 将应用于所有隐式事务。</span><span class="sxs-lookup"><span data-stu-id="15172-156">If you do not explicitly specify READ_COMMITTED_SNAPSHOT ON, READ COMMITTED is applied to all implicit transactions.</span></span> <span data-ttu-id="15172-157">此时的行为与设置 READ_COMMITTED_SNAPSHOT OFF（默认设置）相同。</span><span class="sxs-lookup"><span data-stu-id="15172-157">This produces the same behavior as setting READ_COMMITTED_SNAPSHOT OFF (the default).</span></span> <span data-ttu-id="15172-158">当 READ_COMMITTED_SNAPSHOT OFF 生效时，数据库引擎使用共享锁强制使用默认隔离级别。</span><span class="sxs-lookup"><span data-stu-id="15172-158">When READ_COMMITTED_SNAPSHOT OFF is in effect, the Database Engine uses shared locks to enforce the default isolation level.</span></span> <span data-ttu-id="15172-159">如果将 READ_COMMITTED_SNAPSHOT 数据库选项设置为 ON，数据库引擎将使用行版本化和快照隔离作为默认设置，而不是使用锁来保护数据。</span><span class="sxs-lookup"><span data-stu-id="15172-159">If you set the READ_COMMITTED_SNAPSHOT database option to ON, the database engine uses row versioning and snapshot isolation as the default, instead of using locks to protect the data.</span></span>  
  
## <a name="how-snapshot-isolation-and-row-versioning-work"></a><span data-ttu-id="15172-160">快照隔离和行版本化的工作原理</span><span class="sxs-lookup"><span data-stu-id="15172-160">How Snapshot Isolation and Row Versioning Work</span></span>  
 <span data-ttu-id="15172-161">启用快照隔离级别后，每次更新行时，SQL Server 数据库引擎将原始行的副本存储在**tempdb**中，并将事务序列号添加到该行。</span><span class="sxs-lookup"><span data-stu-id="15172-161">When the SNAPSHOT isolation level is enabled, each time a row is updated, the SQL Server Database Engine stores a copy of the original row in **tempdb**, and adds a transaction sequence number to the row.</span></span> <span data-ttu-id="15172-162">以下是发生的事件序列：</span><span class="sxs-lookup"><span data-stu-id="15172-162">The following is the sequence of events that occurs:</span></span>  
  
- <span data-ttu-id="15172-163">新的事务启动，并为该事务分配一个事务序列号。</span><span class="sxs-lookup"><span data-stu-id="15172-163">A new transaction is initiated, and it is assigned a transaction sequence number.</span></span>  
  
- <span data-ttu-id="15172-164">数据库引擎读取事务中的某行，并从**tempdb**中检索其序列号与事务序列号最接近的行版本，并从其下到下的部分中检索行版本。</span><span class="sxs-lookup"><span data-stu-id="15172-164">The Database Engine reads a row within the transaction and retrieves the row version from **tempdb** whose sequence number is closest to, and lower than, the transaction sequence number.</span></span>  
  
- <span data-ttu-id="15172-165">数据库引擎检查事务编号是否不在未提交事务的事务编号列表中，这些未提交事务是在快照事务开始时进入活动状态的。</span><span class="sxs-lookup"><span data-stu-id="15172-165">The Database Engine checks to see if the transaction sequence number is not in the list of transaction sequence numbers of the uncommitted transactions active when the snapshot transaction started.</span></span>  
  
- <span data-ttu-id="15172-166">事务从当前开始，在事务开始时，从**tempdb**读取行的版本。</span><span class="sxs-lookup"><span data-stu-id="15172-166">The transaction reads the version of the row from **tempdb** that was current as of the start of the transaction.</span></span> <span data-ttu-id="15172-167">事务不会看到事务开始后插入的新行，因为这些序列号值将大于事务序列号的值。</span><span class="sxs-lookup"><span data-stu-id="15172-167">It will not see new rows inserted after the transaction was started because those sequence number values will be higher than the value of the transaction sequence number.</span></span>  
  
- <span data-ttu-id="15172-168">当前事务将会看到在事务开始后删除的行，因为**tempdb**中的行版本具有更低的序列号值。</span><span class="sxs-lookup"><span data-stu-id="15172-168">The current transaction will see rows that were deleted after the transaction began, because there will be a row version in **tempdb** with a lower sequence number value.</span></span>  
  
 <span data-ttu-id="15172-169">快照隔离的实际效果是事务看到在事务开始时存在的所有数据，不会在基础表上授予或放置任何锁。</span><span class="sxs-lookup"><span data-stu-id="15172-169">The net effect of snapshot isolation is that the transaction sees all of the data as it existed at the start of the transaction, without honoring or placing any locks on the underlying tables.</span></span> <span data-ttu-id="15172-170">在存在争用的情况下，这样可以改进性能。</span><span class="sxs-lookup"><span data-stu-id="15172-170">This can result in performance improvements in situations where there is contention.</span></span>  
  
 <span data-ttu-id="15172-171">快照事务始终使用开放式并发控制，不赋予可能阻止其他事务更新行的任何锁。</span><span class="sxs-lookup"><span data-stu-id="15172-171">A snapshot transaction always uses optimistic concurrency control, withholding any locks that would prevent other transactions from updating rows.</span></span> <span data-ttu-id="15172-172">如果快照事务尝试提交对事务开始后已更改的行的更新，事务将回滚并引发错误。</span><span class="sxs-lookup"><span data-stu-id="15172-172">If a snapshot transaction attempts to commit an update to a row that was changed after the transaction began, the transaction is rolled back, and an error is raised.</span></span>  
  
## <a name="working-with-snapshot-isolation-in-adonet"></a><span data-ttu-id="15172-173">在 ADO.NET 中使用快照隔离</span><span class="sxs-lookup"><span data-stu-id="15172-173">Working with Snapshot Isolation in ADO.NET</span></span>  
 <span data-ttu-id="15172-174">ADO.NET 中通过 <xref:System.Data.SqlClient.SqlTransaction> 类支持快照隔离。</span><span class="sxs-lookup"><span data-stu-id="15172-174">Snapshot isolation is supported in ADO.NET by the <xref:System.Data.SqlClient.SqlTransaction> class.</span></span> <span data-ttu-id="15172-175">如果已为快照隔离启用了数据库，但没有为 READ_COMMITTED_SNAPSHOT 配置该数据库，则必须在调用 <xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A> 方法时使用**IsolationLevel**枚举值启动 @no__t 0。</span><span class="sxs-lookup"><span data-stu-id="15172-175">If a database has been enabled for snapshot isolation but is not configured for READ_COMMITTED_SNAPSHOT ON, you must initiate a <xref:System.Data.SqlClient.SqlTransaction> using the **IsolationLevel.Snapshot** enumeration value when calling the <xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A> method.</span></span> <span data-ttu-id="15172-176">此代码段假定连接是打开的 <xref:System.Data.SqlClient.SqlConnection> 对象。</span><span class="sxs-lookup"><span data-stu-id="15172-176">This code fragment assumes that connection is an open <xref:System.Data.SqlClient.SqlConnection> object.</span></span>  
  
```vb  
Dim sqlTran As SqlTransaction = _  
  connection.BeginTransaction(IsolationLevel.Snapshot)  
```  
  
```csharp  
SqlTransaction sqlTran =   
  connection.BeginTransaction(IsolationLevel.Snapshot);  
```  
  
### <a name="example"></a><span data-ttu-id="15172-177">示例</span><span class="sxs-lookup"><span data-stu-id="15172-177">Example</span></span>  
 <span data-ttu-id="15172-178">以下示例通过尝试访问锁定的数据，演示不同隔离级别的行为，并非要在生产代码中使用。</span><span class="sxs-lookup"><span data-stu-id="15172-178">The following example demonstrates how the different isolation levels behave by attempting to access locked data, and it is not intended to be used in production code.</span></span>  
  
 <span data-ttu-id="15172-179">该代码连接到 SQL Server 中的**AdventureWorks**示例数据库，并创建一个名为**TestSnapshot**的表并插入一行数据。</span><span class="sxs-lookup"><span data-stu-id="15172-179">The code connects to the **AdventureWorks** sample database in SQL Server and creates a table named **TestSnapshot** and inserts one row of data.</span></span> <span data-ttu-id="15172-180">该代码使用 ALTER DATABASE Transact-SQL 语句对数据库启用快照隔离，但是不设置 READ_COMMITTED_SNAPSHOT 选项，让默认的 READ COMMITTED 隔离级别的行为生效。</span><span class="sxs-lookup"><span data-stu-id="15172-180">The code uses the ALTER DATABASE Transact-SQL statement to turn on snapshot isolation for the database, but it does not set the READ_COMMITTED_SNAPSHOT option, leaving the default READ COMMITTED isolation-level behavior in effect.</span></span> <span data-ttu-id="15172-181">然后，该代码执行下列操作：</span><span class="sxs-lookup"><span data-stu-id="15172-181">The code then performs the following actions:</span></span>  
  
- <span data-ttu-id="15172-182">开始但是不完成 sqlTransaction1，sqlTransaction1 使用 SERIALIZABLE 隔离级别开始更新事务。</span><span class="sxs-lookup"><span data-stu-id="15172-182">It begins, but does not complete, sqlTransaction1, which uses the SERIALIZABLE isolation level to start an update transaction.</span></span> <span data-ttu-id="15172-183">这样做的结果是锁定表。</span><span class="sxs-lookup"><span data-stu-id="15172-183">This has the effect of locking the table.</span></span>  
  
- <span data-ttu-id="15172-184">它将打开第二个连接，并使用快照隔离级别启动第二个事务，以读取**TestSnapshot**表中的数据。</span><span class="sxs-lookup"><span data-stu-id="15172-184">It opens a second connection and initiates a second transaction using the SNAPSHOT isolation level to read the data in the **TestSnapshot** table.</span></span> <span data-ttu-id="15172-185">因为启用了快照隔离，此事务可以读取在开始 sqlTransaction1 之前存在的数据。</span><span class="sxs-lookup"><span data-stu-id="15172-185">Because snapshot isolation is enabled, this transaction can read the data that existed before sqlTransaction1 started.</span></span>  
  
- <span data-ttu-id="15172-186">打开第三个连接，并使用 READ COMMITTED 隔离级别开始一个事务，尝试读取表中的数据。</span><span class="sxs-lookup"><span data-stu-id="15172-186">It opens a third connection and initiates a transaction using the READ COMMITTED isolation level to attempt to read the data in the table.</span></span> <span data-ttu-id="15172-187">在这种情况下，代码无法读取数据，因为代码在第一个事务中无法通过在表上放置的锁进行读取，因而超时。如果使用 REPEATABLE READ 和 SERIALIZABLE 隔离级别，因为这些隔离级别也无法通过第一个事务中放置的锁，因而会出现同样的结果。</span><span class="sxs-lookup"><span data-stu-id="15172-187">In this case, the code cannot read the data because it cannot read past the locks placed on the table in the first transaction and times out. The same result would occur if the REPEATABLE READ and SERIALIZABLE isolation levels were used because these isolation levels also cannot read past the locks placed in the first transaction.</span></span>  
  
- <span data-ttu-id="15172-188">打开第四个连接，并使用 READ UNCOMMITTED 隔离级别开始一个事务，对 sqlTransaction1 中未提交的值执行脏读。</span><span class="sxs-lookup"><span data-stu-id="15172-188">It opens a fourth connection and initiates a transaction using the READ UNCOMMITTED isolation level, which performs a dirty read of the uncommitted value in sqlTransaction1.</span></span> <span data-ttu-id="15172-189">如果第一个事务未提交，数据库中永远不会真正存在此值。</span><span class="sxs-lookup"><span data-stu-id="15172-189">This value may never actually exist in the database if the first transaction is not committed.</span></span>  
  
- <span data-ttu-id="15172-190">它将回滚第一个事务，并通过删除**TestSnapshot**表并关闭**AdventureWorks**数据库的快照隔离来清理。</span><span class="sxs-lookup"><span data-stu-id="15172-190">It rolls back the first transaction and cleans up by deleting the **TestSnapshot** table and turning off snapshot isolation for the **AdventureWorks** database.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="15172-191">以下示例使用同一连接字符串，且其连接池已关闭。</span><span class="sxs-lookup"><span data-stu-id="15172-191">The following examples use the same connection string with connection pooling turned off.</span></span> <span data-ttu-id="15172-192">如果某个连接被汇集，则重置其隔离级别并不会重置服务器的隔离级别。</span><span class="sxs-lookup"><span data-stu-id="15172-192">If a connection is pooled, resetting its isolation level does not reset the isolation level at the server.</span></span> <span data-ttu-id="15172-193">因此，使用同一内部池连接的后续连接将会启动，且其隔离级别将设置为该池连接的隔离级别。</span><span class="sxs-lookup"><span data-stu-id="15172-193">As a result, subsequent connections that use the same pooled inner connection start with their isolation levels set to that of the pooled connection.</span></span> <span data-ttu-id="15172-194">关闭连接池的另一种方法是为每个连接显式设置隔离级别。</span><span class="sxs-lookup"><span data-stu-id="15172-194">An alternative to turning off connection pooling is to set the isolation level explicitly for each connection.</span></span>  
  
 [!code-csharp[DataWorks SnapshotIsolation.Demo#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.Demo/CS/source.cs#1)]
 [!code-vb[DataWorks SnapshotIsolation.Demo#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.Demo/VB/source.vb#1)]  
  
### <a name="example"></a><span data-ttu-id="15172-195">示例</span><span class="sxs-lookup"><span data-stu-id="15172-195">Example</span></span>  
 <span data-ttu-id="15172-196">以下示例演示修改数据时的快照隔离行为。</span><span class="sxs-lookup"><span data-stu-id="15172-196">The following example demonstrates the behavior of snapshot isolation when data is being modified.</span></span> <span data-ttu-id="15172-197">该代码执行下列操作：</span><span class="sxs-lookup"><span data-stu-id="15172-197">The code performs the following actions:</span></span>  
  
- <span data-ttu-id="15172-198">连接到**AdventureWorks**示例数据库并启用快照隔离。</span><span class="sxs-lookup"><span data-stu-id="15172-198">Connects to the **AdventureWorks** sample database and enables SNAPSHOT isolation.</span></span>  
  
- <span data-ttu-id="15172-199">创建名为**TestSnapshotUpdate**的表，并插入三行示例数据。</span><span class="sxs-lookup"><span data-stu-id="15172-199">Creates a table named **TestSnapshotUpdate** and inserts three rows of sample data.</span></span>  
  
- <span data-ttu-id="15172-200">使用 SNAPSHOT 隔离开始但是不完成 sqlTransaction1。</span><span class="sxs-lookup"><span data-stu-id="15172-200">Begins, but does not complete, sqlTransaction1 using SNAPSHOT isolation.</span></span> <span data-ttu-id="15172-201">在事务中选择三行数据。</span><span class="sxs-lookup"><span data-stu-id="15172-201">Three rows of data are selected in the transaction.</span></span>  
  
- <span data-ttu-id="15172-202">创建第二个**SqlConnection**到**AdventureWorks** ，并使用 "已提交读" 隔离级别创建第二个事务，该事务更新 sqlTransaction1 中所选的某个行中的值。</span><span class="sxs-lookup"><span data-stu-id="15172-202">Creates a second **SqlConnection** to **AdventureWorks** and creates a second transaction using the READ COMMITTED isolation level that updates a value in one of the rows selected in sqlTransaction1.</span></span>  
  
- <span data-ttu-id="15172-203">提交 sqlTransaction2。</span><span class="sxs-lookup"><span data-stu-id="15172-203">Commits sqlTransaction2.</span></span>  
  
- <span data-ttu-id="15172-204">返回 sqlTransaction1 并尝试更新 sqlTransaction1 已提交的相同的行。</span><span class="sxs-lookup"><span data-stu-id="15172-204">Returns to sqlTransaction1 and attempts to update the same row that sqlTransaction1 already committed.</span></span> <span data-ttu-id="15172-205">将引发 3960 错误，sqlTransaction1 将自动回滚。</span><span class="sxs-lookup"><span data-stu-id="15172-205">Error 3960 is raised, and sqlTransaction1 is rolled back automatically.</span></span> <span data-ttu-id="15172-206">**SqlException**和**SqlException**显示在控制台窗口中。</span><span class="sxs-lookup"><span data-stu-id="15172-206">The **SqlException.Number** and **SqlException.Message** are displayed in the Console window.</span></span>  
  
- <span data-ttu-id="15172-207">执行清理代码以关闭**AdventureWorks**中的快照隔离，并删除**TestSnapshotUpdate**表。</span><span class="sxs-lookup"><span data-stu-id="15172-207">Executes clean-up code to turn off snapshot isolation in **AdventureWorks** and delete the **TestSnapshotUpdate** table.</span></span>  
  
 [!code-csharp[DataWorks SnapshotIsolation.DemoUpdate#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.DemoUpdate/CS/source.cs#1)]
 [!code-vb[DataWorks SnapshotIsolation.DemoUpdate#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.DemoUpdate/VB/source.vb#1)]  
  
### <a name="using-lock-hints-with-snapshot-isolation"></a><span data-ttu-id="15172-208">对快照隔离使用锁提示</span><span class="sxs-lookup"><span data-stu-id="15172-208">Using Lock Hints with Snapshot Isolation</span></span>  
 <span data-ttu-id="15172-209">在前面的示例中，第一个事务选择数据，第二个事务在第一个事务完成前更新数据，在第一个事务尝试更新相同行时造成更新冲突。</span><span class="sxs-lookup"><span data-stu-id="15172-209">In the previous example, the first transaction selects data, and a second transaction updates the data before the first transaction is able to complete, causing an update conflict when the first transaction tries to update the same row.</span></span> <span data-ttu-id="15172-210">通过在事务开始时提供锁提示，可以降低在需要很长时间的快照事务中发生更新冲突的机率。</span><span class="sxs-lookup"><span data-stu-id="15172-210">You can reduce the chance of update conflicts in long-running snapshot transactions by supplying lock hints at the beginning of the transaction.</span></span> <span data-ttu-id="15172-211">以下 SELECT 语句使用 UPDLOCK 提示锁定所选行：</span><span class="sxs-lookup"><span data-stu-id="15172-211">The following SELECT statement uses the UPDLOCK hint to lock the selected rows:</span></span>  
  
```sql  
SELECT * FROM TestSnapshotUpdate WITH (UPDLOCK)   
  WHERE PriKey BETWEEN 1 AND 3  
```  
  
 <span data-ttu-id="15172-212">使用 UPDLOCK 锁提示将阻止在第一个事务完成之前尝试更新行的任何行。</span><span class="sxs-lookup"><span data-stu-id="15172-212">Using the UPDLOCK lock hint blocks any rows attempting to update the rows before the first transaction completes.</span></span> <span data-ttu-id="15172-213">这样可以保证所选行以后在事务中进行更新时不会发生冲突。</span><span class="sxs-lookup"><span data-stu-id="15172-213">This guarantees that the selected rows have no conflicts when they are updated later in the transaction.</span></span> <span data-ttu-id="15172-214">请参见“SQL Server 联机图书”中的“锁定提示”。</span><span class="sxs-lookup"><span data-stu-id="15172-214">See "Locking Hints" in SQL Server Books Online.</span></span>  
  
 <span data-ttu-id="15172-215">如果应用程序中存在许多冲突，快照隔离也许不是最佳的选择。</span><span class="sxs-lookup"><span data-stu-id="15172-215">If your application has many conflicts, snapshot isolation may not be the best choice.</span></span> <span data-ttu-id="15172-216">只有在确实需要时，才应使用提示。</span><span class="sxs-lookup"><span data-stu-id="15172-216">Hints should only be used when really needed.</span></span> <span data-ttu-id="15172-217">应用程序的设计不应使其操作始终依赖于锁提示。</span><span class="sxs-lookup"><span data-stu-id="15172-217">Your application should not be designed so that it constantly relies on lock hints for its operation.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="15172-218">请参阅</span><span class="sxs-lookup"><span data-stu-id="15172-218">See also</span></span>

- [<span data-ttu-id="15172-219">SQL Server 和 ADO.NET</span><span class="sxs-lookup"><span data-stu-id="15172-219">SQL Server and ADO.NET</span></span>](index.md)
- [<span data-ttu-id="15172-220">ADO.NET 概述</span><span class="sxs-lookup"><span data-stu-id="15172-220">ADO.NET Overview</span></span>](../ado-net-overview.md)
- [<span data-ttu-id="15172-221">事务锁定和行版本控制指南</span><span class="sxs-lookup"><span data-stu-id="15172-221">Transaction Locking and Row Versioning Guide</span></span>](/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide)
