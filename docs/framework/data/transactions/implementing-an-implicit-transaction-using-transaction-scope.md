---
title: 使用事务范围实现隐式事务
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 49d1706a-1e0c-4c85-9704-75c908372eb9
ms.openlocfilehash: 3a6dd2cc4565cd4f8716b691d564a782887be1e0
ms.sourcegitcommit: 2d792961ed48f235cf413d6031576373c3050918
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 08/31/2019
ms.locfileid: "70205919"
---
# <a name="implementing-an-implicit-transaction-using-transaction-scope"></a><span data-ttu-id="ce231-102">使用事务范围实现隐式事务</span><span class="sxs-lookup"><span data-stu-id="ce231-102">Implementing an Implicit Transaction using Transaction Scope</span></span>
<span data-ttu-id="ce231-103"><xref:System.Transactions.TransactionScope> 类提供了一种简单方法，使您无需与事务自身进行交互，就可以在参与事务时对代码块进行标记。</span><span class="sxs-lookup"><span data-stu-id="ce231-103">The <xref:System.Transactions.TransactionScope> class provides a simple way to mark a block of code as participating in a transaction, without requiring you to interact with the transaction itself.</span></span> <span data-ttu-id="ce231-104">事务范围可以自动选择和管理环境事务。</span><span class="sxs-lookup"><span data-stu-id="ce231-104">A transaction scope can select and manage the ambient transaction automatically.</span></span> <span data-ttu-id="ce231-105">由于 <xref:System.Transactions.TransactionScope> 具有简单易用性和高效性，因此建议您在开发事务应用程序时使用该类。</span><span class="sxs-lookup"><span data-stu-id="ce231-105">Due to its ease of use and efficiency, it is recommended that you use the <xref:System.Transactions.TransactionScope> class when developing a transaction application.</span></span>  
  
 <span data-ttu-id="ce231-106">此外，还无需将资源显式登记到事务。</span><span class="sxs-lookup"><span data-stu-id="ce231-106">In addition, you do not need to enlist resources explicitly with the transaction.</span></span> <span data-ttu-id="ce231-107">任何 <xref:System.Transactions> 资源管理器（如 SQL Server 2005）都可以检测范围所创建的环境事务是否存在，并自动对其进行登记。</span><span class="sxs-lookup"><span data-stu-id="ce231-107">Any <xref:System.Transactions> resource manager (such as SQL Server 2005) can detect the existence of an ambient transaction created by the scope and automatically enlist.</span></span>  
  
## <a name="creating-a-transaction-scope"></a><span data-ttu-id="ce231-108">创建事务范围</span><span class="sxs-lookup"><span data-stu-id="ce231-108">Creating a transaction scope</span></span>  
 <span data-ttu-id="ce231-109">下面的示例演示 <xref:System.Transactions.TransactionScope> 类的简单用法。</span><span class="sxs-lookup"><span data-stu-id="ce231-109">The following sample shows a simple usage of the <xref:System.Transactions.TransactionScope> class.</span></span>  
  
 [!code-csharp[TransactionScope#1](../../../../samples/snippets/csharp/VS_Snippets_Remoting/TransactionScope/cs/ScopeWithSQL.cs#1)]
 [!code-vb[TransactionScope#1](../../../../samples/snippets/visualbasic/VS_Snippets_Remoting/TransactionScope/vb/ScopeWithSQL.vb#1)]  
  
 <span data-ttu-id="ce231-110">创建新<xref:System.Transactions.TransactionScope>的对象后, 将启动事务范围。</span><span class="sxs-lookup"><span data-stu-id="ce231-110">The transaction scope is started once you create a new <xref:System.Transactions.TransactionScope> object.</span></span>  <span data-ttu-id="ce231-111">如代码示例中所示, 建议使用**using**语句创建作用域。</span><span class="sxs-lookup"><span data-stu-id="ce231-111">As illustrated in the code sample, it is recommended that you create scopes with a **using** statement.</span></span> <span data-ttu-id="ce231-112">**Using**语句同时在C#和中 Visual Basic 可用, 其工作方式类似于**try ...finally**块, 以确保正确释放作用域。</span><span class="sxs-lookup"><span data-stu-id="ce231-112">The **using** statement is available both in C# and in Visual Basic, and works like a **try...finally** block to ensure that the scope is disposed of properly.</span></span>  
  
 <span data-ttu-id="ce231-113">在实例化 <xref:System.Transactions.TransactionScope> 时，事务管理器确定哪些事务参与进来。</span><span class="sxs-lookup"><span data-stu-id="ce231-113">When you instantiate <xref:System.Transactions.TransactionScope>, the transaction manager determines which transaction to participate in.</span></span> <span data-ttu-id="ce231-114">一旦确定，该范围将始终参与该事务。</span><span class="sxs-lookup"><span data-stu-id="ce231-114">Once determined, the scope always participates in that transaction.</span></span> <span data-ttu-id="ce231-115">决策基于两个因素: 是否存在环境事务以及构造函数中的**TransactionScopeOption**参数的值。</span><span class="sxs-lookup"><span data-stu-id="ce231-115">The decision is based on two factors: whether an ambient transaction is present and the value of the **TransactionScopeOption** parameter in the constructor.</span></span> <span data-ttu-id="ce231-116">环境事务是指在其中执行代码的事务。</span><span class="sxs-lookup"><span data-stu-id="ce231-116">The ambient transaction is the transaction within which your code executes.</span></span> <span data-ttu-id="ce231-117">可通过调用 <xref:System.Transactions.Transaction.Current%2A?displayProperty=nameWithType> 类的静态 <xref:System.Transactions.Transaction> 属性，获取对环境事务的引用。</span><span class="sxs-lookup"><span data-stu-id="ce231-117">You can obtain a reference to the ambient transaction by calling the static <xref:System.Transactions.Transaction.Current%2A?displayProperty=nameWithType> property of the <xref:System.Transactions.Transaction> class.</span></span> <span data-ttu-id="ce231-118">有关如何使用此参数的详细信息, 请参阅本主题的[使用 TransactionScopeOption 管理事务流](#ManageTxFlow)部分。</span><span class="sxs-lookup"><span data-stu-id="ce231-118">For more information on how this parameter is used, see the [Managing transaction flow using TransactionScopeOption](#ManageTxFlow) section of this topic.</span></span>  
  
## <a name="completing-a-transaction-scope"></a><span data-ttu-id="ce231-119">完成事务范围</span><span class="sxs-lookup"><span data-stu-id="ce231-119">Completing a transaction scope</span></span>  
 <span data-ttu-id="ce231-120">当应用程序完成它要在一个事务中执行的所有工作以后，您应当只调用一次 <xref:System.Transactions.TransactionScope.Complete%2A?displayProperty=nameWIthType> 方法，来通知事务管理器它可以提交事务。</span><span class="sxs-lookup"><span data-stu-id="ce231-120">When your application completes all the work it wants to perform in a transaction, you should call the <xref:System.Transactions.TransactionScope.Complete%2A?displayProperty=nameWIthType> method only once to inform the transaction manager that it is acceptable to commit the transaction.</span></span> <span data-ttu-id="ce231-121">将调用<xref:System.Transactions.TransactionScope.Complete%2A>作为**使用**块中的最后一个语句, 这是一个很好的做法。</span><span class="sxs-lookup"><span data-stu-id="ce231-121">It is very good practice to put the call to <xref:System.Transactions.TransactionScope.Complete%2A> as the last statement in the **using** block.</span></span>  
  
 <span data-ttu-id="ce231-122">未能调用此方法会中止事务, 因为事务管理器会将此解释为系统故障, 或等效于事务范围内引发的异常。</span><span class="sxs-lookup"><span data-stu-id="ce231-122">Failing to call this method aborts the transaction, because the transaction manager interprets this as a system failure, or equivalent to an exception thrown within the scope of the transaction.</span></span> <span data-ttu-id="ce231-123">但是，调用此方法并不保证会提交事务。</span><span class="sxs-lookup"><span data-stu-id="ce231-123">However, calling this method does not guarantee that the transaction wil be committed.</span></span> <span data-ttu-id="ce231-124">它只是一种将状态通知给事务管理器的方式。</span><span class="sxs-lookup"><span data-stu-id="ce231-124">It is merely a way of informing the transaction manager of your status.</span></span> <span data-ttu-id="ce231-125">调用 <xref:System.Transactions.TransactionScope.Complete%2A> 方法之后，就不能再通过 <xref:System.Transactions.Transaction.Current%2A> 属性访问环境事务，尝试这样做将会导致引发异常。</span><span class="sxs-lookup"><span data-stu-id="ce231-125">After calling the <xref:System.Transactions.TransactionScope.Complete%2A> method, you can no longer access the ambient transaction by using the <xref:System.Transactions.Transaction.Current%2A> property, and attempting to do so will result in an exception being thrown.</span></span>  
  
 <span data-ttu-id="ce231-126">如果对象最初创建了事务, 则事务管理器提交事务的实际工作将在 using 块中最后一个代码行之后发生。 <xref:System.Transactions.TransactionScope></span><span class="sxs-lookup"><span data-stu-id="ce231-126">If the <xref:System.Transactions.TransactionScope> object created the transaction initially, the actual work of committing the transaction by the transaction manager occurs after the last line of code in the **using** block.</span></span> <span data-ttu-id="ce231-127">如果该对象未创建事务，则每当 <xref:System.Transactions.CommittableTransaction.Commit%2A> 对象的所有者调用 <xref:System.Transactions.CommittableTransaction> 时都会执行提交。</span><span class="sxs-lookup"><span data-stu-id="ce231-127">If it did not create the transaction, the commit occurs whenever <xref:System.Transactions.CommittableTransaction.Commit%2A> is called by the owner of the <xref:System.Transactions.CommittableTransaction> object.</span></span> <span data-ttu-id="ce231-128">此时, 事务管理器将调用资源管理器, 并根据是否对该<xref:System.Transactions.TransactionScope.Complete%2A> <xref:System.Transactions.TransactionScope>对象调用了方法, 通知它们提交或回滚。</span><span class="sxs-lookup"><span data-stu-id="ce231-128">At that point the transaction manager calls the resource managers and informs them to either commit or rollback, based on whether the <xref:System.Transactions.TransactionScope.Complete%2A> method was called on the <xref:System.Transactions.TransactionScope> object.</span></span>  
  
 <span data-ttu-id="ce231-129">**Using**语句可确保即使发生<xref:System.Transactions.TransactionScope.Dispose%2A>异常, 也<xref:System.Transactions.TransactionScope>会调用该对象的方法。</span><span class="sxs-lookup"><span data-stu-id="ce231-129">The **using** statement ensures that the <xref:System.Transactions.TransactionScope.Dispose%2A> method of the <xref:System.Transactions.TransactionScope> object is called even if an exception occurs.</span></span> <span data-ttu-id="ce231-130"><xref:System.Transactions.TransactionScope.Dispose%2A> 方法标志着事务范围的结束。</span><span class="sxs-lookup"><span data-stu-id="ce231-130">The <xref:System.Transactions.TransactionScope.Dispose%2A> method marks the end of the transaction scope.</span></span> <span data-ttu-id="ce231-131">在调用此方法之后所发生的异常不会影响事务。</span><span class="sxs-lookup"><span data-stu-id="ce231-131">Exceptions that occur after calling this method may not affect the transaction.</span></span> <span data-ttu-id="ce231-132">此方法还将环境事务还原到其前一状态。</span><span class="sxs-lookup"><span data-stu-id="ce231-132">This method also restores the ambient transaction to it previous state.</span></span>  
  
 <span data-ttu-id="ce231-133">如果范围创建事务，则会引发 <xref:System.Transactions.TransactionAbortedException>，从而中止事务。</span><span class="sxs-lookup"><span data-stu-id="ce231-133">A <xref:System.Transactions.TransactionAbortedException> is thrown if the scope creates the transaction, and the transaction is aborted.</span></span> <span data-ttu-id="ce231-134">如果事务管理器无法做出提交决定，则会引发 <xref:System.Transactions.TransactionInDoubtException>。</span><span class="sxs-lookup"><span data-stu-id="ce231-134">A <xref:System.Transactions.TransactionInDoubtException> is thrown if the transaction manager cannot reach a Commit decision.</span></span> <span data-ttu-id="ce231-135">如果已提交事务，则不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="ce231-135">No exception is thrown if the transaction is committed.</span></span>  
  
## <a name="rolling-back-a-transaction"></a><span data-ttu-id="ce231-136">回滚事务</span><span class="sxs-lookup"><span data-stu-id="ce231-136">Rolling back a transaction</span></span>  
 <span data-ttu-id="ce231-137">如果要回滚事务，则不应在事务范围中调用 <xref:System.Transactions.TransactionScope.Complete%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="ce231-137">If you want to rollback a transaction, you should not call the <xref:System.Transactions.TransactionScope.Complete%2A> method within the transaction scope.</span></span> <span data-ttu-id="ce231-138">例如，可以在该范围中引发异常。</span><span class="sxs-lookup"><span data-stu-id="ce231-138">For example, you can throw an exception within the scope.</span></span> <span data-ttu-id="ce231-139">这样，就会回滚该范围所参与的事务。</span><span class="sxs-lookup"><span data-stu-id="ce231-139">The transaction in which it participates in will be rolled back.</span></span>  
  
## <a name="ManageTxFlow"></a><span data-ttu-id="ce231-140">使用 TransactionScopeOption 管理事务流</span><span class="sxs-lookup"><span data-stu-id="ce231-140">Managing transaction flow using TransactionScopeOption</span></span>  
 <span data-ttu-id="ce231-141">可通过调用一个方法来嵌套事务范围，该方法在使用其自己范围的方法中使用 <xref:System.Transactions.TransactionScope>，下面示例中的 `RootMethod` 方法就是前者这样的方法。</span><span class="sxs-lookup"><span data-stu-id="ce231-141">Transaction scope can be nested by calling a method that uses a <xref:System.Transactions.TransactionScope> from within a method that uses its own scope, as is the case with the `RootMethod` method in the following example,</span></span>  
  
```csharp  
void RootMethod()
{
    using(TransactionScope scope = new TransactionScope())
    {
        /* Perform transactional work here */
        SomeMethod();
        scope.Complete();
    }
}

void SomeMethod()
{
    using(TransactionScope scope = new TransactionScope())
    {
        /* Perform transactional work here */
        scope.Complete();
    }
}
```  
  
 <span data-ttu-id="ce231-142">最顶层事务范围称为根范围。</span><span class="sxs-lookup"><span data-stu-id="ce231-142">The top-most transaction scope is referred to as the root scope.</span></span>  
  
 <span data-ttu-id="ce231-143"><xref:System.Transactions.TransactionScope> 类提供了多个重载构造函数，它们接受 <xref:System.Transactions.TransactionScopeOption> 类型的枚举，而该枚举定义范围的事务行为。</span><span class="sxs-lookup"><span data-stu-id="ce231-143">The <xref:System.Transactions.TransactionScope> class provides several overloaded constructors that accept an enumeration of the type <xref:System.Transactions.TransactionScopeOption>, which defines the transactional behavior of the scope.</span></span>  
  
 <span data-ttu-id="ce231-144"><xref:System.Transactions.TransactionScope> 对象有以下三个选项：</span><span class="sxs-lookup"><span data-stu-id="ce231-144">A <xref:System.Transactions.TransactionScope> object has three options:</span></span>  
  
- <span data-ttu-id="ce231-145">联接环境事务，或者在环境事务不存在的情况下创建新的环境事务。</span><span class="sxs-lookup"><span data-stu-id="ce231-145">Join the ambient transaction, or create a new one if one does not exist.</span></span>  
  
- <span data-ttu-id="ce231-146">成为新的根范围，也就是说，启动一个新事务并使该事务成为其自己范围中的新环境事务。</span><span class="sxs-lookup"><span data-stu-id="ce231-146">Be a new root scope, that is, start a new transaction and have that transaction be the new ambient transaction inside its own scope.</span></span>  
  
- <span data-ttu-id="ce231-147">根本不参与事务。</span><span class="sxs-lookup"><span data-stu-id="ce231-147">Not take part in a transaction at all.</span></span> <span data-ttu-id="ce231-148">因此没有环境事务。</span><span class="sxs-lookup"><span data-stu-id="ce231-148">There is no ambient transaction as a result.</span></span>  
  
 <span data-ttu-id="ce231-149">如果用 <xref:System.Transactions.TransactionScopeOption.Required> 实例化范围并且存在环境事务，则该范围会联接该事务。</span><span class="sxs-lookup"><span data-stu-id="ce231-149">If the scope is instantiated with <xref:System.Transactions.TransactionScopeOption.Required>, and an ambient transaction is present, the scope joins that transaction.</span></span> <span data-ttu-id="ce231-150">相反，如果不存在环境事务，该范围就会创建新的事务并成为根范围。</span><span class="sxs-lookup"><span data-stu-id="ce231-150">If, on the other hand, there is no ambient transaction, then the scope creates a new transaction, and become the root scope.</span></span> <span data-ttu-id="ce231-151">这是默认值。</span><span class="sxs-lookup"><span data-stu-id="ce231-151">This is the default value.</span></span> <span data-ttu-id="ce231-152">在使用 <xref:System.Transactions.TransactionScopeOption.Required> 时，无论范围是根范围还是仅联接环境事务，该范围中的代码都不需要有不同的行为。</span><span class="sxs-lookup"><span data-stu-id="ce231-152">When <xref:System.Transactions.TransactionScopeOption.Required> is used, the code inside the scope does not need to behave differently whether it is the root or just joining the ambient transaction.</span></span> <span data-ttu-id="ce231-153">该代码在这两种情况下的行为应相同。</span><span class="sxs-lookup"><span data-stu-id="ce231-153">It should operate identically in both cases.</span></span>  
  
 <span data-ttu-id="ce231-154">如果用 <xref:System.Transactions.TransactionScopeOption.RequiresNew> 实例化范围，则它始终为根范围。</span><span class="sxs-lookup"><span data-stu-id="ce231-154">If the scope is instantiated with <xref:System.Transactions.TransactionScopeOption.RequiresNew>, it is always the root scope.</span></span> <span data-ttu-id="ce231-155">它会启动一个新事务，并且其事务成为该范围中的新环境事务。</span><span class="sxs-lookup"><span data-stu-id="ce231-155">It starts a new transaction, and its transaction becomes the new ambient transaction inside the scope.</span></span>  
  
 <span data-ttu-id="ce231-156">如果用 <xref:System.Transactions.TransactionScopeOption.Suppress> 实例化范围，则无论是否存在环境事务，范围都从不参与事务。</span><span class="sxs-lookup"><span data-stu-id="ce231-156">If the scope is instantiated with <xref:System.Transactions.TransactionScopeOption.Suppress>, it never takes part in a transaction, regardless of whether an ambient transaction is present.</span></span> <span data-ttu-id="ce231-157">使用此值实例化的范围始终具有**null**作为其环境事务。</span><span class="sxs-lookup"><span data-stu-id="ce231-157">A scope instantiated with this value always have **null** as its ambient transaction.</span></span>  
  
 <span data-ttu-id="ce231-158">下表概括了上述这些选项。</span><span class="sxs-lookup"><span data-stu-id="ce231-158">The above options are summarized in the following table.</span></span>  
  
|<span data-ttu-id="ce231-159">TransactionScopeOption</span><span class="sxs-lookup"><span data-stu-id="ce231-159">TransactionScopeOption</span></span>|<span data-ttu-id="ce231-160">参与环境事务</span><span class="sxs-lookup"><span data-stu-id="ce231-160">Ambient Transaction</span></span>|<span data-ttu-id="ce231-161">范围参与</span><span class="sxs-lookup"><span data-stu-id="ce231-161">The scope takes part in</span></span>|  
|----------------------------|-------------------------|-----------------------------|  
|<span data-ttu-id="ce231-162">必填</span><span class="sxs-lookup"><span data-stu-id="ce231-162">Required</span></span>|<span data-ttu-id="ce231-163">No</span><span class="sxs-lookup"><span data-stu-id="ce231-163">No</span></span>|<span data-ttu-id="ce231-164">参与新事务（将成为根范围）</span><span class="sxs-lookup"><span data-stu-id="ce231-164">New Transaction (will be the root)</span></span>|  
|<span data-ttu-id="ce231-165">Requires New</span><span class="sxs-lookup"><span data-stu-id="ce231-165">Requires New</span></span>|<span data-ttu-id="ce231-166">No</span><span class="sxs-lookup"><span data-stu-id="ce231-166">No</span></span>|<span data-ttu-id="ce231-167">参与新事务（将成为根范围）</span><span class="sxs-lookup"><span data-stu-id="ce231-167">New Transaction (will be the root)</span></span>|  
|<span data-ttu-id="ce231-168">Suppress</span><span class="sxs-lookup"><span data-stu-id="ce231-168">Suppress</span></span>|<span data-ttu-id="ce231-169">No</span><span class="sxs-lookup"><span data-stu-id="ce231-169">No</span></span>|<span data-ttu-id="ce231-170">不参与任何事务</span><span class="sxs-lookup"><span data-stu-id="ce231-170">No Transaction</span></span>|  
|<span data-ttu-id="ce231-171">必需</span><span class="sxs-lookup"><span data-stu-id="ce231-171">Required</span></span>|<span data-ttu-id="ce231-172">是</span><span class="sxs-lookup"><span data-stu-id="ce231-172">Yes</span></span>|<span data-ttu-id="ce231-173">参与环境事务</span><span class="sxs-lookup"><span data-stu-id="ce231-173">Ambient  Transaction</span></span>|  
|<span data-ttu-id="ce231-174">Requires New</span><span class="sxs-lookup"><span data-stu-id="ce231-174">Requires New</span></span>|<span data-ttu-id="ce231-175">是</span><span class="sxs-lookup"><span data-stu-id="ce231-175">Yes</span></span>|<span data-ttu-id="ce231-176">参与新事务（将成为根范围）</span><span class="sxs-lookup"><span data-stu-id="ce231-176">New Transaction (will be the root)</span></span>|  
|<span data-ttu-id="ce231-177">Suppress</span><span class="sxs-lookup"><span data-stu-id="ce231-177">Suppress</span></span>|<span data-ttu-id="ce231-178">是</span><span class="sxs-lookup"><span data-stu-id="ce231-178">Yes</span></span>|<span data-ttu-id="ce231-179">不参与任何事务</span><span class="sxs-lookup"><span data-stu-id="ce231-179">No Transaction</span></span>|  
  
 <span data-ttu-id="ce231-180">在 <xref:System.Transactions.TransactionScope> 对象联接现有环境事务时，除非范围中止该事务，否则释放范围对象的操作可能并不会结束事务。</span><span class="sxs-lookup"><span data-stu-id="ce231-180">When a <xref:System.Transactions.TransactionScope> object joins an existing ambient transaction, disposing of the scope object may not end the transaction, unless the scope aborts the transaction.</span></span> <span data-ttu-id="ce231-181">如果环境事务是由根范围创建的，则仅当释放根范围时，才会对事务调用 <xref:System.Transactions.CommittableTransaction.Commit%2A>。</span><span class="sxs-lookup"><span data-stu-id="ce231-181">If the ambient transaction was created by a root scope, only when the root scope is disposed of, does <xref:System.Transactions.CommittableTransaction.Commit%2A> get called on the transaction.</span></span> <span data-ttu-id="ce231-182">如果事务是手动创建的，则它将在中止或由其创建者提交时结束。</span><span class="sxs-lookup"><span data-stu-id="ce231-182">If the transaction was created manually, the transaction ends when it is either aborted, or committed by its creator.</span></span>  
  
 <span data-ttu-id="ce231-183">下面的示例演示一个 <xref:System.Transactions.TransactionScope> 对象，该对象创建了三个嵌套的范围对象，并用不同的 <xref:System.Transactions.TransactionScopeOption> 值对其中每个对象进行了实例化。</span><span class="sxs-lookup"><span data-stu-id="ce231-183">The following example shows a <xref:System.Transactions.TransactionScope> object that creates three nested scope objects, each instantiated with a different <xref:System.Transactions.TransactionScopeOption> value.</span></span>  
  
```csharp  
using(TransactionScope scope1 = new TransactionScope())
//Default is Required
{
    using(TransactionScope scope2 = new TransactionScope(TransactionScopeOption.Required))
    {
        //...
    }

    using(TransactionScope scope3 = new TransactionScope(TransactionScopeOption.RequiresNew))   
    {
        //...  
    }
  
    using(TransactionScope scope4 = new TransactionScope(TransactionScopeOption.Suppress))
    {
        //...  
    }
}
```  
  
 <span data-ttu-id="ce231-184">下面的示例演示一个不包含任何环境事务的代码块，它使用 `scope1` 创建了一个新范围 (<xref:System.Transactions.TransactionScopeOption.Required>)。</span><span class="sxs-lookup"><span data-stu-id="ce231-184">The example shows a code block without any ambient transaction creating a new scope (`scope1`) with <xref:System.Transactions.TransactionScopeOption.Required>.</span></span> <span data-ttu-id="ce231-185">范围 `scope1` 是根范围，因为它创建了一个新事务（事务 A），并使事务 A 成为环境事务。</span><span class="sxs-lookup"><span data-stu-id="ce231-185">The scope `scope1` is a root scope as it creates a new transaction (Transaction A) and makes Transaction A the ambient transaction.</span></span> <span data-ttu-id="ce231-186">`Scope1`然后再创建三个对象, 每个对象<xref:System.Transactions.TransactionScopeOption>具有不同的值。</span><span class="sxs-lookup"><span data-stu-id="ce231-186">`Scope1` then creates three more objects, each with a different <xref:System.Transactions.TransactionScopeOption> value.</span></span> <span data-ttu-id="ce231-187">例如，`scope2` 是用 <xref:System.Transactions.TransactionScopeOption.Required> 创建的；由于存在环境事务，因此该范围联接 `scope1` 所创建的第一个事务。</span><span class="sxs-lookup"><span data-stu-id="ce231-187">For example, `scope2` is created with <xref:System.Transactions.TransactionScopeOption.Required>, and since there is an ambient transaction, it joins the first transaction created by `scope1`.</span></span> <span data-ttu-id="ce231-188">请注意，`scope3` 是新事务的根范围，而 `scope4` 则没有环境事务。</span><span class="sxs-lookup"><span data-stu-id="ce231-188">Note that `scope3` is the root scope of a new transaction, and that `scope4` has no ambient transaction.</span></span>  
  
 <span data-ttu-id="ce231-189">虽然 <xref:System.Transactions.TransactionScopeOption> 的默认值和最常用的值是 <xref:System.Transactions.TransactionScopeOption.Required>，但其他各值都有其独有的用途。</span><span class="sxs-lookup"><span data-stu-id="ce231-189">Although the default and most commonly used value of <xref:System.Transactions.TransactionScopeOption> is <xref:System.Transactions.TransactionScopeOption.Required>, each of the other values has its unique purpose.</span></span>  

### <a name="non-transactional-code-inside-a-transaction-scope"></a><span data-ttu-id="ce231-190">事务范围内的非事务性代码</span><span class="sxs-lookup"><span data-stu-id="ce231-190">Non-transactional code inside a transaction scope</span></span>

 <span data-ttu-id="ce231-191"><xref:System.Transactions.TransactionScopeOption.Suppress>如果要保留代码部分执行的操作, 并且不希望在操作失败的情况下中止环境事务, 则会很有用。</span><span class="sxs-lookup"><span data-stu-id="ce231-191"><xref:System.Transactions.TransactionScopeOption.Suppress> is useful when you want to preserve the operations performed by the code section, and do not want to abort the ambient transaction if the operations fail.</span></span> <span data-ttu-id="ce231-192">例如，在要执行日志记录或审核操作时，或者在无论环境事务提交还是中止都要将事件发布给订户时。</span><span class="sxs-lookup"><span data-stu-id="ce231-192">For example, when you want to perform logging or audit operations, or when you want to publish events to subscribers regardless of whether your ambient transaction commits or aborts.</span></span> <span data-ttu-id="ce231-193">使用此值，可以在事务范围中包含非事务代码段，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="ce231-193">This value allows you to have a non-transactional code section inside a transaction scope, as shown in the following example.</span></span>  
  
```csharp  
using(TransactionScope scope1 = new TransactionScope())
{
    try
    {
        //Start of non-transactional section
        using(TransactionScope scope2 = new
            TransactionScope(TransactionScopeOption.Suppress))  
        {  
            //Do non-transactional work here  
        }  
        //Restores ambient transaction here
   }
   catch {}  
   //Rest of scope1
}
```  
  
### <a name="voting-inside-a-nested-scope"></a><span data-ttu-id="ce231-194">在嵌套范围中投票</span><span class="sxs-lookup"><span data-stu-id="ce231-194">Voting inside a nested scope</span></span>  
 <span data-ttu-id="ce231-195">虽然嵌套范围可联接根范围的环境事务，但在嵌套范围中调用 <xref:System.Transactions.TransactionScope.Complete%2A> 对根范围没有影响。</span><span class="sxs-lookup"><span data-stu-id="ce231-195">Although a nested scope can join the ambient transaction of the root scope, calling <xref:System.Transactions.TransactionScope.Complete%2A> in the nested scope has no affect on the root scope.</span></span> <span data-ttu-id="ce231-196">仅当从根范围到最后一个嵌套范围的所有范围都投票决定提交事务时，才会提交该事务。</span><span class="sxs-lookup"><span data-stu-id="ce231-196">Only if all the scopes from the root scope down to the last nested scope vote to commit the transaction, will the transaction be committed.</span></span> <span data-ttu-id="ce231-197">由于环境事务将立即中止，因此嵌套范围中的 <xref:System.Transactions.TransactionScope.Complete%2A> 调用并不全都会影响根范围。</span><span class="sxs-lookup"><span data-stu-id="ce231-197">Not calling <xref:System.Transactions.TransactionScope.Complete%2A> in a nested scope will affect the root scope as the ambient transaction will immediately be aborted.</span></span>  
  
## <a name="setting-the-transactionscope-timeout"></a><span data-ttu-id="ce231-198">设置 TransactionScope 超时</span><span class="sxs-lookup"><span data-stu-id="ce231-198">Setting the TransactionScope timeout</span></span>  
 <span data-ttu-id="ce231-199"><xref:System.Transactions.TransactionScope> 的有些重载构造函数接受 <xref:System.TimeSpan> 类型的值，该值用于控制事务的超时。</span><span class="sxs-lookup"><span data-stu-id="ce231-199">Some of the overloaded constructors of <xref:System.Transactions.TransactionScope> accept a value of type <xref:System.TimeSpan>, which is used to control the timeout of the transaction.</span></span> <span data-ttu-id="ce231-200">超时设置为零时表示超时无限长。</span><span class="sxs-lookup"><span data-stu-id="ce231-200">A timeout set to zero means an infinite timeout.</span></span> <span data-ttu-id="ce231-201">无限长的超时主要对调试有用，调试过程中可能要经由逐句通过代码来隔离业务逻辑中的问题，并且在尝试确定问题期间不希望所调试的事务超时。</span><span class="sxs-lookup"><span data-stu-id="ce231-201">Infinite timeout is useful mostly for debugging, when you want to isolate a problem in your business logic by stepping through your code, and you do not want the transaction you debug to time out while you attempt to locate the problem.</span></span> <span data-ttu-id="ce231-202">在所有其他情况下使用无限长的超时时一定要格外小心，因为它会覆盖防止事务死锁的保护。</span><span class="sxs-lookup"><span data-stu-id="ce231-202">Be extremely careful using the infinite timeout value in all other cases, because it overrides the safeguards against transaction deadlocks.</span></span>  
  
 <span data-ttu-id="ce231-203"><xref:System.Transactions.TransactionScope> 超时值通常设置为以下两种情况下的默认值之外的值。</span><span class="sxs-lookup"><span data-stu-id="ce231-203">You typically set the <xref:System.Transactions.TransactionScope> timeout to values other than default in two cases.</span></span> <span data-ttu-id="ce231-204">第一种情况是在开发期间要测试应用程序处理中止事务的方式时。</span><span class="sxs-lookup"><span data-stu-id="ce231-204">The first is during development, when you want to test the way your application handles aborted transactions.</span></span> <span data-ttu-id="ce231-205">将超时值设置为较小值（如 1 毫秒）时，会导致事务失败，因而会看到错误处理代码。</span><span class="sxs-lookup"><span data-stu-id="ce231-205">By setting the timeout to a small value (such as one millisecond), you cause your transaction to fail and can thus observe your error handling code.</span></span> <span data-ttu-id="ce231-206">将超时值设置为小于默认超时值的第二种情况是：认为在导致死锁的资源争用中涉及到范围时。</span><span class="sxs-lookup"><span data-stu-id="ce231-206">The second case in which you set the value to be less than the default timeout is when you believe that the scope is involved in resource contention, resulting in deadlocks.</span></span> <span data-ttu-id="ce231-207">在这种情况下，需要尽快地中止事务，而不能等到达到默认超时值。</span><span class="sxs-lookup"><span data-stu-id="ce231-207">In that case, you want to abort the transaction as soon as possible and not wait for the default timeout to expire.</span></span>  
  
 <span data-ttu-id="ce231-208">在范围联接环境事务但所指定的超时值小于为该环境事务所设置的超时值时，会在 <xref:System.Transactions.TransactionScope> 对象上强制实施较小的超时值，并且该范围必须在指定的嵌套时间内结束，否则会自动中止事务。</span><span class="sxs-lookup"><span data-stu-id="ce231-208">When a scope joins an ambient transaction but specifies a smaller timeout than the one the ambient transaction is set to, the new, shorter timeout is enforced on the <xref:System.Transactions.TransactionScope> object, and the scope must end within the nested time specified, or the transaction is automatically aborted.</span></span> <span data-ttu-id="ce231-209">如果嵌套范围的超时值大于环境事务的超时值，则前者无效。</span><span class="sxs-lookup"><span data-stu-id="ce231-209">If the nested scope's timeout is more than that of the ambient transaction, it has no effect.</span></span>  
  
## <a name="setting-the-transactionscope-isolation-level"></a><span data-ttu-id="ce231-210">设置 TransactionScope 隔离级别</span><span class="sxs-lookup"><span data-stu-id="ce231-210">Setting the TransactionScope isolation level</span></span>  
 <span data-ttu-id="ce231-211">除超时值之外，<xref:System.Transactions.TransactionScope> 的有些重载构造函数还接受 <xref:System.Transactions.TransactionOptions> 类型的结构，用于指定隔离级别。</span><span class="sxs-lookup"><span data-stu-id="ce231-211">Some of the overloaded constructors of <xref:System.Transactions.TransactionScope> accept a structure of type <xref:System.Transactions.TransactionOptions> to specify an isolation level, in addition to a timeout value.</span></span> <span data-ttu-id="ce231-212">默认情况下，事务在隔离级别设置为 <xref:System.Transactions.IsolationLevel.Serializable> 的情况下执行。</span><span class="sxs-lookup"><span data-stu-id="ce231-212">By default, the transaction executes with isolation level set to <xref:System.Transactions.IsolationLevel.Serializable>.</span></span> <span data-ttu-id="ce231-213">通常对频繁执行读取的系统选择 <xref:System.Transactions.IsolationLevel.Serializable> 之外的隔离级别。</span><span class="sxs-lookup"><span data-stu-id="ce231-213">Selecting an isolation level other than <xref:System.Transactions.IsolationLevel.Serializable> is commonly used for read-intensive systems.</span></span> <span data-ttu-id="ce231-214">这需要全面地了解事务处理理论、事务本身的语义、所涉及的并发问题以及系统一致性的结果。</span><span class="sxs-lookup"><span data-stu-id="ce231-214">This requires a solid understanding of transaction processing theory and the semantics of the transaction itself, the concurrency issues involved, and the consequences for system consistency.</span></span>  
  
 <span data-ttu-id="ce231-215">此外，并不是所有的资源管理器都支持所有的隔离级别，并且它们可选择参与高于所配置级别的事务。</span><span class="sxs-lookup"><span data-stu-id="ce231-215">In addition, not all resource managers support all levels of isolation, and they may elect to take part in the transaction at a higher level than the one configured.</span></span>  
  
 <span data-ttu-id="ce231-216">除 <xref:System.Transactions.IsolationLevel.Serializable> 之外的所有级别都容易因其他事务访问相同的信息而产生不一致问题。</span><span class="sxs-lookup"><span data-stu-id="ce231-216">Every isolation level besides <xref:System.Transactions.IsolationLevel.Serializable> is susceptible to inconsistency resulting from other transactions accessing the same information.</span></span> <span data-ttu-id="ce231-217">不同隔离级别之间的差异在于它们使用读取和写入锁定的方式。</span><span class="sxs-lookup"><span data-stu-id="ce231-217">The difference between the different isolation levels is in the way read and write locks are used.</span></span> <span data-ttu-id="ce231-218">可在事务访问资源管理器中的数据时保持锁定，也可在提交或中止事务之前保持锁定。</span><span class="sxs-lookup"><span data-stu-id="ce231-218">A lock can be held only when the transaction accesses the data in the resource manager, or it can be held until the transaction is committed or aborted.</span></span> <span data-ttu-id="ce231-219">从吞吐量的角度来说，前者比较适合；而从一致性角度来说，后者比较适合。</span><span class="sxs-lookup"><span data-stu-id="ce231-219">The former is better for throughput, the latter for consistency.</span></span> <span data-ttu-id="ce231-220">这两种锁定和两种操作（读取/写入）提供了四种基本隔离级别。</span><span class="sxs-lookup"><span data-stu-id="ce231-220">The two kinds of locks and the two kinds of operations (read/write) give four basic isolation levels.</span></span> <span data-ttu-id="ce231-221">有关更多信息，请参见<xref:System.Transactions.IsolationLevel>。</span><span class="sxs-lookup"><span data-stu-id="ce231-221">See <xref:System.Transactions.IsolationLevel> for more information.</span></span>  
  
 <span data-ttu-id="ce231-222">在使用嵌套的 <xref:System.Transactions.TransactionScope> 对象时，如果要联接环境事务，则必须将所有嵌套范围配置为使用完全相同的隔离级别。</span><span class="sxs-lookup"><span data-stu-id="ce231-222">When using nested <xref:System.Transactions.TransactionScope> objects, all nested scopes must be configured to use exactly the same isolation level if they want to join the ambient transaction.</span></span> <span data-ttu-id="ce231-223">如果嵌套的 <xref:System.Transactions.TransactionScope> 对象尝试联接环境事务但却指定了不同的隔离级别，则会引发 <xref:System.ArgumentException>。</span><span class="sxs-lookup"><span data-stu-id="ce231-223">If a nested <xref:System.Transactions.TransactionScope> object tries to join the ambient transaction yet it specifies a different isolation level, an <xref:System.ArgumentException> is thrown.</span></span>  
  
## <a name="interop-with-com"></a><span data-ttu-id="ce231-224">与 COM+ 交互</span><span class="sxs-lookup"><span data-stu-id="ce231-224">Interop with COM+</span></span>  
 <span data-ttu-id="ce231-225">在创建新的 <xref:System.Transactions.TransactionScope> 实例时，可以在某一构造函数中使用 <xref:System.Transactions.EnterpriseServicesInteropOption> 枚举来指定与 COM+ 交互的方式。</span><span class="sxs-lookup"><span data-stu-id="ce231-225">When you create a new <xref:System.Transactions.TransactionScope> instance, you can use the <xref:System.Transactions.EnterpriseServicesInteropOption> enumeration in one of the constructors to specify how to interact with COM+.</span></span> <span data-ttu-id="ce231-226">有关此操作的详细信息, 请参阅[与企业服务和 COM + 事务的互操作性](interoperability-with-enterprise-services-and-com-transactions.md)。</span><span class="sxs-lookup"><span data-stu-id="ce231-226">For more information on this, see [Interoperability with Enterprise Services and COM+ Transactions](interoperability-with-enterprise-services-and-com-transactions.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="ce231-227">请参阅</span><span class="sxs-lookup"><span data-stu-id="ce231-227">See also</span></span>

- <xref:System.Transactions.Transaction.Clone%2A>
- <xref:System.Transactions.TransactionScope>
