---
title: XAML 安全注意事项
ms.date: 03/30/2017
helpviewer_keywords:
- security [XAML Services], .NET XAML services
- XAML security [XAML Services]
ms.assetid: 544296d4-f38e-4498-af49-c9f4dad28964
ms.openlocfilehash: 124310497cc2a8e8a816ba90b2c68a16ed342ae6
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/22/2019
ms.locfileid: "59973435"
---
# <a name="xaml-security-considerations"></a><span data-ttu-id="444bd-102">XAML 安全注意事项</span><span class="sxs-lookup"><span data-stu-id="444bd-102">XAML Security Considerations</span></span>
<span data-ttu-id="444bd-103">本主题介绍在应用程序中安全性的最佳做法，当您使用 XAML 和.NET Framework XAML 服务 API。</span><span class="sxs-lookup"><span data-stu-id="444bd-103">This topic describes best practices for security in applications when you use XAML and .NET Framework XAML Services API.</span></span>  
  
## <a name="untrusted-xaml-in-applications"></a><span data-ttu-id="444bd-104">在应用程序中不受信任的 XAML</span><span class="sxs-lookup"><span data-stu-id="444bd-104">Untrusted XAML in Applications</span></span>  
 <span data-ttu-id="444bd-105">在最常规的意义上，不受信任的 XAML 是你的应用程序不是专门未包括或发出任何 XAML 源。</span><span class="sxs-lookup"><span data-stu-id="444bd-105">In the most general sense, untrusted XAML is any XAML source that your application did not specifically include or emit.</span></span>  
  
 <span data-ttu-id="444bd-106">XAML 是编译为或存储为`resx`-类型受信任且经过签名的程序集内的资源不是本质上是不受信任。</span><span class="sxs-lookup"><span data-stu-id="444bd-106">XAML that is compiled into or stored as a `resx`-type resource within a trusted and signed assembly is not inherently untrusted.</span></span> <span data-ttu-id="444bd-107">为您信任的程序集作为一个整体，您可以信任 XAML。</span><span class="sxs-lookup"><span data-stu-id="444bd-107">You can trust the XAML as much as you trust the assembly as a whole.</span></span> <span data-ttu-id="444bd-108">在大多数情况下，你是只关心松散 XAML，这是从流或其他 I/O 加载的 XAML 源的信任方面。</span><span class="sxs-lookup"><span data-stu-id="444bd-108">In most cases, you are only concerned with the trust aspects of loose XAML, which is a XAML source that you load from a stream or other I/O.</span></span> <span data-ttu-id="444bd-109">松散 XAML 不是特定的组件或功能的部署和打包基础结构的应用程序模型。</span><span class="sxs-lookup"><span data-stu-id="444bd-109">Loose XAML is not a specific component or feature of an application model with a deployment and packaging infrastructure.</span></span> <span data-ttu-id="444bd-110">但是，程序集可能会实现涉及加载松散 XAML 的行为。</span><span class="sxs-lookup"><span data-stu-id="444bd-110">However, an assembly might implement a behavior that involves loading loose XAML.</span></span>  
  
 <span data-ttu-id="444bd-111">有关不受信任的 XAML，您应该像通常相同，就好像不受信任的代码。</span><span class="sxs-lookup"><span data-stu-id="444bd-111">For untrusted XAML, you should treat it generally the same as if it were untrusted code.</span></span> <span data-ttu-id="444bd-112">使用沙盒或其他形式来阻止访问受信任的代码可能不受信任的 XAML。</span><span class="sxs-lookup"><span data-stu-id="444bd-112">Use sandboxing or other metaphors to prevent possibly untrusted XAML from accessing your trusted code.</span></span>  
  
 <span data-ttu-id="444bd-113">XAML 功能的特性提供 XAML 构造对象和设置其属性的权限。</span><span class="sxs-lookup"><span data-stu-id="444bd-113">The nature of XAML capabilities gives the XAML the right to construct objects and set their properties.</span></span> <span data-ttu-id="444bd-114">这些功能还包括访问映射和访问应用程序域中的程序集使用标记扩展的类型转换器`x:Code`块，依次类推。</span><span class="sxs-lookup"><span data-stu-id="444bd-114">These capabilities also include accessing type converters, mapping and accessing assemblies in the application domain, using markup extensions, `x:Code` blocks, and so on.</span></span>  
  
 <span data-ttu-id="444bd-115">除了其语言级别功能，XAML 用于用户界面定义中的许多技术。</span><span class="sxs-lookup"><span data-stu-id="444bd-115">In addition to its language-level capabilities, XAML is used for UI definition in many technologies.</span></span> <span data-ttu-id="444bd-116">正在加载不受信任的 XAML 可能意味着加载恶意电子欺骗用户界面。</span><span class="sxs-lookup"><span data-stu-id="444bd-116">Loading untrusted XAML might mean loading a malicious spoofing UI.</span></span>  
  
## <a name="sharing-context-between-readers-and-writers"></a><span data-ttu-id="444bd-117">共享读取器和编写器之间的上下文</span><span class="sxs-lookup"><span data-stu-id="444bd-117">Sharing Context Between Readers and Writers</span></span>  
 <span data-ttu-id="444bd-118">XAML 读取器和 XAML 编写器的.NET Framework XAML 服务体系结构通常要求共享到 XAML 编写器或共享的 XAML 架构上下文的 XAML 读取器。</span><span class="sxs-lookup"><span data-stu-id="444bd-118">The .NET Framework XAML Services architecture for XAML readers and XAML writers often requires sharing a XAML reader to a XAML writer, or a shared XAML schema context.</span></span> <span data-ttu-id="444bd-119">如果你正在编写 XAML 节点循环逻辑，或者提供自定义保存路径可能需要共享的对象或上下文。</span><span class="sxs-lookup"><span data-stu-id="444bd-119">Sharing objects or contexts might be required if you are writing XAML node loop logic, or providing a custom save path.</span></span> <span data-ttu-id="444bd-120">不应共享 XAML 读取器实例、 非默认 XAML 架构上下文或受信任和不受信任代码之间的 XAML 读取器/编写器类的设置。</span><span class="sxs-lookup"><span data-stu-id="444bd-120">You should not share XAML reader instances, nondefault XAML schema context, or settings for XAML reader/writer classes between trusted and untrusted code.</span></span>  
  
 <span data-ttu-id="444bd-121">大多数方案和涉及 XAML 对象编写的基于 CLR 的类型支持的操作可以只使用默认 XAML 架构上下文。</span><span class="sxs-lookup"><span data-stu-id="444bd-121">Most scenarios and operations involving XAML object writing for a CLR-based type backing can just use default XAML schema context.</span></span> <span data-ttu-id="444bd-122">默认 XAML 架构上下文未显式包含可能会危害完全信任的设置。</span><span class="sxs-lookup"><span data-stu-id="444bd-122">The default XAML schema context does not explicitly include settings that could compromise full trust.</span></span> <span data-ttu-id="444bd-123">因此，它是安全地共享受信任和不受信任的 XAML 读取器/编写器组件之间的上下文。</span><span class="sxs-lookup"><span data-stu-id="444bd-123">It is thus safe to share context between trusted and untrusted XAML reader/writer components.</span></span> <span data-ttu-id="444bd-124">但是，如果执行此操作时，它仍是最佳的做法是尽量在单独的此类的阅读器和编写器<xref:System.AppDomain>作用域，使用专用于/进行沙盒处理以部分信任的其中之一。</span><span class="sxs-lookup"><span data-stu-id="444bd-124">However, if you do this, it is still a best practice to keep such readers and writers in separate <xref:System.AppDomain> scopes, with one of them specifically intended/sandboxed for partial trust.</span></span>  
  
## <a name="xaml-namespaces-and-assembly-trust"></a><span data-ttu-id="444bd-125">XAML 命名空间和程序集信任</span><span class="sxs-lookup"><span data-stu-id="444bd-125">XAML Namespaces and Assembly Trust</span></span>  
 <span data-ttu-id="444bd-126">受信任和不受信任程序集加载到应用程序域之间没有区别的基本的非限定的语法和 XAML 如何解释到程序集的自定义 XAML 命名空间映射的定义。</span><span class="sxs-lookup"><span data-stu-id="444bd-126">The basic unqualified syntax and definition for how XAML interprets a custom XAML namespace mapping to an assembly does not distinguish between a trusted and untrusted assembly as loaded into the application domain.</span></span> <span data-ttu-id="444bd-127">因此，它是从技术上讲可能不受信任的程序集以欺骗受信任的程序集的预期的 XAML 命名空间映射，并捕获 XAML 源的声明的对象和属性信息。</span><span class="sxs-lookup"><span data-stu-id="444bd-127">Thus, it is technically possible for an untrusted assembly to spoof a trusted assembly's intended XAML namespace mapping and capture a XAML source's declared object and property information.</span></span> <span data-ttu-id="444bd-128">如果你有安全需求，从而避免这种情况下，应当生成预期的 XAML 命名空间映射，使用以下方法之一：</span><span class="sxs-lookup"><span data-stu-id="444bd-128">If you have security requirements to avoid this situation, your intended XAML namespace mapping should be made using one of the following techniques:</span></span>  
  
-   <span data-ttu-id="444bd-129">具有强名称，在任何 XAML 命名空间映射中所做的应用程序的 XAML 中使用完全限定的程序集的名称。</span><span class="sxs-lookup"><span data-stu-id="444bd-129">Use a fully qualified assembly name with strong name in any XAML namespace mapping made by your application's XAML.</span></span>  
  
-   <span data-ttu-id="444bd-130">限制程序集映射到一组固定的引用程序集，通过构造特定<xref:System.Xaml.XamlSchemaContext>在 XAML 读取器和 XAML 对象编写器。</span><span class="sxs-lookup"><span data-stu-id="444bd-130">Restrict assembly mapping to a fixed set of reference assemblies, by constructing a specific <xref:System.Xaml.XamlSchemaContext> for your XAML readers and XAML object writers.</span></span> <span data-ttu-id="444bd-131">请参阅 <xref:System.Xaml.XamlSchemaContext.%23ctor%28System.Collections.Generic.IEnumerable%7BSystem.Reflection.Assembly%7D%29>。</span><span class="sxs-lookup"><span data-stu-id="444bd-131">See <xref:System.Xaml.XamlSchemaContext.%23ctor%28System.Collections.Generic.IEnumerable%7BSystem.Reflection.Assembly%7D%29>.</span></span>  
  
## <a name="xaml-type-mapping-and-type-system-access"></a><span data-ttu-id="444bd-132">XAML 类型映射和类型系统访问</span><span class="sxs-lookup"><span data-stu-id="444bd-132">XAML Type Mapping and Type System Access</span></span>  
 <span data-ttu-id="444bd-133">XAML 支持其自己的类型系统，这在许多方面与 CLR 如何实现基本的 CLR 类型系统对等。</span><span class="sxs-lookup"><span data-stu-id="444bd-133">XAML supports its own type system, which in many ways is a peer to how CLR implements the basic CLR type system.</span></span> <span data-ttu-id="444bd-134">但是，您将基于其类型信息的类型的信任决定的类型意识的某些方面，您应延迟到 CLR 后备类型中的类型信息。</span><span class="sxs-lookup"><span data-stu-id="444bd-134">However, for certain aspects of type awareness where you are making trust decisions about a type based on its type information, you should defer to the type information in the CLR backing types.</span></span> <span data-ttu-id="444bd-135">这是因为某些 XAML 类型系统的特定报告功能均保持打开状态作为虚拟方法，因此，不完全受控制的原始的.NET Framework XAML 服务实现。</span><span class="sxs-lookup"><span data-stu-id="444bd-135">This is because some of the specific reporting capabilities of the XAML type system are left open as virtual methods and are therefore, not fully under the control of the original .NET Framework XAML Services implementations.</span></span> <span data-ttu-id="444bd-136">这些扩展点存在，因为 XAML 类型系统是可扩展的使之与 XAML 本身的可扩展性和与使用默认 CLR 支持实现和默认 XAML 架构上下文及其可能的替代类型映射策略。</span><span class="sxs-lookup"><span data-stu-id="444bd-136">These extensibility points exist because the XAML type system is extensible, to match the extensibility of XAML itself and its possible alternative type-mapping strategies versus the default CLR-backed implementation and default XAML schema context.</span></span> <span data-ttu-id="444bd-137">详细信息，请参阅特定说明多个的属性上<xref:System.Xaml.XamlType>和<xref:System.Xaml.XamlMember>。</span><span class="sxs-lookup"><span data-stu-id="444bd-137">For more information, see the specific notes on several of the properties of <xref:System.Xaml.XamlType> and <xref:System.Xaml.XamlMember>.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="444bd-138">请参阅</span><span class="sxs-lookup"><span data-stu-id="444bd-138">See also</span></span>

- <xref:System.Xaml.Permissions.XamlAccessLevel>
