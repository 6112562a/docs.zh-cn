---
title: 定义与 .NET Framework XAML 服务一起使用的自定义类型
ms.date: 03/30/2017
helpviewer_keywords:
- defining custom types [XAML Services]
ms.assetid: c2667cbd-2f46-4a7f-9dfc-53696e35e8e4
ms.openlocfilehash: be9c0e26574a15279ce89af2c7862abaa8713360
ms.sourcegitcommit: 0be8a279af6d8a43e03141e349d3efd5d35f8767
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/18/2019
ms.locfileid: "59164432"
---
# <a name="defining-custom-types-for-use-with-net-framework-xaml-services"></a><span data-ttu-id="ddda7-102">定义与 .NET Framework XAML 服务一起使用的自定义类型</span><span class="sxs-lookup"><span data-stu-id="ddda7-102">Defining Custom Types for Use with .NET Framework XAML Services</span></span>
<span data-ttu-id="ddda7-103">当您定义了业务对象的自定义类型或不在特定框架上具有依赖项的类型时，有的 XAML 可以按照某些最佳实践。</span><span class="sxs-lookup"><span data-stu-id="ddda7-103">When you define custom types that are business objects or are types that do not have a dependency on specific frameworks, there are certain best practices for XAML you can follow.</span></span> <span data-ttu-id="ddda7-104">如果您遵循这些实践，.NET Framework XAML 服务及其 XAML 读取器和 XAML 编写器可以发现你的类型的 XAML 特征，并为其适当 XAML 节点流使用的 XAML 类型系统中的表示形式。</span><span class="sxs-lookup"><span data-stu-id="ddda7-104">If you follow these practices, .NET Framework XAML Services and its XAML readers and XAML writers can discover the XAML characteristics of your type and give it appropriate representation in a XAML node stream using the XAML type system.</span></span> <span data-ttu-id="ddda7-105">本主题介绍类型定义、 成员定义和 CLR 类型或成员的特性化最佳的实践。</span><span class="sxs-lookup"><span data-stu-id="ddda7-105">This topic describes best practices for type definitions, member definitions, and CLR attributing of types or members.</span></span>  
  
## <a name="constructor-patterns-and-type-definitions-for-xaml"></a><span data-ttu-id="ddda7-106">构造函数模式和 XAML 的类型定义</span><span class="sxs-lookup"><span data-stu-id="ddda7-106">Constructor Patterns and Type Definitions for XAML</span></span>  
 <span data-ttu-id="ddda7-107">若要实例化成对象元素在 XAML 中，自定义类必须满足以下要求：</span><span class="sxs-lookup"><span data-stu-id="ddda7-107">To be instantiated as an object element in XAML, a custom class must meet the following requirements:</span></span>  
  
-   <span data-ttu-id="ddda7-108">自定义类必须是公共的并且必须公开默认 （无参数） 公共构造函数。</span><span class="sxs-lookup"><span data-stu-id="ddda7-108">The custom class must be public and must expose a default (parameterless) public constructor.</span></span> <span data-ttu-id="ddda7-109">（有关结构注释，请参阅下节内容。）</span><span class="sxs-lookup"><span data-stu-id="ddda7-109">(See following section for notes regarding structures.)</span></span>  
  
-   <span data-ttu-id="ddda7-110">自定义类不得为嵌套的类。</span><span class="sxs-lookup"><span data-stu-id="ddda7-110">The custom class must not be a nested class.</span></span> <span data-ttu-id="ddda7-111">额外的完整名称路径中的"dot"使类命名空间划分不明确的并且会干扰其他 XAML 功能，例如附加属性。</span><span class="sxs-lookup"><span data-stu-id="ddda7-111">The extra "dot" in the full-name path makes the class-namespace division ambiguous, and interferes with other XAML features such as attached properties.</span></span>  
  
 <span data-ttu-id="ddda7-112">如果为对象元素，可以实例化一个对象，所创建的对象可以填充属性元素将该对象作为其基础类型的任何属性的形式。</span><span class="sxs-lookup"><span data-stu-id="ddda7-112">If an object can be instantiated as an object element, the created object can fill the property element form of any properties that take the object as their underlying type.</span></span>  
  
 <span data-ttu-id="ddda7-113">如果启用了值转换器，仍可以为不符合这些条件的类型提供对象值。</span><span class="sxs-lookup"><span data-stu-id="ddda7-113">You can still provide object values for types that do not meet these criteria, if you enable a value converter.</span></span> <span data-ttu-id="ddda7-114">有关详细信息，请参阅[Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions-for-xaml.md)。</span><span class="sxs-lookup"><span data-stu-id="ddda7-114">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions-for-xaml.md).</span></span>  
  
### <a name="structures"></a><span data-ttu-id="ddda7-115">结构</span><span class="sxs-lookup"><span data-stu-id="ddda7-115">Structures</span></span>  
 <span data-ttu-id="ddda7-116">结构永远是能够在 XAML 中，通过 CLR 定义构造的。</span><span class="sxs-lookup"><span data-stu-id="ddda7-116">Structures are always able to be constructed in XAML, by CLR definition.</span></span> <span data-ttu-id="ddda7-117">这是因为 CLR 编译器隐式创建一个结构的默认构造函数。</span><span class="sxs-lookup"><span data-stu-id="ddda7-117">This is because a CLR compiler implicitly creates a default constructor for a structure.</span></span> <span data-ttu-id="ddda7-118">此构造函数初始化为其默认值的所有属性值。</span><span class="sxs-lookup"><span data-stu-id="ddda7-118">This constructor initializes all property values to their defaults.</span></span>  
  
 <span data-ttu-id="ddda7-119">在某些情况下，一种结构的默认构造行为是不可取。</span><span class="sxs-lookup"><span data-stu-id="ddda7-119">In some cases, the default construction behavior for a structure is not desirable.</span></span> <span data-ttu-id="ddda7-120">这可能是因为结构旨在填补值和函数在概念上作为联合。</span><span class="sxs-lookup"><span data-stu-id="ddda7-120">This might be because the structure is intended to fill values and function conceptually as a union.</span></span> <span data-ttu-id="ddda7-121">作为一个联合，所含的值可能具有互斥的解释，并因此，其属性都是不可设置。</span><span class="sxs-lookup"><span data-stu-id="ddda7-121">As a union, the contained values might have mutually exclusive interpretations, and therefore, none of its properties are settable.</span></span> <span data-ttu-id="ddda7-122">此类结构的 WPF 词汇中的一个示例是<xref:System.Windows.GridLength>。</span><span class="sxs-lookup"><span data-stu-id="ddda7-122">An example of such a structure in the WPF vocabulary is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="ddda7-123">此类结构应实现类型转换器，以便可以通过创建不同的解释或模式的结构值的字符串约定属性形式表示的值。</span><span class="sxs-lookup"><span data-stu-id="ddda7-123">Such structures should implement a type converter so that the values can be expressed in attribute form, by using string conventions that create the different interpretations or modes of the structure values.</span></span> <span data-ttu-id="ddda7-124">结构还应通过非默认构造函数对代码构造公开类似的行为。</span><span class="sxs-lookup"><span data-stu-id="ddda7-124">The structure should also expose similar behavior for code construction through a non-default constructor.</span></span>  
  
### <a name="interfaces"></a><span data-ttu-id="ddda7-125">接口</span><span class="sxs-lookup"><span data-stu-id="ddda7-125">Interfaces</span></span>  
 <span data-ttu-id="ddda7-126">接口可以用作基础类型的成员。</span><span class="sxs-lookup"><span data-stu-id="ddda7-126">Interfaces can be used as underlying types of members.</span></span> <span data-ttu-id="ddda7-127">XAML 类型系统检查可分配的列表，并且期望作为值提供的对象可以分配给的接口。</span><span class="sxs-lookup"><span data-stu-id="ddda7-127">The XAML type system checks the assignable list and expects that the object that is provided as the value can be assigned to the interface.</span></span> <span data-ttu-id="ddda7-128">不存在的接口必须存在方式作为 XAML 类型，只要相关的可分配类型支持 XAML 构造要求概念。</span><span class="sxs-lookup"><span data-stu-id="ddda7-128">There is no concept of how the interface must be presented as a XAML type as long as a relevant assignable type supports the XAML construction requirements.</span></span>  
  
### <a name="factory-methods"></a><span data-ttu-id="ddda7-129">工厂方法</span><span class="sxs-lookup"><span data-stu-id="ddda7-129">Factory Methods</span></span>  
 <span data-ttu-id="ddda7-130">工厂方法是 XAML 2009 功能。</span><span class="sxs-lookup"><span data-stu-id="ddda7-130">Factory methods are a XAML 2009 feature.</span></span> <span data-ttu-id="ddda7-131">他们修改 XAML 原则对象必须具有默认构造函数。</span><span class="sxs-lookup"><span data-stu-id="ddda7-131">They modify the XAML principle that objects must have default constructors.</span></span> <span data-ttu-id="ddda7-132">本主题中未记录的工厂方法。</span><span class="sxs-lookup"><span data-stu-id="ddda7-132">Factory methods are not documented in this topic.</span></span> <span data-ttu-id="ddda7-133">请参阅[X:factorymethod 指令](x-factorymethod-directive.md)。</span><span class="sxs-lookup"><span data-stu-id="ddda7-133">See [x:FactoryMethod Directive](x-factorymethod-directive.md).</span></span>  
  
## <a name="enumerations"></a><span data-ttu-id="ddda7-134">枚举</span><span class="sxs-lookup"><span data-stu-id="ddda7-134">Enumerations</span></span>  
 <span data-ttu-id="ddda7-135">枚举具有 XAML 的本机类型转换行为。</span><span class="sxs-lookup"><span data-stu-id="ddda7-135">Enumerations have XAML native type conversion behavior.</span></span> <span data-ttu-id="ddda7-136">在 XAML 中指定的枚举常量名解析对基础的枚举类型，并返回到 XAML 对象编写器的枚举值。</span><span class="sxs-lookup"><span data-stu-id="ddda7-136">Enumeration constant names specified in XAML are resolved against the underlying enumeration type, and return the enumeration value to a XAML object writer.</span></span>  
  
 <span data-ttu-id="ddda7-137">XAML 与枚举支持标志样式使用<xref:System.FlagsAttribute>应用。</span><span class="sxs-lookup"><span data-stu-id="ddda7-137">XAML supports a flags-style usage for enumerations with <xref:System.FlagsAttribute> applied.</span></span> <span data-ttu-id="ddda7-138">有关详细信息，请参阅[XAML 语法详述](../wpf/advanced/xaml-syntax-in-detail.md)。</span><span class="sxs-lookup"><span data-stu-id="ddda7-138">For more information, see [XAML Syntax In Detail](../wpf/advanced/xaml-syntax-in-detail.md).</span></span> <span data-ttu-id="ddda7-139">([XAML 语法详述](../wpf/advanced/xaml-syntax-in-detail.md)专为 WPF 受众，但该主题中的信息的大多数都是适用于不是特定于特定实现框架的 XAML。)</span><span class="sxs-lookup"><span data-stu-id="ddda7-139">([XAML Syntax In Detail](../wpf/advanced/xaml-syntax-in-detail.md) is written for the WPF audience, but most of the information in that topic is relevant for XAML that is not specific to a particular implementing framework.)</span></span>  
  
## <a name="member-definitions"></a><span data-ttu-id="ddda7-140">成员定义</span><span class="sxs-lookup"><span data-stu-id="ddda7-140">Member Definitions</span></span>  
 <span data-ttu-id="ddda7-141">类型可以定义 XAML 用法的成员。</span><span class="sxs-lookup"><span data-stu-id="ddda7-141">Types can define members for XAML usage.</span></span> <span data-ttu-id="ddda7-142">它是可以定义是 XAML 可用，即使该特定类型不是 XAML 可用的成员的类型。</span><span class="sxs-lookup"><span data-stu-id="ddda7-142">It is possible for types that define members that are XAML-usable even if that specific type is not XAML-usable.</span></span> <span data-ttu-id="ddda7-143">这是因为 CLR 继承。</span><span class="sxs-lookup"><span data-stu-id="ddda7-143">This is possible because of CLR inheritance.</span></span> <span data-ttu-id="ddda7-144">只要某种类型的继承成员支持 XAML 用法作为一个类型，并且该成员的基础类型支持 XAML 用法或具有本机的 XAML 语法，该成员是 XAML 可用。</span><span class="sxs-lookup"><span data-stu-id="ddda7-144">So long as some type that inherits the member supports XAML usage as a type, and the member supports XAML usage for its underlying type or has a native XAML syntax available, that member is XAML-usable.</span></span>  
  
### <a name="properties"></a><span data-ttu-id="ddda7-145">属性</span><span class="sxs-lookup"><span data-stu-id="ddda7-145">Properties</span></span>  
 <span data-ttu-id="ddda7-146">如果定义为公共 CLR 属性使用典型的 CLR 属性`get`和`set`访问器模式和相应语言的建立关键词，XAML 类型系统可以提供具有适当的信息的成员作为属性进行报告<xref:System.Xaml.XamlMember>属性，如<xref:System.Xaml.XamlMember.IsReadPublic%2A>和<xref:System.Xaml.XamlMember.IsWritePublic%2A>。</span><span class="sxs-lookup"><span data-stu-id="ddda7-146">If you define properties as a public CLR property using the typical CLR `get` and `set` accessor patterns and language-appropriate keywording, the XAML type system can report the property as a member with appropriate information provided for <xref:System.Xaml.XamlMember> properties, such as <xref:System.Xaml.XamlMember.IsReadPublic%2A> and <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span></span>  
  
 <span data-ttu-id="ddda7-147">特定的属性可以通过应用启用文本语法<xref:System.ComponentModel.TypeConverterAttribute>。</span><span class="sxs-lookup"><span data-stu-id="ddda7-147">Specific properties can enable a text syntax by applying <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="ddda7-148">有关详细信息，请参阅[Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions-for-xaml.md)。</span><span class="sxs-lookup"><span data-stu-id="ddda7-148">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions-for-xaml.md).</span></span>  
  
 <span data-ttu-id="ddda7-149">在没有文本语法或本机的 XAML 转换，并且没有进一步中间环节，例如标记扩展用法，属性的类型 (<xref:System.Xaml.XamlMember.TargetType%2A>中 XAML 类型系统) 必须能够返回到 XAML 对象编写器实例，方法是将 target 作为 CLR 类型的类型。</span><span class="sxs-lookup"><span data-stu-id="ddda7-149">In the absence of a text syntax or native XAML conversion and in the absence of further indirection, such as a markup extension usage, the type of a property (<xref:System.Xaml.XamlMember.TargetType%2A> in the XAML type system) must be able to return an instance to a XAML object writer by treating the target type as a CLR type.</span></span>  
  
 <span data-ttu-id="ddda7-150">如果使用 XAML 2009 [X:reference 标记扩展](x-reference-markup-extension.md)可用于提供值，如果不满足前述注意事项; 但是，这是多个类型定义问题之外的使用情况问题。</span><span class="sxs-lookup"><span data-stu-id="ddda7-150">If using XAML 2009, [x:Reference Markup Extension](x-reference-markup-extension.md) can be used to provide values if the previous considerations are not met; however, that is more of a usage issue than a type definition issue.</span></span>  
  
### <a name="events"></a><span data-ttu-id="ddda7-151">事件</span><span class="sxs-lookup"><span data-stu-id="ddda7-151">Events</span></span>  
 <span data-ttu-id="ddda7-152">如果为公共 CLR 事件定义事件，XAML 类型系统可以将事件报告为成员，同时<xref:System.Xaml.XamlMember.IsEvent%2A>作为`true`。</span><span class="sxs-lookup"><span data-stu-id="ddda7-152">If you define events as a public CLR event, the XAML type system can report the event as a member with <xref:System.Xaml.XamlMember.IsEvent%2A> as `true`.</span></span> <span data-ttu-id="ddda7-153">连接事件处理程序不是.NET Framework XAML 服务功能; 的作用域内此功能由特定框架和实现。</span><span class="sxs-lookup"><span data-stu-id="ddda7-153">Wiring the event handlers is not within the scope of .NET Framework XAML Services capabilities; this is left to specific frameworks and implementations.</span></span>  
  
### <a name="methods"></a><span data-ttu-id="ddda7-154">方法</span><span class="sxs-lookup"><span data-stu-id="ddda7-154">Methods</span></span>  
 <span data-ttu-id="ddda7-155">方法的内联代码不是默认 XAML 功能。</span><span class="sxs-lookup"><span data-stu-id="ddda7-155">Inline code for methods is not a default XAML capability.</span></span> <span data-ttu-id="ddda7-156">在大多数情况下不直接引用方法成员从 XAML，并在 XAML 中的方法的角色是仅为特定 XAML 模式提供支持。</span><span class="sxs-lookup"><span data-stu-id="ddda7-156">In most cases you do not directly reference method members from XAML, and the role of methods in XAML is only to provide support for specific XAML patterns.</span></span> <span data-ttu-id="ddda7-157">[X:factorymethod 指令](x-factorymethod-directive.md)是一个例外。</span><span class="sxs-lookup"><span data-stu-id="ddda7-157">[x:FactoryMethod Directive](x-factorymethod-directive.md) is an exception.</span></span>  
  
### <a name="fields"></a><span data-ttu-id="ddda7-158">字段</span><span class="sxs-lookup"><span data-stu-id="ddda7-158">Fields</span></span>  
 <span data-ttu-id="ddda7-159">CLR 设计原则不鼓励使用非静态字段。</span><span class="sxs-lookup"><span data-stu-id="ddda7-159">CLR design guidelines discourage nonstatic fields.</span></span> <span data-ttu-id="ddda7-160">对于静态字段，您可以访问静态字段值只能通过[X:static 标记扩展](x-static-markup-extension.md); 在这种情况下不执行任何特殊 CLR 定义公开的字段中[x： 静态](x-static-markup-extension.md)用法。</span><span class="sxs-lookup"><span data-stu-id="ddda7-160">For static fields, you can access static field values only through [x:Static Markup Extension](x-static-markup-extension.md); in this case you are not doing anything special in the CLR definition to expose a field for [x:Static](x-static-markup-extension.md) usages.</span></span>  
  
## <a name="attachable-members"></a><span data-ttu-id="ddda7-161">可附加成员</span><span class="sxs-lookup"><span data-stu-id="ddda7-161">Attachable Members</span></span>  
 <span data-ttu-id="ddda7-162">可附加成员上定义的类型的取值函数方法模式通过向 XAML 公开。</span><span class="sxs-lookup"><span data-stu-id="ddda7-162">Attachable members are exposed to XAML through an accessor method pattern on a defining type.</span></span> <span data-ttu-id="ddda7-163">定义类型本身不需要为 XAML 可用作对象。</span><span class="sxs-lookup"><span data-stu-id="ddda7-163">The defining type itself does not need to be XAML-usable as an object.</span></span> <span data-ttu-id="ddda7-164">实际上，一种常见模式是声明其角色是一个服务类来拥有可附加成员和实现相关的行为，但是不提供用户界面表示形式如任何其他函数。</span><span class="sxs-lookup"><span data-stu-id="ddda7-164">In fact, a common pattern is to declare a service class whose role is to own the attachable member and implement the related behaviors, but serve no other function such as a UI representation.</span></span> <span data-ttu-id="ddda7-165">为以下部分中，将占位符*PropertyName*表示可附加成员的名称。</span><span class="sxs-lookup"><span data-stu-id="ddda7-165">For the following sections, the placeholder *PropertyName* represents the name of your attachable member.</span></span> <span data-ttu-id="ddda7-166">该名称中必须是有效[XamlName 语法](xamlname-grammar.md)。</span><span class="sxs-lookup"><span data-stu-id="ddda7-166">That name must be valid in the [XamlName Grammar](xamlname-grammar.md).</span></span>  
  
 <span data-ttu-id="ddda7-167">请务必谨慎的这些模式和类型的其他方法之间的名称冲突。</span><span class="sxs-lookup"><span data-stu-id="ddda7-167">Be cautious of name collisions between these patterns and other methods of a type.</span></span> <span data-ttu-id="ddda7-168">如果存在匹配的模式之一的成员，它可以被解释为可附加成员用法路径由 XAML 处理器即使这不是您的意图。</span><span class="sxs-lookup"><span data-stu-id="ddda7-168">If a member exists that matches one of the patterns, it can be interpreted as an attachable member usage pathway by a XAML processor even if that was not your intention.</span></span>  
  
#### <a name="the-getpropertyname-accessor"></a><span data-ttu-id="ddda7-169">GetPropertyName 访问器</span><span class="sxs-lookup"><span data-stu-id="ddda7-169">The GetPropertyName Accessor</span></span>  
 <span data-ttu-id="ddda7-170">`Get` PropertyName 访问器的签名必须是：</span><span class="sxs-lookup"><span data-stu-id="ddda7-170">The signature for the `Get`*PropertyName* accessor must be:</span></span>  
  
 <span data-ttu-id="ddda7-171">`public static object Get` PropertyName `(object` `target` `)`</span><span class="sxs-lookup"><span data-stu-id="ddda7-171">`public static object Get` *PropertyName* `(object`  `target` `)`</span></span>  
  
-   <span data-ttu-id="ddda7-172">`target` 对象在实现中可以指定为更具体的类型。</span><span class="sxs-lookup"><span data-stu-id="ddda7-172">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="ddda7-173">可以使用此范围限定在可附加成员; 的使用情况你预期的作用域之外的使用情况将引发无效强制转换异常，然后显示 XAML 分析错误的。</span><span class="sxs-lookup"><span data-stu-id="ddda7-173">You can use this to scope the usage of your attachable member; usages outside your intended scope will throw invalid cast exceptions that are then surfaced by a XAML parse error.</span></span> <span data-ttu-id="ddda7-174">参数名称`target`不是必需的但名为`target`大多数实现约定。</span><span class="sxs-lookup"><span data-stu-id="ddda7-174">The parameter name `target` is not a requirement, but is named `target` by convention in most implementations.</span></span>  
  
-   <span data-ttu-id="ddda7-175">返回值在实现中可以指定为更具体的类型。</span><span class="sxs-lookup"><span data-stu-id="ddda7-175">The return value can be specified as a more specific type in your implementation.</span></span>  
  
 <span data-ttu-id="ddda7-176">若要支持<xref:System.ComponentModel.TypeConverter>应用的可附加成员的特性用法的已启用的文本语法<xref:System.ComponentModel.TypeConverterAttribute>到`Get` *PropertyName*访问器。</span><span class="sxs-lookup"><span data-stu-id="ddda7-176">To support a <xref:System.ComponentModel.TypeConverter> enabled text syntax for attribute usage of the attachable member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `Get`*PropertyName* accessor.</span></span> <span data-ttu-id="ddda7-177">将应用于`get`而不是`set`可能看起来直观; 但是，此约定可支持这一概念的只读的可附加成员进行序列化的这是在设计器的情况下很有用。</span><span class="sxs-lookup"><span data-stu-id="ddda7-177">Applying to the `get` instead of the `set` may seem nonintuitive; however, this convention can support the concept of read-only attachable members that are serializable, which is useful in designer scenarios.</span></span>  
  
#### <a name="the-setpropertyname-accessor"></a><span data-ttu-id="ddda7-178">SetPropertyName 访问器</span><span class="sxs-lookup"><span data-stu-id="ddda7-178">The SetPropertyName Accessor</span></span>  
 <span data-ttu-id="ddda7-179">为集签名*PropertyName*访问器必须是：</span><span class="sxs-lookup"><span data-stu-id="ddda7-179">The signature for the Set*PropertyName* accessor must be:</span></span>  
  
 <span data-ttu-id="ddda7-180">`public static void Set` PropertyName `(object`  `target` `, object`  `value` `)`</span><span class="sxs-lookup"><span data-stu-id="ddda7-180">`public static void Set` *PropertyName* `(object`  `target` `, object`  `value` `)`</span></span>  
  
-   <span data-ttu-id="ddda7-181">`target`上一节中所述，可以在实现中，使用相同的逻辑和后果更具体的类型为指定对象。</span><span class="sxs-lookup"><span data-stu-id="ddda7-181">The `target` object can be specified as a more specific type in your implementation, with same logic and consequences as described in the previous section.</span></span>  
  
-   <span data-ttu-id="ddda7-182">`value` 对象在实现中可以指定为更具体的类型。</span><span class="sxs-lookup"><span data-stu-id="ddda7-182">The `value` object can be specified as a more specific type in your implementation.</span></span>  
  
 <span data-ttu-id="ddda7-183">请记住，此方法的值是从 XAML 用法，通常以特性形式的输入。</span><span class="sxs-lookup"><span data-stu-id="ddda7-183">Remember that the value for this method is the input coming from the XAML usage, typically in attribute form.</span></span> <span data-ttu-id="ddda7-184">从属性窗体必须针对文本语法，值转换器支持，并且特性上`Get` *PropertyName*访问器。</span><span class="sxs-lookup"><span data-stu-id="ddda7-184">From attribute form there must be value converter support for a text syntax, and you attribute on the `Get`*PropertyName* accessor.</span></span>  
  
### <a name="attachable-member-stores"></a><span data-ttu-id="ddda7-185">可附加成员存储</span><span class="sxs-lookup"><span data-stu-id="ddda7-185">Attachable Member Stores</span></span>  
 <span data-ttu-id="ddda7-186">访问器方法通常是不足够，以提供一种方式将可附加成员的值放入对象关系图，或用于检索对象图的值并正确地将它们序列化。</span><span class="sxs-lookup"><span data-stu-id="ddda7-186">The accessor methods are typically not enough to provide a means to place attachable member values into an object graph, or to retrieve values out of the object graph and serialize them properly.</span></span> <span data-ttu-id="ddda7-187">若要提供此功能，`target`上一个取值函数签名中的对象必须能够存储值。</span><span class="sxs-lookup"><span data-stu-id="ddda7-187">To provide this functionality, the `target` objects in the previous accessor signatures must be capable of storing values.</span></span> <span data-ttu-id="ddda7-188">应与该成员是可附加到目标的可附加成员不在成员列表中的可附加成员原则一致的存储机制。</span><span class="sxs-lookup"><span data-stu-id="ddda7-188">The storage mechanism should be consistent with the attachable member principle that the member is attachable to targets where the attachable member is not in the members list.</span></span> <span data-ttu-id="ddda7-189">.NET framework XAML 服务提供了实现的一种技术，可附加成员存储通过 Api<xref:System.Xaml.IAttachedPropertyStore>和<xref:System.Xaml.AttachablePropertyServices>。</span><span class="sxs-lookup"><span data-stu-id="ddda7-189">.NET Framework XAML Services provides an implementation technique for attachable member stores through the APIs <xref:System.Xaml.IAttachedPropertyStore> and <xref:System.Xaml.AttachablePropertyServices>.</span></span> <span data-ttu-id="ddda7-190"><xref:System.Xaml.IAttachedPropertyStore> XAML 编写器用于发现存储实现，并应是类型上实现`target`的访问器。</span><span class="sxs-lookup"><span data-stu-id="ddda7-190"><xref:System.Xaml.IAttachedPropertyStore> is used by the XAML writers to discover the store implementation, and should be implemented on the type that is the `target` of the accessors.</span></span> <span data-ttu-id="ddda7-191">静态<xref:System.Xaml.AttachablePropertyServices>Api 的访问器，在正文中使用和通过的可附加成员是指其<xref:System.Xaml.AttachableMemberIdentifier>。</span><span class="sxs-lookup"><span data-stu-id="ddda7-191">The static <xref:System.Xaml.AttachablePropertyServices> APIs are used within the body of the accessors, and refer to the attachable member by its <xref:System.Xaml.AttachableMemberIdentifier>.</span></span>  
  
## <a name="xaml-related-clr-attributes"></a><span data-ttu-id="ddda7-192">与 XAML 相关 CLR 特性</span><span class="sxs-lookup"><span data-stu-id="ddda7-192">XAML-Related CLR Attributes</span></span>  
 <span data-ttu-id="ddda7-193">属性类型、 成员和程序集正确设置到报表到.NET Framework XAML 服务 XAML 类型系统信息的顺序至关重要。</span><span class="sxs-lookup"><span data-stu-id="ddda7-193">Correctly attributing your types, members, and assemblies is important in order to report XAML type system information to .NET Framework XAML Services.</span></span> <span data-ttu-id="ddda7-194">如果你想用于直接基于.NET Framework XAML 服务 XAML 读取器和 XAML 编写器的 XAML 系统类型，或如果你定义或使用基于这些 XAML 读取器和 XAML 编写器的 XAML 利用框架，这是相关。</span><span class="sxs-lookup"><span data-stu-id="ddda7-194">This is relevant if you intend your types for use with XAML systems that are directly based on .NET Framework XAML Services XAML readers and XAML writers, or if you define or use a XAML-utilizing framework that is based on those XAML readers and XAML writers.</span></span>  
  
 <span data-ttu-id="ddda7-195">适用于自定义类型的 XAML 支持的每个与 XAML 相关的属性的列表，请参阅[XAML-Related CLR 特性自定义类型和库的](xaml-related-clr-attributes-for-custom-types-and-libraries.md)。</span><span class="sxs-lookup"><span data-stu-id="ddda7-195">For a listing of each XAML-related attribute that is relevant for XAML support of your custom types, see [XAML-Related CLR Attributes for Custom Types and Libraries](xaml-related-clr-attributes-for-custom-types-and-libraries.md).</span></span>  
  
## <a name="usage"></a><span data-ttu-id="ddda7-196">用法</span><span class="sxs-lookup"><span data-stu-id="ddda7-196">Usage</span></span>  
 <span data-ttu-id="ddda7-197">使用自定义类型需要标记作者必须映射包含自定义类型的程序集和 CLR 命名空间的前缀。</span><span class="sxs-lookup"><span data-stu-id="ddda7-197">Usage of custom types requires that the markup author must map a prefix for the assembly and CLR namespace that contain the custom type.</span></span> <span data-ttu-id="ddda7-198">本主题中不记录此过程。</span><span class="sxs-lookup"><span data-stu-id="ddda7-198">This procedure is not documented in this topic.</span></span>  
  
## <a name="access-level"></a><span data-ttu-id="ddda7-199">访问级别</span><span class="sxs-lookup"><span data-stu-id="ddda7-199">Access Level</span></span>  
 <span data-ttu-id="ddda7-200">XAML 提供了一种加载和实例化类型具有`internal`访问级别。</span><span class="sxs-lookup"><span data-stu-id="ddda7-200">XAML provides a means to load and instantiate types that have an `internal` access level.</span></span> <span data-ttu-id="ddda7-201">此功能，以便用户代码可以定义其自己的类型，然后实例化也是相同的用户代码作用域的一部分的标记从这些类提供。</span><span class="sxs-lookup"><span data-stu-id="ddda7-201">This capability is provided so that user code can define its own types, and then instantiate those classes from markup that is also part of the same user code scope.</span></span>  
  
 <span data-ttu-id="ddda7-202">WPF 中的示例是每当用户的代码定义<xref:System.Windows.Controls.UserControl>目的是作为一种方式重构 UI 行为，但不是可能通过声明的支持类暗示任何可能的扩展机制的一部分`public`访问级别。</span><span class="sxs-lookup"><span data-stu-id="ddda7-202">An example from WPF is whenever user code defines a <xref:System.Windows.Controls.UserControl> that is intended as a way to refactor a UI behavior, but not as part of any possible extension mechanism that might be implied by declaring the supporting class with `public` access level.</span></span> <span data-ttu-id="ddda7-203">此类<xref:System.Windows.Controls.UserControl>可以使用声明`internal`如果支持代码编译到同一程序集从其其引用为 XAML 类型访问。</span><span class="sxs-lookup"><span data-stu-id="ddda7-203">Such a <xref:System.Windows.Controls.UserControl> can be declared with `internal` access if the backing code is compiled into the same assembly from which it is referenced as a XAML type.</span></span>  
  
 <span data-ttu-id="ddda7-204">应用程序，在完全信任下加载 XAML 并使用<xref:System.Xaml.XamlObjectWriter>，类加载`internal`访问级别始终处于启用状态。</span><span class="sxs-lookup"><span data-stu-id="ddda7-204">For an application that loads XAML under full trust and uses <xref:System.Xaml.XamlObjectWriter>, loading classes with `internal` access level is always enabled.</span></span>  
  
 <span data-ttu-id="ddda7-205">对于在部分信任下加载 XAML 的应用，可以通过使用控制访问级别特征<xref:System.Xaml.Permissions.XamlAccessLevel>API。</span><span class="sxs-lookup"><span data-stu-id="ddda7-205">For an application that loads XAML under partial trust, you can control the access level characteristics by using the <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span></span> <span data-ttu-id="ddda7-206">此外，延迟机制 （如 WPF 模板系统） 必须能够将传播任何访问级别权限，并保留它们的最终运行的时计算中;这通过传递内部处理<xref:System.Xaml.Permissions.XamlAccessLevel>信息。</span><span class="sxs-lookup"><span data-stu-id="ddda7-206">Also, deferral mechanisms (such as the WPF template system) must be able to propagate any access level permissions and preserve them for the eventual run time evaluations; this is handled internally by passing the <xref:System.Xaml.Permissions.XamlAccessLevel> information.</span></span>  
  
### <a name="wpf-implementation"></a><span data-ttu-id="ddda7-207">WPF 实现</span><span class="sxs-lookup"><span data-stu-id="ddda7-207">WPF Implementation</span></span>  
 <span data-ttu-id="ddda7-208">WPF XAML 使用部分信任访问模型，如果在部分信任下加载 BAML，则访问权限仅限于<xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A>是 BAML 源的程序集。</span><span class="sxs-lookup"><span data-stu-id="ddda7-208">WPF XAML uses a partial-trust access model where if BAML is loaded under partial trust, access is restricted to <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> for the assembly that is the BAML source.</span></span> <span data-ttu-id="ddda7-209">对于延迟，WPF 使用<xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType>作为传递的访问级别信息的机制。</span><span class="sxs-lookup"><span data-stu-id="ddda7-209">For deferral, WPF uses <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> as a mechanism for passing the access level information.</span></span>  
  
 <span data-ttu-id="ddda7-210">在 WPF XAML 术语中，*内部类型*是由同一程序集，它还包括引用的 XAML 定义的类型。</span><span class="sxs-lookup"><span data-stu-id="ddda7-210">In WPF XAML terminology, an *internal type* is a type that is defined by the same assembly that also includes the referencing XAML.</span></span> <span data-ttu-id="ddda7-211">这种类型可以映射 XAML 命名空间的有意省略了该程序集 = 一部分的映射，例如， `xmlns:local="clr-namespace:WPFApplication1"`。</span><span class="sxs-lookup"><span data-stu-id="ddda7-211">Such a type can be mapped through a XAML namespace that deliberately omits the assembly= portion of a mapping, for example, `xmlns:local="clr-namespace:WPFApplication1"`.</span></span>  <span data-ttu-id="ddda7-212">如果 BAML 将引用的内部类型和类型具有`internal`访问级别，这将生成`GeneratedInternalTypeHelper`程序集的类。</span><span class="sxs-lookup"><span data-stu-id="ddda7-212">If BAML references an internal type and that type has `internal` access level, this generates a `GeneratedInternalTypeHelper` class for the assembly.</span></span> <span data-ttu-id="ddda7-213">如果你想要避免`GeneratedInternalTypeHelper`，则必须使用`public`访问级别，或必须分解为单独的程序集相关的类，并将该程序集依赖。</span><span class="sxs-lookup"><span data-stu-id="ddda7-213">If you want to avoid `GeneratedInternalTypeHelper`, you either must use `public` access level, or must factor the relevant class into a separate assembly and make that assembly dependent.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="ddda7-214">请参阅</span><span class="sxs-lookup"><span data-stu-id="ddda7-214">See also</span></span>

- [<span data-ttu-id="ddda7-215">自定义类型和库的 XAML 相关 CLR 特性</span><span class="sxs-lookup"><span data-stu-id="ddda7-215">XAML-Related CLR Attributes for Custom Types and Libraries</span></span>](xaml-related-clr-attributes-for-custom-types-and-libraries.md)
- [<span data-ttu-id="ddda7-216">XAML 服务</span><span class="sxs-lookup"><span data-stu-id="ddda7-216">XAML Services</span></span>](index.md)
