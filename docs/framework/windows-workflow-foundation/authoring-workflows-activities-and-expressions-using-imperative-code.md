---
title: 使用命令性代码创作工作流、活动和表达式
ms.date: 03/30/2017
ms.assetid: cefc9cfc-2882-4eb9-8c94-7a6da957f2b2
ms.openlocfilehash: 1a11da9ce3dd73f0bc2851b68e7c354e55c9d2d3
ms.sourcegitcommit: 160a88c8087b0e63606e6e35f9bd57fa5f69c168
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/09/2019
ms.locfileid: "57708361"
---
# <a name="authoring-workflows-activities-and-expressions-using-imperative-code"></a><span data-ttu-id="19ff2-102">使用命令性代码创作工作流、活动和表达式</span><span class="sxs-lookup"><span data-stu-id="19ff2-102">Authoring Workflows, Activities, and Expressions Using Imperative Code</span></span>
<span data-ttu-id="19ff2-103">工作流定义是已配置活动对象的树。</span><span class="sxs-lookup"><span data-stu-id="19ff2-103">A workflow definition is a tree of configured activity objects.</span></span> <span data-ttu-id="19ff2-104">这种活动树有多种定义方法，包括手动编辑 XAML 或使用工作流设计器来生成 XAML。</span><span class="sxs-lookup"><span data-stu-id="19ff2-104">This tree of activities can be defined many ways, including by hand-editing XAML or by using the Workflow Designer to produce XAML.</span></span> <span data-ttu-id="19ff2-105">但是，并非必须使用 XAML。</span><span class="sxs-lookup"><span data-stu-id="19ff2-105">Use of XAML, however, is not a requirement.</span></span> <span data-ttu-id="19ff2-106">工作流定义也可以通过编程方式来创建。</span><span class="sxs-lookup"><span data-stu-id="19ff2-106">Workflow definitions can also be created programmatically.</span></span> <span data-ttu-id="19ff2-107">本主题概述如何通过使用代码创建工作流定义、活动和表达式。</span><span class="sxs-lookup"><span data-stu-id="19ff2-107">This topic provides an overview of creating workflow definitions, activities, and expressions by using code.</span></span> <span data-ttu-id="19ff2-108">有关使用 XAML 工作流使用代码的示例，请参阅[序列化工作流和活动与 XAML](serializing-workflows-and-activities-to-and-from-xaml.md)。</span><span class="sxs-lookup"><span data-stu-id="19ff2-108">For examples of working with XAML workflows using code, see [Serializing Workflows and Activities to and from XAML](serializing-workflows-and-activities-to-and-from-xaml.md).</span></span>  
  
## <a name="creating-workflow-definitions"></a><span data-ttu-id="19ff2-109">创建工作流定义</span><span class="sxs-lookup"><span data-stu-id="19ff2-109">Creating Workflow Definitions</span></span>  
 <span data-ttu-id="19ff2-110">通过实例化活动类型的实例以及配置活动对象的属性可创建工作流定义。</span><span class="sxs-lookup"><span data-stu-id="19ff2-110">A workflow definition can be created by instantiating an instance of an activity type and configuring the activity object’s properties.</span></span> <span data-ttu-id="19ff2-111">对于不包含子活动的活动而言，可使用若干代码行来完成。</span><span class="sxs-lookup"><span data-stu-id="19ff2-111">For activities that do not contain child activities, this can be accomplished using a few lines of code.</span></span>  
  
 [!code-csharp[CFX_WorkflowApplicationExample#47](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#47)]  
  
> [!NOTE]
>  <span data-ttu-id="19ff2-112">本主题中的示例使用 <xref:System.Activities.WorkflowInvoker> 来运行示例工作流。</span><span class="sxs-lookup"><span data-stu-id="19ff2-112">The examples in this topic use <xref:System.Activities.WorkflowInvoker> to run the sample workflows.</span></span> <span data-ttu-id="19ff2-113">调用工作流、 传递自变量，以及可用的不同承载选择的详细信息，请参阅[使用 WorkflowInvoker 和 WorkflowApplication](using-workflowinvoker-and-workflowapplication.md)。</span><span class="sxs-lookup"><span data-stu-id="19ff2-113">For more information about invoking workflows, passing arguments, and the different hosting choices that are available, see [Using WorkflowInvoker and WorkflowApplication](using-workflowinvoker-and-workflowapplication.md).</span></span>  
  
 <span data-ttu-id="19ff2-114">在本示例中，将要创建由单个 <xref:System.Activities.Statements.WriteLine> 活动组成的工作流。</span><span class="sxs-lookup"><span data-stu-id="19ff2-114">In this example, a workflow that consists of a single <xref:System.Activities.Statements.WriteLine> activity is created.</span></span> <span data-ttu-id="19ff2-115">还要设置 <xref:System.Activities.Statements.WriteLine> 活动的 <xref:System.Activities.Statements.WriteLine.Text%2A> 参数，并调用该工作流。</span><span class="sxs-lookup"><span data-stu-id="19ff2-115">The <xref:System.Activities.Statements.WriteLine> activity’s <xref:System.Activities.Statements.WriteLine.Text%2A> argument is set, and the workflow is invoked.</span></span> <span data-ttu-id="19ff2-116">如果活动包含子活动，构造方法类似。</span><span class="sxs-lookup"><span data-stu-id="19ff2-116">If an activity contains child activities, the method of construction is similar.</span></span> <span data-ttu-id="19ff2-117">以下示例使用一个包含两个 <xref:System.Activities.Statements.Sequence> 活动的 <xref:System.Activities.Statements.WriteLine> 活动。</span><span class="sxs-lookup"><span data-stu-id="19ff2-117">The following example uses a <xref:System.Activities.Statements.Sequence> activity that contains two <xref:System.Activities.Statements.WriteLine> activities.</span></span>  
  
 [!code-csharp[CFX_WorkflowApplicationExample#48](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#48)]  
  
### <a name="using-object-initializers"></a><span data-ttu-id="19ff2-118">使用对象初始值设定项</span><span class="sxs-lookup"><span data-stu-id="19ff2-118">Using Object Initializers</span></span>  
 <span data-ttu-id="19ff2-119">本主题中的示例使用对象初始化语法。</span><span class="sxs-lookup"><span data-stu-id="19ff2-119">The examples in this topic use object initialization syntax.</span></span> <span data-ttu-id="19ff2-120">对于用代码创建工作流定义而言，对象初始化语法非常有用，因为它为工作流中的活动提供了分层视图，可以显示活动之间的关系。</span><span class="sxs-lookup"><span data-stu-id="19ff2-120">Object initialization syntax can be a useful way to create workflow definitions in code because it provides a hierarchical view of the activities in the workflow and shows the relationship between the activities.</span></span> <span data-ttu-id="19ff2-121">通过编程方式创建工作流时，不要求必须使用对象初始化语法。</span><span class="sxs-lookup"><span data-stu-id="19ff2-121">There is no requirement to use object initialization syntax when you programmatically create workflows.</span></span> <span data-ttu-id="19ff2-122">下面的示例与前面的示例在功能上是等效的。</span><span class="sxs-lookup"><span data-stu-id="19ff2-122">The following example is functionally equivalent to the previous example.</span></span>  
  
 [!code-csharp[CFX_WorkflowApplicationExample#49](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#49)]  
  
 <span data-ttu-id="19ff2-123">有关对象初始值设定项的详细信息，请参阅[如何：而不会调用构造函数初始化对象 (C#编程指南)](https://go.microsoft.com/fwlink/?LinkId=161015)并[如何：使用对象初始值设定项声明对象](https://go.microsoft.com/fwlink/?LinkId=161016)。</span><span class="sxs-lookup"><span data-stu-id="19ff2-123">For more information about object initializers, see [How to: Initialize Objects without Calling a Constructor (C# Programming Guide)](https://go.microsoft.com/fwlink/?LinkId=161015) and [How to: Declare an Object by Using an Object Initializer](https://go.microsoft.com/fwlink/?LinkId=161016).</span></span>  
  
### <a name="working-with-variables-literal-values-and-expressions"></a><span data-ttu-id="19ff2-124">使用变量、文本值和表达式</span><span class="sxs-lookup"><span data-stu-id="19ff2-124">Working with Variables, Literal Values, and Expressions</span></span>  
 <span data-ttu-id="19ff2-125">使用代码创建工作流定义时，请注意哪些代码是作为创建工作流定义的一部分来执行，哪些代码是作为该工作流实例执行的一部分来执行。</span><span class="sxs-lookup"><span data-stu-id="19ff2-125">When creating a workflow definition using code, be aware of what code executes as part of the creation of the workflow definition and what code executes as part of the execution of an instance of that workflow.</span></span> <span data-ttu-id="19ff2-126">例如，以下工作流将生成一个随机数，并将其写入控制台。</span><span class="sxs-lookup"><span data-stu-id="19ff2-126">For example, the following workflow is intended to generate a random number and write it to the console.</span></span>  
  
 [!code-csharp[CFX_WorkflowApplicationExample#50](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#50)]  
  
 <span data-ttu-id="19ff2-127">执行此工作流定义代码时，将会调用 `Random.Next` 并将结果以文本值的形式保存在工作流定义中。</span><span class="sxs-lookup"><span data-stu-id="19ff2-127">When this workflow definition code is executed, the call to `Random.Next` is made and the result is stored in the workflow definition as a literal value.</span></span> <span data-ttu-id="19ff2-128">可以调用此工作流的多个实例，全部实例将显示相同的数字。</span><span class="sxs-lookup"><span data-stu-id="19ff2-128">Many instances of this workflow can be invoked, and all would display the same number.</span></span> <span data-ttu-id="19ff2-129">若要在工作流执行过程中生成随机数，必需使用一个表达式，以便在每次运行工作流时计算该表达式。</span><span class="sxs-lookup"><span data-stu-id="19ff2-129">To have the random number generation occur during workflow execution, an expression must be used that is evaluated each time the workflow runs.</span></span> <span data-ttu-id="19ff2-130">在下例中，Visual Basic 表达式与 <xref:Microsoft.VisualBasic.Activities.VisualBasicValue%601> 一起使用。</span><span class="sxs-lookup"><span data-stu-id="19ff2-130">In the following example, a Visual Basic expression is used with a <xref:Microsoft.VisualBasic.Activities.VisualBasicValue%601>.</span></span>  
  
 [!code-csharp[CFX_WorkflowApplicationExample#51](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#51)]  
  
 <span data-ttu-id="19ff2-131">前例中的表达式还可以使用 <xref:Microsoft.CSharp.Activities.CSharpValue%601> 和 C# 表达式实现。</span><span class="sxs-lookup"><span data-stu-id="19ff2-131">The expression in the previous example could also be implemented using a <xref:Microsoft.CSharp.Activities.CSharpValue%601> and a C# expression.</span></span>  
  
```csharp  
new Assign<int>  
{  
    To = n,  
    Value = new CSharpValue<int>("new Random().Next(1, 101)")  
}  
```  
  
 <span data-ttu-id="19ff2-132">在调用包含 C# 表达式的工作流之前，必须先编译这些表达式。</span><span class="sxs-lookup"><span data-stu-id="19ff2-132">C# expressions must be compiled before the workflow containing them is invoked.</span></span> <span data-ttu-id="19ff2-133">如果C#表达式未编译，<xref:System.NotSupportedException>使用类似于以下的消息调用工作流时，将引发：`Expression Activity type 'CSharpValue`1 需要编译才能运行。</span><span class="sxs-lookup"><span data-stu-id="19ff2-133">If the C# expressions are not compiled, a <xref:System.NotSupportedException> is thrown when the workflow is invoked with a message similar to the following: `Expression Activity type 'CSharpValue`1' requires compilation in order to run.</span></span>  <span data-ttu-id="19ff2-134">请确保已编译工作流。 在大多数情况下，涉及在 Visual Studio C# 中创建的工作流表达式会自动编译，但在某些情况下，例如代码工作流中的 C# 表达式必须手动编译。</span><span class="sxs-lookup"><span data-stu-id="19ff2-134">Please ensure that the workflow has been compiled.\` In most scenarios involving workflows created in Visual Studio the C# expressions are compiled automatically, but in some scenarios, such as code workflows, the C# expressions must be manually compiled.</span></span> <span data-ttu-id="19ff2-135">有关如何编译 C# 表达式的示例，请参阅[在代码工作流中的使用 C# 表达式](csharp-expressions.md#CodeWorkflows)一部分[C# 表达式](csharp-expressions.md)主题。</span><span class="sxs-lookup"><span data-stu-id="19ff2-135">For an example of how to compile C# expressions, see the [Using C# expressions in code workflows](csharp-expressions.md#CodeWorkflows) section of the [C# Expressions](csharp-expressions.md) topic.</span></span>  
  
 <span data-ttu-id="19ff2-136"><xref:Microsoft.VisualBasic.Activities.VisualBasicValue%601> 在 Visual Basic 语法中表示可用作表达式右值的表达式，<xref:Microsoft.CSharp.Activities.CSharpValue%601> 在 C# 语法中表示可用作表达式右值的表达式。</span><span class="sxs-lookup"><span data-stu-id="19ff2-136">A <xref:Microsoft.VisualBasic.Activities.VisualBasicValue%601> represents an expression in Visual Basic syntax that can be used as an r-value in an expression, and a <xref:Microsoft.CSharp.Activities.CSharpValue%601> represents an expression in C# syntax that can be used as an r-value in an expression.</span></span> <span data-ttu-id="19ff2-137">每次执行包含活动时，都会计算这些表达式。</span><span class="sxs-lookup"><span data-stu-id="19ff2-137">These expressions are evaluated each time the containing activity is executed.</span></span> <span data-ttu-id="19ff2-138">将表达式的结果赋给工作流变量 `n`，工作流中的下一个活动将使用这些结果。</span><span class="sxs-lookup"><span data-stu-id="19ff2-138">The result of the expression is assigned to the workflow variable `n`, and these results are used by the next activity in the workflow.</span></span> <span data-ttu-id="19ff2-139">若要在运行时访问工作流变量 `n` 的值，需要 <xref:System.Activities.ActivityContext>。</span><span class="sxs-lookup"><span data-stu-id="19ff2-139">To access the value of the workflow variable `n` at runtime, the <xref:System.Activities.ActivityContext> is required.</span></span> <span data-ttu-id="19ff2-140">可使用以下 lambda 表达式进行访问。</span><span class="sxs-lookup"><span data-stu-id="19ff2-140">This can be accessed by using the following lambda expression.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="19ff2-141">请注意，这些代码都是以 C# 为编程语言的示例，但是一个使用 <xref:Microsoft.VisualBasic.Activities.VisualBasicValue%601>，另一个使用 <xref:Microsoft.CSharp.Activities.CSharpValue%601>。</span><span class="sxs-lookup"><span data-stu-id="19ff2-141">Note that both of these code are examples are using C# as the programming language, but one uses a <xref:Microsoft.VisualBasic.Activities.VisualBasicValue%601> and one uses a <xref:Microsoft.CSharp.Activities.CSharpValue%601>.</span></span> <span data-ttu-id="19ff2-142"><xref:Microsoft.VisualBasic.Activities.VisualBasicValue%601> 和 <xref:Microsoft.CSharp.Activities.CSharpValue%601> 可以在 Visual Basic 和 C# 项目中使用。</span><span class="sxs-lookup"><span data-stu-id="19ff2-142"><xref:Microsoft.VisualBasic.Activities.VisualBasicValue%601> and <xref:Microsoft.CSharp.Activities.CSharpValue%601> can be used in both Visual Basic and C# projects.</span></span> <span data-ttu-id="19ff2-143">默认情况下，在工作流设计器中创建的表达式匹配承载项目的语言。</span><span class="sxs-lookup"><span data-stu-id="19ff2-143">By default, expressions created in the workflow designer match the language of the hosting project.</span></span> <span data-ttu-id="19ff2-144">在代码中创建工作流时，所需的语言由工作流编写者决定。</span><span class="sxs-lookup"><span data-stu-id="19ff2-144">When creating workflows in code, the desired language is at the discretion of the workflow author.</span></span>  
  
 <span data-ttu-id="19ff2-145">这些示例中，将表达式的结果赋给工作流变量 `n`，工作流中的下一个活动将使用这些结果。</span><span class="sxs-lookup"><span data-stu-id="19ff2-145">In these examples the result of the expression is assigned to the workflow variable `n`, and these results are used by the next activity in the workflow.</span></span> <span data-ttu-id="19ff2-146">若要在运行时访问工作流变量 `n` 的值，需要 <xref:System.Activities.ActivityContext>。</span><span class="sxs-lookup"><span data-stu-id="19ff2-146">To access the value of the workflow variable `n` at runtime, the <xref:System.Activities.ActivityContext> is required.</span></span> <span data-ttu-id="19ff2-147">可使用以下 lambda 表达式进行访问。</span><span class="sxs-lookup"><span data-stu-id="19ff2-147">This can be accessed by using the following lambda expression.</span></span>  
  
 [!code-csharp[CFX_WorkflowApplicationExample#52](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#52)]  
  
 <span data-ttu-id="19ff2-148">有关 lambda 表达式的详细信息，请参阅[Lambda 表达式 （C# 编程指南）](https://go.microsoft.com/fwlink/?LinkID=152436)或[Lambda 表达式 (Visual Basic)](https://go.microsoft.com/fwlink/?LinkID=152437)。</span><span class="sxs-lookup"><span data-stu-id="19ff2-148">For more information about lambda expressions, see [Lambda Expressions (C# Programming Guide)](https://go.microsoft.com/fwlink/?LinkID=152436) or [Lambda Expressions (Visual Basic)](https://go.microsoft.com/fwlink/?LinkID=152437).</span></span>  
  
 <span data-ttu-id="19ff2-149">Lambda 表达式不可序列化为 XAML 格式。</span><span class="sxs-lookup"><span data-stu-id="19ff2-149">Lambda expressions are not serializable to XAML format.</span></span> <span data-ttu-id="19ff2-150">如果进行尝试序列化的 lambda 表达式的工作流，<xref:System.Activities.Expressions.LambdaSerializationException>引发并显示以下消息："此工作流包含在代码中指定的 lambda 表达式。</span><span class="sxs-lookup"><span data-stu-id="19ff2-150">If an attempt to serialize a workflow with lambda expressions is made, a <xref:System.Activities.Expressions.LambdaSerializationException> is thrown with the following message: "This workflow contains lambda expressions specified in code.</span></span> <span data-ttu-id="19ff2-151">这些表达式不可序列化为 XAML。</span><span class="sxs-lookup"><span data-stu-id="19ff2-151">These expressions are not XAML serializable.</span></span> <span data-ttu-id="19ff2-152">若要使工作流可序列化为 XAML，请使用 VisualBasicValue/VisualBasicReference 或 ExpressionServices.Convert(lambda)。</span><span class="sxs-lookup"><span data-stu-id="19ff2-152">In order to make your workflow XAML-serializable, either use VisualBasicValue/VisualBasicReference or ExpressionServices.Convert(lambda).</span></span> <span data-ttu-id="19ff2-153">这会将 lambda 表达式转换为表达式活动。”</span><span class="sxs-lookup"><span data-stu-id="19ff2-153">This will convert your lambda expressions into expression activities."</span></span> <span data-ttu-id="19ff2-154">若要使此表达式与 XAML 相兼容，请使用 <xref:System.Activities.Expressions.ExpressionServices> 和 <xref:System.Activities.Expressions.ExpressionServices.Convert%2A>，如下例所示。</span><span class="sxs-lookup"><span data-stu-id="19ff2-154">To make this expression compatible with XAML, use <xref:System.Activities.Expressions.ExpressionServices> and <xref:System.Activities.Expressions.ExpressionServices.Convert%2A>, as shown in the following example.</span></span>  
  
 [!code-csharp[CFX_WorkflowApplicationExample#53](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#53)]  
  
 <span data-ttu-id="19ff2-155">还可以使用 <xref:Microsoft.VisualBasic.Activities.VisualBasicValue%601>。</span><span class="sxs-lookup"><span data-stu-id="19ff2-155">A <xref:Microsoft.VisualBasic.Activities.VisualBasicValue%601> could also be used.</span></span> <span data-ttu-id="19ff2-156">请注意，在使用 Visual Basic 表达式时无需 lambda 表达式。</span><span class="sxs-lookup"><span data-stu-id="19ff2-156">Note that no lambda expression is required when using a Visual Basic expression.</span></span>  
  
 [!code-csharp[CFX_WorkflowApplicationExample#54](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#54)]  
  
 <span data-ttu-id="19ff2-157">Visual Basic 表达式在运行时编译为 LINQ 表达式。</span><span class="sxs-lookup"><span data-stu-id="19ff2-157">At run time, Visual Basic expressions are compiled into LINQ expressions.</span></span> <span data-ttu-id="19ff2-158">前面两个示例都可序列化为 XAML，但是，如果序列化后的 XAML 用于在工作流设计器中查看和编辑，则对表达式使用 <xref:Microsoft.VisualBasic.Activities.VisualBasicValue%601>。</span><span class="sxs-lookup"><span data-stu-id="19ff2-158">Both of the previous examples are serializable to XAML, but if the serialized XAML is intended to be viewed and edited in the workflow designer, use <xref:Microsoft.VisualBasic.Activities.VisualBasicValue%601> for your expressions.</span></span> <span data-ttu-id="19ff2-159">使用 `ExpressionServices.Convert` 的序列化工作流可在设计器中打开，但是表达式的值将为空。</span><span class="sxs-lookup"><span data-stu-id="19ff2-159">Serialized workflows that use `ExpressionServices.Convert` can be opened in the designer, but the value of the expression will be blank.</span></span> <span data-ttu-id="19ff2-160">有关序列化到 XAML 的工作流的详细信息，请参阅[序列化工作流和活动与 XAML](serializing-workflows-and-activities-to-and-from-xaml.md)。</span><span class="sxs-lookup"><span data-stu-id="19ff2-160">For more information about serializing workflows to XAML, see [Serializing Workflows and Activities to and from XAML](serializing-workflows-and-activities-to-and-from-xaml.md).</span></span>  
  
#### <a name="literal-expressions-and-reference-types"></a><span data-ttu-id="19ff2-161">文本表达式和引用类型</span><span class="sxs-lookup"><span data-stu-id="19ff2-161">Literal Expressions and Reference Types</span></span>  
 <span data-ttu-id="19ff2-162">在工作流中，通过 <xref:System.Activities.Expressions.Literal%601> 活动表示文本表达式。</span><span class="sxs-lookup"><span data-stu-id="19ff2-162">Literal expressions are represented in workflows by the <xref:System.Activities.Expressions.Literal%601> activity.</span></span> <span data-ttu-id="19ff2-163">下面的 <xref:System.Activities.Statements.WriteLine> 活动在功能上是等效的。</span><span class="sxs-lookup"><span data-stu-id="19ff2-163">The following <xref:System.Activities.Statements.WriteLine> activities are functionally equivalent.</span></span>  
  
```csharp  
new WriteLine  
{  
    Text = "Hello World."  
},  
new WriteLine  
{  
    Text = new Literal<string>("Hello World.")  
}  
```  
  
 <span data-ttu-id="19ff2-164">使用 <xref:System.String> 外的其他任何引用类型初始化文本表达式都无效。</span><span class="sxs-lookup"><span data-stu-id="19ff2-164">It is invalid to initialize a literal expression with any reference type except <xref:System.String>.</span></span> <span data-ttu-id="19ff2-165">在下例中，<xref:System.Activities.Statements.Assign> 活动的 <xref:System.Activities.Statements.Assign.Value%2A> 属性是通过 `List<string>` 用文本表达式初始化的。</span><span class="sxs-lookup"><span data-stu-id="19ff2-165">In the following example, an <xref:System.Activities.Statements.Assign> activity's <xref:System.Activities.Statements.Assign.Value%2A> property is initialized with a literal expression using a `List<string>`.</span></span>  
  
```csharp  
new Assign  
{  
    To = new OutArgument<List<string>>(items),  
    Value = new InArgument<List<string>>(new List<string>())  
},  
```  
  
 <span data-ttu-id="19ff2-166">验证包含此活动的工作流，则返回以下验证错误："文本仅支持值类型和不可变类型 System.String。</span><span class="sxs-lookup"><span data-stu-id="19ff2-166">When the workflow containing this activity is validated, the following validation error is returned: "Literal only supports value types and the immutable type System.String.</span></span> <span data-ttu-id="19ff2-167">类型 System.Collections.Generic.List\`1[System.String] 不能用作文本。”</span><span class="sxs-lookup"><span data-stu-id="19ff2-167">The type System.Collections.Generic.List\`1[System.String] cannot be used as a literal."</span></span> <span data-ttu-id="19ff2-168">如果调用工作流，会引发包含验证错误文本的 <xref:System.Activities.InvalidWorkflowException>。</span><span class="sxs-lookup"><span data-stu-id="19ff2-168">If the workflow is invoked, an <xref:System.Activities.InvalidWorkflowException> is thrown that contains the text of the validation error.</span></span> <span data-ttu-id="19ff2-169">这是验证错误，因为使用引用类型创建文本表达式不会创建每个工作流实例的引用类型的新实例。</span><span class="sxs-lookup"><span data-stu-id="19ff2-169">This is a validation error because creating a literal expression with a reference type does not create a new instance of the reference type for each instance of the workflow.</span></span> <span data-ttu-id="19ff2-170">要解决此问题，请将文本表达式替换为创建和返回引用类型新实例的表达式。</span><span class="sxs-lookup"><span data-stu-id="19ff2-170">To resolve this, replace the literal expression with one that creates and returns a new instance of the reference type.</span></span>  
  
```csharp  
new Assign  
{  
    To = new OutArgument<List<string>>(items),  
    Value = new InArgument<List<string>>(new VisualBasicValue<List<string>>("New List(Of String)"))  
},  
```  
  
 <span data-ttu-id="19ff2-171">有关表达式的详细信息，请参阅[表达式](expressions.md)。</span><span class="sxs-lookup"><span data-stu-id="19ff2-171">For more information about expressions, see [Expressions](expressions.md).</span></span>  
  
#### <a name="invoking-methods-on-objects-using-expressions-and-the-invokemethod-activity"></a><span data-ttu-id="19ff2-172">使用表达式和 InvokeMethod 活动调用对象上的方法</span><span class="sxs-lookup"><span data-stu-id="19ff2-172">Invoking Methods on Objects using Expressions and the InvokeMethod Activity</span></span>  
 <span data-ttu-id="19ff2-173"><xref:System.Activities.Expressions.InvokeMethod%601> 活动可用于调用 .NET Framework 中的类的静态和实例方法。</span><span class="sxs-lookup"><span data-stu-id="19ff2-173">The <xref:System.Activities.Expressions.InvokeMethod%601> activity can be used to invoke static and instance methods of classes in the .NET Framework.</span></span> <span data-ttu-id="19ff2-174">在此主题中的上一个示例中，使用 <xref:System.Random> 类生成随机数。</span><span class="sxs-lookup"><span data-stu-id="19ff2-174">In a previous example in this topic, a random number was generated using the <xref:System.Random> class.</span></span>  
  
 [!code-csharp[CFX_WorkflowApplicationExample#51](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#51)]  
  
 <span data-ttu-id="19ff2-175"><xref:System.Activities.Expressions.InvokeMethod%601> 活动还可以用于调用 <xref:System.Random.Next%2A> 类的 <xref:System.Random> 方法。</span><span class="sxs-lookup"><span data-stu-id="19ff2-175">The <xref:System.Activities.Expressions.InvokeMethod%601> activity could also have been used to call the <xref:System.Random.Next%2A> method of the <xref:System.Random> class.</span></span>  
  
```csharp  
new InvokeMethod<int>  
{  
    TargetObject = new InArgument<Random>(new VisualBasicValue<Random>("New Random()")),  
    MethodName = "Next",  
    Parameters =   
    {  
        new InArgument<int>(1),  
        new InArgument<int>(101)  
    },  
    Result = n  
}  
```  
  
 <span data-ttu-id="19ff2-176"><xref:System.Random.Next%2A> 不是静态方法，因此为 <xref:System.Random> 属性提供 <xref:System.Activities.Expressions.InvokeMethod%601.TargetObject%2A> 类的实例。</span><span class="sxs-lookup"><span data-stu-id="19ff2-176">Since <xref:System.Random.Next%2A> is not a static method, an instance of the <xref:System.Random> class is supplied for the <xref:System.Activities.Expressions.InvokeMethod%601.TargetObject%2A> property.</span></span> <span data-ttu-id="19ff2-177">在此示例中，使用 Visual Basic 表达式创建一个新实例，但是它可能已在之前创建并存储在工作流变量中。</span><span class="sxs-lookup"><span data-stu-id="19ff2-177">In this example a new instance is created using a Visual Basic expression, but it could also have been created previously and stored in a workflow variable.</span></span> <span data-ttu-id="19ff2-178">在此示例中，更易于使用 <xref:System.Activities.Statements.Assign%601> 活动，而不是 <xref:System.Activities.Expressions.InvokeMethod%601>活动。</span><span class="sxs-lookup"><span data-stu-id="19ff2-178">In this example, it would be simpler to use the <xref:System.Activities.Statements.Assign%601> activity instead of the <xref:System.Activities.Expressions.InvokeMethod%601> activity.</span></span> <span data-ttu-id="19ff2-179">如果最终通过长时间运行的 <xref:System.Activities.Statements.Assign%601> 或 <xref:System.Activities.Expressions.InvokeMethod%601> 活动调用该方法，因为有 <xref:System.Activities.Expressions.InvokeMethod%601> 属性，所以 <xref:System.Activities.Expressions.InvokeMethod%601.RunAsynchronously%2A> 具有优势。</span><span class="sxs-lookup"><span data-stu-id="19ff2-179">If the method call ultimately invoked by either the <xref:System.Activities.Statements.Assign%601> or <xref:System.Activities.Expressions.InvokeMethod%601> activities is long running, <xref:System.Activities.Expressions.InvokeMethod%601> has an advantage since it has a <xref:System.Activities.Expressions.InvokeMethod%601.RunAsynchronously%2A> property.</span></span> <span data-ttu-id="19ff2-180">如果此属性设置为 `true`，对于工作流，调用的方法将异步运行。</span><span class="sxs-lookup"><span data-stu-id="19ff2-180">When this property is set to `true`, the invoked method will run asynchronously with regard to the workflow.</span></span> <span data-ttu-id="19ff2-181">如果存在其他并行的活动，则在方法异步执行时将不会阻止这些活动。</span><span class="sxs-lookup"><span data-stu-id="19ff2-181">If other activities are in parallel, they will not be blocked while the method is asynchronously executing.</span></span> <span data-ttu-id="19ff2-182">此外，如果要调用的方法没有返回值，则 <xref:System.Activities.Expressions.InvokeMethod%601> 是调用该方法的适当方法。</span><span class="sxs-lookup"><span data-stu-id="19ff2-182">Also, if the method to be invoked has no return value, then <xref:System.Activities.Expressions.InvokeMethod%601> is the appropriate way to invoke the method.</span></span>  
  
## <a name="arguments-and-dynamic-activities"></a><span data-ttu-id="19ff2-183">参数与动态活动</span><span class="sxs-lookup"><span data-stu-id="19ff2-183">Arguments and Dynamic Activities</span></span>  
 <span data-ttu-id="19ff2-184">通过将活动组合到活动树中并配置各自变量和属性的方式可创建以代码编写的工作流定义。</span><span class="sxs-lookup"><span data-stu-id="19ff2-184">A workflow definition is created in code by assembling activities into an activity tree and configuring any properties and arguments.</span></span> <span data-ttu-id="19ff2-185">可绑定现有自变量，但无法将新自变量添加到活动中。</span><span class="sxs-lookup"><span data-stu-id="19ff2-185">Existing arguments can be bound, but new arguments cannot be added to activities.</span></span> <span data-ttu-id="19ff2-186">这包括传递给根活动的工作流自变量。</span><span class="sxs-lookup"><span data-stu-id="19ff2-186">This includes workflow arguments passed to the root activity.</span></span> <span data-ttu-id="19ff2-187">在命令性代码中，工作流自变量被指定为新 CLR 类型的属性，而在 XAML 中，它们将使用 `x:Class` 和 `x:Member` 来声明。</span><span class="sxs-lookup"><span data-stu-id="19ff2-187">In imperative code, workflow arguments are specified as properties on a new CLR type, and in XAML they are declared by using `x:Class` and `x:Member`.</span></span> <span data-ttu-id="19ff2-188">将工作流定义创建为内存中对象的树时，由于没有创建新的 CLR 类型，因此无法添加参数。</span><span class="sxs-lookup"><span data-stu-id="19ff2-188">Because there is no new CLR type created when a workflow definition is created as a tree of in-memory objects, arguments cannot be added.</span></span> <span data-ttu-id="19ff2-189">但是，可将参数添加到 <xref:System.Activities.DynamicActivity>。</span><span class="sxs-lookup"><span data-stu-id="19ff2-189">However, arguments can be added to a <xref:System.Activities.DynamicActivity>.</span></span> <span data-ttu-id="19ff2-190">在本示例中，将要创建一个 <xref:System.Activities.DynamicActivity%601>，它接受两个整型自变量并将它们相加，然后返回结果。</span><span class="sxs-lookup"><span data-stu-id="19ff2-190">In this example, a <xref:System.Activities.DynamicActivity%601> is created that takes two integer arguments, adds them together, and returns the result.</span></span> <span data-ttu-id="19ff2-191">为每个自变量创建一个 <xref:System.Activities.DynamicActivityProperty>，并将运算结果赋给 <xref:System.Activities.Activity%601.Result%2A> 的 <xref:System.Activities.DynamicActivity%601> 自变量。</span><span class="sxs-lookup"><span data-stu-id="19ff2-191">A <xref:System.Activities.DynamicActivityProperty> is created for each argument, and the result of the operation is assigned to the <xref:System.Activities.Activity%601.Result%2A> argument of the <xref:System.Activities.DynamicActivity%601>.</span></span>  
  
 [!code-csharp[CFX_WorkflowApplicationExample#55](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#55)]  
  
 <span data-ttu-id="19ff2-192">有关动态活动的详细信息，请参阅[在运行时创建活动](creating-an-activity-at-runtime-with-dynamicactivity.md)。</span><span class="sxs-lookup"><span data-stu-id="19ff2-192">For more information about dynamic activities, see [Creating an Activity at Runtime](creating-an-activity-at-runtime-with-dynamicactivity.md).</span></span>  
  
## <a name="compiled-activities"></a><span data-ttu-id="19ff2-193">编译活动</span><span class="sxs-lookup"><span data-stu-id="19ff2-193">Compiled Activities</span></span>  
 <span data-ttu-id="19ff2-194">动态活动是使用代码定义包含参数的活动的一种方法，但是活动还可以通过代码创建和编译为类型。</span><span class="sxs-lookup"><span data-stu-id="19ff2-194">Dynamic activities are one way to define an activity that contains arguments using code, but activities can also be created in code and compiled into types.</span></span> <span data-ttu-id="19ff2-195">可以创建派生自 <xref:System.Activities.CodeActivity> 的简单活动和派生自 <xref:System.Activities.AsyncCodeActivity> 的异步活动。</span><span class="sxs-lookup"><span data-stu-id="19ff2-195">Simple activities can be created that derive from <xref:System.Activities.CodeActivity>, and asynchronous activities that derive from <xref:System.Activities.AsyncCodeActivity>.</span></span> <span data-ttu-id="19ff2-196">这些活动可以有自变量、返回值，可以使用命令性代码对其逻辑进行定义。</span><span class="sxs-lookup"><span data-stu-id="19ff2-196">These activities can have arguments, return values, and define their logic using imperative code.</span></span> <span data-ttu-id="19ff2-197">有关创建这些类型的活动的示例，请参阅[CodeActivity 基类](workflow-activity-authoring-using-the-codeactivity-class.md)并[创建异步活动](creating-asynchronous-activities-in-wf.md)。</span><span class="sxs-lookup"><span data-stu-id="19ff2-197">For examples of creating these types of activities, see [CodeActivity Base Class](workflow-activity-authoring-using-the-codeactivity-class.md) and [Creating Asynchronous Activities](creating-asynchronous-activities-in-wf.md).</span></span>  
  
 <span data-ttu-id="19ff2-198">派生自 <xref:System.Activities.NativeActivity> 的活动可以使用命令性代码对其逻辑进行定义，其中可以包含定义逻辑的子活动。</span><span class="sxs-lookup"><span data-stu-id="19ff2-198">Activities that derive from <xref:System.Activities.NativeActivity> can define their logic using imperative code and they can also contain child activities that define the logic.</span></span> <span data-ttu-id="19ff2-199">它们还具有对运行时的功能（如创建书签）的完全访问权限。</span><span class="sxs-lookup"><span data-stu-id="19ff2-199">They also have full access to the features of the runtime such as creating bookmarks.</span></span> <span data-ttu-id="19ff2-200">有关创建的示例<xref:System.Activities.NativeActivity>-基于活动，请参阅[NativeActivity 基类](nativeactivity-base-class.md)，[如何：创建活动](how-to-create-an-activity.md)，并[自定义复合使用本机活动](./samples/custom-composite-using-native-activity.md)示例。</span><span class="sxs-lookup"><span data-stu-id="19ff2-200">For examples of creating a <xref:System.Activities.NativeActivity>-based activity, see [NativeActivity Base Class](nativeactivity-base-class.md), [How to: Create an Activity](how-to-create-an-activity.md), and the [Custom Composite using Native Activity](./samples/custom-composite-using-native-activity.md) sample.</span></span>  
  
 <span data-ttu-id="19ff2-201">派生自 <xref:System.Activities.Activity> 的活动仅通过使用子活动定义其逻辑。</span><span class="sxs-lookup"><span data-stu-id="19ff2-201">Activities that derive from <xref:System.Activities.Activity> define their logic solely through the use of child activities.</span></span> <span data-ttu-id="19ff2-202">这些活动通常使用工作流设计器进行创建，但是也可以使用代码进行定义。</span><span class="sxs-lookup"><span data-stu-id="19ff2-202">These activities are typically created by using the workflow designer, but can also be defined by using code.</span></span> <span data-ttu-id="19ff2-203">在下面的示例中，定义了一个派生自 `Square` 的 `Activity<int>` 活动。</span><span class="sxs-lookup"><span data-stu-id="19ff2-203">In the following example, a `Square` activity is defined that derives from `Activity<int>`.</span></span> <span data-ttu-id="19ff2-204">`Square` 活动具有名为 <xref:System.Activities.InArgument%601> 的单一 `Value`，并且通过使用 <xref:System.Activities.Statements.Sequence> 属性指定 <xref:System.Activities.Activity.Implementation%2A> 活动来定义其逻辑。</span><span class="sxs-lookup"><span data-stu-id="19ff2-204">The `Square` activity has a single <xref:System.Activities.InArgument%601> named `Value`, and defines its logic by specifying a <xref:System.Activities.Statements.Sequence> activity using the <xref:System.Activities.Activity.Implementation%2A> property.</span></span> <span data-ttu-id="19ff2-205"><xref:System.Activities.Statements.Sequence> 活动包含 <xref:System.Activities.Statements.WriteLine> 活动和 <xref:System.Activities.Statements.Assign%601> 活动。</span><span class="sxs-lookup"><span data-stu-id="19ff2-205">The <xref:System.Activities.Statements.Sequence> activity contains a <xref:System.Activities.Statements.WriteLine> activity and an <xref:System.Activities.Statements.Assign%601> activity.</span></span> <span data-ttu-id="19ff2-206">这三个活动一起实现 `Square` 活动的逻辑。</span><span class="sxs-lookup"><span data-stu-id="19ff2-206">Together, these three activities implement the logic of the `Square` activity.</span></span>  
  
```csharp  
class Square : Activity<int>  
{  
    [RequiredArgument]  
    public InArgument<int> Value { get; set; }  
  
    public Square()  
    {  
        this.Implementation = () => new Sequence  
        {  
            Activities =  
            {  
                new WriteLine  
                {  
                    Text = new InArgument<string>((env) => "Squaring the value: " + this.Value.Get(env))  
                },  
                new Assign<int>  
                {  
                    To = new OutArgument<int>((env) => this.Result.Get(env)),  
                    Value = new InArgument<int>((env) => this.Value.Get(env) * this.Value.Get(env))  
                }  
            }  
        };  
    }  
}  
```  
  
 <span data-ttu-id="19ff2-207">在下面的示例中，使用 `Square` 调用由单个 <xref:System.Activities.WorkflowInvoker> 活动组成的工作流定义。</span><span class="sxs-lookup"><span data-stu-id="19ff2-207">In the following example, a workflow definition consisting of a single `Square` activity is invoked using <xref:System.Activities.WorkflowInvoker>.</span></span>  
  
```csharp  
Dictionary<string, object> inputs = new Dictionary<string, object> {{ "Value", 5}};  
int result = WorkflowInvoker.Invoke(new Square(), inputs);  
Console.WriteLine("Result: {0}", result);  
```  
  
 <span data-ttu-id="19ff2-208">在调用工作流时，下面的输出显示到控制台：</span><span class="sxs-lookup"><span data-stu-id="19ff2-208">When the workflow is invoked, the following output is displayed to the console:</span></span>  
  
 <span data-ttu-id="19ff2-209">**求平方值：5**</span><span class="sxs-lookup"><span data-stu-id="19ff2-209">**Squaring the value: 5**</span></span>  
<span data-ttu-id="19ff2-210">**结果：25**</span><span class="sxs-lookup"><span data-stu-id="19ff2-210">**Result: 25**</span></span>
