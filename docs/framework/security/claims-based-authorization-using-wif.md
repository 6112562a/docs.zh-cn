---
title: 使用 WIF 的基于声明的授权
ms.date: 03/30/2017
ms.assetid: e24000a3-8fd8-4c0e-bdf0-39882cc0f6d8
author: BrucePerlerMS
ms.openlocfilehash: e269a168c5aa594684a41a98338d961447acd536
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/23/2019
ms.locfileid: "61792829"
---
# <a name="claims-based-authorization-using-wif"></a><span data-ttu-id="b1c02-102">使用 WIF 的基于声明的授权</span><span class="sxs-lookup"><span data-stu-id="b1c02-102">Claims Based Authorization Using WIF</span></span>
<span data-ttu-id="b1c02-103">在依赖方应用程序中，授权可确定允许已经过身份验证的标识访问的资源以及允许该标识对这些资源执行的操作。</span><span class="sxs-lookup"><span data-stu-id="b1c02-103">In a relying party application, authorization determines what resources an authenticated identity is allowed to access and what operations it is allowed to perform on those resources.</span></span> <span data-ttu-id="b1c02-104">授权不当会导致信息泄露和数据篡改。</span><span class="sxs-lookup"><span data-stu-id="b1c02-104">Improper or weak authorization leads to information disclosure and data tampering.</span></span> <span data-ttu-id="b1c02-105">本主题概述了可用于通过 Windows Identity Foundation (WIF) 和安全令牌服务 (STS) 来实现针对声明感知 ASP.NET Web 应用程序和服务（例如，Microsoft Azure 访问控制服务 (ACS)）的授权的方法。</span><span class="sxs-lookup"><span data-stu-id="b1c02-105">This topic outlines the available approaches to implementing authorization for claims-aware ASP.NET web applications and services using Windows Identity Foundation (WIF) and a Security Token Service (STS), for example, the Windows Azure Access Control Service (ACS).</span></span>  
  
## <a name="overview"></a><span data-ttu-id="b1c02-106">概述</span><span class="sxs-lookup"><span data-stu-id="b1c02-106">Overview</span></span>  
 <span data-ttu-id="b1c02-107">.NET Framework 自其第一个版本开始便已提供用于实现授权的灵活机制。</span><span class="sxs-lookup"><span data-stu-id="b1c02-107">Since its first version, the .NET Framework has offered a flexible mechanism for implementing authorization.</span></span> <span data-ttu-id="b1c02-108">此机制基于两个简单接口 - IPrincipal 接口和 IIdentity 接口。</span><span class="sxs-lookup"><span data-stu-id="b1c02-108">This mechanism is based on two simple interfaces—**IPrincipal** and **IIdentity**.</span></span> <span data-ttu-id="b1c02-109">IIdentity 接口的具体实现表示已经过身份验证的用户。</span><span class="sxs-lookup"><span data-stu-id="b1c02-109">Concrete implementations of **IIdentity** represent an authenticated user.</span></span> <span data-ttu-id="b1c02-110">例如，WindowsIdentity 实现表示已由 Active Directory 进行身份验证的用户，而 GenericIdentity 表示已经过自定义身份验证过程验证其身份的用户。</span><span class="sxs-lookup"><span data-stu-id="b1c02-110">For example, the **WindowsIdentity** implementation represents a user who is authenticated by Active Directory, and **GenericIdentity** represents a user whose identity is verified via a custom authentication process.</span></span> <span data-ttu-id="b1c02-111">IPrincipal 接口的具体实现可帮助使用角色（具体取决于角色存储）检查权限。</span><span class="sxs-lookup"><span data-stu-id="b1c02-111">Concrete implementations of **IPrincipal** help to check permissions using roles depending on the role store.</span></span> <span data-ttu-id="b1c02-112">例如，WindowsPrincipal 检查 Active Directory 组中 WindowsIdentity 的成员资格。</span><span class="sxs-lookup"><span data-stu-id="b1c02-112">For example, **WindowsPrincipal** checks **WindowsIdentity** for membership in Active Directory groups.</span></span> <span data-ttu-id="b1c02-113">通过在 IPrincipal 接口上调用 IsInRole 方法执行此检查。</span><span class="sxs-lookup"><span data-stu-id="b1c02-113">This check is performed by calling the **IsInRole** method on the **IPrincipal** interface.</span></span> <span data-ttu-id="b1c02-114">基于角色检查访问权称作基于角色的访问控制 (RBAC)。</span><span class="sxs-lookup"><span data-stu-id="b1c02-114">Checking access based on roles is called Role-Based Access Control (RBAC).</span></span> <span data-ttu-id="b1c02-115">有关详细信息，请参阅[基于角色的访问控制](../../../docs/framework/security/claims-based-authorization-using-wif.md#BKMK_1)。</span><span class="sxs-lookup"><span data-stu-id="b1c02-115">For more information, see [Role-Based Access Control](../../../docs/framework/security/claims-based-authorization-using-wif.md#BKMK_1).</span></span>  <span data-ttu-id="b1c02-116">声明可用于携带有关角色的信息以支持熟悉的、基于角色的授权机制。</span><span class="sxs-lookup"><span data-stu-id="b1c02-116">Claims can be used to carry information about roles to support familiar, role-based authorization mechanisms.</span></span>  
  
 <span data-ttu-id="b1c02-117">声明还可用于启用超出角色范围的更复杂的授权决策。</span><span class="sxs-lookup"><span data-stu-id="b1c02-117">Claims can also be used to enable more complicated authorization decisions beyond roles.</span></span> <span data-ttu-id="b1c02-118">声明可以基于用户的年龄、邮编、鞋码等几乎任何信息。基于任意声明的访问控制机制称为基于声明的授权。</span><span class="sxs-lookup"><span data-stu-id="b1c02-118">Claims can be based on virtually any information about the user - age, zip code, shoe size, etc. An access control mechanism that is based on arbitrary claims is called claims-based authorization.</span></span> <span data-ttu-id="b1c02-119">有关详细信息，请参阅[基于声明的授权](../../../docs/framework/security/claims-based-authorization-using-wif.md#BKMK_2)。</span><span class="sxs-lookup"><span data-stu-id="b1c02-119">For more information, see [Claims-based Authorization](../../../docs/framework/security/claims-based-authorization-using-wif.md#BKMK_2).</span></span>  
  
<a name="BKMK_1"></a>   
## <a name="role-based-access-control"></a><span data-ttu-id="b1c02-120">基于角色的访问控制</span><span class="sxs-lookup"><span data-stu-id="b1c02-120">Role-Based Access Control</span></span>  
 <span data-ttu-id="b1c02-121">RBAC 是一种授权方法，其中的用户权限由基于用户角色的应用程序管理和强制实施。</span><span class="sxs-lookup"><span data-stu-id="b1c02-121">RBAC is an authorization approach in which user permissions are managed and enforced by an application based on user roles.</span></span> <span data-ttu-id="b1c02-122">如果用户具有执行操作所需的角色，则将授予访问权；否则，访问将被拒绝。</span><span class="sxs-lookup"><span data-stu-id="b1c02-122">If a user has a role that is required to perform an action, the access is granted; otherwise, access is denied.</span></span>  
  
### <a name="iprincipalisinrole-method"></a><span data-ttu-id="b1c02-123">IPrincipal.IsInRole 方法</span><span class="sxs-lookup"><span data-stu-id="b1c02-123">IPrincipal.IsInRole Method</span></span>  
 <span data-ttu-id="b1c02-124">若要在声明感知应用程序中实现 RBAC 方法，请在 IPrinicpal 接口中使用 IsInRole() 方法，与在非声明感知应用程序中执行的操作一样。</span><span class="sxs-lookup"><span data-stu-id="b1c02-124">To implement the RBAC approach in claims-aware applications, use the **IsInRole()** method in the **IPrinicpal** interface, just as you would in non-claims-aware applications.</span></span> <span data-ttu-id="b1c02-125">使用 IsInRole() 方法有好几种方式：</span><span class="sxs-lookup"><span data-stu-id="b1c02-125">There are several ways of using the **IsInRole()** method:</span></span>  
  
- <span data-ttu-id="b1c02-126">对 IPrincipal.IsInRole(“Administrator”) 进行显式调用。</span><span class="sxs-lookup"><span data-stu-id="b1c02-126">Explicitly calling on **IPrincipal.IsInRole("Administrator")**.</span></span> <span data-ttu-id="b1c02-127">在此方法中，结果为布尔值。</span><span class="sxs-lookup"><span data-stu-id="b1c02-127">In this approach, the outcome is a Boolean.</span></span> <span data-ttu-id="b1c02-128">在条件语句中使用它。</span><span class="sxs-lookup"><span data-stu-id="b1c02-128">Use it in your conditional statements.</span></span> <span data-ttu-id="b1c02-129">可在代码中的任意位置使用它。</span><span class="sxs-lookup"><span data-stu-id="b1c02-129">It can be used arbitrarily any place in your code.</span></span>  
  
- <span data-ttu-id="b1c02-130">使用安全性要求 PrincipalPermission.Demand()。</span><span class="sxs-lookup"><span data-stu-id="b1c02-130">Using the security demand **PrincipalPermission.Demand()**.</span></span> <span data-ttu-id="b1c02-131">在此方法中，如果未满足要求，则结果为异常。</span><span class="sxs-lookup"><span data-stu-id="b1c02-131">In this approach, the outcome is an exception in case the demand is not satisfied.</span></span> <span data-ttu-id="b1c02-132">这应适合您的异常处理策略。</span><span class="sxs-lookup"><span data-stu-id="b1c02-132">This should fit your exception handling strategy.</span></span> <span data-ttu-id="b1c02-133">从性能角度看，与停用布尔值相比，引发异常的代价更高。</span><span class="sxs-lookup"><span data-stu-id="b1c02-133">Throwing exceptions is much more expensive from a performance perspective compared to returning Boolean.</span></span> <span data-ttu-id="b1c02-134">可在代码中的任何位置进行使用。</span><span class="sxs-lookup"><span data-stu-id="b1c02-134">This can be used any place in your code.</span></span>  
  
- <span data-ttu-id="b1c02-135">使用声明性特性 [PrincipalPermission(SecurityAction.Demand, Role = “Administrator”)]。</span><span class="sxs-lookup"><span data-stu-id="b1c02-135">Using the declarative attributes **[PrincipalPermission(SecurityAction.Demand, Role = "Administrator")]**.</span></span> <span data-ttu-id="b1c02-136">此方法称为声明性方法，因为它用于修饰方法。</span><span class="sxs-lookup"><span data-stu-id="b1c02-136">This approach is called declarative, because it is used to decorate methods.</span></span> <span data-ttu-id="b1c02-137">它不能在方法实现中的代码块内使用。</span><span class="sxs-lookup"><span data-stu-id="b1c02-137">It cannot be used in code blocks inside the method’s implementations.</span></span> <span data-ttu-id="b1c02-138">如果未满足要求，则结果为异常。</span><span class="sxs-lookup"><span data-stu-id="b1c02-138">The outcome is an exception in case the demand is not satisfied.</span></span> <span data-ttu-id="b1c02-139">您应确保它适合您的异常处理策略。</span><span class="sxs-lookup"><span data-stu-id="b1c02-139">You should make sure that it fits your exception-handling strategy.</span></span>  
  
- <span data-ttu-id="b1c02-140">使用 URL 授权，并使用 web.config 中的\<authorization> 部分。在 URL 级别上管理授权时，此方法很适用。</span><span class="sxs-lookup"><span data-stu-id="b1c02-140">Using URL authorization, using the **\<authorization>** section in **web.config**. This approach is suitable when you are managing authorization on a URL level.</span></span> <span data-ttu-id="b1c02-141">这是前面提到的方法中最粗糙的方法。</span><span class="sxs-lookup"><span data-stu-id="b1c02-141">This is the most coarse level among those previously mentioned.</span></span> <span data-ttu-id="b1c02-142">此方法的优点在于，更改是在配置文件中做出的，这意味着无需编译代码即可利用此更改。</span><span class="sxs-lookup"><span data-stu-id="b1c02-142">The advantage of this approach is that changes are made in the configuration file, which means that the code should not be compiled to take advantage of the change.</span></span>  
  
### <a name="expressing-roles-as-claims"></a><span data-ttu-id="b1c02-143">将角色表示为声明</span><span class="sxs-lookup"><span data-stu-id="b1c02-143">Expressing Roles as Claims</span></span>  
 <span data-ttu-id="b1c02-144">调用 IsInRole() 方法时，会进行一次检查以查明当前用户是否拥有该角色。</span><span class="sxs-lookup"><span data-stu-id="b1c02-144">When the **IsInRole()** method is called, there is a check made to see if the current user has that role.</span></span> <span data-ttu-id="b1c02-145">在声明感知应用程序中，该角色由应在令牌中可用的角色声明类型表示。</span><span class="sxs-lookup"><span data-stu-id="b1c02-145">In claims-aware applications, the role is expressed by a role claim type that should be available in the token.</span></span> <span data-ttu-id="b1c02-146">使用以下 URI 表示此角色声明类型：</span><span class="sxs-lookup"><span data-stu-id="b1c02-146">The role claim type is expressed using the following URI:</span></span>  
  
 `http://schemas.microsoft.com/ws/2008/06/identity/claims/role`
  
 <span data-ttu-id="b1c02-147">可通过几种方法增强带角色声明类型的令牌：</span><span class="sxs-lookup"><span data-stu-id="b1c02-147">There are several ways to enrich a token with a role claim type:</span></span>  
  
- <span data-ttu-id="b1c02-148">**在令牌颁发过程中**。</span><span class="sxs-lookup"><span data-stu-id="b1c02-148">**During token issuance**.</span></span> <span data-ttu-id="b1c02-149">对用户进行身份验证时，可由标识提供程序 STS 或联合身份验证提供程序（如 Microsoft Azure 访问控制服务 (ACS)）发布角色声明。</span><span class="sxs-lookup"><span data-stu-id="b1c02-149">When a user is authenticated the role claim can be issued by the identity provider STS or by a federation provider such as the Windows Azure Access Control Service (ACS).</span></span>  
  
- <span data-ttu-id="b1c02-150">**使用 ClaimsAuthenticationManager 将任意声明转换为声明角色类型**。</span><span class="sxs-lookup"><span data-stu-id="b1c02-150">**Transforming arbitrary claims into of claims role type using ClaimsAuthenticationManager**.</span></span> <span data-ttu-id="b1c02-151">ClaimsAuthenticationManager 是作为 WIF 的一部分附带的组件。</span><span class="sxs-lookup"><span data-stu-id="b1c02-151">The ClaimsAuthenticationManager is a component that ships as part of WIF.</span></span> <span data-ttu-id="b1c02-152">它允许在请求启动应用程序时拦截请求，并通过添加、更改或删除声明来检查并转换令牌。</span><span class="sxs-lookup"><span data-stu-id="b1c02-152">It allows requests to be intercepted when they launch an application, inspecting tokens and transforming them by adding, changing, or removing claims.</span></span> <span data-ttu-id="b1c02-153">有关如何使用 ClaimsAuthenticationManager 来转换声明的详细信息，请参阅[How To:实现基于角色的访问控制 (RBAC) 在声明感知 ASP.NET 应用程序应用程序使用 WIF 和 ACS](https://go.microsoft.com/fwlink/?LinkID=247445)。</span><span class="sxs-lookup"><span data-stu-id="b1c02-153">For more information about how to use ClaimsAuthenticationManager for transforming claims, see [How To: Implement Role Based Access Control (RBAC) in a Claims Aware ASP.NET Application Using WIF and ACS](https://go.microsoft.com/fwlink/?LinkID=247445).</span></span>  
  
- <span data-ttu-id="b1c02-154">使用 samlSecurityTokenRequirement 配置节将任意声明映射到角色类型 - 一种声明性方法，其中仅使用配置完成声明转换且无需编码。</span><span class="sxs-lookup"><span data-stu-id="b1c02-154">**Mapping arbitrary claims to a role type using the samlSecurityTokenRequirement configuration section**—A declarative approach where the claims transformation is done using only the configuration and no coding is required.</span></span>  
  
<a name="BKMK_2"></a>   
## <a name="claims-based-authorization"></a><span data-ttu-id="b1c02-155">基于声明的授权</span><span class="sxs-lookup"><span data-stu-id="b1c02-155">Claims-based Authorization</span></span>  
 <span data-ttu-id="b1c02-156">基于声明的授权是一种方法，其中授予访问权或拒绝访问的授权决策基于使用声明中的可用数据做出决策的任意逻辑。</span><span class="sxs-lookup"><span data-stu-id="b1c02-156">Claims-based authorization is an approach where the authorization decision to grant or deny access is based on arbitrary logic that uses data available in claims to make the decision.</span></span> <span data-ttu-id="b1c02-157">请记住，对于 RBAC，仅使用角色类型声明。</span><span class="sxs-lookup"><span data-stu-id="b1c02-157">Recall that in the case of RBAC, the only claim used was role type claim.</span></span> <span data-ttu-id="b1c02-158">角色类型声明用于检查用户是否属于特定角色。</span><span class="sxs-lookup"><span data-stu-id="b1c02-158">A role type claim was used to check if the user belongs to specific role or not.</span></span> <span data-ttu-id="b1c02-159">若要阐释使用基于声明的授权方法做出授权决策的过程，请考虑以下步骤：</span><span class="sxs-lookup"><span data-stu-id="b1c02-159">To illustrate the process of making the authorization decisions using claims-based authorization approach, consider the following steps:</span></span>  
  
1. <span data-ttu-id="b1c02-160">应用程序收到要求对用户进行身份验证的请求。</span><span class="sxs-lookup"><span data-stu-id="b1c02-160">The application receives a request that requires the user is authenticated.</span></span>  
  
2. <span data-ttu-id="b1c02-161">WIF 将用户重定向到其标识提供程序，在对用户进行身份验证后，使用关联的安全令牌（表示包含有关声明的用户）发出应用程序请求。</span><span class="sxs-lookup"><span data-stu-id="b1c02-161">WIF redirects the user to their identity provider, after they are authenticated the application request is made with an associated security token representing the user containing claims about them.</span></span> <span data-ttu-id="b1c02-162">WIF 将这些声明与表示用户的主体相关联。</span><span class="sxs-lookup"><span data-stu-id="b1c02-162">WIF associates those claims with the principal that represents the user.</span></span>  
  
3. <span data-ttu-id="b1c02-163">应用程序将声明传递给决策逻辑机制。</span><span class="sxs-lookup"><span data-stu-id="b1c02-163">The application passes the claims to the decision logic mechanism.</span></span> <span data-ttu-id="b1c02-164">它可以是内存中的代码、对 Web 服务的调用、对数据库的查询、复杂的规则引擎或使用 ClaimsAuthorizationManager。</span><span class="sxs-lookup"><span data-stu-id="b1c02-164">It can be in-memory code, a call to a web service, a query to a database, a sophisticated rules engine, or using the ClaimsAuthorizationManager.</span></span>  
  
4. <span data-ttu-id="b1c02-165">决策机制根据声明计算结果。</span><span class="sxs-lookup"><span data-stu-id="b1c02-165">The decision mechanism calculates the outcome based on the claims.</span></span>  
  
5. <span data-ttu-id="b1c02-166">如果结果为 true，则授予访问权；如果结果为 false，则拒绝访问。</span><span class="sxs-lookup"><span data-stu-id="b1c02-166">Access is granted if the outcome is true and denied if it is false.</span></span> <span data-ttu-id="b1c02-167">例如，规则可能是年龄为 21 岁或以上且居住在华盛顿州的用户。</span><span class="sxs-lookup"><span data-stu-id="b1c02-167">For example, the rule might be that the user is of age 21 or above and lives in Washington State.</span></span>  
  
 <span data-ttu-id="b1c02-168"><xref:System.Security.Claims.ClaimsAuthorizationManager> 有助于在应用程序中具体化基于声明的授权的决策逻辑。</span><span class="sxs-lookup"><span data-stu-id="b1c02-168"><xref:System.Security.Claims.ClaimsAuthorizationManager> is useful for externalizing the decision logic for  claims-based authorization in your applications.</span></span> <span data-ttu-id="b1c02-169">ClaimsAuthorizationManager 是作为 .NET 4.5 的一部分附带的 WIF 组件。</span><span class="sxs-lookup"><span data-stu-id="b1c02-169">ClaimsAuthorizationManager is a WIF component that ships as part of .NET 4.5.</span></span> <span data-ttu-id="b1c02-170">ClaimsAuthorizationManager 允许您拦截传入请求，并实现选定的任何逻辑以根据传入声明做出授权决策。</span><span class="sxs-lookup"><span data-stu-id="b1c02-170">ClaimsAuthorizationManager allows you to intercept incoming requests and implement any logic of your choice to make authorization decisions based on the incoming claims.</span></span> <span data-ttu-id="b1c02-171">在需要更改授权逻辑时，这变得非常重要。</span><span class="sxs-lookup"><span data-stu-id="b1c02-171">This becomes important when authorization logic needs to be changed.</span></span> <span data-ttu-id="b1c02-172">在这种情况下，使用 ClaimsAuthorizationManager 将不会影响应用程序的完整性，从而降低了更改导致应用程序错误的可能性。</span><span class="sxs-lookup"><span data-stu-id="b1c02-172">In that case, using ClaimsAuthorizationManager will not affect the application’s integrity, thereby reducing the likelihood of an application error as a result of the change.</span></span> <span data-ttu-id="b1c02-173">若要了解有关如何使用 ClaimsAuthorizationManager 实现基于声明的访问控制的详细信息，请参阅[How To:实现声明授权在声明感知 ASP.NET 应用程序应用程序使用 WIF 和 ACS](https://go.microsoft.com/fwlink/?LinkID=247446)。</span><span class="sxs-lookup"><span data-stu-id="b1c02-173">To learn more about how to use ClaimsAuthorizationManager to implement claims-based access control, see [How To: Implement Claims Authorization in a Claims Aware ASP.NET Application Using WIF and ACS](https://go.microsoft.com/fwlink/?LinkID=247446).</span></span>
