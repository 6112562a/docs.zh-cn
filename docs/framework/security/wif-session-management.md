---
title: WIF 会话管理
ms.date: 03/30/2017
ms.assetid: 98bce126-18a9-401b-b20d-67ee462a5f8a
author: BrucePerlerMS
ms.openlocfilehash: 980d0c6dca9b0b5fadf2d4a841e4c95a9acaff52
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/23/2019
ms.locfileid: "61780076"
---
# <a name="wif-session-management"></a><span data-ttu-id="24203-102">WIF 会话管理</span><span class="sxs-lookup"><span data-stu-id="24203-102">WIF Session Management</span></span>
<span data-ttu-id="24203-103">客户端首次尝试访问信赖方托管的受保护资源时，客户端应先向信赖方信任的安全令牌服务 (STS) 验证自身身份。</span><span class="sxs-lookup"><span data-stu-id="24203-103">When a client first tries to access a protected resource that is hosted by a relying party, the client must first authenticate itself to a security token service (STS) that is trusted by the relying party.</span></span> <span data-ttu-id="24203-104">然后，STS 向客户端颁发安全令牌。</span><span class="sxs-lookup"><span data-stu-id="24203-104">The STS then issues a security token to the client.</span></span> <span data-ttu-id="24203-105">客户端向信赖方出示此令牌，然后信赖方授予客户端访问受保护资源的权限。</span><span class="sxs-lookup"><span data-stu-id="24203-105">The client presents this token to the relying party, which then grants the client access to the protected resource.</span></span> <span data-ttu-id="24203-106">但是，不希望客户端针对每个请求重新向 STS 进行身份验证，特别是因为它甚至可能与依赖方不在同一台计算机上或同一个域中。</span><span class="sxs-lookup"><span data-stu-id="24203-106">However, you don’t want the client to have to re-authenticate to the STS for each request, especially because it might not even be on the same computer or in the same domain as the relying party.</span></span> <span data-ttu-id="24203-107">相反，Windows Identity Foundation (WIF) 中客户端和信赖方建立一个会话，该会话中客户端为首次请求后的所有请求使用会话安全令牌向信赖方验证自身身份。</span><span class="sxs-lookup"><span data-stu-id="24203-107">Instead, Windows Identity Foundation (WIF) has the client and relying party establish a session in which the client uses a session security token to authenticate itself to the relying party for all requests after the first request.</span></span> <span data-ttu-id="24203-108">信赖方可以使用 cookie 中存储的此会话安全令牌重构客户端的 <xref:System.Security.Claims.ClaimsPrincipal?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="24203-108">The relying party can use this session security token, which is stored inside a cookie, to reconstruct the client’s <xref:System.Security.Claims.ClaimsPrincipal?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="24203-109">STS 定义客户端应提供的身份验证类型。</span><span class="sxs-lookup"><span data-stu-id="24203-109">The STS defines what authentication the client must provide.</span></span> <span data-ttu-id="24203-110">但是，客户端可能有多个用于向 STS 验证自身身份的凭据。</span><span class="sxs-lookup"><span data-stu-id="24203-110">However, the client might have multiple credentials with which it can authenticate itself to the STS.</span></span> <span data-ttu-id="24203-111">例如，它可能有来自 Windows Live 的令牌、用户名和密码、证书和智能密钥。</span><span class="sxs-lookup"><span data-stu-id="24203-111">For example, it might have a token from Windows Live, a user name and password, a certificate, and a smartkey.</span></span> <span data-ttu-id="24203-112">在这种情况下，STS 会向客户端授予多个标识，每个标识对应客户端出示的凭据之一。</span><span class="sxs-lookup"><span data-stu-id="24203-112">In that case, the STS grants the client several identities, with each identity corresponding to one of the credentials that the client presents.</span></span> <span data-ttu-id="24203-113">信赖方决定授予客户端哪一等级的访问时，可以使用一个或多个此类标识。</span><span class="sxs-lookup"><span data-stu-id="24203-113">The relying party can use one or more of these identities when it decides what level of access to grant the client.</span></span>  
  
 <span data-ttu-id="24203-114">使用 <xref:System.IdentityModel.Tokens.SessionSecurityToken?displayProperty=nameWithType> 重新构造客户端的 <xref:System.Security.Claims.ClaimsPrincipal?displayProperty=nameWithType>其中包含 <xref:System.Security.Claims.ClaimsPrincipal.Identities%2A> 中的所有客户端标识。</span><span class="sxs-lookup"><span data-stu-id="24203-114">The <xref:System.IdentityModel.Tokens.SessionSecurityToken?displayProperty=nameWithType> is used to reconstruct the client’s <xref:System.Security.Claims.ClaimsPrincipal?displayProperty=nameWithType>, which contains all of the client’s identities in <xref:System.Security.Claims.ClaimsPrincipal.Identities%2A>.</span></span> <span data-ttu-id="24203-115">集合中的每个 <xref:System.Security.Claims.ClaimsIdentity?displayProperty=nameWithType> 都包含与该标识相关联的启动令牌。</span><span class="sxs-lookup"><span data-stu-id="24203-115">Each <xref:System.Security.Claims.ClaimsIdentity?displayProperty=nameWithType> in the collection contains the bootstrap tokens that are associated with that identity.</span></span>  
  
 <span data-ttu-id="24203-116">如果同时颁发新会话令牌和原始会话令牌的会话 ID，<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler?displayProperty=nameWithType> 将不会更新令牌缓存中的新会话令牌。</span><span class="sxs-lookup"><span data-stu-id="24203-116">If a new session token is issued with the session ID of the original session token, <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler?displayProperty=nameWithType> does not update the session token in the token cache.</span></span> <span data-ttu-id="24203-117">应始终使用唯一的会话 ID 实例化会话令牌。</span><span class="sxs-lookup"><span data-stu-id="24203-117">You should always instantiate a session token with a unique session ID.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="24203-118">如果 Session.SecurityTokenHandler.ReadToken 收到无效的输入（例如，如果包含会话令牌的 cookie 损坏），会引发 <xref:System.Xml.XmlException> 异常。</span><span class="sxs-lookup"><span data-stu-id="24203-118">Session.SecurityTokenHandler.ReadToken throws a <xref:System.Xml.XmlException> exception if it receives invalid input; for example, if the cookie that contains the session token is corrupted.</span></span> <span data-ttu-id="24203-119">我们建议捕捉此异常并提供特定于应用程序的行为。</span><span class="sxs-lookup"><span data-stu-id="24203-119">We recommend that you catch this exception and provide application-specific behavior.</span></span>  
  
 <span data-ttu-id="24203-120">如果受保护网页包含大量同样位于受保护域的资源（如小图形），那么客户端必须项信赖方重新验证自身身份以下载这些资源。</span><span class="sxs-lookup"><span data-stu-id="24203-120">If a protected Web page contains lots of resources (such as small graphics) that are also in the protected domain, the client must re-authenticate itself to the relying party to download each of those resources.</span></span> <span data-ttu-id="24203-121">使用会话身份验证令牌可避免每次请求都需要向 STS 验证身份的情况，但仍意味着在发送许多 cookie。</span><span class="sxs-lookup"><span data-stu-id="24203-121">Use of a session authentication token avoids the need to authenticate to the STS for each request, but it still means that many cookies are being sent over.</span></span> <span data-ttu-id="24203-122">你可能希望设置网页以使重要数据和资源存储在受保护的域中，同时次要项存储在不受保护的域中并从主网页创建链接。</span><span class="sxs-lookup"><span data-stu-id="24203-122">You might want to set up the Web page so that the important data and resources are stored in the protected domain while minor items are stored in an unprotected domain and linked to from the main Web page.</span></span> <span data-ttu-id="24203-123">此外，将 cookie 路径设置为只引用受保护的域。</span><span class="sxs-lookup"><span data-stu-id="24203-123">Also, set the cookie path to reference only the protected domain.</span></span>  
  
 <span data-ttu-id="24203-124">若要在引用模式下操作，Microsoft 建议为“global.asax.cs”文件中的 <xref:System.IdentityModel.Services.WSFederationAuthenticationModule.SessionSecurityTokenCreated> 事件提供一个处理程序，并在 <xref:System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs.SessionToken%2A> 属性中传递的令牌上设置“IsReferenceMode”属性。</span><span class="sxs-lookup"><span data-stu-id="24203-124">To operate in reference mode, Microsoft recommends providing a handler for the <xref:System.IdentityModel.Services.WSFederationAuthenticationModule.SessionSecurityTokenCreated> event in the **global.asax.cs** file and setting the **IsReferenceMode** property on the token passed in the <xref:System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs.SessionToken%2A> property.</span></span> <span data-ttu-id="24203-125">这些更新将确保会话令牌在每个请求的引用模式下运行，并更倾向于仅在会话身份验证模块上设置 <xref:System.IdentityModel.Services.SessionAuthenticationModule.IsReferenceMode%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="24203-125">These updates will ensure that the session token operates in reference mode for every request and is favored over merely setting the  <xref:System.IdentityModel.Services.SessionAuthenticationModule.IsReferenceMode%2A> property on the Session Authentication Module.</span></span>  
  
## <a name="extensibility"></a><span data-ttu-id="24203-126">扩展性</span><span class="sxs-lookup"><span data-stu-id="24203-126">Extensibility</span></span>  
 <span data-ttu-id="24203-127">可以扩展会话管理机制。</span><span class="sxs-lookup"><span data-stu-id="24203-127">You can extend the session management mechanism.</span></span> <span data-ttu-id="24203-128">原因之一是可提升性能。</span><span class="sxs-lookup"><span data-stu-id="24203-128">One reason for this would be to improve the performance.</span></span> <span data-ttu-id="24203-129">例如，可以创建一个自定义 cookie 处理程序，该处理程序转换或优化内存中状态间的会话安全令牌和进入 cookie 中的内容。</span><span class="sxs-lookup"><span data-stu-id="24203-129">For example, you could create a custom cookie handler that transforms or optimizes the session security token between its in-memory state and what goes into the cookie.</span></span> <span data-ttu-id="24203-130">为此，可以配置 <xref:System.IdentityModel.Services.SessionAuthenticationModule?displayProperty=nameWithType> 的 <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A?displayProperty=nameWithType> 属性以使用派生自 <xref:System.IdentityModel.Services.CookieHandler?displayProperty=nameWithType> 的自定义 cookie 处理程序。</span><span class="sxs-lookup"><span data-stu-id="24203-130">To do so, you can configure the <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A?displayProperty=nameWithType> property of the <xref:System.IdentityModel.Services.SessionAuthenticationModule?displayProperty=nameWithType> to use a custom cookie handler that derives from <xref:System.IdentityModel.Services.CookieHandler?displayProperty=nameWithType>.</span></span> <span data-ttu-id="24203-131"><xref:System.IdentityModel.Services.ChunkedCookieHandler?displayProperty=nameWithType> 是默认 cookie 处理程序，因为 cookie 超过了超文本传输协议 (HTTP) 允许的大小；如果使用自定义 cookie 处理程序代替，必须进行分块。</span><span class="sxs-lookup"><span data-stu-id="24203-131"><xref:System.IdentityModel.Services.ChunkedCookieHandler?displayProperty=nameWithType> is the default cookie handler because the cookies exceed the allowable size for Hypertext Transfer Protocol (HTTP); if you use a custom cookie handler instead, you must implement chunking.</span></span>  
  
 <span data-ttu-id="24203-132">有关详细信息，请参阅[ClaimsAwareWebFarm](https://go.microsoft.com/fwlink/?LinkID=248408)示例。</span><span class="sxs-lookup"><span data-stu-id="24203-132">For more information, see [ClaimsAwareWebFarm](https://go.microsoft.com/fwlink/?LinkID=248408) sample.</span></span> <span data-ttu-id="24203-133">此示例演示场就绪会话缓存（相对于 tokenreplycache），以便可以通过引用而非交换大型 cookie 使用会话。此示例还演示保护群集中的 cookie 更简单的方法。</span><span class="sxs-lookup"><span data-stu-id="24203-133">This sample shows a farm ready session cache (as opposed to a tokenreplycache) so that you can use sessions by reference instead of exchanging big cookies; this sample also demonstrates an easier way of securing cookies in a farm.</span></span> <span data-ttu-id="24203-134">会话缓存基于 WCF。</span><span class="sxs-lookup"><span data-stu-id="24203-134">The session cache is WCF-based.</span></span> <span data-ttu-id="24203-135">至于会话保护，该示例演示 WIF 4.5 中基于 MachineKey 的 cookie 转换的新功能，只需在 web.config 中粘贴适当的代码片段即可激活。示例本身并未“场化”，但是它显示应用场就绪需要什么。</span><span class="sxs-lookup"><span data-stu-id="24203-135">With regard to session securing, the sample demonstrates a new capability in WIF 4.5 of a cookie transform based on MachineKey, which can be activated by simply pasting the appropriate snippet in the web.config. The sample itself is not "farmed", but it demonstrates what you need for making your app farm-ready.</span></span>
