---
title: 反射的安全注意事项
ms.date: 03/30/2017
helpviewer_keywords:
- permissions [.NET Framework], reflection
- MethodInfo parameters
- reflection, security
- partial trust,reflection
- nonpublic members
- reflection,partial trust
- link demands
ms.assetid: 42d9dc2a-8fcc-4ff3-b002-4ff260ef3dc5
ms.openlocfilehash: 1bdaf3abd39797274236ace4cb2967d2e7d199b2
ms.sourcegitcommit: 62285ec11fa8e8424bab00511a90760c60e63c95
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/20/2020
ms.locfileid: "81644186"
---
# <a name="security-considerations-for-reflection"></a><span data-ttu-id="ac9ba-102">反射的安全注意事项</span><span class="sxs-lookup"><span data-stu-id="ac9ba-102">Security Considerations for Reflection</span></span>

<span data-ttu-id="ac9ba-103">通过反射能够获取有关类型和成员的信息，并能访问成员（即，调用方法和构造函数来获取和设置属性值，添加和移除事件处理程序，等等）。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-103">Reflection provides the ability to obtain information about types and members, and to access members (that is, to call methods and constructors, to get and set property values, to add and remove event handlers, and so on).</span></span> <span data-ttu-id="ac9ba-104">使用反射可以获取有关类型的信息并且成员是不受限制的。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-104">The use of reflection to obtain information about types and members is not restricted.</span></span> <span data-ttu-id="ac9ba-105">所有代码都可使用反射来执行以下任务：</span><span class="sxs-lookup"><span data-stu-id="ac9ba-105">All code can use reflection to perform the following tasks:</span></span>

- <span data-ttu-id="ac9ba-106">枚举类型和成员，并检查其元数据。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-106">Enumerate types and members, and examine their metadata.</span></span>

- <span data-ttu-id="ac9ba-107">枚举并检查程序集和模块。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-107">Enumerate and examine assemblies and modules.</span></span>

<span data-ttu-id="ac9ba-108">与之相反，使用反射来访问成员会受到限制。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-108">Using reflection to access members, by contrast, is subject to restrictions.</span></span> <span data-ttu-id="ac9ba-109">从 .NET Framework 4 开始，只有受信任的代码才能使用反射来访问安全关键成员。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-109">Beginning with the .NET Framework 4, only trusted code can use reflection to access security-critical members.</span></span> <span data-ttu-id="ac9ba-110">而且，只有受信任的代码才能使用反射访问无法由已编译代码直接访问的非公共成员。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-110">Furthermore, only trusted code can use reflection to access nonpublic members that would not be directly accessible to compiled code.</span></span> <span data-ttu-id="ac9ba-111">最后，使用反射访问关键安全成员的代码必须具有关键安全成员要求的任何权限，就像编译的代码一样。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-111">Finally, code that uses reflection to access a safe-critical member must have whatever permissions the safe-critical member demands, just as with compiled code.</span></span>

<span data-ttu-id="ac9ba-112">具有一定的权限，代码可以使用反射来执行以下类型的访问：</span><span class="sxs-lookup"><span data-stu-id="ac9ba-112">Subject to necessary permissions, code can use reflection to perform the following kinds of access:</span></span>

- <span data-ttu-id="ac9ba-113">访问不是安全关键的公共成员。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-113">Access public members that are not security-critical.</span></span>

- <span data-ttu-id="ac9ba-114">若这些成员不是安全关键，则访问可进入编译代码的非公共成员。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-114">Access nonpublic members that would be accessible to compiled code, if those members are not security-critical.</span></span> <span data-ttu-id="ac9ba-115">此类非公共成员的示例包括：</span><span class="sxs-lookup"><span data-stu-id="ac9ba-115">Examples of such nonpublic members include:</span></span>

  - <span data-ttu-id="ac9ba-116">调用代码的基础类的受保护成员。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-116">Protected members of the calling code's base classes.</span></span> <span data-ttu-id="ac9ba-117">（在反射中，这称为系列级访问权限。）</span><span class="sxs-lookup"><span data-stu-id="ac9ba-117">(In reflection, this is referred to as family-level access.)</span></span>

  - <span data-ttu-id="ac9ba-118">调用代码的程序集中的 `internal` 成员（Visual Basic 中的 `Friend` 成员）。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-118">`internal` members (`Friend` members in Visual Basic) in the calling code's assembly.</span></span> <span data-ttu-id="ac9ba-119">（在反射中，这称为程序集级别的访问。）</span><span class="sxs-lookup"><span data-stu-id="ac9ba-119">(In reflection, this is referred to as assembly-level access.)</span></span>

  - <span data-ttu-id="ac9ba-120">包含调用代码的类的其他实例的私有成员。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-120">Private members of other instances of the class that contains the calling code.</span></span>

<span data-ttu-id="ac9ba-121">例如，在沙盒应用程序域中运行的代码被限制于此列表所述的访问权限，除非该应用程序域授予其他权限。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-121">For example, code that is run in a sandboxed application domain is limited to the access described in this list, unless the application domain grants additional permissions.</span></span>

<span data-ttu-id="ac9ba-122">从 .NET Framework 2.0 Service Pack 1 开始，尝试访问通常无法访问的成员将生成目标对象授权集的需求以及带 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 标志的 <xref:System.Security.Permissions.ReflectionPermission>。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-122">Starting with the .NET Framework 2.0 Service Pack 1, attempting to access members that are normally inaccessible generates a demand for the grant set of the target object plus <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="ac9ba-123">以“完全信任”运行的代码（比如，从命令行启动的应用程序中的代码）始终可以满足这些权限。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-123">Code that is running with full trust (for example, code in an application that is launched from the command line) can always satisfy these permissions.</span></span> <span data-ttu-id="ac9ba-124">（如本文后续部分所述，访问安全关键成员时会受到限制。）</span><span class="sxs-lookup"><span data-stu-id="ac9ba-124">(This is subject to limitations in accessing security-critical members, as described later in this article.)</span></span>

<span data-ttu-id="ac9ba-125">沙盒应用程序域可以向 <xref:System.Security.Permissions.ReflectionPermission> 授予 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 标志，如本文后续部分中的[访问通常不可访问的成员](#accessingNormallyInaccessible)中所述。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-125">Optionally, a sandboxed application domain can grant <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag, as described in the section [Accessing Members That Are Normally Inaccessible](#accessingNormallyInaccessible), later in this article.</span></span>

<a name="accessingSecurityCritical"></a>

## <a name="accessing-security-critical-members"></a><span data-ttu-id="ac9ba-126">访问安全关键成员</span><span class="sxs-lookup"><span data-stu-id="ac9ba-126">Accessing Security-Critical Members</span></span>

<span data-ttu-id="ac9ba-127">一个成员如果具有 <xref:System.Security.SecurityCriticalAttribute>，而它属于具有 <xref:System.Security.SecurityCriticalAttribute> 的类型，或是它在安全关键程序集中，则该成员为安全关键成员。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-127">A member is security-critical if it has the <xref:System.Security.SecurityCriticalAttribute>, if it belongs to a type that has the <xref:System.Security.SecurityCriticalAttribute>, or if it is in a security-critical assembly.</span></span> <span data-ttu-id="ac9ba-128">从 .NET Framework 4 开始，访问安全关键成员的规则如下：</span><span class="sxs-lookup"><span data-stu-id="ac9ba-128">Beginning with the .NET Framework 4, the rules for accessing security-critical members are as follows:</span></span>

- <span data-ttu-id="ac9ba-129">透明代码不能使用反射来访问安全关键成员，即使是完全受信任的代码。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-129">Transparent code cannot use reflection to access security-critical members, even if the code is fully trusted.</span></span> <span data-ttu-id="ac9ba-130">引发一个 <xref:System.MethodAccessException>、<xref:System.FieldAccessException> 或 <xref:System.TypeAccessException>。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-130">A <xref:System.MethodAccessException>, <xref:System.FieldAccessException>, or <xref:System.TypeAccessException> is thrown.</span></span>

- <span data-ttu-id="ac9ba-131">使用部分信任运行的代码将被视为透明。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-131">Code that is running with partial trust is treated as transparent.</span></span>

<span data-ttu-id="ac9ba-132">无论是通过已编译代码直接访问还是使用反射访问安全关键成员，这些规则都不会变。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-132">These rules are the same whether a security-critical member is accessed directly by compiled code, or accessed by using reflection.</span></span>

<span data-ttu-id="ac9ba-133">从命令行运行的应用程序代码将以“完全信任”运行。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-133">Application code that is run from the command line runs with full trust.</span></span> <span data-ttu-id="ac9ba-134">只要不被标记为透明，它就可以使用反射来访问安全关键成员。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-134">As long as it is not marked as transparent, it can use reflection to access security-critical members.</span></span> <span data-ttu-id="ac9ba-135">当同一代码以部分信任运行时（例如，在沙箱应用程序域中），程序集的信任级别将决定其是否能够访问安全关键代码：如果程序集有强名称并安装在全局程序集缓存中，则是受信任的程序集，可以调用安全关键成员。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-135">When the same code is run with partial trust (for example, in a sandboxed application domain) the assembly's trust level determines whether it can access security-critical code: If the assembly has a strong name and is installed in the global assembly cache, it is a trusted assembly and can call security-critical members.</span></span> <span data-ttu-id="ac9ba-136">如果不是受信任的，即使未标记为透明，它也将变为透明，并且它不能访问安全关键成员。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-136">If it is not trusted, it becomes transparent even though it was not marked as transparent, and it cannot access security-critical members.</span></span>

<span data-ttu-id="ac9ba-137">有关 .NET Framework 4 中安全模型的详细信息，请参阅[安全更改](https://docs.microsoft.com/previous-versions/dotnet/framework/security/security-changes)。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-137">For more information about the security model in the .NET Framework 4, see [Security Changes](https://docs.microsoft.com/previous-versions/dotnet/framework/security/security-changes).</span></span>

## <a name="reflection-and-transparency"></a><span data-ttu-id="ac9ba-138">反射和透明度</span><span class="sxs-lookup"><span data-stu-id="ac9ba-138">Reflection and Transparency</span></span>

<span data-ttu-id="ac9ba-139">以 .NET Framework 4 开始，公共语言运行时从若干方面确定一个类型或成员的透明度级别，包括程序集和应用程序域的信任级别。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-139">Beginning with the .NET Framework 4, the common language runtime determines the transparency level of a type or member from several factors, including the trust level of the assembly and the trust level of the application domain.</span></span> <span data-ttu-id="ac9ba-140">反射提供了 <xref:System.Type.IsSecurityCritical%2A>、<xref:System.Type.IsSecuritySafeCritical%2A> 和 <xref:System.Type.IsSecurityTransparent%2A> 属性，以使你能够发现类型的透明度级别。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-140">Reflection provides the <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties to enable you to discover the transparency level of a type.</span></span> <span data-ttu-id="ac9ba-141">下表显示了这些属性的有效组合。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-141">The following table shows the valid combinations of these properties.</span></span>

|<span data-ttu-id="ac9ba-142">安全级别</span><span class="sxs-lookup"><span data-stu-id="ac9ba-142">Security level</span></span>|<span data-ttu-id="ac9ba-143">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="ac9ba-143">IsSecurityCritical</span></span>|<span data-ttu-id="ac9ba-144">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="ac9ba-144">IsSecuritySafeCritical</span></span>|<span data-ttu-id="ac9ba-145">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="ac9ba-145">IsSecurityTransparent</span></span>|
|--------------------|------------------------|----------------------------|---------------------------|
|<span data-ttu-id="ac9ba-146">严重</span><span class="sxs-lookup"><span data-stu-id="ac9ba-146">Critical</span></span>|`true`|`false`|`false`|
|<span data-ttu-id="ac9ba-147">安全-关键</span><span class="sxs-lookup"><span data-stu-id="ac9ba-147">Safe-critical</span></span>|`true`|`true`|`false`|
|<span data-ttu-id="ac9ba-148">透明</span><span class="sxs-lookup"><span data-stu-id="ac9ba-148">Transparent</span></span>|`false`|`false`|`true`|

<span data-ttu-id="ac9ba-149">使用这些属性比检查程序集及其类型的安全批注、检查当前的信任级别，以及尝试复制运行时的规则要简单得多。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-149">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span> <span data-ttu-id="ac9ba-150">例如，当从命令行中运行时，相同的类型可以是安全关键，或者在沙盒应用程序域中运行时，它们又是安全-透明的。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-150">For example, the same type can be security-critical when it is run from the command line, or security-transparent when it is run in a sandboxed application domain.</span></span>

<span data-ttu-id="ac9ba-151">在 <xref:System.Reflection.MethodBase>、<xref:System.Reflection.FieldInfo>、<xref:System.Reflection.Emit.TypeBuilder>、<xref:System.Reflection.Emit.MethodBuilder> 和 <xref:System.Reflection.Emit.DynamicMethod> 上有类似的属性。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-151">There are similar properties on the <xref:System.Reflection.MethodBase>, <xref:System.Reflection.FieldInfo>, <xref:System.Reflection.Emit.TypeBuilder>, <xref:System.Reflection.Emit.MethodBuilder>, and <xref:System.Reflection.Emit.DynamicMethod> classes.</span></span> <span data-ttu-id="ac9ba-152">（对于其他反射和反射发出抽象化，安全属性应用到关联的方法；例如，在它们应用于属性访问器的属性的情况下）。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-152">(For other reflection and reflection emit abstractions, security attributes are applied to the associated methods; for example, in the case of properties they are applied to the property accessors.)</span></span>

<a name="accessingNormallyInaccessible"></a>

## <a name="accessing-members-that-are-normally-inaccessible"></a><span data-ttu-id="ac9ba-153">访问通常不可访问的成员</span><span class="sxs-lookup"><span data-stu-id="ac9ba-153">Accessing Members That Are Normally Inaccessible</span></span>

<span data-ttu-id="ac9ba-154">根据公共语言运行时的可访问性规则，若要使用反射来调用无法访问的成员，你的代码必须获得以下两个权限之一：</span><span class="sxs-lookup"><span data-stu-id="ac9ba-154">To use reflection to invoke members that are inaccessible according to the accessibility rules of the common language runtime, your code must be granted one of two permissions:</span></span>

- <span data-ttu-id="ac9ba-155">若要允许代码调用任何非公共成员：代码必须获得带 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 标志的 <xref:System.Security.Permissions.ReflectionPermission>。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-155">To allow code to invoke any nonpublic member:Your code must be granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag.</span></span>

  > [!NOTE]
  > <span data-ttu-id="ac9ba-156">默认情况下，安全策略拒绝源于 Internet 的代码的权限。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-156">By default, security policy denies this permission to code that originates from the Internet.</span></span> <span data-ttu-id="ac9ba-157">此权限永远不会授权予源自 Internet 的代码。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-157">This permission should never be granted to code that originates from the Internet.</span></span>

- <span data-ttu-id="ac9ba-158">要允许代码调用任何非公共成员，只要包含调用成员的程序集的授予集与包含调用代码的程序集的授予集相同或与其子集相同：你的代码必须授予带 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 标志的 <xref:System.Security.Permissions.ReflectionPermission>。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-158">To allow code to invoke any nonpublic member, as long as the grant set of the assembly that contains the invoked member is the same as, or a subset of, the grant set of the assembly that contains the invoking code: Your code must be granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag.</span></span>

<span data-ttu-id="ac9ba-159">例如，假设你为应用程序域授予 Internet 权限以及带 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 标志的 <xref:System.Security.Permissions.ReflectionPermission>，则使用两个程序集 A 和 B 运行 Internet 应用程序。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-159">For example, suppose you grant an application domain Internet permissions plus <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag, and then run an Internet application with two assemblies, A and B.</span></span>

- <span data-ttu-id="ac9ba-160">程序集 A 可以使用反射来访问程序集 B 的私有成员，因为程序集 B 的授予集不包括一个 A 尚未被授予的任何权限。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-160">Assembly A can use reflection to access private members of assembly B, because the grant set of assembly B does not include any permissions that A has not been granted.</span></span>

- <span data-ttu-id="ac9ba-161">程序集 A 不能使用反射来访问 .NET Framework 程序集的私有成员（如 mscorlib.dll），因为 mscorlib.dll 是完全受信任的，因此有尚未被授予给程序集 A 的权限。代码访问安全性在运行时审核堆栈将引发 <xref:System.MemberAccessException>。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-161">Assembly A cannot use reflection to access private members of .NET Framework assemblies such as mscorlib.dll, because mscorlib.dll is fully trusted and therefore has permissions that have not been granted to assembly A. A <xref:System.MemberAccessException> is thrown when code access security walks the stack at run time.</span></span>

## <a name="serialization"></a><span data-ttu-id="ac9ba-162">序列化</span><span class="sxs-lookup"><span data-stu-id="ac9ba-162">Serialization</span></span>

<span data-ttu-id="ac9ba-163">对于序列化，带 <xref:System.Security.Permissions.SecurityPermissionAttribute.SerializationFormatter%2A?displayProperty=nameWithType> 标志的 <xref:System.Security.Permissions.SecurityPermission>，无论其访问级别是什么，都能够获取和设置序列化类型的成员。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-163">For serialization, <xref:System.Security.Permissions.SecurityPermission> with the <xref:System.Security.Permissions.SecurityPermissionAttribute.SerializationFormatter%2A?displayProperty=nameWithType> flag provides the ability to get and set members of serializable types, regardless of accessibility.</span></span> <span data-ttu-id="ac9ba-164">此权限使代码可以发现并更改实例的私有状态。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-164">This permission enables code to discover and change the private state of an instance.</span></span> <span data-ttu-id="ac9ba-165">（除被授予适当权限以外，在元数据中该类型必须[标记](../../standard/attributes/applying-attributes.md)为可序列化。）</span><span class="sxs-lookup"><span data-stu-id="ac9ba-165">(In addition to being granted the appropriate permissions, the type must be [marked](../../standard/attributes/applying-attributes.md) as serializable in metadata.)</span></span>

## <a name="parameters-of-type-methodinfo"></a><span data-ttu-id="ac9ba-166">类型 MethodInfo 的参数</span><span class="sxs-lookup"><span data-stu-id="ac9ba-166">Parameters of Type MethodInfo</span></span>

<span data-ttu-id="ac9ba-167">尤其是对受信任的代码，要避免编写采用 <xref:System.Reflection.MethodInfo> 参数的公共成员。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-167">Avoid writing public members that take <xref:System.Reflection.MethodInfo> parameters, especially for trusted code.</span></span> <span data-ttu-id="ac9ba-168">此类成员可能更容易受到恶意代码的攻击。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-168">Such members might be more vulnerable to malicious code.</span></span> <span data-ttu-id="ac9ba-169">例如，考虑采用 <xref:System.Reflection.MethodInfo> 参数的高度受信任代码中的公共成员。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-169">For example, consider a public member in highly trusted code that takes a <xref:System.Reflection.MethodInfo> parameter.</span></span> <span data-ttu-id="ac9ba-170">假定公共成员间接调用所提供参数 <xref:System.Reflection.MethodBase.Invoke%2A> 上的方法。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-170">Assume that the public member indirectly calls the <xref:System.Reflection.MethodBase.Invoke%2A> method on the supplied parameter.</span></span> <span data-ttu-id="ac9ba-171">如果公共成员不执行必要的权限检查，对 <xref:System.Reflection.MethodBase.Invoke%2A> 方法的调用会一直成功，因为安全系统确定了该调用方为高度受信任的调用方。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-171">If the public member does not perform the necessary permission checks, the call to the <xref:System.Reflection.MethodBase.Invoke%2A> method will always succeed, because the security system determines that the caller is highly trusted.</span></span> <span data-ttu-id="ac9ba-172">即使恶意代码没有直接调用该方法的权限，它仍可以通过调用公共成员间接调用该方法。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-172">Even if malicious code does not have the permission to directly invoke the method, it can still do so indirectly by calling the public member.</span></span>

## <a name="version-information"></a><span data-ttu-id="ac9ba-173">版本信息</span><span class="sxs-lookup"><span data-stu-id="ac9ba-173">Version Information</span></span>

- <span data-ttu-id="ac9ba-174">从 .NET Framework 4 开始，透明代码不能使用反射来访问安全关键成员。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-174">Beginning with the .NET Framework 4, transparent code cannot use reflection to access security-critical members.</span></span>

- <span data-ttu-id="ac9ba-175">.NET Framework 2.0 Service Pack 1 中引入了 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 标志。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-175">The <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag is introduced in the .NET Framework 2.0 Service Pack 1.</span></span> <span data-ttu-id="ac9ba-176">早期版本的 .NET Framework 需要使用反射访问非公共成员的代码的 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 标志。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-176">Earlier versions of the .NET Framework require the <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag for code that uses reflection to access nonpublic members.</span></span> <span data-ttu-id="ac9ba-177">这是绝对不会授予给部分受信任的代码的权限。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-177">This is a permission that should never be granted to partially trusted code.</span></span>

- <span data-ttu-id="ac9ba-178">从 .NET Framework 2.0 开始，使用反射获取关于非公共类型和成员的信息不需要任何权限。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-178">Beginning with the .NET Framework 2.0, using reflection to obtain information about nonpublic types and members does not require any permissions.</span></span> <span data-ttu-id="ac9ba-179">早期版本中，需要带 <xref:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation?displayProperty=nameWithType> 标志的 <xref:System.Security.Permissions.ReflectionPermission>。</span><span class="sxs-lookup"><span data-stu-id="ac9ba-179">In earlier versions, <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation?displayProperty=nameWithType> flag is required.</span></span>

## <a name="see-also"></a><span data-ttu-id="ac9ba-180">请参阅</span><span class="sxs-lookup"><span data-stu-id="ac9ba-180">See also</span></span>

- <xref:System.Security.Permissions.ReflectionPermissionFlag>
- <xref:System.Security.Permissions.ReflectionPermission>
- <xref:System.Security.Permissions.SecurityPermission>
- [<span data-ttu-id="ac9ba-181">安全更改</span><span class="sxs-lookup"><span data-stu-id="ac9ba-181">Security Changes</span></span>](https://docs.microsoft.com/previous-versions/dotnet/framework/security/security-changes)
- [<span data-ttu-id="ac9ba-182">代码访问安全性</span><span class="sxs-lookup"><span data-stu-id="ac9ba-182">Code Access Security</span></span>](../misc/code-access-security.md)
- [<span data-ttu-id="ac9ba-183">反射发出中的安全问题</span><span class="sxs-lookup"><span data-stu-id="ac9ba-183">Security Issues in Reflection Emit</span></span>](security-issues-in-reflection-emit.md)
- [<span data-ttu-id="ac9ba-184">查看类型信息</span><span class="sxs-lookup"><span data-stu-id="ac9ba-184">Viewing Type Information</span></span>](viewing-type-information.md)
- [<span data-ttu-id="ac9ba-185">应用特性</span><span class="sxs-lookup"><span data-stu-id="ac9ba-185">Applying Attributes</span></span>](../../standard/attributes/applying-attributes.md)
- [<span data-ttu-id="ac9ba-186">访问自定义属性</span><span class="sxs-lookup"><span data-stu-id="ac9ba-186">Accessing Custom Attributes</span></span>](accessing-custom-attributes.md)
