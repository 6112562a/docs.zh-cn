---
title: 附加属性概述
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- attached properties [WPF Designer]
ms.assetid: 75928354-dc01-47e8-a018-8409aec1f32d
ms.openlocfilehash: de17fb30358bdf1a8e2a1d6cfc4f5f80fefa1268
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/23/2019
ms.locfileid: "62032226"
---
# <a name="attached-properties-overview"></a><span data-ttu-id="caa10-102">附加属性概述</span><span class="sxs-lookup"><span data-stu-id="caa10-102">Attached Properties Overview</span></span>

<span data-ttu-id="caa10-103">附加属性是由 XAML 定义的概念。</span><span class="sxs-lookup"><span data-stu-id="caa10-103">An attached property is a concept defined by XAML.</span></span> <span data-ttu-id="caa10-104">附加属性旨在用作可在任何对象上设置的一类全局属性。</span><span class="sxs-lookup"><span data-stu-id="caa10-104">An attached property is intended to be used as a type of global property that is settable on any object.</span></span> <span data-ttu-id="caa10-105">在 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 中，附加属性通常定义为没有常规属性“包装器”的依赖性属性的专用形式。</span><span class="sxs-lookup"><span data-stu-id="caa10-105">In [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], attached properties are typically defined as a specialized form of dependency property that does not have the conventional property "wrapper".</span></span>

## <span data-ttu-id="caa10-106">系统必备组件 <a name="prerequisites"></a></span><span class="sxs-lookup"><span data-stu-id="caa10-106">Prerequisites <a name="prerequisites"></a></span></span>

<span data-ttu-id="caa10-107">本主题假定你从 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 类的现有依赖属性的使用者角度了解依赖属性，并且已阅读[依赖属性概述](dependency-properties-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="caa10-107">This topic assumes that you understand dependency properties from the perspective of a consumer of existing dependency properties on [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] classes, and have read the [Dependency Properties Overview](dependency-properties-overview.md).</span></span> <span data-ttu-id="caa10-108">若要遵循本主题中的示例，您应了解 XAML 并知道如何编写 WPF 应用程序。</span><span class="sxs-lookup"><span data-stu-id="caa10-108">To follow the examples in this topic, you should also understand XAML and know how to write WPF applications.</span></span>

## <span data-ttu-id="caa10-109">为什么使用附加的属性 <a name="attached_properties_usage"></a></span><span class="sxs-lookup"><span data-stu-id="caa10-109">Why Use Attached Properties <a name="attached_properties_usage"></a></span></span>

<span data-ttu-id="caa10-110">附加属性的一个用途是允许不同的子元素为实际在父元素中定义的属性指定唯一值。</span><span class="sxs-lookup"><span data-stu-id="caa10-110">One purpose of an attached property is to allow different child elements to specify unique values for a property that is actually defined in a parent element.</span></span> <span data-ttu-id="caa10-111">此方案的一个具体应用是，让子元素通知父元素它们在 [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] 中的呈现方式。</span><span class="sxs-lookup"><span data-stu-id="caa10-111">A specific application of this scenario is having child elements inform the parent element of how they are to be presented in the [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)].</span></span> <span data-ttu-id="caa10-112">一个示例是<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>属性。</span><span class="sxs-lookup"><span data-stu-id="caa10-112">One example is the <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="caa10-113"><xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>作为附加属性创建属性，因为这为了在中包含的元素上设置<xref:System.Windows.Controls.DockPanel>，而不是在<xref:System.Windows.Controls.DockPanel>本身。</span><span class="sxs-lookup"><span data-stu-id="caa10-113">The <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> property is created as an attached property because it is designed to be set on elements that are contained within a <xref:System.Windows.Controls.DockPanel>, rather than on <xref:System.Windows.Controls.DockPanel> itself.</span></span> <span data-ttu-id="caa10-114"><xref:System.Windows.Controls.DockPanel>类定义了静态<xref:System.Windows.DependencyProperty>名为字段<xref:System.Windows.Controls.DockPanel.DockProperty>，然后提供<xref:System.Windows.Controls.DockPanel.GetDock%2A>和<xref:System.Windows.Controls.DockPanel.SetDock%2A>附加属性的方法作为公共访问器。</span><span class="sxs-lookup"><span data-stu-id="caa10-114">The <xref:System.Windows.Controls.DockPanel> class defines the static <xref:System.Windows.DependencyProperty> field named <xref:System.Windows.Controls.DockPanel.DockProperty>, and then provides the <xref:System.Windows.Controls.DockPanel.GetDock%2A> and <xref:System.Windows.Controls.DockPanel.SetDock%2A> methods as public accessors for the attached property.</span></span>

## <span data-ttu-id="caa10-115">XAML 中的附加的属性 <a name="attached_properties_xaml"></a></span><span class="sxs-lookup"><span data-stu-id="caa10-115">Attached Properties in XAML <a name="attached_properties_xaml"></a></span></span>

<span data-ttu-id="caa10-116">在 XAML 中，可以使用语法 AttachedPropertyProvider.PropertyName 来设置附加属性</span><span class="sxs-lookup"><span data-stu-id="caa10-116">In XAML, you set attached properties by using the syntax *AttachedPropertyProvider*.*PropertyName*</span></span>

<span data-ttu-id="caa10-117">下面是举例说明如何设置<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>在 XAML 中：</span><span class="sxs-lookup"><span data-stu-id="caa10-117">The following is an example of how you can set <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> in XAML:</span></span>

[!code-xaml[PropertiesOvwSupport#APBasicUsage](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml#apbasicusage)]

<span data-ttu-id="caa10-118">请注意，有些类似于静态属性; 使用情况始终引用类型<xref:System.Windows.Controls.DockPanel>，拥有并注册附加的属性，而不是引用通过名称指定的任何实例。</span><span class="sxs-lookup"><span data-stu-id="caa10-118">Note that the usage is somewhat similar to a static property; you always reference the type <xref:System.Windows.Controls.DockPanel> that owns and registers the attached property, rather than referring to any instance specified by name.</span></span>

<span data-ttu-id="caa10-119">此外，由于 XAML 中的附加属性是在标记中设置的属性，因此，只有设置操作具有相关性。</span><span class="sxs-lookup"><span data-stu-id="caa10-119">Also, because an attached property in XAML is an attribute that you set in markup, only the set operation has any relevance.</span></span> <span data-ttu-id="caa10-120">尽管存在一些用于比较值的间接机制（如在样式中触发），但无法直接在 XAML 中直接获取属性（有关详细信息，请参阅[样式设置和模板化](../controls/styling-and-templating.md)）。</span><span class="sxs-lookup"><span data-stu-id="caa10-120">You cannot directly get a property in XAML, although there are some indirect mechanisms for comparing values, such as triggers in styles (for details, see [Styling and Templating](../controls/styling-and-templating.md)).</span></span>

### <a name="attached-property-implementation-in-wpf"></a><span data-ttu-id="caa10-121">WPF 中的附加属性实现</span><span class="sxs-lookup"><span data-stu-id="caa10-121">Attached Property Implementation in WPF</span></span>

<span data-ttu-id="caa10-122">在[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]，大部分与 UI 表示形式相关的 WPF 类型存在的附加属性实现为依赖属性。</span><span class="sxs-lookup"><span data-stu-id="caa10-122">In [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], most of the attached properties that exist on WPF types that are related to UI presentation are implemented as dependency properties.</span></span> <span data-ttu-id="caa10-123">附加的属性是一个 XAML 概念，而依赖项属性是 WPF 概念。</span><span class="sxs-lookup"><span data-stu-id="caa10-123">Attached properties are a XAML concept, whereas dependency properties are a WPF concept.</span></span> <span data-ttu-id="caa10-124">由于 WPF 附加属性是依赖项属性，它们支持依赖属性概念，如属性元数据和属性元数据的默认值。</span><span class="sxs-lookup"><span data-stu-id="caa10-124">Because WPF attached properties are dependency properties, they support dependency property concepts such as property metadata, and default values from that property metadata.</span></span>

## <span data-ttu-id="caa10-125">如何使用附加的属性所属类型 <a name="howused"></a></span><span class="sxs-lookup"><span data-stu-id="caa10-125">How Attached Properties Are Used by the Owning Type <a name="howused"></a></span></span>

<span data-ttu-id="caa10-126">尽管可以在任何对象上设置附加属性，但这并不自动意味着设置该属性会产生实际的结果，或者该值会被其他对象使用。</span><span class="sxs-lookup"><span data-stu-id="caa10-126">Although attached properties are settable on any object, that does not automatically mean that setting the property will produce a tangible result, or that the value will ever be used by another object.</span></span> <span data-ttu-id="caa10-127">通常，附加属性是为了使来自各种可能的类层次结构或逻辑关系的对象都可以向用于定义附加属性的类型报告公用信息。</span><span class="sxs-lookup"><span data-stu-id="caa10-127">Generally, attached properties are intended so that objects coming from a wide variety of possible class hierarchies or logical relationships can each report common information to the type that defines the attached property.</span></span> <span data-ttu-id="caa10-128">定义附加属性的类型通常采用以下模型之一：</span><span class="sxs-lookup"><span data-stu-id="caa10-128">The type that defines the attached property typically follows one of these models:</span></span>

- <span data-ttu-id="caa10-129">设计定义附加属性的类型，以便它可以是将为附加属性设置值的元素的父元素。</span><span class="sxs-lookup"><span data-stu-id="caa10-129">The type that defines the attached property is designed so that it can be the parent element of the elements that will set values for the attached property.</span></span> <span data-ttu-id="caa10-130">随后，该类型将在内部逻辑中对照某些对象树结构循环访问其子对象，获取值，并以某种方式作用于这些值。</span><span class="sxs-lookup"><span data-stu-id="caa10-130">The type then iterates its child objects through internal logic against some object tree structure, obtains the values, and acts on those values in some manner.</span></span>

- <span data-ttu-id="caa10-131">定义附加属性的类型将用作各种可能的父元素和内容模型的子元素。</span><span class="sxs-lookup"><span data-stu-id="caa10-131">The type that defines the attached property will be used as the child element for a variety of possible parent elements and content models.</span></span>

- <span data-ttu-id="caa10-132">定义附加属性的类型表示一项服务。</span><span class="sxs-lookup"><span data-stu-id="caa10-132">The type that defines the attached property represents a service.</span></span> <span data-ttu-id="caa10-133">其他类型为该附加属性设置值。</span><span class="sxs-lookup"><span data-stu-id="caa10-133">Other types set values for the attached property.</span></span> <span data-ttu-id="caa10-134">然后，当在服务的上下文中计算设置该属性的元素时，将通过服务类的内部逻辑获取附加属性的值。</span><span class="sxs-lookup"><span data-stu-id="caa10-134">Then, when the element that set the property is evaluated in the context of the service, the attached property values are obtained through internal logic of the service class.</span></span>

### <a name="an-example-of-a-parent-defined-attached-property"></a><span data-ttu-id="caa10-135">父级定义的附加属性示例</span><span class="sxs-lookup"><span data-stu-id="caa10-135">An Example of a Parent-Defined Attached Property</span></span>

<span data-ttu-id="caa10-136">其中 WPF 定义附加的属性的最典型方案是行为的父元素支持子元素集合，并且还实现了一种行为细节的单独报告每个子元素。</span><span class="sxs-lookup"><span data-stu-id="caa10-136">The most typical scenario where WPF defines an attached property is when a parent element supports a child element collection, and also implements a behavior where the specifics of the behavior are reported individually for each child element.</span></span>

<span data-ttu-id="caa10-137"><xref:System.Windows.Controls.DockPanel> 定义<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>附加属性，并<xref:System.Windows.Controls.DockPanel>作为其呈现逻辑的一部分具有类级别的代码 (具体而言，<xref:System.Windows.Controls.DockPanel.MeasureOverride%2A>和<xref:System.Windows.Controls.DockPanel.ArrangeOverride%2A>)。</span><span class="sxs-lookup"><span data-stu-id="caa10-137"><xref:System.Windows.Controls.DockPanel> defines the <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> attached property, and <xref:System.Windows.Controls.DockPanel> has class-level code as part of its rendering logic (specifically, <xref:System.Windows.Controls.DockPanel.MeasureOverride%2A> and <xref:System.Windows.Controls.DockPanel.ArrangeOverride%2A>).</span></span> <span data-ttu-id="caa10-138">一个<xref:System.Windows.Controls.DockPanel>实例将始终检查是否任何其直接子元素设置的值<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="caa10-138">A <xref:System.Windows.Controls.DockPanel> instance will always check to see whether any of its immediate child elements have set a value for <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="caa10-139">如果已设置，这些值将变为应用于该特定子元素的呈现逻辑的输入。</span><span class="sxs-lookup"><span data-stu-id="caa10-139">If so, those values become input for the rendering logic applied to that particular child element.</span></span> <span data-ttu-id="caa10-140">嵌套<xref:System.Windows.Controls.DockPanel>实例都处理自己的直接子元素集合，但该行为是特定于实现的如何<xref:System.Windows.Controls.DockPanel>进程<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>值。</span><span class="sxs-lookup"><span data-stu-id="caa10-140">Nested <xref:System.Windows.Controls.DockPanel> instances each treat their own immediate child element collections, but that behavior is implementation-specific to how <xref:System.Windows.Controls.DockPanel> processes <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> values.</span></span> <span data-ttu-id="caa10-141">理论上，可以有影响直接父级之外的元素的附加属性。</span><span class="sxs-lookup"><span data-stu-id="caa10-141">It is theoretically possible to have attached properties that influence elements beyond the immediate parent.</span></span> <span data-ttu-id="caa10-142">如果<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>未包含任何元素上设置附加的属性<xref:System.Windows.Controls.DockPanel>父元素不作用它、 任何错误或异常引发。</span><span class="sxs-lookup"><span data-stu-id="caa10-142">If the <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> attached property is set on an element that has no <xref:System.Windows.Controls.DockPanel> parent element to act upon it, no error or exception is raised.</span></span> <span data-ttu-id="caa10-143">这只是意味着设置全局属性值，但它有没有当前<xref:System.Windows.Controls.DockPanel>无法使用该信息的父级。</span><span class="sxs-lookup"><span data-stu-id="caa10-143">This simply means that a global property value was set, but it has no current <xref:System.Windows.Controls.DockPanel> parent that could consume the information.</span></span>

## <span data-ttu-id="caa10-144">在代码中的附加的属性 <a name="attached_properties_code"></a></span><span class="sxs-lookup"><span data-stu-id="caa10-144">Attached Properties in Code <a name="attached_properties_code"></a></span></span>

<span data-ttu-id="caa10-145">WPF 中的附加的属性不具有典型[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]用于简化 get/set 访问的"包装"方法。</span><span class="sxs-lookup"><span data-stu-id="caa10-145">Attached properties in WPF do not have the typical [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] "wrapper" methods for easy get/set access.</span></span> <span data-ttu-id="caa10-146">这是因为附加属性不是必须属于设置它的实例的 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 命名空间的一部分。</span><span class="sxs-lookup"><span data-stu-id="caa10-146">This is because the attached property is not necessarily part of the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] namespace for instances where the property is set.</span></span> <span data-ttu-id="caa10-147">但是，分析 XAML 时，XAML 处理器必须能够设置这些值。</span><span class="sxs-lookup"><span data-stu-id="caa10-147">However, a XAML processor must be able to set those values when XAML is parsed.</span></span> <span data-ttu-id="caa10-148">若要支持的有效的附加的属性用法，附加属性的所有者类型必须实现专用访问器方法在窗体**Get_PropertyName_** 并**Set_PropertyName_**。</span><span class="sxs-lookup"><span data-stu-id="caa10-148">To support an effective attached property usage, the owner type of the attached property must implement dedicated accessor methods in the form **Get_PropertyName_** and **Set_PropertyName_**.</span></span> <span data-ttu-id="caa10-149">这些专用访问器方法对在代码中设置附加属性也很有帮助。</span><span class="sxs-lookup"><span data-stu-id="caa10-149">These dedicated accessor methods are also useful to get or set the attached property in code.</span></span> <span data-ttu-id="caa10-150">从代码的角度来看，附加属性类似于具有方法访问器而不是属性访问器的支持字段，且支持字段可在任何对象上存在，无需专门定义。</span><span class="sxs-lookup"><span data-stu-id="caa10-150">From a code perspective, an attached property is similar to a backing field that has method accessors instead of property accessors, and that backing field can exist on any object rather than needing to be specifically defined.</span></span>

<span data-ttu-id="caa10-151">下面的示例演示如何在代码中设置附加属性。</span><span class="sxs-lookup"><span data-stu-id="caa10-151">The following example shows how you can set an attached property in code.</span></span> <span data-ttu-id="caa10-152">在此示例中，`myCheckBox`的一个实例<xref:System.Windows.Controls.CheckBox>类。</span><span class="sxs-lookup"><span data-stu-id="caa10-152">In this example, `myCheckBox` is an instance of the <xref:System.Windows.Controls.CheckBox> class.</span></span>

[!code-csharp[PropertiesOvwSupport#APCode](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml.cs#apcode)]
[!code-vb[PropertiesOvwSupport#APCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertiesOvwSupport/visualbasic/page4.xaml.vb#apcode)]

<span data-ttu-id="caa10-153">类似于 XAML 用例中，如果`myCheckBox`不已添加的子元素作为`myDockPanel`由第三行代码，第四行代码不会引发异常，但属性值不会与交互<xref:System.Windows.Controls.DockPanel>父级，因此将不执行任何操作。</span><span class="sxs-lookup"><span data-stu-id="caa10-153">Similar to the XAML case, if `myCheckBox` had not already been added as a child element of `myDockPanel` by the third line of code, the fourth line of code would not raise an exception, but the property value would not interact with a <xref:System.Windows.Controls.DockPanel> parent and thus would do nothing.</span></span> <span data-ttu-id="caa10-154">仅<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>值且存在的子元素上设置<xref:System.Windows.Controls.DockPanel>父元素将导致呈现的应用程序中有效的行为。</span><span class="sxs-lookup"><span data-stu-id="caa10-154">Only a <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> value set on a child element combined with the presence of a <xref:System.Windows.Controls.DockPanel> parent element will cause an effective behavior in the rendered application.</span></span> <span data-ttu-id="caa10-155">（在这种情况下，可以设置附加属性，然后附加到树。</span><span class="sxs-lookup"><span data-stu-id="caa10-155">(In this case, you could set the attached property, then attach to the tree.</span></span> <span data-ttu-id="caa10-156">或者，可以先附加到该树中，然后设置附加属性。</span><span class="sxs-lookup"><span data-stu-id="caa10-156">Or you could attach to the tree then set the attached property.</span></span> <span data-ttu-id="caa10-157">这两种操作顺序结果都相同。）</span><span class="sxs-lookup"><span data-stu-id="caa10-157">Either action order provides the same result.)</span></span>

## <span data-ttu-id="caa10-158">附加的属性元数据 <a name="attached_properties_metadata"></a></span><span class="sxs-lookup"><span data-stu-id="caa10-158">Attached Property Metadata <a name="attached_properties_metadata"></a></span></span>

<span data-ttu-id="caa10-159">注册该属性时<xref:System.Windows.FrameworkPropertyMetadata>设置为指定的属性，如的属性会影响呈现、 度量等特征。</span><span class="sxs-lookup"><span data-stu-id="caa10-159">When registering the property, <xref:System.Windows.FrameworkPropertyMetadata> is set to specify characteristics of the property, such as whether the property affects rendering, measurement, and so on.</span></span> <span data-ttu-id="caa10-160">附加属性的元数据通常与依赖属性上的元数据基本上都相同。</span><span class="sxs-lookup"><span data-stu-id="caa10-160">Metadata for an attached property is generally no different than on a dependency property.</span></span> <span data-ttu-id="caa10-161">如果在附加属性元数据替代中指定默认值，该值将成为替代类实例上显式附加属性的默认值。</span><span class="sxs-lookup"><span data-stu-id="caa10-161">If you specify a default value in an override to attached property metadata, that value becomes the default value of the implicit attached property on instances of the overriding class.</span></span> <span data-ttu-id="caa10-162">具体而言，当某些进程通过该属性的 `Get` 方法访问器请求附加属性值，并指定在其中指定元数据的类的示例时，将报告默认值，而不会设置该附加属性的值。</span><span class="sxs-lookup"><span data-stu-id="caa10-162">Specifically, your default value is reported if some process queries for the value of an attached property through the `Get` method accessor for that property, specifying an instance of the class where you specified the metadata, and the value for that attached property was otherwise not set.</span></span>

<span data-ttu-id="caa10-163">如果希望对属性启用属性值继承，应使用附加属性，而不是非附加的依赖属性。</span><span class="sxs-lookup"><span data-stu-id="caa10-163">If you want to enable property value inheritance on a property, you should use attached properties rather than non-attached dependency properties.</span></span> <span data-ttu-id="caa10-164">有关详细信息，请参阅[属性值继承](property-value-inheritance.md)。</span><span class="sxs-lookup"><span data-stu-id="caa10-164">For details, see [Property Value Inheritance](property-value-inheritance.md).</span></span>

## <span data-ttu-id="caa10-165">自定义附加属性 <a name="custom"></a></span><span class="sxs-lookup"><span data-stu-id="caa10-165">Custom Attached Properties <a name="custom"></a></span></span>

### <span data-ttu-id="caa10-166">何时创建附加的属性 <a name="create_attached_properties"></a></span><span class="sxs-lookup"><span data-stu-id="caa10-166">When to Create an Attached Property <a name="create_attached_properties"></a></span></span>

<span data-ttu-id="caa10-167">当需要有一个可用于定义类之外的其他类的属性设置机制时，建议创建附加属性。</span><span class="sxs-lookup"><span data-stu-id="caa10-167">You might create an attached property when there is a reason to have a property setting mechanism available for classes other than the defining class.</span></span> <span data-ttu-id="caa10-168">对于这一情况，最常见的方案是布局。</span><span class="sxs-lookup"><span data-stu-id="caa10-168">The most common scenario for this is layout.</span></span> <span data-ttu-id="caa10-169">现有布局属性的示例有<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>， <xref:System.Windows.Controls.Panel.ZIndex%2A?displayProperty=nameWithType>，和<xref:System.Windows.Controls.Canvas.Top%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="caa10-169">Examples of existing layout properties are <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>, <xref:System.Windows.Controls.Panel.ZIndex%2A?displayProperty=nameWithType>, and <xref:System.Windows.Controls.Canvas.Top%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="caa10-170">这里启用的方案是，作为布局控制元素的子元素存在的元素能够分别向其布局父级元素表达布局要求，其中每个元素都设置一个被父级定义为附加属性的属性值。</span><span class="sxs-lookup"><span data-stu-id="caa10-170">The scenario enabled here is that elements that exist as child elements to layout-controlling elements are able to express layout requirements to their layout parent elements individually, each setting a property value that the parent defined as an attached property.</span></span>

<span data-ttu-id="caa10-171">使用附加属性的另一种情况是，你的类表示一种服务，且你希望类能够以更透明的方式继承该服务。</span><span class="sxs-lookup"><span data-stu-id="caa10-171">Another scenario for using an attached property is when your class represents a service, and you want classes to be able to integrate the service more transparently.</span></span>

<span data-ttu-id="caa10-172">但另一个情况是收到 Visual Studio WPF 设计器支持，例如**属性**窗口编辑。</span><span class="sxs-lookup"><span data-stu-id="caa10-172">Yet another scenario is to receive Visual Studio WPF Designer support, such as **Properties** window editing.</span></span> <span data-ttu-id="caa10-173">有关详细信息，请参阅[控件创作概述](../controls/control-authoring-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="caa10-173">For more information, see [Control Authoring Overview](../controls/control-authoring-overview.md).</span></span>

<span data-ttu-id="caa10-174">如前文所述，如果想要使用属性值继承，你应该注册为附加属性。</span><span class="sxs-lookup"><span data-stu-id="caa10-174">As mentioned before, you should register as an attached property if you want to use property value inheritance.</span></span>

### <span data-ttu-id="caa10-175">如何创建附加的属性 <a name="how_do_i_create_attached_properties"></a></span><span class="sxs-lookup"><span data-stu-id="caa10-175">How to Create an Attached Property <a name="how_do_i_create_attached_properties"></a></span></span>

<span data-ttu-id="caa10-176">如果您的类定义附加的属性严格使用其他类型，则不需要从派生类<xref:System.Windows.DependencyObject>。</span><span class="sxs-lookup"><span data-stu-id="caa10-176">If your class is defining the attached property strictly for use on other types, then the class does not have to derive from <xref:System.Windows.DependencyObject>.</span></span> <span data-ttu-id="caa10-177">但需要派生自<xref:System.Windows.DependencyObject>如果遵循使附加的属性也是依赖项属性的整体 WPF 模型。</span><span class="sxs-lookup"><span data-stu-id="caa10-177">But you do need to derive from <xref:System.Windows.DependencyObject> if you follow the overall WPF model of having your attached property also be a dependency property.</span></span>

<span data-ttu-id="caa10-178">将附加的属性定义为依赖属性通过声明`public static readonly`类型的字段<xref:System.Windows.DependencyProperty>。</span><span class="sxs-lookup"><span data-stu-id="caa10-178">Define your attached property as a dependency property by declaring a `public static readonly` field of type <xref:System.Windows.DependencyProperty>.</span></span> <span data-ttu-id="caa10-179">使用的返回值定义此字段<xref:System.Windows.DependencyProperty.RegisterAttached%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="caa10-179">You define this field by using the return value of the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method.</span></span> <span data-ttu-id="caa10-180">字段名称必须匹配附加的属性名称，且追加字符串`Property`，以遵循命名标识字段及其它们所表示的属性的已建立的 WPF 模式。</span><span class="sxs-lookup"><span data-stu-id="caa10-180">The field name must match the attached property name, appended with the string `Property`, to follow the established WPF pattern of naming the identifying fields versus the properties that they represent.</span></span> <span data-ttu-id="caa10-181">附加的属性提供程序还必须提供静态**Get_PropertyName_** 并**Set_PropertyName_** 方法访问器作为附加属性。 如果不这样做将导致属性系统无法使用附加的属性。</span><span class="sxs-lookup"><span data-stu-id="caa10-181">The attached property provider must also provide static **Get_PropertyName_** and **Set_PropertyName_** methods as accessors for the attached property; failing to do this will result in the property system being unable to use your attached property.</span></span>

> [!NOTE]
> <span data-ttu-id="caa10-182">如果省略附加的属性的 get 访问器，在属性上的数据绑定不会在设计工具，如 Visual Studio 和 Expression Blend 中。</span><span class="sxs-lookup"><span data-stu-id="caa10-182">If you omit the attached property's get accessor, data binding on the property will not work in design tools, such as Visual Studio and Expression Blend.</span></span>

#### <a name="the-get-accessor"></a><span data-ttu-id="caa10-183">Get 访问器</span><span class="sxs-lookup"><span data-stu-id="caa10-183">The Get Accessor</span></span>

<span data-ttu-id="caa10-184">签名**Get_PropertyName_** 访问器必须是：</span><span class="sxs-lookup"><span data-stu-id="caa10-184">The signature for the **Get_PropertyName_** accessor must be:</span></span>

`public static object GetPropertyName(object target)`

- <span data-ttu-id="caa10-185">`target` 对象在实现中可以指定为更具体的类型。</span><span class="sxs-lookup"><span data-stu-id="caa10-185">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="caa10-186">例如，<xref:System.Windows.Controls.DockPanel.GetDock%2A?displayProperty=nameWithType>方法的类型参数作为<xref:System.Windows.UIElement>，因为附加的属性只是在上设置<xref:System.Windows.UIElement>实例。</span><span class="sxs-lookup"><span data-stu-id="caa10-186">For example, the <xref:System.Windows.Controls.DockPanel.GetDock%2A?displayProperty=nameWithType> method types the parameter as <xref:System.Windows.UIElement>, because the attached property is only intended to be set on <xref:System.Windows.UIElement> instances.</span></span>

- <span data-ttu-id="caa10-187">返回值在实现中可以指定为更具体的类型。</span><span class="sxs-lookup"><span data-stu-id="caa10-187">The return value can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="caa10-188">例如，<xref:System.Windows.Controls.DockPanel.GetDock%2A>方法将其作为类型<xref:System.Windows.Controls.Dock>，因为值只能设置为该枚举。</span><span class="sxs-lookup"><span data-stu-id="caa10-188">For example, the <xref:System.Windows.Controls.DockPanel.GetDock%2A> method types it as <xref:System.Windows.Controls.Dock>, because the value can only be set to that enumeration.</span></span>

#### <a name="the-set-accessor"></a><span data-ttu-id="caa10-189">Set 访问器</span><span class="sxs-lookup"><span data-stu-id="caa10-189">The Set Accessor</span></span>

<span data-ttu-id="caa10-190">签名**Set_PropertyName_** 访问器必须是：</span><span class="sxs-lookup"><span data-stu-id="caa10-190">The signature for the **Set_PropertyName_** accessor must be:</span></span>

`public static void SetPropertyName(object target, object value)`

- <span data-ttu-id="caa10-191">`target` 对象在实现中可以指定为更具体的类型。</span><span class="sxs-lookup"><span data-stu-id="caa10-191">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="caa10-192">例如，<xref:System.Windows.Controls.DockPanel.SetDock%2A>方法将其作为类型<xref:System.Windows.UIElement>，因为附加的属性只是在上设置<xref:System.Windows.UIElement>实例。</span><span class="sxs-lookup"><span data-stu-id="caa10-192">For example, the <xref:System.Windows.Controls.DockPanel.SetDock%2A> method types it as <xref:System.Windows.UIElement>, because the attached property is only intended to be set on <xref:System.Windows.UIElement> instances.</span></span>

- <span data-ttu-id="caa10-193">`value` 对象在实现中可以指定为更具体的类型。</span><span class="sxs-lookup"><span data-stu-id="caa10-193">The `value` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="caa10-194">例如，<xref:System.Windows.Controls.DockPanel.SetDock%2A>方法将其作为类型<xref:System.Windows.Controls.Dock>，因为值只能设置为该枚举。</span><span class="sxs-lookup"><span data-stu-id="caa10-194">For example, the <xref:System.Windows.Controls.DockPanel.SetDock%2A> method types it as <xref:System.Windows.Controls.Dock>, because the value can only be set to that enumeration.</span></span> <span data-ttu-id="caa10-195">请记住，此方法的值是 XAML 加载器在标记中的附加属性用法中遇到附加属性时的输入。</span><span class="sxs-lookup"><span data-stu-id="caa10-195">Remember that the value for this method is the input coming from the XAML loader when it encounters your attached property in an attached property usage in markup.</span></span> <span data-ttu-id="caa10-196">该输入是在标记中指定为 XAML 属性值的值。</span><span class="sxs-lookup"><span data-stu-id="caa10-196">That input is the value specified as a XAML attribute value in markup.</span></span> <span data-ttu-id="caa10-197">因此必须存在可用于你所使用的类型的类型转换、值序列化程序或标记扩展支持，以便可以从属性值（最终仅仅是一个字符串）创建相应的类型。</span><span class="sxs-lookup"><span data-stu-id="caa10-197">Therefore there must be type conversion, value serializer, or markup extension support for the type you use, such that the appropriate type can be created from the attribute value (which is ultimately just a string).</span></span>

<span data-ttu-id="caa10-198">下面的示例显示了依赖关系属性注册 (使用<xref:System.Windows.DependencyProperty.RegisterAttached%2A>方法)，并将**Get_PropertyName_** 并**Set_PropertyName_** 访问器。</span><span class="sxs-lookup"><span data-stu-id="caa10-198">The following example shows the dependency property registration (using the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method), as well as the **Get_PropertyName_** and **Set_PropertyName_** accessors.</span></span> <span data-ttu-id="caa10-199">在此示例中，附加属性名称为 `IsBubbleSource`。</span><span class="sxs-lookup"><span data-stu-id="caa10-199">In the example, the attached property name is `IsBubbleSource`.</span></span> <span data-ttu-id="caa10-200">因此，访问器必须名为 `GetIsBubbleSource` 和 `SetIsBubbleSource`。</span><span class="sxs-lookup"><span data-stu-id="caa10-200">Therefore, the accessors must be named `GetIsBubbleSource` and `SetIsBubbleSource`.</span></span>

[!code-csharp[WPFAquariumSln#RegisterAttachedBubbler](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler)]
[!code-vb[WPFAquariumSln#RegisterAttachedBubbler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler)]

#### <a name="attached-property-attributes"></a><span data-ttu-id="caa10-201">附加属性特性</span><span class="sxs-lookup"><span data-stu-id="caa10-201">Attached Property Attributes</span></span>

<span data-ttu-id="caa10-202">WPF 定义了多个[!INCLUDE[TLA2#tla_netframewkattr#plural](../../../../includes/tla2sharptla-netframewkattrsharpplural-md.md)]，后者用于提供有关向反射进程和反射类型和属性的信息，例如设计器的典型用户的附加属性的信息。</span><span class="sxs-lookup"><span data-stu-id="caa10-202">WPF defines several [!INCLUDE[TLA2#tla_netframewkattr#plural](../../../../includes/tla2sharptla-netframewkattrsharpplural-md.md)] that are intended to provide information about attached properties to reflection processes, and to typical users of reflection and property information such as designers.</span></span> <span data-ttu-id="caa10-203">由于附加属性的类型没有范围限制，因此设计者需要一种方法来避免用户查看全局列表时，看到使用 XAML 的特定技术实现中定义的所有附加属性。</span><span class="sxs-lookup"><span data-stu-id="caa10-203">Because attached properties have a type of unlimited scope, designers need a way to avoid overwhelming users with a global list of all the attached properties that are defined in a particular technology implementation that uses XAML.</span></span> <span data-ttu-id="caa10-204">[!INCLUDE[TLA2#tla_netframewkattr#plural](../../../../includes/tla2sharptla-netframewkattrsharpplural-md.md)]该 WPF 定义附加的属性可用于范围限定在属性窗口中，其中应显示给定的附加的属性的情况。</span><span class="sxs-lookup"><span data-stu-id="caa10-204">The [!INCLUDE[TLA2#tla_netframewkattr#plural](../../../../includes/tla2sharptla-netframewkattrsharpplural-md.md)] that WPF defines for attached properties can be used to scope the situations where a given attached property should be shown in a properties window.</span></span> <span data-ttu-id="caa10-205">你还可考虑对自己的自定义附加属性应用这些特性。</span><span class="sxs-lookup"><span data-stu-id="caa10-205">You might consider applying these attributes for your own custom attached properties also.</span></span> <span data-ttu-id="caa10-206">有关 [!INCLUDE[TLA2#tla_netframewkattr#plural](../../../../includes/tla2sharptla-netframewkattrsharpplural-md.md)] 的用途和语法说明，请参阅相应的参考页面：</span><span class="sxs-lookup"><span data-stu-id="caa10-206">The purpose and syntax of the [!INCLUDE[TLA2#tla_netframewkattr#plural](../../../../includes/tla2sharptla-netframewkattrsharpplural-md.md)] is described on the appropriate reference pages:</span></span>

- <xref:System.Windows.AttachedPropertyBrowsableAttribute>

- <xref:System.Windows.AttachedPropertyBrowsableForChildrenAttribute>

- <xref:System.Windows.AttachedPropertyBrowsableForTypeAttribute>

- <xref:System.Windows.AttachedPropertyBrowsableWhenAttributePresentAttribute>

## <span data-ttu-id="caa10-207">了解更多关于附加属性 <a name="more"></a></span><span class="sxs-lookup"><span data-stu-id="caa10-207">Learning More About Attached Properties <a name="more"></a></span></span>

- <span data-ttu-id="caa10-208">有关如何创建附加属性的详细信息，请参阅[注册附加属性](how-to-register-an-attached-property.md)。</span><span class="sxs-lookup"><span data-stu-id="caa10-208">For more information on creating an attached property, see [Register an Attached Property](how-to-register-an-attached-property.md).</span></span>

- <span data-ttu-id="caa10-209">有关依赖属性和附加属性的更多高级使用方案，请参阅[自定义依赖属性](custom-dependency-properties.md)。</span><span class="sxs-lookup"><span data-stu-id="caa10-209">For more advanced usage scenarios for dependency properties and attached properties, see [Custom Dependency Properties](custom-dependency-properties.md).</span></span>

- <span data-ttu-id="caa10-210">还可将属性注册为附加属性和依赖属性，但仍需公开“包装器”实现。</span><span class="sxs-lookup"><span data-stu-id="caa10-210">You can also register a property as an attached property, and as a dependency property, but then still expose "wrapper" implementations.</span></span> <span data-ttu-id="caa10-211">在这种情况下，属性可在该元素上设置，也可通过 XAML 附加属性语法在任何元素上设置。</span><span class="sxs-lookup"><span data-stu-id="caa10-211">In this case, the property can be set either on that element, or on any element through the XAML attached property syntax.</span></span> <span data-ttu-id="caa10-212">具有适当的方案的标准和附加用法的属性的一个示例是<xref:System.Windows.FrameworkElement.FlowDirection%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="caa10-212">An example of a property with an appropriate scenario for both standard and attached usages is <xref:System.Windows.FrameworkElement.FlowDirection%2A?displayProperty=nameWithType>.</span></span>

## <a name="see-also"></a><span data-ttu-id="caa10-213">请参阅</span><span class="sxs-lookup"><span data-stu-id="caa10-213">See also</span></span>

- <xref:System.Windows.DependencyProperty>
- [<span data-ttu-id="caa10-214">依赖项属性概述</span><span class="sxs-lookup"><span data-stu-id="caa10-214">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="caa10-215">自定义依赖属性</span><span class="sxs-lookup"><span data-stu-id="caa10-215">Custom Dependency Properties</span></span>](custom-dependency-properties.md)
- [<span data-ttu-id="caa10-216">XAML 概述 (WPF)</span><span class="sxs-lookup"><span data-stu-id="caa10-216">XAML Overview (WPF)</span></span>](xaml-overview-wpf.md)
- [<span data-ttu-id="caa10-217">注册附加属性</span><span class="sxs-lookup"><span data-stu-id="caa10-217">Register an Attached Property</span></span>](how-to-register-an-attached-property.md)