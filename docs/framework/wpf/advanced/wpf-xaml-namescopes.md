---
title: WPF XAML 名称范围
ms.date: 03/30/2017
helpviewer_keywords:
- namescopes [WPF]
- styles [WPF], namescopes in
- templates [WPF], namescopes in
- APIs [WPF], name-related
- name-related APIs
- XAML [WPF], namescopes
- classes [WPF], FrameworkContentElement
ms.assetid: 52bbf4f2-15fc-40d4-837b-bb4c21ead7d4
ms.openlocfilehash: a46942188fd417b46ba4feb44d436800e1362098
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/23/2019
ms.locfileid: "61764642"
---
# <a name="wpf-xaml-namescopes"></a><span data-ttu-id="a4f2b-102">WPF XAML 名称范围</span><span class="sxs-lookup"><span data-stu-id="a4f2b-102">WPF XAML Namescopes</span></span>
<span data-ttu-id="a4f2b-103">XAML 名称范围是关于标识 XAML 中定义的对象的一个概念。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-103">XAML namescopes are a concept that identifies objects that are defined in XAML.</span></span> <span data-ttu-id="a4f2b-104">XAML 名称范围中的名称可用于在对象树的对象 XAML 定义名称和其实例等效项之间建立关系。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-104">The names in a XAML namescope can be used to establish relationships between the XAML-defined names of objects and their instance equivalents in an object tree.</span></span> <span data-ttu-id="a4f2b-105">通常，在加载 XAML 应用程序的各个 XAML 页面根时会以 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 托管代码创建 XAML 名称范围。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-105">Typically, XAML namescopes in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] managed code are created when loading the individual XAML page roots for a XAML application.</span></span> <span data-ttu-id="a4f2b-106">由定义作为编程对象的 XAML 名称范围<xref:System.Windows.Markup.INameScope>接口，并由实际类还实现<xref:System.Windows.NameScope>。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-106">XAML namescopes as the programming object are defined by the <xref:System.Windows.Markup.INameScope> interface and are also implemented by the practical class <xref:System.Windows.NameScope>.</span></span>  

<a name="Namescopes_in_Loaded_XAML_Applications"></a>   
## <a name="namescopes-in-loaded-xaml-applications"></a><span data-ttu-id="a4f2b-107">加载的 XAML 应用程序中的名称范围</span><span class="sxs-lookup"><span data-stu-id="a4f2b-107">Namescopes in Loaded XAML Applications</span></span>  
 <span data-ttu-id="a4f2b-108">从更广泛的编程或计算机科学来说，编程概念通常包括可用于访问对象的唯一标识符或名称的原则。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-108">In a broader programming or computer science context, programming concepts often include the principle of a unique identifier or name that can be used to access an object.</span></span> <span data-ttu-id="a4f2b-109">对于使用标识符或名称的系统，名称范围会定义边界，在该边界中，进程或技术会搜索是否请求了具有该名称的对象或者是否执行了标识名称唯一性。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-109">For systems that use identifiers or names, the namescope defines the boundaries within which a process or technique will search if an object of that name is requested, or the boundaries wherein uniqueness of identifying names is enforced.</span></span> <span data-ttu-id="a4f2b-110">这些一般原则适用于 XAML 名称范围。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-110">These general principles are true for XAML namescopes.</span></span> <span data-ttu-id="a4f2b-111">在 WPF 中，当 XAML 页面加载时，会在该页面的根元素上创建 XAML 名称范围。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-111">In WPF, XAML namescopes are created on the root element for a XAML page when the page is loaded.</span></span> <span data-ttu-id="a4f2b-112">在 XAML 页面的页面根位置处指定的每个名称会添加到相关的 XAML 名称范围中。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-112">Each name specified within the XAML page starting at the page root is added to a pertinent XAML namescope.</span></span>  
  
 <span data-ttu-id="a4f2b-113">在 WPF XAML，是常见的根元素的元素 (如<xref:System.Windows.Controls.Page>，和<xref:System.Windows.Window>) 始终控制 XAML 名称范围。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-113">In WPF XAML, elements that are common root elements (such as <xref:System.Windows.Controls.Page>, and <xref:System.Windows.Window>) always control a XAML namescope.</span></span> <span data-ttu-id="a4f2b-114">如果一个元素，如<xref:System.Windows.FrameworkElement>或<xref:System.Windows.FrameworkContentElement>是在标记中，页面的根元素[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]处理器添加<xref:System.Windows.Controls.Page>隐式根以便<xref:System.Windows.Controls.Page>可以提供工作 XAML 名称范围。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-114">If an element such as <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement> is the root element of the page in markup, a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] processor adds a <xref:System.Windows.Controls.Page> root implicitly so that the <xref:System.Windows.Controls.Page> can provide a working XAML namescope.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a4f2b-115">即使在 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 标记中的任何元素上都没有定义 `Name` 或 `x:Name` 特性，WPF 生成操作也将为 XAML 生产创建 XAML 名称范围。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-115">WPF build actions create a XAML namescope for a XAML production even if no `Name` or `x:Name` attributes are defined on any elements in the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] markup.</span></span>  
  
 <span data-ttu-id="a4f2b-116">如果尝试在任何 XAML 名称范围中两次使用相同的名称，将引发异常。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-116">If you try to use the same name twice in any XAML namescope, an exception is raised.</span></span> <span data-ttu-id="a4f2b-117">对于具有代码隐藏且作为已编译应用程序的一部分的 WPF XAML，在初始标记编译期间为页面创建生成类时，WPF 生成操作在生成时会引发异常。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-117">For WPF XAML that has code-behind and is part of a compiled application, the exception is raised at build time by WPF build actions, when creating the generated class for the page during the initial markup compile.</span></span> <span data-ttu-id="a4f2b-118">对于不由任何生成操作进行标记编译的 XAML，加载 XAML 时可能会引发与 XAML 名称范围问题相关的异常。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-118">For XAML that is not markup-compiled by any build action, exceptions related to XAML namescope issues might be raised when the XAML is loaded.</span></span> <span data-ttu-id="a4f2b-119">XAML 设计器在设计时也可能会出现 XAML 名称范围问题。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-119">XAML designers might also anticipate XAML namescope issues at design time.</span></span>  
  
### <a name="adding-objects-to-runtime-object-trees"></a><span data-ttu-id="a4f2b-120">将对象添加到运行时对象树</span><span class="sxs-lookup"><span data-stu-id="a4f2b-120">Adding Objects to Runtime Object Trees</span></span>  
 <span data-ttu-id="a4f2b-121">分析 XAML 时即意味着创建并定义 WPF XAML 名称范围的时刻。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-121">The moment that XAML is parsed represents the moment in time that a WPF XAML namescope is created and defined.</span></span> <span data-ttu-id="a4f2b-122">如果在分析生成对象树的 XAML 之后的时间点将对象添加到对象树，新对象上的 `Name` 或 `x:Name` 值不会在 XAML 名称范围中自动更新信息。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-122">If you add an object to an object tree at a point in time after the XAML that produced that tree was parsed, a `Name` or `x:Name` value on the new object does not automatically update the information in a XAML namescope.</span></span> <span data-ttu-id="a4f2b-123">若要将一个对象的名称添加到 WPF XAML 名称范围，加载 XAML 后，必须调用的相应实现<xref:System.Windows.Markup.INameScope.RegisterName%2A>上定义的 XAML 名称范围的对象，通常是 XAML 页面根。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-123">To add a name for an object into a WPF XAML namescope after XAML is loaded, you must call the appropriate implementation of <xref:System.Windows.Markup.INameScope.RegisterName%2A> on the object that defines the XAML namescope, which is typically the XAML page root.</span></span> <span data-ttu-id="a4f2b-124">如果未注册名称，添加的对象不能按名称引用通过方法如<xref:System.Windows.FrameworkElement.FindName%2A>，也不能使用该名称用于动画定位。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-124">If the name is not registered, the added object cannot be referenced by name through methods such as <xref:System.Windows.FrameworkElement.FindName%2A>, and you cannot use that name for animation targeting.</span></span>  
  
 <span data-ttu-id="a4f2b-125">应用程序开发人员的最常见方案是，将使用<xref:System.Windows.FrameworkElement.RegisterName%2A>名称注册到当前页的根上的 XAML 名称范围。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-125">The most common scenario for application developers is that you will use <xref:System.Windows.FrameworkElement.RegisterName%2A> to register names into the XAML namescope on the current root of the page.</span></span> <span data-ttu-id="a4f2b-126"><xref:System.Windows.FrameworkElement.RegisterName%2A> 是的情节提要的一个重要用途一部分动画的目标对象。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-126"><xref:System.Windows.FrameworkElement.RegisterName%2A> is part of an important scenario for storyboards that target objects for animations.</span></span> <span data-ttu-id="a4f2b-127">有关详细信息，请参阅[情节提要概述](../graphics-multimedia/storyboards-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-127">For more information, see [Storyboards Overview](../graphics-multimedia/storyboards-overview.md).</span></span>  
  
 <span data-ttu-id="a4f2b-128">如果您调用<xref:System.Windows.FrameworkElement.RegisterName%2A>上定义的 XAML 名称范围的对象以外的对象，该名称仍会注册到中，保留调用对象的 XAML 名称范围就像已调用<xref:System.Windows.FrameworkElement.RegisterName%2A>上定义对象的 XAML 名称范围。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-128">If you call <xref:System.Windows.FrameworkElement.RegisterName%2A> on an object other than the object that defines the XAML namescope, the name is still registered to the XAML namescope that the calling object is held within, as if you had called <xref:System.Windows.FrameworkElement.RegisterName%2A> on the XAML namescope defining object.</span></span>  
  
### <a name="xaml-namescopes-in-code"></a><span data-ttu-id="a4f2b-129">代码中的 XAML 名称范围</span><span class="sxs-lookup"><span data-stu-id="a4f2b-129">XAML Namescopes in Code</span></span>  
 <span data-ttu-id="a4f2b-130">可以通过代码创建然后使用 XAML 名称范围。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-130">You can create and then use XAML namescopes in code.</span></span> <span data-ttu-id="a4f2b-131">创建 XAML 名称范围所涉及的 API 和概念甚至与使用纯代码相同，因为 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 的 XAML 处理器在自身处理 XAML 时就会使用这些 API 和概念。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-131">The APIs and the concepts involved in XAML namescope creation are the same even for a pure code usage, because the XAML processor for [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses these APIs and concepts when it processes XAML itself.</span></span> <span data-ttu-id="a4f2b-132">这些概念和 API 存在的主要目的是为了能够在对象树中按名称查找对象（此对象树通常在 XAML 中完全或部分定义）。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-132">The concepts and API exist mainly for the purpose of being able to find objects by name within an object tree that is typically defined partially or entirely in XAML.</span></span>  
  
 <span data-ttu-id="a4f2b-133">有关以编程方式创建的应用程序而不是从已加载的 XAML，定义 XAML 名称范围的对象必须实现<xref:System.Windows.Markup.INameScope>，或者是<xref:System.Windows.FrameworkElement>或<xref:System.Windows.FrameworkContentElement>派生类，以便在支持的 XAML 名称范围创建其实例。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-133">For applications that are created programmatically, and not from loaded XAML, the object that defines a XAML namescope must implement <xref:System.Windows.Markup.INameScope>, or be a <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement> derived class, in order to support creation of a XAML namescope on its instances.</span></span>  
  
 <span data-ttu-id="a4f2b-134">此外，对于任何不由 XAML 处理器加载和处理的元素，默认情况下不会创建或初始化对象的 XAML 名称范围。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-134">Also, for any element that is not loaded and processed by a XAML processor, the XAML namescope for the object is not created or initialized by default.</span></span> <span data-ttu-id="a4f2b-135">必须为随后要将名称注册到其中的任何对象显式创建新的 XAML 名称范围。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-135">You must explicitly create a new XAML namescope for any object that you intend to register names into subsequently.</span></span> <span data-ttu-id="a4f2b-136">若要创建 XAML 名称范围，则可以调用静态<xref:System.Windows.NameScope.SetNameScope%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-136">To create a XAML namescope, you call the static <xref:System.Windows.NameScope.SetNameScope%2A> method.</span></span> <span data-ttu-id="a4f2b-137">指定的对象，将拥有其作为`dependencyObject`参数，和一个新<xref:System.Windows.NameScope.%23ctor%2A>构造函数的调用`value`参数。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-137">Specify the object that will own it as the `dependencyObject` parameter, and a new <xref:System.Windows.NameScope.%23ctor%2A> constructor call as the `value` parameter.</span></span>  
  
 <span data-ttu-id="a4f2b-138">如果该对象提供作为`dependencyObject`有关<xref:System.Windows.NameScope.SetNameScope%2A>不是<xref:System.Windows.Markup.INameScope>实现中，<xref:System.Windows.FrameworkElement>或<xref:System.Windows.FrameworkContentElement>，则调用<xref:System.Windows.FrameworkElement.RegisterName%2A>对任何子元素不会产生影响。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-138">If the object provided as `dependencyObject` for <xref:System.Windows.NameScope.SetNameScope%2A> is not a <xref:System.Windows.Markup.INameScope> implementation, <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>, calling <xref:System.Windows.FrameworkElement.RegisterName%2A> on any child elements will have no effect.</span></span> <span data-ttu-id="a4f2b-139">如果您不能显式创建新的 XAML 名称范围，然后调用<xref:System.Windows.FrameworkElement.RegisterName%2A>将引发异常。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-139">If you fail to create the new XAML namescope explicitly, then calls to <xref:System.Windows.FrameworkElement.RegisterName%2A> will raise an exception.</span></span>  
  
 <span data-ttu-id="a4f2b-140">有关以代码方式使用 XAML 名称范围 API 的示例，请参阅[定义名称范围](../graphics-multimedia/how-to-define-a-name-scope.md)。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-140">For an example of using XAML namescope APIs in code, see [Define a Name Scope](../graphics-multimedia/how-to-define-a-name-scope.md).</span></span>  
  
<a name="Namescopes_in_Styles_and_Templates"></a>   
## <a name="xaml-namescopes-in-styles-and-templates"></a><span data-ttu-id="a4f2b-141">样式和模板中的 XAML 名称范围</span><span class="sxs-lookup"><span data-stu-id="a4f2b-141">XAML Namescopes in Styles and Templates</span></span>  
 <span data-ttu-id="a4f2b-142">通过 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中的样式和模板，可以直接重复使用和重复应用内容。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-142">Styles and templates in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] provide the ability to reuse and reapply content in a straightforward way.</span></span> <span data-ttu-id="a4f2b-143">但是，样式和模板可能还包含具有模板级别定义的 XAML 名称的元素。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-143">However, styles and templates might also include elements with XAML names defined at the template level.</span></span> <span data-ttu-id="a4f2b-144">此相同模板可在一个页面中多次使用。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-144">That same template might be used multiple times in a page.</span></span> <span data-ttu-id="a4f2b-145">出于此原因，样式和模板皆定义其自身的 XAML 名称范围，与在应用样式或模板的对象树中的位置无关。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-145">For this reason, styles and templates both define their own XAML namescopes, independent of whatever location in an object tree where the style or template is applied.</span></span>  
  
 <span data-ttu-id="a4f2b-146">请看下面的示例：</span><span class="sxs-lookup"><span data-stu-id="a4f2b-146">Consider the following example:</span></span>  
  
 [!code-xaml[XamlOvwSupport#NameScopeTemplates](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page6.xaml#namescopetemplates)]  
  
 <span data-ttu-id="a4f2b-147">此处，同一模板应用到两个不同的按钮。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-147">Here, the same template is applied to two different buttons.</span></span> <span data-ttu-id="a4f2b-148">如果模板不具有离散的 XAML 名称范围，则模板中使用的 `TheBorder` 名称会导致 XAML 名称范围中的名称冲突。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-148">If templates did not have discrete XAML namescopes, the `TheBorder` name used in the template would cause a name collision in the XAML namescope.</span></span> <span data-ttu-id="a4f2b-149">模板的每个实例都具有其自己的 XAML 名称范围，因此在本例中，每个实例化模板的 XAML 名称范围仅包含一个名称。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-149">Each instantiation of the template has its own XAML namescope, so in this example each instantiated template's XAML namescope would contain exactly one name.</span></span>  
  
 <span data-ttu-id="a4f2b-150">样式也定义其自身的 XAML 名称范围，因此情节提要的各部分均可分配有特定的名称。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-150">Styles also define their own XAML namescope, mostly so that parts of storyboards can have particular names assigned.</span></span> <span data-ttu-id="a4f2b-151">即使在控件自定义过程中重新定义模板，这些名称也可实现控件特定行为，定位具有该名称的元素。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-151">These names enable control specific behaviors that will target elements of that name, even if the template was re-defined as part of control customization.</span></span>  
  
 <span data-ttu-id="a4f2b-152">由于这些分开的 XAML 名称范围，在模板中查找命名元素比在页面中查找非模板命名元素难度更大。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-152">Because of the separate XAML namescopes, finding named elements in a template is more challenging than finding a non-templated named element in a page.</span></span> <span data-ttu-id="a4f2b-153">首先需要确定所应用的模板，通过获取<xref:System.Windows.Controls.Control.Template%2A>应用模板的控件属性值。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-153">You first need to determine the applied template, by getting the <xref:System.Windows.Controls.Control.Template%2A> property value of the control where the template is applied.</span></span> <span data-ttu-id="a4f2b-154">然后，调用的模板版本的<xref:System.Windows.FrameworkTemplate.FindName%2A>，将控件传递的第二个参数应用了模板。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-154">Then, you call the template version of <xref:System.Windows.FrameworkTemplate.FindName%2A>, passing the control where the template was applied as the second parameter.</span></span>  
  
 <span data-ttu-id="a4f2b-155">如果你是控件作者且要生成其中特定名称的应用的模板中的元素是一种行为，由控件本身定义的目标的约定，则可以使用<xref:System.Windows.FrameworkElement.GetTemplateChild%2A>从您的控件实现代码的方法。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-155">If you are a control author and you are generating a convention where a particular named element in an applied template is the target for a behavior that is defined by the control itself, you can use the <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> method from your control implementation code.</span></span> <span data-ttu-id="a4f2b-156"><xref:System.Windows.FrameworkElement.GetTemplateChild%2A>保护方法，因此只有控件作者有权访问它。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-156">The <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> method is protected, so only the control author has access to it.</span></span>  
  
 <span data-ttu-id="a4f2b-157">如果你正在从模板中，并需要获取应用模板的 XAML 名称范围内，获取的值<xref:System.Windows.FrameworkElement.TemplatedParent%2A>，然后调用<xref:System.Windows.FrameworkElement.FindName%2A>存在。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-157">If you are working from within a template, and need to get to the XAML namescope where the template is applied, get the value of <xref:System.Windows.FrameworkElement.TemplatedParent%2A>, and then call <xref:System.Windows.FrameworkElement.FindName%2A> there.</span></span> <span data-ttu-id="a4f2b-158">从模板内入手的一个示例是编写事件将从已应用模板中的元素引发的事件处理程序实现。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-158">An example of working within the template would be if you are writing the event handler implementation where the event will be raised from an element in an applied template.</span></span>  
  
<a name="Namescopes_and_Name_related_APIs"></a>   
## <a name="xaml-namescopes-and-name-related-apis"></a><span data-ttu-id="a4f2b-159">XAML 名称范围和与名称相关的 API</span><span class="sxs-lookup"><span data-stu-id="a4f2b-159">XAML Namescopes and Name-related APIs</span></span>  
 <span data-ttu-id="a4f2b-160"><xref:System.Windows.FrameworkElement> 具有<xref:System.Windows.FrameworkElement.FindName%2A>，<xref:System.Windows.FrameworkElement.RegisterName%2A>和<xref:System.Windows.FrameworkElement.UnregisterName%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-160"><xref:System.Windows.FrameworkElement> has <xref:System.Windows.FrameworkElement.FindName%2A>, <xref:System.Windows.FrameworkElement.RegisterName%2A> and <xref:System.Windows.FrameworkElement.UnregisterName%2A> methods.</span></span> <span data-ttu-id="a4f2b-161">如果在其上调用这些方法的对象拥有 XAML 名称范围，则这些方法会调入相关 XAML 名称范围的方法。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-161">If the object you call these methods on owns a XAML namescope, the methods call into the methods of the relevant XAML namescope.</span></span> <span data-ttu-id="a4f2b-162">否则，将检查父元素以查看其是否拥有 XAML 名称范围，此过程以递归方式持续发生，直到找到 XAML 名称范围（由于 XAML 处理器行为，根处必定存在一个 XAML 名称范围）。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-162">Otherwise, the parent element is checked to see if it owns a XAML namescope, and this process continues recursively until a XAML namescope is found (because of the XAML processor behavior, there is guaranteed to be a XAML namescope at the root).</span></span> <span data-ttu-id="a4f2b-163"><xref:System.Windows.FrameworkContentElement> 具有类似行为，出现异常，没有<xref:System.Windows.FrameworkContentElement>会拥有 XAML 名称范围。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-163"><xref:System.Windows.FrameworkContentElement> has analogous behaviors, with the exception that no <xref:System.Windows.FrameworkContentElement> will ever own a XAML namescope.</span></span> <span data-ttu-id="a4f2b-164">这些方法存在上<xref:System.Windows.FrameworkContentElement>，以便可以为最终转发调用<xref:System.Windows.FrameworkElement>父元素。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-164">The methods exist on <xref:System.Windows.FrameworkContentElement> so that the calls can be forwarded eventually to a <xref:System.Windows.FrameworkElement> parent element.</span></span>  
  
 <span data-ttu-id="a4f2b-165"><xref:System.Windows.NameScope.SetNameScope%2A> 用于将新的 XAML 名称范围映射到现有对象。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-165"><xref:System.Windows.NameScope.SetNameScope%2A> is used to map a new XAML namescope to an existing object.</span></span> <span data-ttu-id="a4f2b-166">您可以调用<xref:System.Windows.NameScope.SetNameScope%2A>不止一次来重置或清除 XAML 名称范围，但这不是常见的用法。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-166">You can call <xref:System.Windows.NameScope.SetNameScope%2A> more than once in order to reset or clear the XAML namescope, but that is not a common usage.</span></span> <span data-ttu-id="a4f2b-167">此外，<xref:System.Windows.NameScope.GetNameScope%2A>通常不使用代码中。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-167">Also, <xref:System.Windows.NameScope.GetNameScope%2A> is not typically used from code.</span></span>  
  
### <a name="xaml-namescope-implementations"></a><span data-ttu-id="a4f2b-168">XAML 名称范围实现</span><span class="sxs-lookup"><span data-stu-id="a4f2b-168">XAML Namescope Implementations</span></span>  
 <span data-ttu-id="a4f2b-169">以下类实现<xref:System.Windows.Markup.INameScope>直接：</span><span class="sxs-lookup"><span data-stu-id="a4f2b-169">The following classes implement <xref:System.Windows.Markup.INameScope> directly:</span></span>  
  
- <xref:System.Windows.NameScope>  
  
- <xref:System.Windows.Style>  
  
- <xref:System.Windows.ResourceDictionary>  
  
- <xref:System.Windows.FrameworkTemplate>  
  
 <span data-ttu-id="a4f2b-170"><xref:System.Windows.ResourceDictionary> 不使用 XAML 名称范围;因为它是一种字典实现，它而是使用密钥。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-170"><xref:System.Windows.ResourceDictionary> does not use XAML names or namescopes ; it uses keys instead, because it is a dictionary implementation.</span></span> <span data-ttu-id="a4f2b-171">唯一原因<xref:System.Windows.ResourceDictionary>实现<xref:System.Windows.Markup.INameScope>是引发异常对用户代码，可帮助阐明，则返回 true 的 XAML 名称范围之间的区别以及如何<xref:System.Windows.ResourceDictionary>处理键，并还确保 XAML 名称范围不应用于<xref:System.Windows.ResourceDictionary>由父元素。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-171">The only reason that <xref:System.Windows.ResourceDictionary> implements <xref:System.Windows.Markup.INameScope> is so it can raise exceptions to user code that help clarify the distinction between a true XAML namescope and how a <xref:System.Windows.ResourceDictionary> handles keys, and also to assure that XAML namescopes are not applied to a <xref:System.Windows.ResourceDictionary> by parent elements.</span></span>  
  
 <span data-ttu-id="a4f2b-172"><xref:System.Windows.FrameworkTemplate> 并<xref:System.Windows.Style>实现<xref:System.Windows.Markup.INameScope>通过显式接口定义。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-172"><xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style> implement <xref:System.Windows.Markup.INameScope> through explicit interface definitions.</span></span> <span data-ttu-id="a4f2b-173">显式实现可使这些 XAML 名称范围，当通过访问按约定发生行为<xref:System.Windows.Markup.INameScope>接口，这是如何传达 XAML 名称范围通过[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]内部进程。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-173">The explicit implementations allow these XAML namescopes to behave conventionally when they are accessed through the <xref:System.Windows.Markup.INameScope> interface, which is how XAML namescopes are communicated by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] internal processes.</span></span> <span data-ttu-id="a4f2b-174">显式接口定义不属于的传统 API 图面，但是<xref:System.Windows.FrameworkTemplate>并<xref:System.Windows.Style>，因为很少需要调用<xref:System.Windows.Markup.INameScope>上的方法<xref:System.Windows.FrameworkTemplate>和<xref:System.Windows.Style>直接，并改为使用其他 API如<xref:System.Windows.FrameworkElement.GetTemplateChild%2A>。</span><span class="sxs-lookup"><span data-stu-id="a4f2b-174">But the explicit interface definitions are not part of the conventional API surface of <xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style>, because you seldom need to call the <xref:System.Windows.Markup.INameScope> methods on <xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style> directly, and instead would use other API such as <xref:System.Windows.FrameworkElement.GetTemplateChild%2A>.</span></span>  
  
 <span data-ttu-id="a4f2b-175">以下类定义其自己的 XAML 名称范围，通过使用<xref:System.Windows.NameScope?displayProperty=nameWithType>帮助器类，并连接到通过其 XAML 名称范围实现<xref:System.Windows.NameScope.NameScope%2A?displayProperty=nameWithType>附加属性：</span><span class="sxs-lookup"><span data-stu-id="a4f2b-175">The following classes define their own XAML namescope, by using the <xref:System.Windows.NameScope?displayProperty=nameWithType> helper class and connecting to its XAML namescope implementation through the <xref:System.Windows.NameScope.NameScope%2A?displayProperty=nameWithType> attached property:</span></span>  
  
- <xref:System.Windows.FrameworkElement>  
  
- <xref:System.Windows.FrameworkContentElement>  
  
## <a name="see-also"></a><span data-ttu-id="a4f2b-176">请参阅</span><span class="sxs-lookup"><span data-stu-id="a4f2b-176">See also</span></span>

- [<span data-ttu-id="a4f2b-177">WPF XAML 的 XAML 命名空间和命名空间映射</span><span class="sxs-lookup"><span data-stu-id="a4f2b-177">XAML Namespaces and Namespace Mapping for WPF XAML</span></span>](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)
- [<span data-ttu-id="a4f2b-178">x:Name 指令</span><span class="sxs-lookup"><span data-stu-id="a4f2b-178">x:Name Directive</span></span>](../../xaml-services/x-name-directive.md)
