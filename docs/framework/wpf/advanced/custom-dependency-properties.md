---
title: 自定义依赖项属性
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- implementing [WPF], wrappers
- registering properties [WPF]
- properties [WPF], metadata
- metadata [WPF], for properties
- custom dependency properties [WPF]
- properties [WPF], registering
- wrappers [WPF], implementing
- dependency properties [WPF], custom
ms.assetid: e6bfcfac-b10d-4f58-9f77-a864c2a2938f
ms.openlocfilehash: e4117d7add2a34d6d989d9222e7688361cf6b379
ms.sourcegitcommit: 62285ec11fa8e8424bab00511a90760c60e63c95
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/20/2020
ms.locfileid: "81646357"
---
# <a name="custom-dependency-properties"></a><span data-ttu-id="abe38-102">自定义依赖项属性</span><span class="sxs-lookup"><span data-stu-id="abe38-102">Custom Dependency Properties</span></span>

<span data-ttu-id="abe38-103">本主题介绍了 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 应用程序开发者和组件作者想要创建自定义依赖属性的原因，并介绍了一些可以提高属性的性能、可用性或通用性的实现步骤以及实现选项。</span><span class="sxs-lookup"><span data-stu-id="abe38-103">This topic describes the reasons that [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] application developers and component authors might want to create custom dependency property, and describes the implementation steps as well as some implementation options that can improve performance, usability, or versatility of the property.</span></span>

<a name="prerequisites"></a>

## <a name="prerequisites"></a><span data-ttu-id="abe38-104">先决条件</span><span class="sxs-lookup"><span data-stu-id="abe38-104">Prerequisites</span></span>

<span data-ttu-id="abe38-105">本主题假设你作为 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 类的现有依赖属性的使用者已经对依赖属性有所了解，并且已经阅读了[依赖属性概述](dependency-properties-overview.md)主题。</span><span class="sxs-lookup"><span data-stu-id="abe38-105">This topic assumes that you understand dependency properties from the perspective of a consumer of existing dependency properties on [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes, and have read the [Dependency Properties Overview](dependency-properties-overview.md) topic.</span></span> <span data-ttu-id="abe38-106">若要理解本主题中的示例，还应当了解 [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] 并知道如何编写 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 应用程序。</span><span class="sxs-lookup"><span data-stu-id="abe38-106">In order to follow the examples in this topic, you should also understand [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] and know how to write [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications.</span></span>

<a name="whatis"></a>

## <a name="what-is-a-dependency-property"></a><span data-ttu-id="abe38-107">什么是依赖属性？</span><span class="sxs-lookup"><span data-stu-id="abe38-107">What Is a Dependency Property?</span></span>

<span data-ttu-id="abe38-108">您可以启用本来是通用语言运行时 （CLR） 属性，通过将其作为依赖项属性实现来支持样式设置、数据绑定、继承、动画和默认值。</span><span class="sxs-lookup"><span data-stu-id="abe38-108">You can enable what would otherwise be a common language runtime (CLR) property to support styling, data binding, inheritance, animations, and default values by implementing it as a dependency property.</span></span> <span data-ttu-id="abe38-109">依赖项属性[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]是通过调用<xref:System.Windows.DependencyProperty.Register%2A>方法 （或<xref:System.Windows.DependencyProperty.RegisterReadOnly%2A>） 并在<xref:System.Windows.DependencyProperty>标识符字段中备份的属性在属性系统中注册的属性。</span><span class="sxs-lookup"><span data-stu-id="abe38-109">Dependency properties are properties that are registered with the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system by calling the <xref:System.Windows.DependencyProperty.Register%2A> method (or <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A>), and that are backed by a <xref:System.Windows.DependencyProperty> identifier field.</span></span> <span data-ttu-id="abe38-110">依赖项属性只能<xref:System.Windows.DependencyObject>由类型使用，但在<xref:System.Windows.DependencyObject>[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]类层次结构中相当高，因此 中[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]大多数可用的类可以支持依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="abe38-110">Dependency properties can be used only by <xref:System.Windows.DependencyObject> types, but <xref:System.Windows.DependencyObject> is quite high in the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] class hierarchy, so the majority of classes available in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] can support dependency properties.</span></span> <span data-ttu-id="abe38-111">有关依赖项属性以及用于在此 SDK 中描述它们的一些术语和约定的详细信息，请参阅[依赖项属性概述](dependency-properties-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="abe38-111">For more information about dependency properties and some of the terminology and conventions used for describing them in this SDK, see [Dependency Properties Overview](dependency-properties-overview.md).</span></span>

<a name="example_dp"></a>

## <a name="examples-of-dependency-properties"></a><span data-ttu-id="abe38-112">依赖属性示例</span><span class="sxs-lookup"><span data-stu-id="abe38-112">Examples of Dependency Properties</span></span>

<span data-ttu-id="abe38-113">在类[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]上实现的依赖项属性的示例<xref:System.Windows.Controls.Control.Background%2A>包括属性、<xref:System.Windows.FrameworkElement.Width%2A>属性和<xref:System.Windows.Controls.TextBox.Text%2A>属性等。</span><span class="sxs-lookup"><span data-stu-id="abe38-113">Examples of dependency properties that are implemented on [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes include the <xref:System.Windows.Controls.Control.Background%2A> property, the <xref:System.Windows.FrameworkElement.Width%2A> property, and the <xref:System.Windows.Controls.TextBox.Text%2A> property, among many others.</span></span> <span data-ttu-id="abe38-114">类公开的每个依赖项属性都有在同一类上公开的相应的公共静态<xref:System.Windows.DependencyProperty>类型字段。</span><span class="sxs-lookup"><span data-stu-id="abe38-114">Each dependency property exposed by a class has a corresponding public static field of type <xref:System.Windows.DependencyProperty> exposed on that same class.</span></span> <span data-ttu-id="abe38-115">这是依赖属性的标识符。</span><span class="sxs-lookup"><span data-stu-id="abe38-115">This is the identifier for the dependency property.</span></span> <span data-ttu-id="abe38-116">此标识符的命名约定为：依赖属性名称后面加上字符串 `Property`。</span><span class="sxs-lookup"><span data-stu-id="abe38-116">The identifier is named using a convention: the name of the dependency property with the string `Property` appended to it.</span></span> <span data-ttu-id="abe38-117">例如，属性的<xref:System.Windows.DependencyProperty><xref:System.Windows.Controls.Control.Background%2A>相应标识符字段为<xref:System.Windows.Controls.Control.BackgroundProperty>。</span><span class="sxs-lookup"><span data-stu-id="abe38-117">For example, the corresponding <xref:System.Windows.DependencyProperty> identifier field for the <xref:System.Windows.Controls.Control.Background%2A> property is <xref:System.Windows.Controls.Control.BackgroundProperty>.</span></span> <span data-ttu-id="abe38-118">标识符在注册时存储有关依赖项属性的信息，然后标识符稍后用于涉及依赖项属性的其他操作，如调用<xref:System.Windows.DependencyObject.SetValue%2A>。</span><span class="sxs-lookup"><span data-stu-id="abe38-118">The identifier stores the information about the dependency property as it was registered, and the identifier is then used later for other operations involving the dependency property, such as calling <xref:System.Windows.DependencyObject.SetValue%2A>.</span></span>

<span data-ttu-id="abe38-119">如[依赖项属性概述](dependency-properties-overview.md)中所述，由于实现"包装[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]"，中的所有依赖项属性（大多数附加属性除外）也是 CLR 属性。</span><span class="sxs-lookup"><span data-stu-id="abe38-119">As mentioned in the [Dependency Properties Overview](dependency-properties-overview.md), all dependency properties in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] (except most attached properties) are also CLR properties because of the "wrapper" implementation.</span></span> <span data-ttu-id="abe38-120">因此，通过代码，可以通过调用 CLR 访问器来获取或设置依赖项属性，这些访问器以与其他 CLR 属性相同的方式定义包装器。</span><span class="sxs-lookup"><span data-stu-id="abe38-120">Therefore, from code, you can get or set dependency properties by calling CLR accessors that define the wrappers in the same manner that you would use other CLR properties.</span></span> <span data-ttu-id="abe38-121">作为已建立的依赖项属性的使用者，您通常不使用<xref:System.Windows.DependencyObject>与基础属性系统<xref:System.Windows.DependencyObject.GetValue%2A>的连接<xref:System.Windows.DependencyObject.SetValue%2A>点的方法和 。</span><span class="sxs-lookup"><span data-stu-id="abe38-121">As a consumer of established dependency properties, you do not typically use the <xref:System.Windows.DependencyObject> methods <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A>, which are the connection point to the underlying property system.</span></span> <span data-ttu-id="abe38-122"><xref:System.Windows.DependencyObject.GetValue%2A>相反，CLR 属性的现有实现已经调用，并在<xref:System.Windows.DependencyObject.SetValue%2A>属性的`get`和`set`包装器实现中，适当地使用标识符字段。</span><span class="sxs-lookup"><span data-stu-id="abe38-122">Rather, the existing implementation of the CLR properties will have already called <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> within the `get` and `set` wrapper implementations of the property, using the identifier field appropriately.</span></span> <span data-ttu-id="abe38-123">若要自己实现自定义依赖属性，则需要使用类似的方法定义包装器。</span><span class="sxs-lookup"><span data-stu-id="abe38-123">If you are implementing a custom dependency property yourself, then you will be defining the wrapper in a similar way.</span></span>

<a name="backing_with_dp"></a>

## <a name="when-should-you-implement-a-dependency-property"></a><span data-ttu-id="abe38-124">应该何时实现依赖属性？</span><span class="sxs-lookup"><span data-stu-id="abe38-124">When Should You Implement a Dependency Property?</span></span>

<span data-ttu-id="abe38-125">在类上实现属性时，只要类派生自<xref:System.Windows.DependencyObject>，可以选择使用<xref:System.Windows.DependencyProperty>标识符支持属性，从而使该属性成为依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="abe38-125">When you implement a property on a class, so long as your class derives from <xref:System.Windows.DependencyObject>, you have the option to back your property with a <xref:System.Windows.DependencyProperty> identifier and thus to make it a dependency property.</span></span> <span data-ttu-id="abe38-126">不必总是将属性实现为依赖属性，这不一定合适，具体取决于方案需要。</span><span class="sxs-lookup"><span data-stu-id="abe38-126">Having your property be a dependency property is not always necessary or appropriate, and will depend on your scenario needs.</span></span> <span data-ttu-id="abe38-127">有时，使用私有字段支持属性的通常方法已足够满足需求。</span><span class="sxs-lookup"><span data-stu-id="abe38-127">Sometimes, the typical technique of backing your property with a private field is adequate.</span></span> <span data-ttu-id="abe38-128">但是，如果要使属性支持以下一个或多个 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 功能，则应该将属性实现为依赖属性：</span><span class="sxs-lookup"><span data-stu-id="abe38-128">However, you should implement your property as a dependency property whenever you want your property to support one or more of the following [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] capabilities:</span></span>

- <span data-ttu-id="abe38-129">需要可以在样式中设置属性。</span><span class="sxs-lookup"><span data-stu-id="abe38-129">You want your property to be settable in a style.</span></span> <span data-ttu-id="abe38-130">有关详细信息，请参阅[样式和模板](../../../desktop-wpf/fundamentals/styles-templates-overview.md)化。</span><span class="sxs-lookup"><span data-stu-id="abe38-130">For more information, see [Styling and Templating](../../../desktop-wpf/fundamentals/styles-templates-overview.md).</span></span>

- <span data-ttu-id="abe38-131">需要属性支持数据绑定。</span><span class="sxs-lookup"><span data-stu-id="abe38-131">You want your property to support data binding.</span></span> <span data-ttu-id="abe38-132">有关数据绑定依赖属性的详细信息，请参阅[绑定两个控件的属性](../data/how-to-bind-the-properties-of-two-controls.md)。</span><span class="sxs-lookup"><span data-stu-id="abe38-132">For more information about data binding dependency properties, see [Bind the Properties of Two Controls](../data/how-to-bind-the-properties-of-two-controls.md).</span></span>

- <span data-ttu-id="abe38-133">需要可以使用动态资源引用设置属性。</span><span class="sxs-lookup"><span data-stu-id="abe38-133">You want your property to be settable with a dynamic resource reference.</span></span> <span data-ttu-id="abe38-134">有关详细信息，请参阅 [XAML 资源](../../../desktop-wpf/fundamentals/xaml-resources-define.md)。</span><span class="sxs-lookup"><span data-stu-id="abe38-134">For more information, see [XAML Resources](../../../desktop-wpf/fundamentals/xaml-resources-define.md).</span></span>

- <span data-ttu-id="abe38-135">需要从元素树中的父元素自动继承属性值。</span><span class="sxs-lookup"><span data-stu-id="abe38-135">You want to inherit a property value automatically from a parent element in the element tree.</span></span> <span data-ttu-id="abe38-136">在这种情况下，请向 方法<xref:System.Windows.DependencyProperty.RegisterAttached%2A>注册，即使您也为 CLR 访问创建了属性包装器。</span><span class="sxs-lookup"><span data-stu-id="abe38-136">In this case, register with the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method, even if you also create a property wrapper for CLR access.</span></span> <span data-ttu-id="abe38-137">有关详细信息，请参阅[属性值继承](property-value-inheritance.md)。</span><span class="sxs-lookup"><span data-stu-id="abe38-137">For more information, see [Property Value Inheritance](property-value-inheritance.md).</span></span>

- <span data-ttu-id="abe38-138">需要属性可以进行动画处理。</span><span class="sxs-lookup"><span data-stu-id="abe38-138">You want your property to be animatable.</span></span> <span data-ttu-id="abe38-139">有关详细信息，请参阅 [动画概述](../graphics-multimedia/animation-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="abe38-139">For more information, see [Animation Overview](../graphics-multimedia/animation-overview.md).</span></span>

- <span data-ttu-id="abe38-140">需要属性系统在先前的值因属性系统、环境或用户执行的操作而发生更改，或者因读取和使用样式而发生更改时进行报告。</span><span class="sxs-lookup"><span data-stu-id="abe38-140">You want the property system to report when the previous value of the property has been changed by actions taken by the property system, the environment, or the user, or by reading and using styles.</span></span> <span data-ttu-id="abe38-141">通过使用属性元素据，属性可以指定回调方法，每次属性系统确定属性值已明确改动时将调用此回调方法。</span><span class="sxs-lookup"><span data-stu-id="abe38-141">By using property metadata, your property can specify a callback method that will be invoked each time the property system determines that your property value was definitively changed.</span></span> <span data-ttu-id="abe38-142">与此相关的一个概念是属性值强制转换。</span><span class="sxs-lookup"><span data-stu-id="abe38-142">A related concept is property value coercion.</span></span> <span data-ttu-id="abe38-143">有关详细信息，请参阅[依赖属性回调和验证](dependency-property-callbacks-and-validation.md)。</span><span class="sxs-lookup"><span data-stu-id="abe38-143">For more information, see [Dependency Property Callbacks and Validation](dependency-property-callbacks-and-validation.md).</span></span>

- <span data-ttu-id="abe38-144">需要使用同时也被 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 进程使用的已建立的元数据约定，例如报告更改属性值是否应需要布局系统重新安排元素的可视内容。</span><span class="sxs-lookup"><span data-stu-id="abe38-144">You want to use established metadata conventions that are also used by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] processes, such as reporting whether changing a property value should require the layout system to recompose the visuals for an element.</span></span> <span data-ttu-id="abe38-145">或者需要能够使用元素据替代，以便派生类可以更改基于元数据的特性，例如默认值。</span><span class="sxs-lookup"><span data-stu-id="abe38-145">Or you want to be able to use metadata overrides so that derived classes can change metadata-based characteristics such as the default value.</span></span>

- <span data-ttu-id="abe38-146">您希望自定义控件的属性接收 Visual Studio WPF 设计器支持，例如**属性**窗口编辑。</span><span class="sxs-lookup"><span data-stu-id="abe38-146">You want properties of a custom control to receive Visual Studio WPF Designer support, such as **Properties** window editing.</span></span> <span data-ttu-id="abe38-147">有关详细信息，请参阅[控件创作概述](../controls/control-authoring-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="abe38-147">For more information, see [Control Authoring Overview](../controls/control-authoring-overview.md).</span></span>

<span data-ttu-id="abe38-148">检查这些方案时，还应考虑是否可以通过替代现有依赖属性的元素据而不是通过实现一个全新的属性来实现方案。</span><span class="sxs-lookup"><span data-stu-id="abe38-148">When you examine these scenarios, you should also consider whether you can achieve your scenario by overriding the metadata of an existing dependency property, rather than implementing a completely new property.</span></span> <span data-ttu-id="abe38-149">元素据替代是否可行取决于方案以及方案与现有的 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 依赖属性和类中的实现的相似度。</span><span class="sxs-lookup"><span data-stu-id="abe38-149">Whether a metadata override is practical depends on your scenario and how closely that scenario resembles the implementation in existing [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] dependency properties and classes.</span></span> <span data-ttu-id="abe38-150">有关替代现有属性上的元素据的详细信息，请参阅[依赖属性元素据](dependency-property-metadata.md)。</span><span class="sxs-lookup"><span data-stu-id="abe38-150">For more information about overriding metadata on existing properties, see [Dependency Property Metadata](dependency-property-metadata.md).</span></span>

<a name="checklist"></a>

## <a name="checklist-for-defining-a-dependency-property"></a><span data-ttu-id="abe38-151">定义依赖属性的检查清单</span><span class="sxs-lookup"><span data-stu-id="abe38-151">Checklist for Defining a Dependency Property</span></span>

<span data-ttu-id="abe38-152">定义依赖属性包含 4 个不同的概念。</span><span class="sxs-lookup"><span data-stu-id="abe38-152">Defining a dependency property consists of four distinct concepts.</span></span> <span data-ttu-id="abe38-153">这些概念并不一定是严格的过程步骤，因为其中一些概念在实现中会被合并为一行代码：</span><span class="sxs-lookup"><span data-stu-id="abe38-153">These concepts are not necessarily strict procedural steps, because some of these end up being combined as single lines of code in the implementation:</span></span>

- <span data-ttu-id="abe38-154">（可选）创建依赖属性的属性元素据。</span><span class="sxs-lookup"><span data-stu-id="abe38-154">(Optional) Create property metadata for the dependency property.</span></span>

- <span data-ttu-id="abe38-155">在属性系统中注册属性名称，并指定所有者类型和属性值类型。</span><span class="sxs-lookup"><span data-stu-id="abe38-155">Register the property name with the property system, specifying an owner type and the type of the property value.</span></span> <span data-ttu-id="abe38-156">此外，还应指定属性元素据（如果用到）。</span><span class="sxs-lookup"><span data-stu-id="abe38-156">Also specify the property metadata, if used.</span></span>

- <span data-ttu-id="abe38-157">将<xref:System.Windows.DependencyProperty>标识符定义为`public``static``readonly`所有者类型的字段。</span><span class="sxs-lookup"><span data-stu-id="abe38-157">Define a <xref:System.Windows.DependencyProperty> identifier as a `public` `static` `readonly` field on the owner type.</span></span>

- <span data-ttu-id="abe38-158">定义 CLR"包装器"属性，其名称与依赖项属性的名称匹配。</span><span class="sxs-lookup"><span data-stu-id="abe38-158">Define a CLR "wrapper" property whose name matches the name of the dependency property.</span></span> <span data-ttu-id="abe38-159">实现 CLR"包装器"属性`get`和`set`访问器，以便与支持它的依赖项属性连接。</span><span class="sxs-lookup"><span data-stu-id="abe38-159">Implement the CLR "wrapper" property's `get` and `set` accessors to connect with the dependency property that backs it.</span></span>

<a name="registering"></a>

### <a name="registering-the-property-with-the-property-system"></a><span data-ttu-id="abe38-160">在属性系统中注册属性</span><span class="sxs-lookup"><span data-stu-id="abe38-160">Registering the Property with the Property System</span></span>

<span data-ttu-id="abe38-161">为使属性成为依赖属性，必须在属性系统维护的表中注册该属性，并为属性指定一个唯一标识符。此唯一标识符会用作后续属性系统操作的限定符。</span><span class="sxs-lookup"><span data-stu-id="abe38-161">In order for your property to be a dependency property, you must register that property into a table maintained by the property system, and give it a unique identifier that is used as the qualifier for later property system operations.</span></span> <span data-ttu-id="abe38-162">这些操作可能是内部操作，或者您自己的代码调用属性系统 API。</span><span class="sxs-lookup"><span data-stu-id="abe38-162">These operations might be internal operations, or your own code calling property system APIs.</span></span> <span data-ttu-id="abe38-163">要注册该属性，请在类正文<xref:System.Windows.DependencyProperty.Register%2A>中调用 方法（类内部，但超出任何成员定义）。</span><span class="sxs-lookup"><span data-stu-id="abe38-163">To register the property, you call the <xref:System.Windows.DependencyProperty.Register%2A> method within the body of your class (inside the class, but outside of any member definitions).</span></span> <span data-ttu-id="abe38-164">标识符字段也由<xref:System.Windows.DependencyProperty.Register%2A>方法调用作为返回值提供。</span><span class="sxs-lookup"><span data-stu-id="abe38-164">The identifier field is also provided by the <xref:System.Windows.DependencyProperty.Register%2A> method call, as the return value.</span></span> <span data-ttu-id="abe38-165"><xref:System.Windows.DependencyProperty.Register%2A>调用是在其他成员定义之外完成的，因为您使用此返回值作为类的一`public``static``readonly`部分分配和创建类型<xref:System.Windows.DependencyProperty>字段。</span><span class="sxs-lookup"><span data-stu-id="abe38-165">The reason that the <xref:System.Windows.DependencyProperty.Register%2A> call is done outside of other member definitions is because you use this return value to assign and create a `public` `static` `readonly` field of type <xref:System.Windows.DependencyProperty> as part of your class.</span></span> <span data-ttu-id="abe38-166">此字段会作为依赖属性的标识符。</span><span class="sxs-lookup"><span data-stu-id="abe38-166">This field becomes the identifier for your dependency property.</span></span>

[!code-csharp[WPFAquariumSln#RegisterAG](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerag)]
[!code-vb[WPFAquariumSln#RegisterAG](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerag)]

<a name="nameconventions"></a>

### <a name="dependency-property-name-conventions"></a><span data-ttu-id="abe38-167">依赖属性命名约定</span><span class="sxs-lookup"><span data-stu-id="abe38-167">Dependency Property Name Conventions</span></span>

<span data-ttu-id="abe38-168">必需完全遵循已有的依赖属性命名约定，例外情况除外。</span><span class="sxs-lookup"><span data-stu-id="abe38-168">There are established naming conventions regarding dependency properties that you must follow in all but exceptional circumstances.</span></span>

<span data-ttu-id="abe38-169">依赖项属性本身将具有基本名称"水族馆图"，如本示例中所示，该名称作为<xref:System.Windows.DependencyProperty.Register%2A>的第一个参数给出。</span><span class="sxs-lookup"><span data-stu-id="abe38-169">The dependency property itself will have a basic name, "AquariumGraphic" as in this example, which is given as the first parameter of <xref:System.Windows.DependencyProperty.Register%2A>.</span></span> <span data-ttu-id="abe38-170">此名称在每个注册类型内必须唯一。</span><span class="sxs-lookup"><span data-stu-id="abe38-170">That name must be unique within each registering type.</span></span> <span data-ttu-id="abe38-171">通过基类型继承的依赖属性会被视为注册类型的已有部分；无法再次注册已继承属性的名称。</span><span class="sxs-lookup"><span data-stu-id="abe38-171">Dependency properties inherited through base types are considered to be already part of the registering type; names of inherited properties cannot be registered again.</span></span> <span data-ttu-id="abe38-172">但是，即使不继承依赖属性，也有方法可将类添加为依赖属性的所有者；有关详细信息，请参阅[依赖属性元素据](dependency-property-metadata.md)。</span><span class="sxs-lookup"><span data-stu-id="abe38-172">However, there is a technique for adding a class as owner of a dependency property even when that dependency property is not inherited; for details, see [Dependency Property Metadata](dependency-property-metadata.md).</span></span>

<span data-ttu-id="abe38-173">创建标识符字段时，按注册时的属性名称命名此字段，再加上后缀 `Property`。</span><span class="sxs-lookup"><span data-stu-id="abe38-173">When you create the identifier field, name this field by the name of the property as you registered it, plus the suffix `Property`.</span></span> <span data-ttu-id="abe38-174">此字段是依赖项属性的标识符，稍后将用作包装器中要进行的<xref:System.Windows.DependencyObject.SetValue%2A>和<xref:System.Windows.DependencyObject.GetValue%2A>调用的输入、您自己的代码对该属性的任何其他代码访问、您允许的任何外部代码访问、属性系统以及可能由[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]处理器访问。</span><span class="sxs-lookup"><span data-stu-id="abe38-174">This field is your identifier for the dependency property, and it will be used later as an input for the <xref:System.Windows.DependencyObject.SetValue%2A> and <xref:System.Windows.DependencyObject.GetValue%2A> calls you will make in the wrappers, by any other code access to the property by your own code, by any external code access you allow, by the property system, and potentially by [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] processors.</span></span>

> [!NOTE]
> <span data-ttu-id="abe38-175">在类的主体中定义依赖属性是典型的实现，但也可以在类静态构造函数中定义依赖属性。</span><span class="sxs-lookup"><span data-stu-id="abe38-175">Defining the dependency property in the class body is the typical implementation, but it is also possible to define a dependency property in the class static constructor.</span></span> <span data-ttu-id="abe38-176">需要多行代码来初始化依赖属性时，此方法会很有用。</span><span class="sxs-lookup"><span data-stu-id="abe38-176">This approach might make sense if you need more than one line of code to initialize the dependency property.</span></span>

<a name="wrapper1"></a>

### <a name="implementing-the-wrapper"></a><span data-ttu-id="abe38-177">实现“包装器”</span><span class="sxs-lookup"><span data-stu-id="abe38-177">Implementing the "Wrapper"</span></span>

<span data-ttu-id="abe38-178">包装<xref:System.Windows.DependencyObject.GetValue%2A>器实现应在`get`实现和<xref:System.Windows.DependencyObject.SetValue%2A>`set`实现中调用（此处也显示原始注册调用和字段，以便清楚）。</span><span class="sxs-lookup"><span data-stu-id="abe38-178">Your wrapper implementation should call <xref:System.Windows.DependencyObject.GetValue%2A> in the `get` implementation, and <xref:System.Windows.DependencyObject.SetValue%2A> in the `set` implementation (the original registration call and field are shown here too for clarity).</span></span>

<span data-ttu-id="abe38-179">在除了特殊情况外，包装器实现应分别执行 和<xref:System.Windows.DependencyObject.GetValue%2A><xref:System.Windows.DependencyObject.SetValue%2A>操作。</span><span class="sxs-lookup"><span data-stu-id="abe38-179">In all but exceptional circumstances, your wrapper implementations should perform only the <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> actions, respectively.</span></span> <span data-ttu-id="abe38-180">其原因请参阅 [XAML 加载和依赖属性](xaml-loading-and-dependency-properties.md)主题。</span><span class="sxs-lookup"><span data-stu-id="abe38-180">The reason for this is discussed in the topic [XAML Loading and Dependency Properties](xaml-loading-and-dependency-properties.md).</span></span>

<span data-ttu-id="abe38-181">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 类上提供的所有现有公共依赖属性都使用这一简单的包装器实现模型；大多数情况下，依赖属性工作原理的复杂性本质上在于它是属性系统的行为，还是通过其他概念（例如强制转换或通过属性元数据进行的属性更改回调）实现的行为。</span><span class="sxs-lookup"><span data-stu-id="abe38-181">All existing public dependency properties that are provided on the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes use this simple wrapper implementation model; most of the complexity of how dependency properties work is either inherently a behavior of the property system, or is implemented through other concepts such as coercion or property change callbacks through property metadata.</span></span>

[!code-csharp[WPFAquariumSln#AGWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#agwithwrapper)]
[!code-vb[WPFAquariumSln#AGWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#agwithwrapper)]

<span data-ttu-id="abe38-182">同样，按照惯例，包装器属性的名称必须与选择的名称相同，并作为注册该属性的<xref:System.Windows.DependencyProperty.Register%2A>调用的第一个参数给出。</span><span class="sxs-lookup"><span data-stu-id="abe38-182">Again, by convention, the name of the wrapper property must be the same as the name chosen and given as first parameter of the <xref:System.Windows.DependencyProperty.Register%2A> call that registered the property.</span></span> <span data-ttu-id="abe38-183">如果属性不遵从此约定，尽管不一定会禁用所有可能的用法，但你会遇到几个比较突出的问题：</span><span class="sxs-lookup"><span data-stu-id="abe38-183">If your property does not follow the convention, this does not necessarily disable all possible uses, but you will encounter several notable issues:</span></span>

- <span data-ttu-id="abe38-184">样式和模板的某些方面不起作用。</span><span class="sxs-lookup"><span data-stu-id="abe38-184">Certain aspects of styles and templates will not work.</span></span>

- <span data-ttu-id="abe38-185">大多数工具和设计器必须依赖命名约定，才能正确序列化 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 或在每个属性级别提供设计器环境帮助。</span><span class="sxs-lookup"><span data-stu-id="abe38-185">Most tools and designers must rely on the naming conventions to properly serialize [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], or to provide designer environment assistance at a per-property level.</span></span>

- <span data-ttu-id="abe38-186">加载程序的[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)][!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]当前实现完全绕过包装器，在处理属性值时依赖于命名约定。</span><span class="sxs-lookup"><span data-stu-id="abe38-186">The current implementation of the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] loader bypasses the wrappers entirely, and relies on the naming convention when processing attribute values.</span></span> <span data-ttu-id="abe38-187">有关详细信息，请参阅 [XAML 加载和依赖属性](xaml-loading-and-dependency-properties.md)。</span><span class="sxs-lookup"><span data-stu-id="abe38-187">For more information, see [XAML Loading and Dependency Properties](xaml-loading-and-dependency-properties.md).</span></span>

<a name="metadata"></a>

### <a name="property-metadata-for-a-new-dependency-property"></a><span data-ttu-id="abe38-188">新依赖属性的属性元数据</span><span class="sxs-lookup"><span data-stu-id="abe38-188">Property Metadata for a New Dependency Property</span></span>

<span data-ttu-id="abe38-189">注册依赖属性时，通过属性系统进行注册会创建一个存储属性特征的元素据对象。</span><span class="sxs-lookup"><span data-stu-id="abe38-189">When you register a dependency property, the registration through the property system creates a metadata object that stores property characteristics.</span></span> <span data-ttu-id="abe38-190">如果属性注册了<xref:System.Windows.DependencyProperty.Register%2A>的简单签名，则这些特征中有许多具有默认设置。</span><span class="sxs-lookup"><span data-stu-id="abe38-190">Many of these characteristics have defaults that are set if the property is registered with the simple signatures of <xref:System.Windows.DependencyProperty.Register%2A>.</span></span> <span data-ttu-id="abe38-191">的其他签名<xref:System.Windows.DependencyProperty.Register%2A>允许您在注册属性时指定所需的元数据。</span><span class="sxs-lookup"><span data-stu-id="abe38-191">Other signatures of <xref:System.Windows.DependencyProperty.Register%2A> allow you to specify the metadata that you want as you register the property.</span></span> <span data-ttu-id="abe38-192">为依赖属性使用的最常见元数据是为其使用默认值。该默认值适用于使用此属性的新实例。</span><span class="sxs-lookup"><span data-stu-id="abe38-192">The most common metadata given for dependency properties is to give them a default value that is applied on new instances that use the property.</span></span>

<span data-ttu-id="abe38-193">如果要创建存在于 派生类的依赖项属性，则可以使用更专用的<xref:System.Windows.FrameworkElement>元数据类<xref:System.Windows.FrameworkPropertyMetadata>而不是基<xref:System.Windows.PropertyMetadata>类。</span><span class="sxs-lookup"><span data-stu-id="abe38-193">If you are creating a dependency property that exists on a derived class of <xref:System.Windows.FrameworkElement>, you can use the more specialized metadata class <xref:System.Windows.FrameworkPropertyMetadata> rather than the base <xref:System.Windows.PropertyMetadata> class.</span></span> <span data-ttu-id="abe38-194">类的<xref:System.Windows.FrameworkPropertyMetadata>构造函数具有多个签名，您可以在其中组合指定各种元数据特征。</span><span class="sxs-lookup"><span data-stu-id="abe38-194">The constructor for the <xref:System.Windows.FrameworkPropertyMetadata> class has several signatures where you can specify various metadata characteristics in combination.</span></span> <span data-ttu-id="abe38-195">如果只想指定默认值，请使用采用类型 为<xref:System.Object>的单个参数的签名。</span><span class="sxs-lookup"><span data-stu-id="abe38-195">If you want to specify the default value only, use the signature that takes a single parameter of type <xref:System.Object>.</span></span> <span data-ttu-id="abe38-196">将该对象参数作为属性的特定于类型的默认值传递（提供的默认值必须是您在`propertyType`<xref:System.Windows.DependencyProperty.Register%2A>调用中作为参数提供的类型）。</span><span class="sxs-lookup"><span data-stu-id="abe38-196">Pass that object parameter as a type-specific default value for your property (the default value provided must be the type you provided as the `propertyType` parameter in the <xref:System.Windows.DependencyProperty.Register%2A> call).</span></span>

<span data-ttu-id="abe38-197">对于<xref:System.Windows.FrameworkPropertyMetadata>，还可以为属性指定元数据选项标志。</span><span class="sxs-lookup"><span data-stu-id="abe38-197">For <xref:System.Windows.FrameworkPropertyMetadata>, you can also specify metadata option flags for your property.</span></span> <span data-ttu-id="abe38-198">注册后这些标记会转换为属性元素据上的不同属性，并用于将某些条件传送给布局引擎等其他进程。</span><span class="sxs-lookup"><span data-stu-id="abe38-198">These flags are converted into discrete properties on the property metadata after registration and are used to communicate certain conditionals to other processes such as the layout engine.</span></span>

#### <a name="setting-appropriate-metadata-flags"></a><span data-ttu-id="abe38-199">设置合适的元数据标记</span><span class="sxs-lookup"><span data-stu-id="abe38-199">Setting Appropriate Metadata Flags</span></span>

- <span data-ttu-id="abe38-200">如果属性（或其值的更改）影响[!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)]，并且特别影响布局系统在页中的大小或呈现元素的方式，请设置以下一个或多个标志： <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure>。 <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsArrange> <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsRender>。</span><span class="sxs-lookup"><span data-stu-id="abe38-200">If your property (or changes in its value) affects the [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)], and in particular affects how the layout system should size or render your element in a page, set one or more of the following flags: <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure>, <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsArrange>, <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsRender>.</span></span>

  - <span data-ttu-id="abe38-201"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure>指示对此属性的更改需要更改为[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]呈现，其中包含对象可能需要父对象中或多或少的空间。</span><span class="sxs-lookup"><span data-stu-id="abe38-201"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure> indicates that a change to this property requires a change to [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] rendering where the containing object might require more or less space within the parent.</span></span> <span data-ttu-id="abe38-202">例如，“宽度”属性应该设置此标记。</span><span class="sxs-lookup"><span data-stu-id="abe38-202">For example, a "Width" property should have this flag set.</span></span>

  - <span data-ttu-id="abe38-203"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsArrange>指示对此属性的更改需要更改[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]渲染，这通常不需要在专用空间中进行更改，但确实表示空间中的定位已更改。</span><span class="sxs-lookup"><span data-stu-id="abe38-203"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsArrange> indicates that a change to this property requires a change to [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] rendering that typically does not require a change in the dedicated space, but does indicate that the positioning within the space has changed.</span></span> <span data-ttu-id="abe38-204">例如，“对齐”属性应该设置此标记。</span><span class="sxs-lookup"><span data-stu-id="abe38-204">For example, an "Alignment" property should have this flag set.</span></span>

  - <span data-ttu-id="abe38-205"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsRender>指示发生了一些其他更改，这些更改不会影响布局和度量值，但确实需要另一个渲染。</span><span class="sxs-lookup"><span data-stu-id="abe38-205"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsRender> indicates that some other change has occurred that will not affect layout and measure, but does require another render.</span></span> <span data-ttu-id="abe38-206">更改现有元素的颜色的属性便是一个示例，例如“背景”。</span><span class="sxs-lookup"><span data-stu-id="abe38-206">An example would be a property that changes a color of an existing element, such as "Background".</span></span>

  - <span data-ttu-id="abe38-207">对属性系统或布局回调进行自己的替代实现时，这些标记通常用作元数据中的协议。</span><span class="sxs-lookup"><span data-stu-id="abe38-207">These flags are often used as a protocol in metadata for your own override implementations of property system or layout callbacks.</span></span> <span data-ttu-id="abe38-208">例如，如果实例的任何属性报告<xref:System.Windows.DependencyObject.OnPropertyChanged%2A>值更改且其元数据<xref:System.Windows.UIElement.InvalidateArrange%2A>中具有<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>，`true`则可能具有回调。</span><span class="sxs-lookup"><span data-stu-id="abe38-208">For instance, you might have an <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> callback that will call <xref:System.Windows.UIElement.InvalidateArrange%2A> if any property of the instance reports a value change and has <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> as `true` in its metadata.</span></span>

- <span data-ttu-id="abe38-209">超出上述所需大小时，某些属性可能会影响所含父元素的呈现特征。</span><span class="sxs-lookup"><span data-stu-id="abe38-209">Some properties may affect the rendering characteristics of the containing parent element, in ways above and beyond the changes in required size mentioned above.</span></span> <span data-ttu-id="abe38-210">例如，流文档<xref:System.Windows.Documents.Paragraph.MinOrphanLines%2A>模型中使用的属性，其中对该属性的更改可以更改包含段落的流文档的总体呈现。</span><span class="sxs-lookup"><span data-stu-id="abe38-210">An example is the <xref:System.Windows.Documents.Paragraph.MinOrphanLines%2A> property used in the flow document model, where changes to that property can change the overall rendering of the flow document that contains the paragraph.</span></span> <span data-ttu-id="abe38-211">使用<xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsParentArrange><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsParentMeasure>或在您自己的属性中识别类似情况。</span><span class="sxs-lookup"><span data-stu-id="abe38-211">Use <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsParentArrange> or <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsParentMeasure> to identify similar cases in your own properties.</span></span>

- <span data-ttu-id="abe38-212">默认情况下，依赖属性支持数据绑定。</span><span class="sxs-lookup"><span data-stu-id="abe38-212">By default, dependency properties support data binding.</span></span> <span data-ttu-id="abe38-213">在无实际的数据绑定方案或大型对象的数据绑定性能构成问题的情况下，可有意禁用数据绑定。</span><span class="sxs-lookup"><span data-stu-id="abe38-213">You can deliberately disable data binding, for cases where there is no realistic scenario for data binding, or where performance in data binding for a large object is recognized as a problem.</span></span>

- <span data-ttu-id="abe38-214">默认情况下，依赖项属性<xref:System.Windows.Data.Binding.Mode%2A>的数据绑定默认为<xref:System.Windows.Data.BindingMode.OneWay>。</span><span class="sxs-lookup"><span data-stu-id="abe38-214">By default, data binding <xref:System.Windows.Data.Binding.Mode%2A> for dependency properties defaults to <xref:System.Windows.Data.BindingMode.OneWay>.</span></span> <span data-ttu-id="abe38-215">您可以随时将绑定更改为<xref:System.Windows.Data.BindingMode.TwoWay>每个绑定实例;因此，您可以将绑定更改为每个绑定实例。有关详细信息，请参阅[指定绑定的方向](../data/how-to-specify-the-direction-of-the-binding.md)。</span><span class="sxs-lookup"><span data-stu-id="abe38-215">You can always change the binding to be <xref:System.Windows.Data.BindingMode.TwoWay> per binding instance; for details, see [Specify the Direction of the Binding](../data/how-to-specify-the-direction-of-the-binding.md).</span></span> <span data-ttu-id="abe38-216">但是，作为依赖项属性作者，您可以选择使属性默认使用<xref:System.Windows.Data.BindingMode.TwoWay>绑定模式。</span><span class="sxs-lookup"><span data-stu-id="abe38-216">But as the dependency property author, you can choose to make the property use <xref:System.Windows.Data.BindingMode.TwoWay> binding mode by default.</span></span> <span data-ttu-id="abe38-217">现有依赖项属性的示例是<xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A?displayProperty=nameWithType>。此属性的方案是<xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A>设置逻辑和组合与<xref:System.Windows.Controls.MenuItem>默认主题样式交互。</span><span class="sxs-lookup"><span data-stu-id="abe38-217">An example of an existing dependency property is <xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A?displayProperty=nameWithType>; the scenario for this property is that the <xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A> setting logic and the compositing of <xref:System.Windows.Controls.MenuItem> interact with the default theme style.</span></span> <span data-ttu-id="abe38-218">属性<xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A>逻辑使用本机绑定的数据来根据其他状态属性和方法调用维护属性的状态。</span><span class="sxs-lookup"><span data-stu-id="abe38-218">The <xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A> property logic uses data binding natively to maintain the state of the property in accordance to other state properties and method calls.</span></span> <span data-ttu-id="abe38-219">默认情况下绑定<xref:System.Windows.Data.BindingMode.TwoWay>的另一个示例属性是<xref:System.Windows.Controls.TextBox.Text%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="abe38-219">Another example property that binds <xref:System.Windows.Data.BindingMode.TwoWay> by default is <xref:System.Windows.Controls.TextBox.Text%2A?displayProperty=nameWithType>.</span></span>

- <span data-ttu-id="abe38-220">还可以通过设置<xref:System.Windows.FrameworkPropertyMetadataOptions.Inherits>标志在自定义依赖项属性中启用属性继承。</span><span class="sxs-lookup"><span data-stu-id="abe38-220">You can also enable property inheritance in a custom dependency property by setting the <xref:System.Windows.FrameworkPropertyMetadataOptions.Inherits> flag.</span></span> <span data-ttu-id="abe38-221">在父元素和子元素具有相同属性的情况中，属性继承非常有用，它可以使子元素将该特定属性值设置为与父元素设置的值相同。</span><span class="sxs-lookup"><span data-stu-id="abe38-221">Property inheritance is useful for a scenario where parent elements and child elements have a property in common, and it makes sense for the child elements to have that particular property value set to the same value as the parent set it.</span></span> <span data-ttu-id="abe38-222">可继承属性的示例为<xref:System.Windows.FrameworkElement.DataContext%2A>，用于绑定操作，以启用数据表示的重要主详细信息方案。</span><span class="sxs-lookup"><span data-stu-id="abe38-222">An example inheritable property is <xref:System.Windows.FrameworkElement.DataContext%2A>, which is used for binding operations to enable the important master-detail scenario for data presentation.</span></span> <span data-ttu-id="abe38-223">通过使<xref:System.Windows.FrameworkElement.DataContext%2A>可继承，任何子元素也继承该数据上下文。</span><span class="sxs-lookup"><span data-stu-id="abe38-223">By making <xref:System.Windows.FrameworkElement.DataContext%2A> inheritable, any child elements inherit that data context also.</span></span> <span data-ttu-id="abe38-224">因为使用了属性值继承，你可以在页面或应用程序根目录上指定数据上下文，而无需对所有可能子元素中的绑定重新指定上下文。</span><span class="sxs-lookup"><span data-stu-id="abe38-224">Because of property value inheritance, you can specify a data context at the page or application root, and do not need to respecify it for bindings in all possible child elements.</span></span> <span data-ttu-id="abe38-225"><xref:System.Windows.FrameworkElement.DataContext%2A>也是一个很好的例子，说明继承重写默认值，但它始终可以在本地设置在任何特定的子元素上;有关详细信息，请参阅[使用具有分层数据的主详细信息模式](../data/how-to-use-the-master-detail-pattern-with-hierarchical-data.md)。</span><span class="sxs-lookup"><span data-stu-id="abe38-225"><xref:System.Windows.FrameworkElement.DataContext%2A> is also a good example to illustrate that inheritance overrides the default value, but it can always be set locally on any particular child element; for details, see [Use the Master-Detail Pattern with Hierarchical Data](../data/how-to-use-the-master-detail-pattern-with-hierarchical-data.md).</span></span> <span data-ttu-id="abe38-226">属性值继承确实可能存在性能成本，因此应谨慎使用；有关详细信息，请参阅[属性值继承](property-value-inheritance.md)。</span><span class="sxs-lookup"><span data-stu-id="abe38-226">Property value inheritance does have a possible performance cost, and thus should be used sparingly; for details, see [Property Value Inheritance](property-value-inheritance.md).</span></span>

- <span data-ttu-id="abe38-227">设置标志<xref:System.Windows.FrameworkPropertyMetadataOptions.Journal>以指示是否应检测到依赖项属性或由导航日记服务使用。</span><span class="sxs-lookup"><span data-stu-id="abe38-227">Set the <xref:System.Windows.FrameworkPropertyMetadataOptions.Journal> flag to indicate if your dependency property should be detected or used by navigation journaling services.</span></span> <span data-ttu-id="abe38-228">属性就是一<xref:System.Windows.Controls.Primitives.Selector.SelectedIndex%2A>个示例;导航日记历史记录时，应保留选择控件中选择的任何项。</span><span class="sxs-lookup"><span data-stu-id="abe38-228">An example is the <xref:System.Windows.Controls.Primitives.Selector.SelectedIndex%2A> property; any item selected in a selection control should be persisted when the journaling history is navigated.</span></span>

<a name="RODP"></a>

## <a name="read-only-dependency-properties"></a><span data-ttu-id="abe38-229">只读依赖项属性</span><span class="sxs-lookup"><span data-stu-id="abe38-229">Read-Only Dependency Properties</span></span>

<span data-ttu-id="abe38-230">可以定义只读的依赖属性。</span><span class="sxs-lookup"><span data-stu-id="abe38-230">You can define a dependency property that is read-only.</span></span> <span data-ttu-id="abe38-231">但是，为何将属性定义为只读的情况略有不同，其过程与在属性系统中注册属性并公开标识符相同。</span><span class="sxs-lookup"><span data-stu-id="abe38-231">However, the scenarios for why you might define your property as read-only are somewhat different, as is the procedure for registering them with the property system and exposing the identifier.</span></span> <span data-ttu-id="abe38-232">有关详细信息，请参阅[只读依赖属性](read-only-dependency-properties.md)。</span><span class="sxs-lookup"><span data-stu-id="abe38-232">For more information, see [Read-Only Dependency Properties](read-only-dependency-properties.md).</span></span>

<a name="CTDP"></a>

## <a name="collection-type-dependency-properties"></a><span data-ttu-id="abe38-233">集合类型依赖项属性</span><span class="sxs-lookup"><span data-stu-id="abe38-233">Collection-Type Dependency Properties</span></span>

<span data-ttu-id="abe38-234">集合类型依赖属性要考虑一些其他实现问题。</span><span class="sxs-lookup"><span data-stu-id="abe38-234">Collection-type dependency properties have some additional implementation issues to consider.</span></span> <span data-ttu-id="abe38-235">有关详细信息，请参阅[集合类型依赖属性](collection-type-dependency-properties.md)。</span><span class="sxs-lookup"><span data-stu-id="abe38-235">For details, see [Collection-Type Dependency Properties](collection-type-dependency-properties.md).</span></span>

<a name="SecurityC"></a>

## <a name="dependency-property-security-considerations"></a><span data-ttu-id="abe38-236">依赖属性安全注意事项</span><span class="sxs-lookup"><span data-stu-id="abe38-236">Dependency Property Security Considerations</span></span>

<span data-ttu-id="abe38-237">依赖属性应声明为公共属性。</span><span class="sxs-lookup"><span data-stu-id="abe38-237">Dependency properties should be declared as public properties.</span></span> <span data-ttu-id="abe38-238">依赖属性标识符字段应声明为公共静态字段。</span><span class="sxs-lookup"><span data-stu-id="abe38-238">Dependency property identifier fields should be declared as public static fields.</span></span> <span data-ttu-id="abe38-239">即使您尝试声明其他访问级别（如受保护），也始终可以通过标识符与属性系统 API 一起访问依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="abe38-239">Even if you attempt to declare other access levels (such as protected), a dependency property can always be accessed through the identifier in combination with the property system APIs.</span></span> <span data-ttu-id="abe38-240">由于元数据报告或作为属性系统的一部分的值确定 API（如<xref:System.Windows.LocalValueEnumerator>），即使受保护的标识符字段也可能访问。</span><span class="sxs-lookup"><span data-stu-id="abe38-240">Even a protected identifier field is potentially accessible because of metadata reporting or value determination APIs that are part of the property system, such as <xref:System.Windows.LocalValueEnumerator>.</span></span> <span data-ttu-id="abe38-241">有关详细信息，请参阅[依赖属性的安全性](dependency-property-security.md)。</span><span class="sxs-lookup"><span data-stu-id="abe38-241">For more information, see [Dependency Property Security](dependency-property-security.md).</span></span>

<a name="DPCtor"></a>

## <a name="dependency-properties-and-class-constructors"></a><span data-ttu-id="abe38-242">依赖属性和类构造函数</span><span class="sxs-lookup"><span data-stu-id="abe38-242">Dependency Properties and Class Constructors</span></span>

<span data-ttu-id="abe38-243">托管代码编程（通常通过FxCop 等代码分析工具强制执行）的一般原则是：类构造函数不应调用虚方法。</span><span class="sxs-lookup"><span data-stu-id="abe38-243">There is a general principle in managed code programming (often enforced by code analysis tools such as FxCop) that class constructors should not call virtual methods.</span></span> <span data-ttu-id="abe38-244">这是因为构造函数可以作为派生的类构造函数的基本初始化来调用，并且可能会在所构造的对象实例不完全初始化状态下通过构造函数输入虚方法。</span><span class="sxs-lookup"><span data-stu-id="abe38-244">This is because constructors can be called as base initialization of a derived class constructor, and entering the virtual method through the constructor might occur at an incomplete initialization state of the object instance being constructed.</span></span> <span data-ttu-id="abe38-245">当您从已经派生的任何<xref:System.Windows.DependencyObject>类派生时，应注意属性系统本身在内部调用并公开虚拟方法。</span><span class="sxs-lookup"><span data-stu-id="abe38-245">When you derive from any class that already derives from <xref:System.Windows.DependencyObject>, you should be aware that the property system itself calls and exposes virtual methods internally.</span></span> <span data-ttu-id="abe38-246">这些虚方法属于 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 属性系统服务。</span><span class="sxs-lookup"><span data-stu-id="abe38-246">These virtual methods are part of the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system services.</span></span> <span data-ttu-id="abe38-247">替代方法会使派生类参与值确定。</span><span class="sxs-lookup"><span data-stu-id="abe38-247">Overriding the methods enables derived classes to participate in value determination.</span></span> <span data-ttu-id="abe38-248">为避免运行时初始化出现潜在问题，，不应该在类的构造函数中设置依赖属性值，除非遵循特定的构造函数模式进行操作。</span><span class="sxs-lookup"><span data-stu-id="abe38-248">To avoid potential issues with runtime initialization, you should not set dependency property values within constructors of classes, unless you follow a very specific constructor pattern.</span></span> <span data-ttu-id="abe38-249">有关详细信息，请参阅 [DependencyObject 的安全构造函数模式](safe-constructor-patterns-for-dependencyobjects.md)。</span><span class="sxs-lookup"><span data-stu-id="abe38-249">For details, see [Safe Constructor Patterns for DependencyObjects](safe-constructor-patterns-for-dependencyobjects.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="abe38-250">另请参阅</span><span class="sxs-lookup"><span data-stu-id="abe38-250">See also</span></span>

- [<span data-ttu-id="abe38-251">依赖项属性概述</span><span class="sxs-lookup"><span data-stu-id="abe38-251">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="abe38-252">依赖项属性元数据</span><span class="sxs-lookup"><span data-stu-id="abe38-252">Dependency Property Metadata</span></span>](dependency-property-metadata.md)
- [<span data-ttu-id="abe38-253">控件创作概述</span><span class="sxs-lookup"><span data-stu-id="abe38-253">Control Authoring Overview</span></span>](../controls/control-authoring-overview.md)
- [<span data-ttu-id="abe38-254">集合类型依赖项属性</span><span class="sxs-lookup"><span data-stu-id="abe38-254">Collection-Type Dependency Properties</span></span>](collection-type-dependency-properties.md)
- [<span data-ttu-id="abe38-255">依赖项属性的安全性</span><span class="sxs-lookup"><span data-stu-id="abe38-255">Dependency Property Security</span></span>](dependency-property-security.md)
- [<span data-ttu-id="abe38-256">XAML 加载和依赖项属性</span><span class="sxs-lookup"><span data-stu-id="abe38-256">XAML Loading and Dependency Properties</span></span>](xaml-loading-and-dependency-properties.md)
- [<span data-ttu-id="abe38-257">DependencyObject 的安全构造函数模式</span><span class="sxs-lookup"><span data-stu-id="abe38-257">Safe Constructor Patterns for DependencyObjects</span></span>](safe-constructor-patterns-for-dependencyobjects.md)
