---
title: 自定义依赖项属性
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- implementing [WPF], wrappers
- registering properties [WPF]
- properties [WPF], metadata
- metadata [WPF], for properties
- custom dependency properties [WPF]
- properties [WPF], registering
- wrappers [WPF], implementing
- dependency properties [WPF], custom
ms.assetid: e6bfcfac-b10d-4f58-9f77-a864c2a2938f
ms.openlocfilehash: 12843c74a7519d29e869be0342b18a1137f2dc5a
ms.sourcegitcommit: 0c48191d6d641ce88d7510e319cf38c0e35697d0
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/05/2019
ms.locfileid: "57372212"
---
# <a name="custom-dependency-properties"></a><span data-ttu-id="2e538-102">自定义依赖项属性</span><span class="sxs-lookup"><span data-stu-id="2e538-102">Custom Dependency Properties</span></span>

<span data-ttu-id="2e538-103">本主题介绍了 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 应用程序开发者和组件作者想要创建自定义依赖属性的原因，并介绍了一些可以提高属性的性能、可用性或通用性的实现步骤以及实现选项。</span><span class="sxs-lookup"><span data-stu-id="2e538-103">This topic describes the reasons that [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] application developers and component authors might want to create custom dependency property, and describes the implementation steps as well as some implementation options that can improve performance, usability, or versatility of the property.</span></span>

<a name="prerequisites"></a>
## <a name="prerequisites"></a><span data-ttu-id="2e538-104">系统必备</span><span class="sxs-lookup"><span data-stu-id="2e538-104">Prerequisites</span></span>

<span data-ttu-id="2e538-105">本主题假设你作为 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 类的现有依赖属性的使用者已经对依赖属性有所了解，并且已经阅读了[依赖属性概述](dependency-properties-overview.md)主题。</span><span class="sxs-lookup"><span data-stu-id="2e538-105">This topic assumes that you understand dependency properties from the perspective of a consumer of existing dependency properties on [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes, and have read the [Dependency Properties Overview](dependency-properties-overview.md) topic.</span></span> <span data-ttu-id="2e538-106">若要理解本主题中的示例，还应当了解 [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] 并知道如何编写 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 应用程序。</span><span class="sxs-lookup"><span data-stu-id="2e538-106">In order to follow the examples in this topic, you should also understand [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] and know how to write [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications.</span></span>

<a name="whatis"></a>
## <a name="what-is-a-dependency-property"></a><span data-ttu-id="2e538-107">什么是依赖属性？</span><span class="sxs-lookup"><span data-stu-id="2e538-107">What Is a Dependency Property?</span></span>

<span data-ttu-id="2e538-108">可以通过启用原本是[!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] 属性的属性来支持样式设置、数据绑定、继承、动画和默认值，方法是将该属性作为依赖属性进行实现。</span><span class="sxs-lookup"><span data-stu-id="2e538-108">You can enable what would otherwise be a [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] property to support styling, data binding, inheritance, animations, and default values by implementing it as a dependency property.</span></span> <span data-ttu-id="2e538-109">依赖项属性是使用注册的属性[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]通过调用属性系统<xref:System.Windows.DependencyProperty.Register%2A>方法 (或<xref:System.Windows.DependencyProperty.RegisterReadOnly%2A>)，并由支持<xref:System.Windows.DependencyProperty>标识符字段。</span><span class="sxs-lookup"><span data-stu-id="2e538-109">Dependency properties are properties that are registered with the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system by calling the <xref:System.Windows.DependencyProperty.Register%2A> method (or <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A>), and that are backed by a <xref:System.Windows.DependencyProperty> identifier field.</span></span> <span data-ttu-id="2e538-110">可以仅通过使用依赖关系属性<xref:System.Windows.DependencyObject>类型，但<xref:System.Windows.DependencyObject>中很高[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]类层次结构中，因此大部分可用的类中[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]可以支持依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="2e538-110">Dependency properties can be used only by <xref:System.Windows.DependencyObject> types, but <xref:System.Windows.DependencyObject> is quite high in the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] class hierarchy, so the majority of classes available in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] can support dependency properties.</span></span> <span data-ttu-id="2e538-111">若要详细了解依赖属性和此 [!INCLUDE[TLA2#tla_sdk](../../../../includes/tla2sharptla-sdk-md.md)] 中对依赖属性进行描述所使用的术语和约定，请参阅[依赖属性概述](dependency-properties-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="2e538-111">For more information about dependency properties and some of the terminology and conventions used for describing them in this [!INCLUDE[TLA2#tla_sdk](../../../../includes/tla2sharptla-sdk-md.md)], see [Dependency Properties Overview](dependency-properties-overview.md).</span></span>

<a name="example_dp"></a>
## <a name="examples-of-dependency-properties"></a><span data-ttu-id="2e538-112">依赖属性示例</span><span class="sxs-lookup"><span data-stu-id="2e538-112">Examples of Dependency Properties</span></span>

<span data-ttu-id="2e538-113">实现的依赖项属性的示例[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]类包括<xref:System.Windows.Controls.Control.Background%2A>属性，<xref:System.Windows.FrameworkElement.Width%2A>属性，并<xref:System.Windows.Controls.TextBox.Text%2A>属性，此外还有许多其他属性。</span><span class="sxs-lookup"><span data-stu-id="2e538-113">Examples of dependency properties that are implemented on [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes include the <xref:System.Windows.Controls.Control.Background%2A> property, the <xref:System.Windows.FrameworkElement.Width%2A> property, and the <xref:System.Windows.Controls.TextBox.Text%2A> property, among many others.</span></span> <span data-ttu-id="2e538-114">类公开的每个依赖属性具有相应类型的公共静态字段<xref:System.Windows.DependencyProperty>相同的类上公开。</span><span class="sxs-lookup"><span data-stu-id="2e538-114">Each dependency property exposed by a class has a corresponding public static field of type <xref:System.Windows.DependencyProperty> exposed on that same class.</span></span> <span data-ttu-id="2e538-115">这是依赖属性的标识符。</span><span class="sxs-lookup"><span data-stu-id="2e538-115">This is the identifier for the dependency property.</span></span> <span data-ttu-id="2e538-116">此标识符的命名约定为：依赖属性名称后面加上字符串 `Property`。</span><span class="sxs-lookup"><span data-stu-id="2e538-116">The identifier is named using a convention: the name of the dependency property with the string `Property` appended to it.</span></span> <span data-ttu-id="2e538-117">例如，在相应<xref:System.Windows.DependencyProperty>的标识符字段<xref:System.Windows.Controls.Control.Background%2A>属性是<xref:System.Windows.Controls.Control.BackgroundProperty>。</span><span class="sxs-lookup"><span data-stu-id="2e538-117">For example, the corresponding <xref:System.Windows.DependencyProperty> identifier field for the <xref:System.Windows.Controls.Control.Background%2A> property is <xref:System.Windows.Controls.Control.BackgroundProperty>.</span></span> <span data-ttu-id="2e538-118">标识符存储有关依赖项属性的信息，因为它已注册，并在然后涉及依赖项属性，例如，调用其他操作的更高版本使用标识符<xref:System.Windows.DependencyObject.SetValue%2A>。</span><span class="sxs-lookup"><span data-stu-id="2e538-118">The identifier stores the information about the dependency property as it was registered, and the identifier is then used later for other operations involving the dependency property, such as calling <xref:System.Windows.DependencyObject.SetValue%2A>.</span></span>

<span data-ttu-id="2e538-119">如[依赖属性概述](dependency-properties-overview.md)中所述，因为“包装器”实现，[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中的所有依赖属性（大多数附加属性除外）也是 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 属性。</span><span class="sxs-lookup"><span data-stu-id="2e538-119">As mentioned in the [Dependency Properties Overview](dependency-properties-overview.md), all dependency properties in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] (except most attached properties) are also [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] properties because of the "wrapper" implementation.</span></span> <span data-ttu-id="2e538-120">因此，在代码中通过调用定义包装器的 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 访问器（调用方法与使用其他 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 属性相同）可以获取或设置依赖属性。</span><span class="sxs-lookup"><span data-stu-id="2e538-120">Therefore, from code, you can get or set dependency properties by calling [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] accessors that define the wrappers in the same manner that you would use other [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] properties.</span></span> <span data-ttu-id="2e538-121">建立的依赖属性的使用者，您通常不会使用<xref:System.Windows.DependencyObject>方法<xref:System.Windows.DependencyObject.GetValue%2A>和<xref:System.Windows.DependencyObject.SetValue%2A>，这是基础属性系统的连接点。</span><span class="sxs-lookup"><span data-stu-id="2e538-121">As a consumer of established dependency properties, you do not typically use the <xref:System.Windows.DependencyObject> methods <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A>, which are the connection point to the underlying property system.</span></span> <span data-ttu-id="2e538-122">而是，现有的实施[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]属性将已经调用了<xref:System.Windows.DependencyObject.GetValue%2A>和<xref:System.Windows.DependencyObject.SetValue%2A>内`get`和`set`适当地使用标识符字段的属性的包装器实现.</span><span class="sxs-lookup"><span data-stu-id="2e538-122">Rather, the existing implementation of the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] properties will have already called <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> within the `get` and `set` wrapper implementations of the property, using the identifier field appropriately.</span></span> <span data-ttu-id="2e538-123">若要自己实现自定义依赖属性，则需要使用类似的方法定义包装器。</span><span class="sxs-lookup"><span data-stu-id="2e538-123">If you are implementing a custom dependency property yourself, then you will be defining the wrapper in a similar way.</span></span>

<a name="backing_with_dp"></a>
## <a name="when-should-you-implement-a-dependency-property"></a><span data-ttu-id="2e538-124">应该何时实现依赖属性？</span><span class="sxs-lookup"><span data-stu-id="2e538-124">When Should You Implement a Dependency Property?</span></span>

<span data-ttu-id="2e538-125">上一个类，实现属性，只要类派生自<xref:System.Windows.DependencyObject>，可以选择支持与属性<xref:System.Windows.DependencyProperty>标识符，因此若要使其依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="2e538-125">When you implement a property on a class, so long as your class derives from <xref:System.Windows.DependencyObject>, you have the option to back your property with a <xref:System.Windows.DependencyProperty> identifier and thus to make it a dependency property.</span></span> <span data-ttu-id="2e538-126">不必总是将属性实现为依赖属性，这不一定合适，具体取决于方案需要。</span><span class="sxs-lookup"><span data-stu-id="2e538-126">Having your property be a dependency property is not always necessary or appropriate, and will depend on your scenario needs.</span></span> <span data-ttu-id="2e538-127">有时，使用私有字段支持属性的通常方法已足够满足需求。</span><span class="sxs-lookup"><span data-stu-id="2e538-127">Sometimes, the typical technique of backing your property with a private field is adequate.</span></span> <span data-ttu-id="2e538-128">但是，如果要使属性支持以下一个或多个 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 功能，则应该将属性实现为依赖属性：</span><span class="sxs-lookup"><span data-stu-id="2e538-128">However, you should implement your property as a dependency property whenever you want your property to support one or more of the following [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] capabilities:</span></span>

-   <span data-ttu-id="2e538-129">需要可以在样式中设置属性。</span><span class="sxs-lookup"><span data-stu-id="2e538-129">You want your property to be settable in a style.</span></span> <span data-ttu-id="2e538-130">有关详细信息，请参阅[样式设置和模板化](../controls/styling-and-templating.md)。</span><span class="sxs-lookup"><span data-stu-id="2e538-130">For more information, see [Styling and Templating](../controls/styling-and-templating.md).</span></span>

-   <span data-ttu-id="2e538-131">需要属性支持数据绑定。</span><span class="sxs-lookup"><span data-stu-id="2e538-131">You want your property to support data binding.</span></span> <span data-ttu-id="2e538-132">有关数据绑定依赖属性的详细信息，请参阅[绑定两个控件的属性](../data/how-to-bind-the-properties-of-two-controls.md)。</span><span class="sxs-lookup"><span data-stu-id="2e538-132">For more information about data binding dependency properties, see [Bind the Properties of Two Controls](../data/how-to-bind-the-properties-of-two-controls.md).</span></span>

-   <span data-ttu-id="2e538-133">需要可以使用动态资源引用设置属性。</span><span class="sxs-lookup"><span data-stu-id="2e538-133">You want your property to be settable with a dynamic resource reference.</span></span> <span data-ttu-id="2e538-134">有关详细信息，请参阅 [XAML 资源](xaml-resources.md)。</span><span class="sxs-lookup"><span data-stu-id="2e538-134">For more information, see [XAML Resources](xaml-resources.md).</span></span>

-   <span data-ttu-id="2e538-135">需要从元素树中的父元素自动继承属性值。</span><span class="sxs-lookup"><span data-stu-id="2e538-135">You want to inherit a property value automatically from a parent element in the element tree.</span></span> <span data-ttu-id="2e538-136">在这种情况下，注册<xref:System.Windows.DependencyProperty.RegisterAttached%2A>方法，即使您还创建了属性包装器的[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]访问。</span><span class="sxs-lookup"><span data-stu-id="2e538-136">In this case, register with the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method, even if you also create a property wrapper for [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] access.</span></span> <span data-ttu-id="2e538-137">有关详细信息，请参阅[属性值继承](property-value-inheritance.md)。</span><span class="sxs-lookup"><span data-stu-id="2e538-137">For more information, see [Property Value Inheritance](property-value-inheritance.md).</span></span>

-   <span data-ttu-id="2e538-138">需要属性可以进行动画处理。</span><span class="sxs-lookup"><span data-stu-id="2e538-138">You want your property to be animatable.</span></span> <span data-ttu-id="2e538-139">有关详细信息，请参阅 [动画概述](../graphics-multimedia/animation-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="2e538-139">For more information, see [Animation Overview](../graphics-multimedia/animation-overview.md).</span></span>

-   <span data-ttu-id="2e538-140">需要属性系统在先前的值因属性系统、环境或用户执行的操作而发生更改，或者因读取和使用样式而发生更改时进行报告。</span><span class="sxs-lookup"><span data-stu-id="2e538-140">You want the property system to report when the previous value of the property has been changed by actions taken by the property system, the environment, or the user, or by reading and using styles.</span></span> <span data-ttu-id="2e538-141">通过使用属性元素据，属性可以指定回调方法，每次属性系统确定属性值已明确改动时将调用此回调方法。</span><span class="sxs-lookup"><span data-stu-id="2e538-141">By using property metadata, your property can specify a callback method that will be invoked each time the property system determines that your property value was definitively changed.</span></span> <span data-ttu-id="2e538-142">与此相关的一个概念是属性值强制转换。</span><span class="sxs-lookup"><span data-stu-id="2e538-142">A related concept is property value coercion.</span></span> <span data-ttu-id="2e538-143">有关详细信息，请参阅[依赖属性回调和验证](dependency-property-callbacks-and-validation.md)。</span><span class="sxs-lookup"><span data-stu-id="2e538-143">For more information, see [Dependency Property Callbacks and Validation](dependency-property-callbacks-and-validation.md).</span></span>

-   <span data-ttu-id="2e538-144">需要使用同时也被 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 进程使用的已建立的元数据约定，例如报告更改属性值是否应需要布局系统重新安排元素的可视内容。</span><span class="sxs-lookup"><span data-stu-id="2e538-144">You want to use established metadata conventions that are also used by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] processes, such as reporting whether changing a property value should require the layout system to recompose the visuals for an element.</span></span> <span data-ttu-id="2e538-145">或者需要能够使用元素据替代，以便派生类可以更改基于元数据的特性，例如默认值。</span><span class="sxs-lookup"><span data-stu-id="2e538-145">Or you want to be able to use metadata overrides so that derived classes can change metadata-based characteristics such as the default value.</span></span>

-   <span data-ttu-id="2e538-146">你想接收 Visual Studio WPF 设计器的自定义控件的属性支持，如**属性**窗口编辑。</span><span class="sxs-lookup"><span data-stu-id="2e538-146">You want properties of a custom control to receive Visual Studio WPF Designer support, such as **Properties** window editing.</span></span> <span data-ttu-id="2e538-147">有关详细信息，请参阅[控件创作概述](../controls/control-authoring-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="2e538-147">For more information, see [Control Authoring Overview](../controls/control-authoring-overview.md).</span></span>

<span data-ttu-id="2e538-148">检查这些方案时，还应考虑是否可以通过替代现有依赖属性的元素据而不是通过实现一个全新的属性来实现方案。</span><span class="sxs-lookup"><span data-stu-id="2e538-148">When you examine these scenarios, you should also consider whether you can achieve your scenario by overriding the metadata of an existing dependency property, rather than implementing a completely new property.</span></span> <span data-ttu-id="2e538-149">元素据替代是否可行取决于方案以及方案与现有的 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 依赖属性和类中的实现的相似度。</span><span class="sxs-lookup"><span data-stu-id="2e538-149">Whether a metadata override is practical depends on your scenario and how closely that scenario resembles the implementation in existing [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] dependency properties and classes.</span></span> <span data-ttu-id="2e538-150">有关替代现有属性上的元素据的详细信息，请参阅[依赖属性元素据](dependency-property-metadata.md)。</span><span class="sxs-lookup"><span data-stu-id="2e538-150">For more information about overriding metadata on existing properties, see [Dependency Property Metadata](dependency-property-metadata.md).</span></span>

<a name="checklist"></a>
## <a name="checklist-for-defining-a-dependency-property"></a><span data-ttu-id="2e538-151">定义依赖属性的检查清单</span><span class="sxs-lookup"><span data-stu-id="2e538-151">Checklist for Defining a Dependency Property</span></span>

<span data-ttu-id="2e538-152">定义依赖属性包含 4 个不同的概念。</span><span class="sxs-lookup"><span data-stu-id="2e538-152">Defining a dependency property consists of four distinct concepts.</span></span> <span data-ttu-id="2e538-153">这些概念并不一定是严格的过程步骤，因为其中一些概念在实现中会被合并为一行代码：</span><span class="sxs-lookup"><span data-stu-id="2e538-153">These concepts are not necessarily strict procedural steps, because some of these end up being combined as single lines of code in the implementation:</span></span>

-   <span data-ttu-id="2e538-154">（可选）创建依赖属性的属性元素据。</span><span class="sxs-lookup"><span data-stu-id="2e538-154">(Optional) Create property metadata for the dependency property.</span></span>

-   <span data-ttu-id="2e538-155">在属性系统中注册属性名称，并指定所有者类型和属性值类型。</span><span class="sxs-lookup"><span data-stu-id="2e538-155">Register the property name with the property system, specifying an owner type and the type of the property value.</span></span> <span data-ttu-id="2e538-156">此外，还应指定属性元素据（如果用到）。</span><span class="sxs-lookup"><span data-stu-id="2e538-156">Also specify the property metadata, if used.</span></span>

-   <span data-ttu-id="2e538-157">定义<xref:System.Windows.DependencyProperty>标识符作为`public` `static` `readonly`字段上的所有者类型。</span><span class="sxs-lookup"><span data-stu-id="2e538-157">Define a <xref:System.Windows.DependencyProperty> identifier as a `public` `static` `readonly` field on the owner type.</span></span>

-   <span data-ttu-id="2e538-158">定义一个 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]“包装器”属性，并且其名称与依赖属性名称相匹配。</span><span class="sxs-lookup"><span data-stu-id="2e538-158">Define a [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] "wrapper" property whose name matches the name of the dependency property.</span></span> <span data-ttu-id="2e538-159">实现 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]“包装器”属性的 `get` 和 `set` 访问器，以连接支持此属性的依赖属性。</span><span class="sxs-lookup"><span data-stu-id="2e538-159">Implement the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] "wrapper" property's `get` and `set` accessors to connect with the dependency property that backs it.</span></span>

<a name="registering"></a>
### <a name="registering-the-property-with-the-property-system"></a><span data-ttu-id="2e538-160">在属性系统中注册属性</span><span class="sxs-lookup"><span data-stu-id="2e538-160">Registering the Property with the Property System</span></span>

<span data-ttu-id="2e538-161">为使属性成为依赖属性，必须在属性系统维护的表中注册该属性，并为属性指定一个唯一标识符。此唯一标识符会用作后续属性系统操作的限定符。</span><span class="sxs-lookup"><span data-stu-id="2e538-161">In order for your property to be a dependency property, you must register that property into a table maintained by the property system, and give it a unique identifier that is used as the qualifier for later property system operations.</span></span> <span data-ttu-id="2e538-162">这些操作可能是内部操作，也可能使用你自己的代码调用属性系统 [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="2e538-162">These operations might be internal operations, or your own code calling property system [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)].</span></span> <span data-ttu-id="2e538-163">若要注册该属性，请调用<xref:System.Windows.DependencyProperty.Register%2A>类 （在类中，但任何成员定义外） 的正文中的方法。</span><span class="sxs-lookup"><span data-stu-id="2e538-163">To register the property, you call the <xref:System.Windows.DependencyProperty.Register%2A> method within the body of your class (inside the class, but outside of any member definitions).</span></span> <span data-ttu-id="2e538-164">此外提供标识符字段<xref:System.Windows.DependencyProperty.Register%2A>方法调用，作为返回值。</span><span class="sxs-lookup"><span data-stu-id="2e538-164">The identifier field is also provided by the <xref:System.Windows.DependencyProperty.Register%2A> method call, as the return value.</span></span> <span data-ttu-id="2e538-165">原因，<xref:System.Windows.DependencyProperty.Register%2A>完成调用之外其他成员定义是因为使用此返回值分配并创建`public` `static` `readonly`类型的字段<xref:System.Windows.DependencyProperty>作为您的类的一部分。</span><span class="sxs-lookup"><span data-stu-id="2e538-165">The reason that the <xref:System.Windows.DependencyProperty.Register%2A> call is done outside of other member definitions is because you use this return value to assign and create a `public` `static` `readonly` field of type <xref:System.Windows.DependencyProperty> as part of your class.</span></span> <span data-ttu-id="2e538-166">此字段会作为依赖属性的标识符。</span><span class="sxs-lookup"><span data-stu-id="2e538-166">This field becomes the identifier for your dependency property.</span></span>

[!code-csharp[WPFAquariumSln#RegisterAG](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerag)]
[!code-vb[WPFAquariumSln#RegisterAG](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerag)]

<a name="nameconventions"></a>
### <a name="dependency-property-name-conventions"></a><span data-ttu-id="2e538-167">依赖属性命名约定</span><span class="sxs-lookup"><span data-stu-id="2e538-167">Dependency Property Name Conventions</span></span>

<span data-ttu-id="2e538-168">必需完全遵循已有的依赖属性命名约定，例外情况除外。</span><span class="sxs-lookup"><span data-stu-id="2e538-168">There are established naming conventions regarding dependency properties that you must follow in all but exceptional circumstances.</span></span>

<span data-ttu-id="2e538-169">依赖项属性本身有一个基本的名称，"AquariumGraphic 此示例中，它被指定为第一个参数的<xref:System.Windows.DependencyProperty.Register%2A>。</span><span class="sxs-lookup"><span data-stu-id="2e538-169">The dependency property itself will have a basic name, "AquariumGraphic" as in this example, which is given as the first parameter of <xref:System.Windows.DependencyProperty.Register%2A>.</span></span> <span data-ttu-id="2e538-170">此名称在每个注册类型内必须唯一。</span><span class="sxs-lookup"><span data-stu-id="2e538-170">That name must be unique within each registering type.</span></span> <span data-ttu-id="2e538-171">通过基类型继承的依赖属性会被视为注册类型的已有部分；无法再次注册已继承属性的名称。</span><span class="sxs-lookup"><span data-stu-id="2e538-171">Dependency properties inherited through base types are considered to be already part of the registering type; names of inherited properties cannot be registered again.</span></span> <span data-ttu-id="2e538-172">但是，即使不继承依赖属性，也有方法可将类添加为依赖属性的所有者；有关详细信息，请参阅[依赖属性元素据](dependency-property-metadata.md)。</span><span class="sxs-lookup"><span data-stu-id="2e538-172">However, there is a technique for adding a class as owner of a dependency property even when that dependency property is not inherited; for details, see [Dependency Property Metadata](dependency-property-metadata.md).</span></span>

<span data-ttu-id="2e538-173">创建标识符字段时，按注册时的属性名称命名此字段，再加上后缀 `Property`。</span><span class="sxs-lookup"><span data-stu-id="2e538-173">When you create the identifier field, name this field by the name of the property as you registered it, plus the suffix `Property`.</span></span> <span data-ttu-id="2e538-174">该字段是依赖属性的标识符，它将在稍后用作的输入<xref:System.Windows.DependencyObject.SetValue%2A>和<xref:System.Windows.DependencyObject.GetValue%2A>允许您将在包装器，通过任何其他代码访问权限由你自己的代码，该属性由外部代码中你的调用由属性系统，以及可能通过[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]处理器。</span><span class="sxs-lookup"><span data-stu-id="2e538-174">This field is your identifier for the dependency property, and it will be used later as an input for the <xref:System.Windows.DependencyObject.SetValue%2A> and <xref:System.Windows.DependencyObject.GetValue%2A> calls you will make in the wrappers, by any other code access to the property by your own code, by any external code access you allow, by the property system, and potentially by [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] processors.</span></span>

> [!NOTE]
> <span data-ttu-id="2e538-175">在类的主体中定义依赖属性是典型的实现，但也可以在类静态构造函数中定义依赖属性。</span><span class="sxs-lookup"><span data-stu-id="2e538-175">Defining the dependency property in the class body is the typical implementation, but it is also possible to define a dependency property in the class static constructor.</span></span> <span data-ttu-id="2e538-176">需要多行代码来初始化依赖属性时，此方法会很有用。</span><span class="sxs-lookup"><span data-stu-id="2e538-176">This approach might make sense if you need more than one line of code to initialize the dependency property.</span></span>

<a name="wrapper1"></a>
### <a name="implementing-the-wrapper"></a><span data-ttu-id="2e538-177">实现“包装器”</span><span class="sxs-lookup"><span data-stu-id="2e538-177">Implementing the "Wrapper"</span></span>

<span data-ttu-id="2e538-178">应调用包装器实现<xref:System.Windows.DependencyObject.GetValue%2A>中`get`实现中，并<xref:System.Windows.DependencyObject.SetValue%2A>中`set`（原始注册调用和字段，此处也显示为清楚起见） 的实现。</span><span class="sxs-lookup"><span data-stu-id="2e538-178">Your wrapper implementation should call <xref:System.Windows.DependencyObject.GetValue%2A> in the `get` implementation, and <xref:System.Windows.DependencyObject.SetValue%2A> in the `set` implementation (the original registration call and field are shown here too for clarity).</span></span>

<span data-ttu-id="2e538-179">在所有例外情况除外，应仅执行包装器实现<xref:System.Windows.DependencyObject.GetValue%2A>和<xref:System.Windows.DependencyObject.SetValue%2A>操作，分别。</span><span class="sxs-lookup"><span data-stu-id="2e538-179">In all but exceptional circumstances, your wrapper implementations should perform only the <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> actions, respectively.</span></span> <span data-ttu-id="2e538-180">其原因请参阅 [XAML 加载和依赖属性](xaml-loading-and-dependency-properties.md)主题。</span><span class="sxs-lookup"><span data-stu-id="2e538-180">The reason for this is discussed in the topic [XAML Loading and Dependency Properties](xaml-loading-and-dependency-properties.md).</span></span>

<span data-ttu-id="2e538-181">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 类上提供的所有现有公共依赖属性都使用这一简单的包装器实现模型；大多数情况下，依赖属性工作原理的复杂性本质上在于它是属性系统的行为，还是通过其他概念（例如强制转换或通过属性元数据进行的属性更改回调）实现的行为。</span><span class="sxs-lookup"><span data-stu-id="2e538-181">All existing public dependency properties that are provided on the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes use this simple wrapper implementation model; most of the complexity of how dependency properties work is either inherently a behavior of the property system, or is implemented through other concepts such as coercion or property change callbacks through property metadata.</span></span>

[!code-csharp[WPFAquariumSln#AGWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#agwithwrapper)]
[!code-vb[WPFAquariumSln#AGWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#agwithwrapper)]

<span data-ttu-id="2e538-182">同样，按照约定，包装器属性的名称必须是选择并指定为第一个参数的名称相同<xref:System.Windows.DependencyProperty.Register%2A>注册属性的调用。</span><span class="sxs-lookup"><span data-stu-id="2e538-182">Again, by convention, the name of the wrapper property must be the same as the name chosen and given as first parameter of the <xref:System.Windows.DependencyProperty.Register%2A> call that registered the property.</span></span> <span data-ttu-id="2e538-183">如果属性不遵从此约定，尽管不一定会禁用所有可能的用法，但你会遇到几个比较突出的问题：</span><span class="sxs-lookup"><span data-stu-id="2e538-183">If your property does not follow the convention, this does not necessarily disable all possible uses, but you will encounter several notable issues:</span></span>

-   <span data-ttu-id="2e538-184">样式和模板的某些方面不起作用。</span><span class="sxs-lookup"><span data-stu-id="2e538-184">Certain aspects of styles and templates will not work.</span></span>

-   <span data-ttu-id="2e538-185">大多数工具和设计器必须依赖命名约定，才能正确序列化 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 或在每个属性级别提供设计器环境帮助。</span><span class="sxs-lookup"><span data-stu-id="2e538-185">Most tools and designers must rely on the naming conventions to properly serialize [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], or to provide designer environment assistance at a per-property level.</span></span>

-   <span data-ttu-id="2e538-186">处理特性值时，[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 加载程序的会完全跳过包装器，并依赖于命名约定。</span><span class="sxs-lookup"><span data-stu-id="2e538-186">The current implementation of the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] loader bypasses the wrappers entirely, and relies on the naming convention when processing attribute values.</span></span> <span data-ttu-id="2e538-187">有关详细信息，请参阅 [XAML 加载和依赖属性](xaml-loading-and-dependency-properties.md)。</span><span class="sxs-lookup"><span data-stu-id="2e538-187">For more information, see [XAML Loading and Dependency Properties](xaml-loading-and-dependency-properties.md).</span></span>

<a name="metadata"></a>
### <a name="property-metadata-for-a-new-dependency-property"></a><span data-ttu-id="2e538-188">新依赖属性的属性元数据</span><span class="sxs-lookup"><span data-stu-id="2e538-188">Property Metadata for a New Dependency Property</span></span>

<span data-ttu-id="2e538-189">注册依赖属性时，通过属性系统进行注册会创建一个存储属性特征的元素据对象。</span><span class="sxs-lookup"><span data-stu-id="2e538-189">When you register a dependency property, the registration through the property system creates a metadata object that stores property characteristics.</span></span> <span data-ttu-id="2e538-190">其中许多特性具有默认值，如果该属性是否已注册的简单签名都将设置<xref:System.Windows.DependencyProperty.Register%2A>。</span><span class="sxs-lookup"><span data-stu-id="2e538-190">Many of these characteristics have defaults that are set if the property is registered with the simple signatures of <xref:System.Windows.DependencyProperty.Register%2A>.</span></span> <span data-ttu-id="2e538-191">其他签名<xref:System.Windows.DependencyProperty.Register%2A>，可以指定你想为您注册该属性的元数据。</span><span class="sxs-lookup"><span data-stu-id="2e538-191">Other signatures of <xref:System.Windows.DependencyProperty.Register%2A> allow you to specify the metadata that you want as you register the property.</span></span> <span data-ttu-id="2e538-192">为依赖属性使用的最常见元数据是为其使用默认值。该默认值适用于使用此属性的新实例。</span><span class="sxs-lookup"><span data-stu-id="2e538-192">The most common metadata given for dependency properties is to give them a default value that is applied on new instances that use the property.</span></span>

<span data-ttu-id="2e538-193">如果要创建存在的依赖关系属性在派生类的<xref:System.Windows.FrameworkElement>，可以使用更专业的元数据类<xref:System.Windows.FrameworkPropertyMetadata>而不是基<xref:System.Windows.PropertyMetadata>类。</span><span class="sxs-lookup"><span data-stu-id="2e538-193">If you are creating a dependency property that exists on a derived class of <xref:System.Windows.FrameworkElement>, you can use the more specialized metadata class <xref:System.Windows.FrameworkPropertyMetadata> rather than the base <xref:System.Windows.PropertyMetadata> class.</span></span> <span data-ttu-id="2e538-194">构造函数<xref:System.Windows.FrameworkPropertyMetadata>类具有多个签名可在其中指定各种元数据特性结合使用。</span><span class="sxs-lookup"><span data-stu-id="2e538-194">The constructor for the <xref:System.Windows.FrameworkPropertyMetadata> class has several signatures where you can specify various metadata characteristics in combination.</span></span> <span data-ttu-id="2e538-195">如果你想要指定的默认值，使用采用单个参数的类型的签名<xref:System.Object>。</span><span class="sxs-lookup"><span data-stu-id="2e538-195">If you want to specify the default value only, use the signature that takes a single parameter of type <xref:System.Object>.</span></span> <span data-ttu-id="2e538-196">将该对象参数作为属性的特定于类型的默认值 (提供的默认值必须是作为提供类型`propertyType`中的参数<xref:System.Windows.DependencyProperty.Register%2A>调用)。</span><span class="sxs-lookup"><span data-stu-id="2e538-196">Pass that object parameter as a type-specific default value for your property (the default value provided must be the type you provided as the `propertyType` parameter in the <xref:System.Windows.DependencyProperty.Register%2A> call).</span></span>

<span data-ttu-id="2e538-197">有关<xref:System.Windows.FrameworkPropertyMetadata>，您还可以指定该属性的元数据选项标志。</span><span class="sxs-lookup"><span data-stu-id="2e538-197">For <xref:System.Windows.FrameworkPropertyMetadata>, you can also specify metadata option flags for your property.</span></span> <span data-ttu-id="2e538-198">注册后这些标记会转换为属性元素据上的不同属性，并用于将某些条件传送给布局引擎等其他进程。</span><span class="sxs-lookup"><span data-stu-id="2e538-198">These flags are converted into discrete properties on the property metadata after registration and are used to communicate certain conditionals to other processes such as the layout engine.</span></span>

#### <a name="setting-appropriate-metadata-flags"></a><span data-ttu-id="2e538-199">设置合适的元数据标记</span><span class="sxs-lookup"><span data-stu-id="2e538-199">Setting Appropriate Metadata Flags</span></span>

-   <span data-ttu-id="2e538-200">如果属性 （或值的更改） 将影响[!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)]，并特别是影响布局系统的大小或呈现的页上，将元素的方式将设置一个或多个下列标志： <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure>， <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsArrange>， <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsRender>。</span><span class="sxs-lookup"><span data-stu-id="2e538-200">If your property (or changes in its value) affects the [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)], and in particular affects how the layout system should size or render your element in a page, set one or more of the following flags: <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure>, <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsArrange>, <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsRender>.</span></span>

    -   <span data-ttu-id="2e538-201"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure> 指示对此属性的更改需要更改[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]呈现其中包含的对象可能需要增加或减少空间父级范围内的。</span><span class="sxs-lookup"><span data-stu-id="2e538-201"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure> indicates that a change to this property requires a change to [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] rendering where the containing object might require more or less space within the parent.</span></span> <span data-ttu-id="2e538-202">例如，“宽度”属性应该设置此标记。</span><span class="sxs-lookup"><span data-stu-id="2e538-202">For example, a "Width" property should have this flag set.</span></span>

    -   <span data-ttu-id="2e538-203"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsArrange> 指示对此属性的更改需要更改[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]呈现，通常不需要更改在专用空间中，但不指明该空间内的位置已更改。</span><span class="sxs-lookup"><span data-stu-id="2e538-203"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsArrange> indicates that a change to this property requires a change to [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] rendering that typically does not require a change in the dedicated space, but does indicate that the positioning within the space has changed.</span></span> <span data-ttu-id="2e538-204">例如，“对齐”属性应该设置此标记。</span><span class="sxs-lookup"><span data-stu-id="2e538-204">For example, an "Alignment" property should have this flag set.</span></span>

    -   <span data-ttu-id="2e538-205"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsRender> 指示发生的一些其他更改不会影响布局和度量值，但需要其他的呈现。</span><span class="sxs-lookup"><span data-stu-id="2e538-205"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsRender> indicates that some other change has occurred that will not affect layout and measure, but does require another render.</span></span> <span data-ttu-id="2e538-206">更改现有元素的颜色的属性便是一个示例，例如“背景”。</span><span class="sxs-lookup"><span data-stu-id="2e538-206">An example would be a property that changes a color of an existing element, such as "Background".</span></span>

    -   <span data-ttu-id="2e538-207">对属性系统或布局回调进行自己的替代实现时，这些标记通常用作元数据中的协议。</span><span class="sxs-lookup"><span data-stu-id="2e538-207">These flags are often used as a protocol in metadata for your own override implementations of property system or layout callbacks.</span></span> <span data-ttu-id="2e538-208">例如，您可能有<xref:System.Windows.DependencyObject.OnPropertyChanged%2A>将调用的回调<xref:System.Windows.UIElement.InvalidateArrange%2A>如果实例的任何属性报告值发生了更改，并具有<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>作为`true`其元数据中。</span><span class="sxs-lookup"><span data-stu-id="2e538-208">For instance, you might have an <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> callback that will call <xref:System.Windows.UIElement.InvalidateArrange%2A> if any property of the instance reports a value change and has <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> as `true` in its metadata.</span></span>

-   <span data-ttu-id="2e538-209">超出上述所需大小时，某些属性可能会影响所含父元素的呈现特征。</span><span class="sxs-lookup"><span data-stu-id="2e538-209">Some properties may affect the rendering characteristics of the containing parent element, in ways above and beyond the changes in required size mentioned above.</span></span> <span data-ttu-id="2e538-210">例如，<xref:System.Windows.Documents.Paragraph.MinOrphanLines%2A>对该属性的更改可以在其中更改包含段落的流文档的整个呈现流文档模型中使用的属性。</span><span class="sxs-lookup"><span data-stu-id="2e538-210">An example is the <xref:System.Windows.Documents.Paragraph.MinOrphanLines%2A> property used in the flow document model, where changes to that property can change the overall rendering of the flow document that contains the paragraph.</span></span> <span data-ttu-id="2e538-211">使用<xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsParentArrange>或<xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsParentMeasure>来标识您自己的属性中相似的情况。</span><span class="sxs-lookup"><span data-stu-id="2e538-211">Use <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsParentArrange> or <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsParentMeasure> to identify similar cases in your own properties.</span></span>

-   <span data-ttu-id="2e538-212">默认情况下，依赖属性支持数据绑定。</span><span class="sxs-lookup"><span data-stu-id="2e538-212">By default, dependency properties support data binding.</span></span> <span data-ttu-id="2e538-213">在无实际的数据绑定方案或大型对象的数据绑定性能构成问题的情况下，可有意禁用数据绑定。</span><span class="sxs-lookup"><span data-stu-id="2e538-213">You can deliberately disable data binding, for cases where there is no realistic scenario for data binding, or where performance in data binding for a large object is recognized as a problem.</span></span>

-   <span data-ttu-id="2e538-214">默认情况下，数据绑定<xref:System.Windows.Data.Binding.Mode%2A>的依赖项属性值默认为<xref:System.Windows.Data.BindingMode.OneWay>。</span><span class="sxs-lookup"><span data-stu-id="2e538-214">By default, data binding <xref:System.Windows.Data.Binding.Mode%2A> for dependency properties defaults to <xref:System.Windows.Data.BindingMode.OneWay>.</span></span> <span data-ttu-id="2e538-215">您始终可以更改绑定要<xref:System.Windows.Data.BindingMode.TwoWay>每个绑定实例; 有关详细信息，请参阅[指定绑定的方向](../data/how-to-specify-the-direction-of-the-binding.md)。</span><span class="sxs-lookup"><span data-stu-id="2e538-215">You can always change the binding to be <xref:System.Windows.Data.BindingMode.TwoWay> per binding instance; for details, see [Specify the Direction of the Binding](../data/how-to-specify-the-direction-of-the-binding.md).</span></span> <span data-ttu-id="2e538-216">作为依赖属性的作者，你可以选择要使用的属性，但<xref:System.Windows.Data.BindingMode.TwoWay>默认情况下的绑定模式。</span><span class="sxs-lookup"><span data-stu-id="2e538-216">But as the dependency property author, you can choose to make the property use <xref:System.Windows.Data.BindingMode.TwoWay> binding mode by default.</span></span> <span data-ttu-id="2e538-217">现有依赖属性的一个示例是<xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A?displayProperty=nameWithType>; 此属性的方案是<xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A>设置逻辑和的合成<xref:System.Windows.Controls.MenuItem>与默认主题样式交互。</span><span class="sxs-lookup"><span data-stu-id="2e538-217">An example of an existing dependency property is <xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A?displayProperty=nameWithType>; the scenario for this property is that the <xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A> setting logic and the compositing of <xref:System.Windows.Controls.MenuItem> interact with the default theme style.</span></span> <span data-ttu-id="2e538-218"><xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A>属性逻辑在以本机方式使用数据绑定来根据其他状态属性和方法调用保持的属性的状态。</span><span class="sxs-lookup"><span data-stu-id="2e538-218">The <xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A> property logic uses data binding natively to maintain the state of the property in accordance to other state properties and method calls.</span></span> <span data-ttu-id="2e538-219">绑定的另一个示例属性<xref:System.Windows.Data.BindingMode.TwoWay>默认情况下是<xref:System.Windows.Controls.TextBox.Text%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="2e538-219">Another example property that binds <xref:System.Windows.Data.BindingMode.TwoWay> by default is <xref:System.Windows.Controls.TextBox.Text%2A?displayProperty=nameWithType>.</span></span>

-   <span data-ttu-id="2e538-220">此外可以通过设置启用属性继承自定义依赖属性中的<xref:System.Windows.FrameworkPropertyMetadataOptions.Inherits>标志。</span><span class="sxs-lookup"><span data-stu-id="2e538-220">You can also enable property inheritance in a custom dependency property by setting the <xref:System.Windows.FrameworkPropertyMetadataOptions.Inherits> flag.</span></span> <span data-ttu-id="2e538-221">在父元素和子元素具有相同属性的情况中，属性继承非常有用，它可以使子元素将该特定属性值设置为与父元素设置的值相同。</span><span class="sxs-lookup"><span data-stu-id="2e538-221">Property inheritance is useful for a scenario where parent elements and child elements have a property in common, and it makes sense for the child elements to have that particular property value set to the same value as the parent set it.</span></span> <span data-ttu-id="2e538-222">示例可继承的属性是<xref:System.Windows.FrameworkElement.DataContext%2A>，这用于绑定操作，启用数据演示的重要母版-详细信息方案。</span><span class="sxs-lookup"><span data-stu-id="2e538-222">An example inheritable property is <xref:System.Windows.FrameworkElement.DataContext%2A>, which is used for binding operations to enable the important master-detail scenario for data presentation.</span></span> <span data-ttu-id="2e538-223">通过使<xref:System.Windows.FrameworkElement.DataContext%2A>可继承的任何子元素继承该数据上下文还。</span><span class="sxs-lookup"><span data-stu-id="2e538-223">By making <xref:System.Windows.FrameworkElement.DataContext%2A> inheritable, any child elements inherit that data context also.</span></span> <span data-ttu-id="2e538-224">因为使用了属性值继承，你可以在页面或应用程序根目录上指定数据上下文，而无需对所有可能子元素中的绑定重新指定上下文。</span><span class="sxs-lookup"><span data-stu-id="2e538-224">Because of property value inheritance, you can specify a data context at the page or application root, and do not need to respecify it for bindings in all possible child elements.</span></span> <span data-ttu-id="2e538-225"><xref:System.Windows.FrameworkElement.DataContext%2A> 也是一个很好的示例来演示继承覆盖默认值，但它可以始终在本地上设置的任何特定的子元素;有关详细信息，请参阅[对分层数据使用主-从模式](../data/how-to-use-the-master-detail-pattern-with-hierarchical-data.md)。</span><span class="sxs-lookup"><span data-stu-id="2e538-225"><xref:System.Windows.FrameworkElement.DataContext%2A> is also a good example to illustrate that inheritance overrides the default value, but it can always be set locally on any particular child element; for details, see [Use the Master-Detail Pattern with Hierarchical Data](../data/how-to-use-the-master-detail-pattern-with-hierarchical-data.md).</span></span> <span data-ttu-id="2e538-226">属性值继承确实可能存在性能成本，因此应谨慎使用；有关详细信息，请参阅[属性值继承](property-value-inheritance.md)。</span><span class="sxs-lookup"><span data-stu-id="2e538-226">Property value inheritance does have a possible performance cost, and thus should be used sparingly; for details, see [Property Value Inheritance](property-value-inheritance.md).</span></span>

-   <span data-ttu-id="2e538-227">设置<xref:System.Windows.FrameworkPropertyMetadataOptions.Journal>标志，用于指示是否应检测到或者使用导航日志服务的依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="2e538-227">Set the <xref:System.Windows.FrameworkPropertyMetadataOptions.Journal> flag to indicate if your dependency property should be detected or used by navigation journaling services.</span></span> <span data-ttu-id="2e538-228">例如，<xref:System.Windows.Controls.Primitives.Selector.SelectedIndex%2A>属性; 在所选内容中选择任何项时导航日志历史记录应保留控件。</span><span class="sxs-lookup"><span data-stu-id="2e538-228">An example is the <xref:System.Windows.Controls.Primitives.Selector.SelectedIndex%2A> property; any item selected in a selection control should be persisted when the journaling history is navigated.</span></span>

<a name="RODP"></a>
## <a name="read-only-dependency-properties"></a><span data-ttu-id="2e538-229">只读依赖项属性</span><span class="sxs-lookup"><span data-stu-id="2e538-229">Read-Only Dependency Properties</span></span>

<span data-ttu-id="2e538-230">可以定义只读的依赖属性。</span><span class="sxs-lookup"><span data-stu-id="2e538-230">You can define a dependency property that is read-only.</span></span> <span data-ttu-id="2e538-231">但是，为何将属性定义为只读的情况略有不同，其过程与在属性系统中注册属性并公开标识符相同。</span><span class="sxs-lookup"><span data-stu-id="2e538-231">However, the scenarios for why you might define your property as read-only are somewhat different, as is the procedure for registering them with the property system and exposing the identifier.</span></span> <span data-ttu-id="2e538-232">有关详细信息，请参阅[只读依赖属性](read-only-dependency-properties.md)。</span><span class="sxs-lookup"><span data-stu-id="2e538-232">For more information, see [Read-Only Dependency Properties](read-only-dependency-properties.md).</span></span>

<a name="CTDP"></a>
## <a name="collection-type-dependency-properties"></a><span data-ttu-id="2e538-233">集合类型依赖项属性</span><span class="sxs-lookup"><span data-stu-id="2e538-233">Collection-Type Dependency Properties</span></span>

<span data-ttu-id="2e538-234">集合类型依赖属性要考虑一些其他实现问题。</span><span class="sxs-lookup"><span data-stu-id="2e538-234">Collection-type dependency properties have some additional implementation issues to consider.</span></span> <span data-ttu-id="2e538-235">有关详细信息，请参阅[集合类型依赖属性](collection-type-dependency-properties.md)。</span><span class="sxs-lookup"><span data-stu-id="2e538-235">For details, see [Collection-Type Dependency Properties](collection-type-dependency-properties.md).</span></span>

<a name="SecurityC"></a>
## <a name="dependency-property-security-considerations"></a><span data-ttu-id="2e538-236">依赖属性安全注意事项</span><span class="sxs-lookup"><span data-stu-id="2e538-236">Dependency Property Security Considerations</span></span>

<span data-ttu-id="2e538-237">依赖属性应声明为公共属性。</span><span class="sxs-lookup"><span data-stu-id="2e538-237">Dependency properties should be declared as public properties.</span></span> <span data-ttu-id="2e538-238">依赖属性标识符字段应声明为公共静态字段。</span><span class="sxs-lookup"><span data-stu-id="2e538-238">Dependency property identifier fields should be declared as public static fields.</span></span> <span data-ttu-id="2e538-239">即使尝试声明其他访问级别（例如受保护），也始终可以通过标识符和属性系统 [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] 来访问依赖属性。</span><span class="sxs-lookup"><span data-stu-id="2e538-239">Even if you attempt to declare other access levels (such as protected), a dependency property can always be accessed through the identifier in combination with the property system [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)].</span></span> <span data-ttu-id="2e538-240">由于元数据报告或值确定受保护的标识符字段，甚至是可以访问[!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)]属于属性系统，如<xref:System.Windows.LocalValueEnumerator>。</span><span class="sxs-lookup"><span data-stu-id="2e538-240">Even a protected identifier field is potentially accessible because of metadata reporting or value determination [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] that are part of the property system, such as <xref:System.Windows.LocalValueEnumerator>.</span></span> <span data-ttu-id="2e538-241">有关详细信息，请参阅[依赖属性的安全性](dependency-property-security.md)。</span><span class="sxs-lookup"><span data-stu-id="2e538-241">For more information, see [Dependency Property Security](dependency-property-security.md).</span></span>

<a name="DPCtor"></a>
## <a name="dependency-properties-and-class-constructors"></a><span data-ttu-id="2e538-242">依赖属性和类构造函数</span><span class="sxs-lookup"><span data-stu-id="2e538-242">Dependency Properties and Class Constructors</span></span>

<span data-ttu-id="2e538-243">托管代码编程（通常通过FxCop 等代码分析工具强制执行）的一般原则是：类构造函数不应调用虚方法。</span><span class="sxs-lookup"><span data-stu-id="2e538-243">There is a general principle in managed code programming (often enforced by code analysis tools such as FxCop) that class constructors should not call virtual methods.</span></span> <span data-ttu-id="2e538-244">这是因为构造函数可以作为派生的类构造函数的基本初始化来调用，并且可能会在所构造的对象实例不完全初始化状态下通过构造函数输入虚方法。</span><span class="sxs-lookup"><span data-stu-id="2e538-244">This is because constructors can be called as base initialization of a derived class constructor, and entering the virtual method through the constructor might occur at an incomplete initialization state of the object instance being constructed.</span></span> <span data-ttu-id="2e538-245">从已派生自任何类派生时<xref:System.Windows.DependencyObject>，应注意，属性系统本身调用，并在内部公开虚方法。</span><span class="sxs-lookup"><span data-stu-id="2e538-245">When you derive from any class that already derives from <xref:System.Windows.DependencyObject>, you should be aware that the property system itself calls and exposes virtual methods internally.</span></span> <span data-ttu-id="2e538-246">这些虚方法属于 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 属性系统服务。</span><span class="sxs-lookup"><span data-stu-id="2e538-246">These virtual methods are part of the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system services.</span></span> <span data-ttu-id="2e538-247">替代方法会使派生类参与值确定。</span><span class="sxs-lookup"><span data-stu-id="2e538-247">Overriding the methods enables derived classes to participate in value determination.</span></span> <span data-ttu-id="2e538-248">为避免运行时初始化出现潜在问题，，不应该在类的构造函数中设置依赖属性值，除非遵循特定的构造函数模式进行操作。</span><span class="sxs-lookup"><span data-stu-id="2e538-248">To avoid potential issues with runtime initialization, you should not set dependency property values within constructors of classes, unless you follow a very specific constructor pattern.</span></span> <span data-ttu-id="2e538-249">有关详细信息，请参阅 [DependencyObject 的安全构造函数模式](safe-constructor-patterns-for-dependencyobjects.md)。</span><span class="sxs-lookup"><span data-stu-id="2e538-249">For details, see [Safe Constructor Patterns for DependencyObjects](safe-constructor-patterns-for-dependencyobjects.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="2e538-250">请参阅</span><span class="sxs-lookup"><span data-stu-id="2e538-250">See also</span></span>

- [<span data-ttu-id="2e538-251">依赖项属性概述</span><span class="sxs-lookup"><span data-stu-id="2e538-251">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="2e538-252">依赖属性元数据</span><span class="sxs-lookup"><span data-stu-id="2e538-252">Dependency Property Metadata</span></span>](dependency-property-metadata.md)
- [<span data-ttu-id="2e538-253">控件创作概述</span><span class="sxs-lookup"><span data-stu-id="2e538-253">Control Authoring Overview</span></span>](../controls/control-authoring-overview.md)
- [<span data-ttu-id="2e538-254">集合类型依赖属性</span><span class="sxs-lookup"><span data-stu-id="2e538-254">Collection-Type Dependency Properties</span></span>](collection-type-dependency-properties.md)
- [<span data-ttu-id="2e538-255">依赖属性的安全性</span><span class="sxs-lookup"><span data-stu-id="2e538-255">Dependency Property Security</span></span>](dependency-property-security.md)
- [<span data-ttu-id="2e538-256">XAML 加载和依赖项属性</span><span class="sxs-lookup"><span data-stu-id="2e538-256">XAML Loading and Dependency Properties</span></span>](xaml-loading-and-dependency-properties.md)
- [<span data-ttu-id="2e538-257">DependencyObject 的安全构造函数模式</span><span class="sxs-lookup"><span data-stu-id="2e538-257">Safe Constructor Patterns for DependencyObjects</span></span>](safe-constructor-patterns-for-dependencyobjects.md)