---
title: XAML 语法详述
ms.date: 03/30/2017
helpviewer_keywords:
- XML [WPF], namespaces
- XAML [WPF], parsing of attributes
- parsing of attributes [WPF]
- XAML [WPF], markup extensions
- attached properties [WPF]
- tag syntax [XAML]
- markup extensions [WPF]
- XAML [WPF], object element syntax
- XAML [WPF], syntax terminology
- attached events [WPF]
- lookup semantics [WPF]
- XAML [WPF], attached events
- XAML [WPF], content syntax
- XAML [WPF], lookup semantics
- content syntax [WPF]
- object element syntax [WPF]
- syntax terminology [XAML]
- XAML [WPF], attached properties
- attributes [XAML], parsing
- XAML [WPF], tag syntax
- XAML [WPF], attribute syntax
- property element syntax [WPF]
- terminology [XAML]
- namespaces [WPF], XML
- attribute syntax [XAML]
- XAML [WPF], property element syntax
ms.assetid: 67cce290-ca26-4c41-a797-b68aabc45479
ms.openlocfilehash: 5f8bb862ce443fd7397036b10f69cda65a6960bc
ms.sourcegitcommit: 62285ec11fa8e8424bab00511a90760c60e63c95
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/20/2020
ms.locfileid: "81646146"
---
# <a name="xaml-syntax-in-detail"></a><span data-ttu-id="3c5d9-102">XAML 语法详述</span><span class="sxs-lookup"><span data-stu-id="3c5d9-102">XAML Syntax In Detail</span></span>
<span data-ttu-id="3c5d9-103">本主题定义用于描述 XAML 语法元素的术语。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-103">This topic defines the terms that are used to describe the elements of XAML syntax.</span></span> <span data-ttu-id="3c5d9-104">这些术语在本文档的其余部分中经常使用，具体用于 WPF 文档，以及使用 XAML 或其他框架的其他框架，这些框架或在 System.Xaml 级别启用的 XAML 语言支持。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-104">These terms are used frequently throughout the remainder of this documentation, both for WPF documentation specifically and for the other frameworks that use XAML or the basic XAML concepts enabled by the XAML language support at the System.Xaml level.</span></span> <span data-ttu-id="3c5d9-105">本主题将展开主题[XAML 概述 （WPF）](../../../desktop-wpf/fundamentals/xaml.md)中介绍的基本术语。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-105">This topic expands on the basic terminology introduced in the topic [XAML Overview (WPF)](../../../desktop-wpf/fundamentals/xaml.md).</span></span>  

<a name="the_xaml_language_specification"></a>
## <a name="the-xaml-language-specification"></a><span data-ttu-id="3c5d9-106">XAML 语言规范</span><span class="sxs-lookup"><span data-stu-id="3c5d9-106">The XAML Language Specification</span></span>  
 <span data-ttu-id="3c5d9-107">此处定义的 XAML 语法术语也在 XAML 语言规范中定义或引用。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-107">The XAML syntax terminology defined here is also defined or referenced within the XAML language specification.</span></span> <span data-ttu-id="3c5d9-108">XAML 是基于 XML 的语言，它遵循或扩展了 XML 结构规则。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-108">XAML is a language based on XML and follows or expands upon XML structural rules.</span></span> <span data-ttu-id="3c5d9-109">某些术语来自或基于描述 XML 语言或 XML 文档对象模型时常用的术语。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-109">Some of the terminology is shared from or is based on the terminology commonly used when describing the XML language or the XML document object model.</span></span>  
  
 <span data-ttu-id="3c5d9-110">有关 XAML 语言规范的详细信息，请从 Microsoft 下载中心下载[\[MS-XAML。\] ](https://download.microsoft.com/download/0/A/6/0A6F7755-9AF5-448B-907D-13985ACCF53E/[MS-XAML].pdf)</span><span class="sxs-lookup"><span data-stu-id="3c5d9-110">For more information about the XAML language specification, download [\[MS-XAML\]](https://download.microsoft.com/download/0/A/6/0A6F7755-9AF5-448B-907D-13985ACCF53E/[MS-XAML].pdf) from the Microsoft Download Center.</span></span>  
  
<a name="xaml_and_clr"></a>
## <a name="xaml-and-clr"></a><span data-ttu-id="3c5d9-111">XAML 和 CLR</span><span class="sxs-lookup"><span data-stu-id="3c5d9-111">XAML and CLR</span></span>  
 <span data-ttu-id="3c5d9-112">XAML 是一种标记语言。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-112">XAML is a markup language.</span></span> <span data-ttu-id="3c5d9-113">通用语言运行时 （CLR） （CLR） 的名称所暗示，支持运行时执行。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-113">The common language runtime (CLR), as implied by its name, enables runtime execution.</span></span> <span data-ttu-id="3c5d9-114">XAML 本身并不是 CLR 运行时直接使用的常见语言之一。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-114">XAML is not by itself one of the common languages that is directly consumed by the CLR runtime.</span></span> <span data-ttu-id="3c5d9-115">相反，您可以将 XAML 视为支持其自己的类型系统。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-115">Instead, you can think of XAML as supporting its own type system.</span></span> <span data-ttu-id="3c5d9-116">WPF 使用的特定 XAML 解析系统构建在 CLR 和 CLR 类型系统上。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-116">The particular XAML parsing system that is used by WPF is built on the CLR and the CLR type system.</span></span> <span data-ttu-id="3c5d9-117">XAML 类型映射到 CLR 类型，以在分析 WPF 的 XAML 时实例化运行时表示。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-117">XAML types are mapped to CLR types to instantiate a run time representation when the XAML for WPF is parsed.</span></span> <span data-ttu-id="3c5d9-118">因此，本文档中关于语法的讨论的其余部分将包括对 CLR 类型系统的引用，即使 XAML 语言规范中的等效语法讨论没有。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-118">For this reason, the remainder of discussion of syntax in this document will include references to the CLR type system, even though the equivalent syntax discussions in the XAML language specification do not.</span></span> <span data-ttu-id="3c5d9-119">（根据 XAML 语言规范级别，XAML 类型可以映射到任何其他类型系统，其中不必是 CLR，但需要创建和使用不同的 XAML 解析器。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-119">(Per the XAML language specification level, XAML types could be mapped to any other type system, which does not have to be the CLR, but that would require the creation and use of a different XAML parser.)</span></span>  
  
#### <a name="members-of-types-and-class-inheritance"></a><span data-ttu-id="3c5d9-120">类型和类继承的成员</span><span class="sxs-lookup"><span data-stu-id="3c5d9-120">Members of Types and Class Inheritance</span></span>  
 <span data-ttu-id="3c5d9-121">属性和事件作为[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]类型的 XAML 成员显示时通常从基类型继承。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-121">Properties and events as they appear as XAML members of a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] type are often inherited from base types.</span></span> <span data-ttu-id="3c5d9-122">例如，请考虑此示例： `<Button Background="Blue" .../>`。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-122">For example, consider this example: `<Button Background="Blue" .../>`.</span></span> <span data-ttu-id="3c5d9-123">如果要<xref:System.Windows.Controls.Control.Background%2A>查看类定义、反射结果或文档，<xref:System.Windows.Controls.Button>则该属性不是类上的立即声明属性。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-123">The <xref:System.Windows.Controls.Control.Background%2A> property is not an immediately declared property on the <xref:System.Windows.Controls.Button> class, if you were to look at the class definition, reflection results, or the documentation.</span></span> <span data-ttu-id="3c5d9-124"><xref:System.Windows.Controls.Control.Background%2A>而是从基<xref:System.Windows.Controls.Control>类继承的。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-124">Instead, <xref:System.Windows.Controls.Control.Background%2A> is inherited from the base <xref:System.Windows.Controls.Control> class.</span></span>  
  
 <span data-ttu-id="3c5d9-125">XAML 元素[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]的类继承行为与 XML 标记的架构强制解释有重大背离。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-125">The class inheritance behavior of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML elements is a significant departure from a schema-enforced interpretation of XML markup.</span></span> <span data-ttu-id="3c5d9-126">类继承可能会变得复杂，尤其是在中间基类是抽象的，或者涉及接口时。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-126">Class inheritance can become complex, particularly when intermediate base classes are abstract, or when interfaces are involved.</span></span> <span data-ttu-id="3c5d9-127">这是 XAML 元素集及其允许属性难以准确、完整地使用通常用于 XML 编程的架构类型（如 DTD 或 XSD 格式）的一个原因。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-127">This is one reason that the set of XAML elements and their permissible attributes is difficult to represent accurately and completely using the schema types that are typically used for XML programming, such as DTD or XSD format.</span></span> <span data-ttu-id="3c5d9-128">另一个原因是 XAML 语言本身的可扩展性和类型映射功能排除了允许类型和成员的任何固定表示形式的完整性。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-128">Another reason is that extensibility and type-mapping features of the XAML language itself preclude completeness of any fixed representation of the permissible types and members.</span></span>  
  
<a name="object_element_syntax"></a>
## <a name="object-element-syntax"></a><span data-ttu-id="3c5d9-129">对象元素语法</span><span class="sxs-lookup"><span data-stu-id="3c5d9-129">Object Element Syntax</span></span>  
 <span data-ttu-id="3c5d9-130">*对象元素语法*是 XAML 标记语法，它通过声明 XML 元素实例化 CLR 类或结构。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-130">*Object element syntax* is the XAML markup syntax that instantiates a CLR class or structure by declaring an XML element.</span></span> <span data-ttu-id="3c5d9-131">此语法类似于其他标记语言（如 HTML）的元素语法。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-131">This syntax resembles the element syntax of other markup languages such as HTML.</span></span> <span data-ttu-id="3c5d9-132">对象元素语法以左角度括号 （），\<紧接着是实例化的类或结构的类型名称。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-132">Object element syntax begins with a left angle bracket (\<), followed immediately by the type name of the class or structure being instantiated.</span></span> <span data-ttu-id="3c5d9-133">零个或多个空格可以遵循类型名称，也可以在对象元素上声明零个或多个属性，其中一个或多个空格分隔每个属性名称 ="值"对。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-133">Zero or more spaces can follow the type name, and zero or more attributes may also be declared on the object element, with one or more spaces separating each attribute name="value" pair.</span></span> <span data-ttu-id="3c5d9-134">最后，以下必须为 true：</span><span class="sxs-lookup"><span data-stu-id="3c5d9-134">Finally, one of the following must be true:</span></span>  
  
- <span data-ttu-id="3c5d9-135">元素和标记必须用前斜杠 （/） 紧接，然后紧跟直角支架 （>）。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-135">The element and tag must be closed by a forward slash (/) followed immediately by a right angle bracket (>).</span></span>  
  
- <span data-ttu-id="3c5d9-136">开口标记必须由直角支架（>）完成。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-136">The opening tag must be completed by a right angle bracket (>).</span></span> <span data-ttu-id="3c5d9-137">其他对象元素、属性元素或内部文本可以遵循打开标记。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-137">Other object elements, property elements, or inner text, can follow the opening tag.</span></span> <span data-ttu-id="3c5d9-138">此处可能包含的内容通常受元素的对象模型的约束。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-138">Exactly what content may be contained here is typically constrained by the object model of the element.</span></span> <span data-ttu-id="3c5d9-139">对象元素的等效关闭标记也必须存在，以适当的嵌套并与其他打开和关闭标记对平衡。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-139">The equivalent closing tag for the object element must also exist, in proper nesting and balance with other opening and closing tag pairs.</span></span>  
  
 <span data-ttu-id="3c5d9-140">.NET 实现的 XAML 具有一组规则，这些规则将对象元素映射到类型、属性或事件的属性以及 XAML 命名空间到 CLR 命名空间加上程序集。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-140">XAML as implemented by .NET has a set of rules that map object elements into types, attributes into properties or events, and XAML namespaces to CLR namespaces plus assembly.</span></span> <span data-ttu-id="3c5d9-141">对于 WPF 和 .NET，XAML 对象元素映射到引用程序集中定义的 .NET 类型，属性映射到这些类型的成员。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-141">For WPF and .NET, XAML object elements map to .NET types as defined in referenced assemblies, and the attributes map to members of those types.</span></span> <span data-ttu-id="3c5d9-142">在 XAML 中引用 CLR 类型时，您也有权访问该类型的继承成员。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-142">When you reference a CLR type in XAML, you have access to the inherited members of that type as well.</span></span>  
  
 <span data-ttu-id="3c5d9-143">例如，以下示例是对象元素语法，它实例化<xref:System.Windows.Controls.Button>类的新实例，并指定该<xref:System.Windows.FrameworkElement.Name%2A>属性的属性和值：</span><span class="sxs-lookup"><span data-stu-id="3c5d9-143">For example, the following example is object element syntax that instantiates a new instance of the <xref:System.Windows.Controls.Button> class, and also specifies a <xref:System.Windows.FrameworkElement.Name%2A> attribute and a value for that attribute:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxOE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#syntaxoe)]  
  
 <span data-ttu-id="3c5d9-144">下面的示例是对象元素语法，该语法还包括 XAML 内容属性语法。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-144">The following example is object element syntax that also includes XAML content property syntax.</span></span> <span data-ttu-id="3c5d9-145">中包含的内部文本将用于设置<xref:System.Windows.Controls.TextBox>XAML 内容属性 。 <xref:System.Windows.Controls.TextBox.Text%2A></span><span class="sxs-lookup"><span data-stu-id="3c5d9-145">The inner text contained within will be used to set the <xref:System.Windows.Controls.TextBox> XAML content property, <xref:System.Windows.Controls.TextBox.Text%2A>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#ThisIsATextBox](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#thisisatextbox)]  
  
### <a name="content-models"></a><span data-ttu-id="3c5d9-146">内容模型</span><span class="sxs-lookup"><span data-stu-id="3c5d9-146">Content Models</span></span>  
 <span data-ttu-id="3c5d9-147">类在语法方面可能支持作为 XAML 对象元素的用法，但该元素只有在放置在总体内容模型或元素树的预期位置时，才会在应用程序或页面中正常运行。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-147">A class might support a usage as a XAML object element in terms of the syntax, but that element will only function properly in an application or page when it is placed in an expected position of an overall content model or element tree.</span></span> <span data-ttu-id="3c5d9-148">例如，通常<xref:System.Windows.Controls.MenuItem>应仅作为<xref:System.Windows.Controls.Primitives.MenuBase>派生类（如<xref:System.Windows.Controls.Menu>） 的子级放置。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-148">For example, a <xref:System.Windows.Controls.MenuItem> should typically only be placed as a child of a <xref:System.Windows.Controls.Primitives.MenuBase> derived class such as <xref:System.Windows.Controls.Menu>.</span></span> <span data-ttu-id="3c5d9-149">特定元素的内容模型作为控件和其他[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]类可用作 XAML 元素的类页上的备注的一部分进行记录。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-149">Content models for specific elements are documented as part of the remarks on the class pages for controls and other [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes that can be used as XAML elements.</span></span>  
  
<a name="properties_of_object_elements"></a>
## <a name="properties-of-object-elements"></a><span data-ttu-id="3c5d9-150">对象元素的属性</span><span class="sxs-lookup"><span data-stu-id="3c5d9-150">Properties of Object Elements</span></span>  
 <span data-ttu-id="3c5d9-151">XAML 中的属性由各种可能的语法设置。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-151">Properties in XAML are set by a variety of possible syntaxes.</span></span> <span data-ttu-id="3c5d9-152">哪些语法可用于特定属性将因所设置的属性的基础类型系统特征而异。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-152">Which syntax can be used for a particular property will vary, based on the underlying type system characteristics of the property that you are setting.</span></span>  
  
 <span data-ttu-id="3c5d9-153">通过设置属性的值，可以像运行时对象图中存在的对象一样，向对象添加要素或特征。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-153">By setting values of properties, you add features or characteristics to objects as they exist in the run time object graph.</span></span> <span data-ttu-id="3c5d9-154">从对象元素创建的对象的初始状态基于无参数构造函数行为。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-154">The initial state of the created object from a object element is based on the parameterless constructor behavior.</span></span> <span data-ttu-id="3c5d9-155">通常，应用程序将使用任何给定对象的完全默认实例以外的内容。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-155">Typically, your application will use something other than a completely default instance of any given object.</span></span>  
  
<a name="attribute_syntax_properties"></a>
## <a name="attribute-syntax-properties"></a><span data-ttu-id="3c5d9-156">特性语法（属性）</span><span class="sxs-lookup"><span data-stu-id="3c5d9-156">Attribute Syntax (Properties)</span></span>  
 <span data-ttu-id="3c5d9-157">属性语法是 XAML 标记语法，通过在现有对象元素上声明属性来设置属性的值。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-157">Attribute syntax is the XAML markup syntax that sets a value for a property by declaring an attribute on an existing object element.</span></span> <span data-ttu-id="3c5d9-158">属性名称必须与支持相关对象元素的类属性的 CLR 成员名称匹配。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-158">The attribute name must match the CLR member name of the property of the class that backs the relevant object element.</span></span> <span data-ttu-id="3c5d9-159">属性名称后跟赋值运算符 （\*）。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-159">The attribute name is followed by an assignment operator (=).</span></span> <span data-ttu-id="3c5d9-160">属性值必须是包含在引号中的字符串。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-160">The attribute value must be a string enclosed within quotes.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="3c5d9-161">可以使用交替引号在属性中放置文本引号。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-161">You can use alternating quotes to place a literal quotation mark within an attribute.</span></span> <span data-ttu-id="3c5d9-162">例如，可以使用单引号作为声明包含其中双引号字符的字符串的方法。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-162">For instance you can use single quotes as a means to declare a string that contains a double quote character within it.</span></span> <span data-ttu-id="3c5d9-163">无论使用单引号还是双引号，都应使用匹配对来打开和关闭属性值字符串。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-163">Whether you use single or double quotes, you should use a matching pair for opening and closing the attribute value string.</span></span> <span data-ttu-id="3c5d9-164">还有一些转义序列或其他技术可用于解决任何特定 XAML 语法施加的字符限制。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-164">There are also escape sequences or other techniques available for working around character restrictions imposed by any particular XAML syntax.</span></span> <span data-ttu-id="3c5d9-165">请参阅[XML 字符实体和 XAML](../../../desktop-wpf/xaml-services/xml-character-entities.md)。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-165">See [XML Character Entities and XAML](../../../desktop-wpf/xaml-services/xml-character-entities.md).</span></span>  
  
 <span data-ttu-id="3c5d9-166">要通过属性语法进行设置，属性必须是公共的，并且必须是可写入的。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-166">In order to be set through attribute syntax, a property must be public and must be writeable.</span></span> <span data-ttu-id="3c5d9-167">支持类型系统中的属性值必须是值类型，或者必须是访问相关备份类型时 XAML 处理器可以实例化或引用的引用类型。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-167">The value of the property in the backing type system must be a value type, or must be a reference type that can be instantiated or referenced by a XAML processor when accessing the relevant backing type.</span></span>  
  
 <span data-ttu-id="3c5d9-168">对于 WPF XAML 事件，引用为属性名称的事件必须是公共的，并且具有公共委托。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-168">For WPF XAML events, the event that is referenced as the attribute name must be public and have a public delegate.</span></span>  
  
 <span data-ttu-id="3c5d9-169">属性或事件必须是由包含对象元素实例化的类或结构的成员。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-169">The property or event must be a member of the class or structure that is instantiated by the containing object element.</span></span>  
  
### <a name="processing-of-attribute-values"></a><span data-ttu-id="3c5d9-170">属性值的处理</span><span class="sxs-lookup"><span data-stu-id="3c5d9-170">Processing of Attribute Values</span></span>  
 <span data-ttu-id="3c5d9-171">首开和收盘引号中包含的字符串值由 XAML 处理器处理。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-171">The string value contained within the opening and closing quotation marks is processed by a XAML processor.</span></span> <span data-ttu-id="3c5d9-172">对于属性，默认处理行为由基础 CLR 属性的类型确定。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-172">For properties, the default processing behavior is determined by the type of the underlying CLR property.</span></span>  
  
 <span data-ttu-id="3c5d9-173">属性值由以下之一填充，使用此处理顺序：</span><span class="sxs-lookup"><span data-stu-id="3c5d9-173">The attribute value is filled by one of the following, using this processing order:</span></span>  
  
1. <span data-ttu-id="3c5d9-174">如果 XAML 处理器遇到大括号或派生自<xref:System.Windows.Markup.MarkupExtension>的对象元素，则首先计算引用的标记扩展，而不是将该值作为字符串处理，标记扩展返回的对象用作值。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-174">If the XAML processor encounters a curly brace, or an object element that derives from <xref:System.Windows.Markup.MarkupExtension>, then the referenced markup extension is evaluated first rather than processing the value as a string, and the object returned by the markup extension is used as the value.</span></span> <span data-ttu-id="3c5d9-175">在许多情况下，标记扩展返回的对象将是对现有对象的引用，或将计算推迟到运行时的表达式，而不是新实例化的对象。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-175">In many cases the object returned by a markup extension will be a reference to an existing object, or an expression that defers evaluation until run time, and is not a newly instantiated object.</span></span>  
  
2. <span data-ttu-id="3c5d9-176">如果属性用属性声明<xref:System.ComponentModel.TypeConverter>，或者该属性的值类型用属性<xref:System.ComponentModel.TypeConverter>声明，则属性的字符串值将作为转换输入提交到类型转换器，转换器将返回一个新的对象实例。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-176">If the property is declared with an attributed <xref:System.ComponentModel.TypeConverter>, or the value type of that property is declared with an attributed <xref:System.ComponentModel.TypeConverter>, the string value of the attribute is submitted to the type converter as a conversion input, and the converter will return a new object instance.</span></span>  
  
3. <span data-ttu-id="3c5d9-177">如果没有<xref:System.ComponentModel.TypeConverter>，则尝试直接转换为属性类型。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-177">If there is no <xref:System.ComponentModel.TypeConverter>, a direct conversion to the property type is attempted.</span></span> <span data-ttu-id="3c5d9-178">此最终级别是 XAML 语言基元类型之间的解析器本机值的直接转换，或对枚举中命名常量的名称的检查（解析器随后访问匹配值）。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-178">This final level is a direct conversion at the parser-native value between XAML language primitive types, or a check for the names of named constants in an enumeration (the parser then accesses the matching values).</span></span>  
  
#### <a name="enumeration-attribute-values"></a><span data-ttu-id="3c5d9-179">枚举属性值</span><span class="sxs-lookup"><span data-stu-id="3c5d9-179">Enumeration Attribute Values</span></span>  
 <span data-ttu-id="3c5d9-180">XAML 中的枚举由 XAML 解析器进行内在处理，枚举成员应通过指定枚举命名常量之一的字符串名称来指定枚举。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-180">Enumerations in XAML are processed intrinsically by XAML parsers, and the members of an enumeration should be specified by specifying the string name of one of the enumeration's named constants.</span></span>  
  
 <span data-ttu-id="3c5d9-181">对于非标记枚举值，本机行为是处理属性值的字符串并将其解析为枚举值之一。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-181">For nonflag enumeration values, the native behavior is to process the string of an attribute value and resolve it to one of the enumeration values.</span></span> <span data-ttu-id="3c5d9-182">您不会在格式枚*举*中指定枚举。*值*，就像您在代码中所做的一样。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-182">You do not specify the enumeration in the format *Enumeration*.*Value*, as you do in code.</span></span> <span data-ttu-id="3c5d9-183">相反，您只指定*值*，而*枚举*则由要设置的属性的类型推断。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-183">Instead, you specify only *Value*, and *Enumeration* is inferred by the type of the property you are setting.</span></span> <span data-ttu-id="3c5d9-184">如果在*枚举*中指定属性。*值*形式，它将不会正确解析。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-184">If you specify an attribute in the *Enumeration*.*Value* form, it will not resolve correctly.</span></span>  
  
 <span data-ttu-id="3c5d9-185">对于正面枚举，行为基于 方法<xref:System.Enum.Parse%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-185">For flagwise enumerations, the behavior is based on the <xref:System.Enum.Parse%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="3c5d9-186">可以通过用逗号分隔每个值来为旗面枚举指定多个值。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-186">You can specify multiple values for a flagwise enumeration by separating each value with a comma.</span></span> <span data-ttu-id="3c5d9-187">但是，不能合并不按标志标记的枚举值。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-187">However, you cannot combine enumeration values that are not flagwise.</span></span> <span data-ttu-id="3c5d9-188">例如，不能使用逗号语法尝试创建<xref:System.Windows.Trigger>对非标志枚举的多个条件具有作用的 语法：</span><span class="sxs-lookup"><span data-stu-id="3c5d9-188">For instance, you cannot use the comma syntax to attempt to create a <xref:System.Windows.Trigger> that acts on multiple conditions of a nonflag enumeration:</span></span>  
  
```xaml  
<!--This will not compile, because Visibility is not a flagwise enumeration.-->  
...  
<Trigger Property="Visibility" Value="Collapsed,Hidden">  
  <Setter ... />  
</Trigger>  
...  
```  
  
 <span data-ttu-id="3c5d9-189">在 WPF 中，支持在 XAML 中可设置的属性的标记枚举很少见。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-189">Flagwise enumerations that support attributes that are settable in XAML are rare in WPF.</span></span> <span data-ttu-id="3c5d9-190">但是，此类枚举之一是<xref:System.Windows.Media.StyleSimulations>。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-190">However, one such enumeration is <xref:System.Windows.Media.StyleSimulations>.</span></span> <span data-ttu-id="3c5d9-191">例如，您可以使用逗号分隔的标记属性语法来修改<xref:System.Windows.Documents.Glyphs>类的备注中提供的示例;`StyleSimulations = "BoldSimulation"`可能变成`StyleSimulations = "BoldSimulation,ItalicSimulation"`。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-191">You could, for instance, use the comma-delimited flagwise attribute syntax to modify the example provided in the Remarks for the <xref:System.Windows.Documents.Glyphs> class; `StyleSimulations = "BoldSimulation"` could become `StyleSimulations = "BoldSimulation,ItalicSimulation"`.</span></span> <span data-ttu-id="3c5d9-192"><xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType>是另一个可以指定多个枚举值的属性。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-192"><xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType> is another property where more than one enumeration value can be specified.</span></span> <span data-ttu-id="3c5d9-193">但是，此属性恰好是一个特殊情况，因为<xref:System.Windows.Input.ModifierKeys>枚举支持其自己的类型转换器。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-193">However, this property happens to be a special case, because the <xref:System.Windows.Input.ModifierKeys> enumeration supports its own type converter.</span></span> <span data-ttu-id="3c5d9-194">修改器的类型转换器使用加号 （+） 作为分隔符而不是逗号 （，）。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-194">The type converter for modifiers uses a plus sign (+) as a delimiter rather than a comma (,).</span></span> <span data-ttu-id="3c5d9-195">此转换支持更传统的语法，以表示 Microsoft Windows 编程中的关键组合，例如"Ctrl_Alt"。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-195">This conversion supports the more traditional syntax to represent key combinations in Microsoft Windows programming, such as "Ctrl+Alt".</span></span>  
  
### <a name="properties-and-event-member-name-references"></a><span data-ttu-id="3c5d9-196">属性和事件成员名称引用</span><span class="sxs-lookup"><span data-stu-id="3c5d9-196">Properties and Event Member Name References</span></span>  
 <span data-ttu-id="3c5d9-197">指定属性时，可以引用作为为包含对象元素实例化的 CLR 类型的成员存在的任何属性或事件。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-197">When specifying an attribute, you can reference any property or event that exists as a member of the CLR type you instantiated for the containing object element.</span></span>  
  
 <span data-ttu-id="3c5d9-198">或者，您可以引用附加的属性或附加事件，而独立于包含的对象元素。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-198">Or, you can reference an attached property or attached event, independent of the containing object element.</span></span> <span data-ttu-id="3c5d9-199">（附加属性将在接下来的部分中讨论。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-199">(Attached properties are discussed in an upcoming section.)</span></span>  
  
 <span data-ttu-id="3c5d9-200">还可以使用*typeName*从可通过默认命名空间访问的任何对象命名任何事件。*事件*部分限定名称;此语法支持为路由事件附加处理程序，其中处理程序旨在处理来自子元素的事件路由，但父元素的成员表中也没有该事件。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-200">You can also name any event from any object that is accessible through the default namespace by using a *typeName*.*event* partially qualified name; this syntax supports attaching handlers for routed events where the handler is intended to handle events routing from child elements, but the parent element does not also have that event in its members table.</span></span> <span data-ttu-id="3c5d9-201">此语法类似于附加的事件语法，但此处的事件不是真正的附加事件。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-201">This syntax resembles an attached event syntax, but the event here is not a true attached event.</span></span> <span data-ttu-id="3c5d9-202">相反，您引用的事件具有限定名称。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-202">Instead, you are referencing an event with a qualified name.</span></span> <span data-ttu-id="3c5d9-203">有关详细信息，请参阅[路由事件概述](routed-events-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-203">For more information, see [Routed Events Overview](routed-events-overview.md).</span></span>  
  
 <span data-ttu-id="3c5d9-204">对于某些方案，属性名称有时作为属性的值提供，而不是属性名称。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-204">For some scenarios, property names are sometimes provided as the value of an attribute, rather than the attribute name.</span></span> <span data-ttu-id="3c5d9-205">该属性名称还可以包括限定符，例如窗体*所有者类型*中指定的属性。*属项属性名称*。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-205">That property name can also include qualifiers, such as the property specified in the form *ownerType*.*dependencyPropertyName*.</span></span> <span data-ttu-id="3c5d9-206">在 XAML 中编写样式或模板时，此方案很常见。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-206">This scenario is common when writing styles or templates in XAML.</span></span> <span data-ttu-id="3c5d9-207">作为属性值提供的属性名称的处理规则不同，并且受要设置的属性类型或特定 WPF 子系统的行为控制。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-207">The processing rules for property names provided as an attribute value are different, and are governed by the type of the property being set or by the behaviors of particular WPF subsystems.</span></span> <span data-ttu-id="3c5d9-208">有关详细信息，请参阅[样式和模板](../../../desktop-wpf/fundamentals/styles-templates-overview.md)化。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-208">For details, see [Styling and Templating](../../../desktop-wpf/fundamentals/styles-templates-overview.md).</span></span>  
  
 <span data-ttu-id="3c5d9-209">属性名称的另一个用法是属性值描述属性-属性关系时。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-209">Another usage for property names is when an attribute value describes a property-property relationship.</span></span> <span data-ttu-id="3c5d9-210">此功能用于数据绑定和情节提要目标，并且由<xref:System.Windows.PropertyPath>类及其类型转换器启用。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-210">This feature is used for data binding and for storyboard targets, and is enabled by the <xref:System.Windows.PropertyPath> class and its type converter.</span></span> <span data-ttu-id="3c5d9-211">有关查找语义的更完整说明，请参阅[属性路径 XAML 语法](propertypath-xaml-syntax.md)。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-211">For a more complete description of the lookup semantics, see [PropertyPath XAML Syntax](propertypath-xaml-syntax.md).</span></span>  
  
<a name="property_element_syntax"></a>
## <a name="property-element-syntax"></a><span data-ttu-id="3c5d9-212">属性元素语法</span><span class="sxs-lookup"><span data-stu-id="3c5d9-212">Property Element Syntax</span></span>  
 <span data-ttu-id="3c5d9-213">*属性元素语法*是一种语法，它在某种程度上与元素的基本 XML 语法规则不同。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-213">*Property element syntax* is a syntax that diverges somewhat from the basic XML syntax rules for elements.</span></span> <span data-ttu-id="3c5d9-214">在 XML 中，属性的值是事实字符串，唯一可能的变化是使用哪个字符串编码格式。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-214">In XML, the value of an attribute is a de facto string, with the only possible variation being which string encoding format is being used.</span></span> <span data-ttu-id="3c5d9-215">在 XAML 中，可以将其他对象元素指定为属性的值。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-215">In XAML, you can assign other object elements to be the value of a property.</span></span> <span data-ttu-id="3c5d9-216">此属性元素语法启用此功能。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-216">This capability is enabled by the property element syntax.</span></span> <span data-ttu-id="3c5d9-217">该属性使用*元素TypeName*中的打开元素标记指定该属性，而不是将属性指定为元素标记中的属性。*属性名称*窗体中，在 其中指定属性的值，然后关闭属性元素。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-217">Instead of the property being specified as an attribute within the element tag, the property is specified using an opening element tag in *elementTypeName*.*propertyName* form, the value of the property is specified within, and then the property element is closed.</span></span>  
  
 <span data-ttu-id="3c5d9-218">具体而言，语法以左角度括号 （）\<开头，紧接着是属性元素语法中包含的类或结构的类型名称。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-218">Specifically, the syntax begins with a left angle bracket (\<), followed immediately by the type name of the class or structure that the property element syntax is contained within.</span></span> <span data-ttu-id="3c5d9-219">紧接着是一个点 （.），然后是属性的名称，然后是直角括号 （>）。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-219">This is followed immediately by a single dot (.), then by the name of a property, then by a right angle bracket (>).</span></span> <span data-ttu-id="3c5d9-220">与属性语法一样，该属性必须存在于指定类型的已声明的公共成员中。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-220">As with attribute syntax, that property must exist within the declared public members of the specified type.</span></span> <span data-ttu-id="3c5d9-221">要分配给该属性的值包含在属性元素中。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-221">The value to be assigned to the property is contained within the property element.</span></span> <span data-ttu-id="3c5d9-222">通常，该值作为一个或多个对象元素给出，因为将对象指定为值是属性元素语法旨在解决的方案。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-222">Typically, the value is given as one or more object elements, because specifying objects as values is the scenario that property element syntax is intended to address.</span></span> <span data-ttu-id="3c5d9-223">最后，指定相同*元素TypeName*的等效结束标记。*属性名称*组合必须提供，以适当的嵌套和平衡与其他元素标记。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-223">Finally, an equivalent closing tag specifying the same *elementTypeName*.*propertyName* combination must be provided, in proper nesting and balance with other element tags.</span></span>  
  
 <span data-ttu-id="3c5d9-224">例如，以下是 属性的属性的属性元素语法<xref:System.Windows.FrameworkElement.ContextMenu%2A><xref:System.Windows.Controls.Button>。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-224">For example, the following is property element syntax for the <xref:System.Windows.FrameworkElement.ContextMenu%2A> property of a <xref:System.Windows.Controls.Button>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#ContextMenu](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#contextmenu)]  
  
 <span data-ttu-id="3c5d9-225">属性元素中的值也可以作为内部文本给出，在指定的属性类型为基元值类型的情况下，例如<xref:System.String>， 或指定名称的枚举。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-225">The value within a property element can also be given as inner text, in cases where the property type being specified is a primitive value type, such as <xref:System.String>, or an enumeration where a name is specified.</span></span> <span data-ttu-id="3c5d9-226">这两个用法有些不常见，因为每个情况都可以使用更简单的属性语法。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-226">These two usages are somewhat uncommon, because each of these cases could also use a simpler attribute syntax.</span></span> <span data-ttu-id="3c5d9-227">使用字符串填充属性元素的一个方案是，对于不是 XAML 内容属性但仍用于表示 UI 文本的属性，并且特定的空白元素（如行馈送）必须出现在该 UI 文本中。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-227">One scenario for filling a property element with a string is for properties that are not the XAML content property but still are used for representation of UI text, and particular white-space elements such as linefeeds are required to appear in that UI text.</span></span> <span data-ttu-id="3c5d9-228">属性语法无法保留行馈，但属性元素语法可以，只要显著的空白保留处于活动状态（有关详细信息，请参阅[XAML 中的空白处理](../../../desktop-wpf/xaml-services/white-space-processing.md)）。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-228">Attribute syntax cannot preserve linefeeds, but property element syntax can, so long as significant white-space preservation is active (for details, see [White space processing in XAML](../../../desktop-wpf/xaml-services/white-space-processing.md)).</span></span> <span data-ttu-id="3c5d9-229">另一种情况是[，x：Uid 指令](../../../desktop-wpf/xaml-services/xuid-directive.md)可以应用于属性元素，从而将 中的值标记为应在 WPF 输出 BAML 或其他技术中本地化的值。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-229">Another scenario is so that [x:Uid Directive](../../../desktop-wpf/xaml-services/xuid-directive.md) can be applied to the property element and thus mark the value within as a value that should be localized in the WPF output BAML or by other techniques.</span></span>  
  
 <span data-ttu-id="3c5d9-230">属性元素未在 WPF 逻辑树中表示。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-230">A property element is not represented in the WPF logical tree.</span></span> <span data-ttu-id="3c5d9-231">属性元素只是设置属性的特定语法，而不是具有实例或对象支持它的元素。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-231">A property element is just a particular syntax for setting a property, and is not an element that has an instance or object backing it.</span></span> <span data-ttu-id="3c5d9-232">（有关逻辑树概念的详细信息，请参阅[WPF 中的树](trees-in-wpf.md)。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-232">(For details on the logical tree concept, see [Trees in WPF](trees-in-wpf.md).)</span></span>  
  
 <span data-ttu-id="3c5d9-233">对于同时支持属性和属性元素语法的属性，这两种语法通常具有相同的结果，尽管空格处理等细微之处在语法之间可能略有不同。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-233">For properties where both attribute and property element syntax are supported, the two syntaxes generally have the same result, although subtleties such as white-space handling can vary slightly between syntaxes.</span></span>  
  
<a name="collection_syntax"></a>
## <a name="collection-syntax"></a><span data-ttu-id="3c5d9-234">集合语法</span><span class="sxs-lookup"><span data-stu-id="3c5d9-234">Collection Syntax</span></span>  
 <span data-ttu-id="3c5d9-235">XAML 规范要求 XAML 处理器实现标识值类型为集合的属性。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-235">The XAML specification requires XAML processor implementations to identify properties where the value type is a collection.</span></span> <span data-ttu-id="3c5d9-236">.NET 中的常规 XAML 处理器实现基于托管代码和 CLR，它通过以下之一标识集合类型：</span><span class="sxs-lookup"><span data-stu-id="3c5d9-236">The general XAML processor implementation in .NET is based on managed code and the CLR, and it identifies collection types through one of the following:</span></span>  
  
- <span data-ttu-id="3c5d9-237">类型实现<xref:System.Collections.IList>。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-237">Type implements <xref:System.Collections.IList>.</span></span>  
  
- <span data-ttu-id="3c5d9-238">类型实现<xref:System.Collections.IDictionary>。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-238">Type implements <xref:System.Collections.IDictionary>.</span></span>  
  
- <span data-ttu-id="3c5d9-239">类型派生自<xref:System.Array>（有关 XAML 中的数组的详细信息，请参阅[x：数组标记扩展](../../../desktop-wpf/xaml-services/xarray-markup-extension.md)。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-239">Type derives from <xref:System.Array> (for more information about arrays in XAML, see [x:Array Markup Extension](../../../desktop-wpf/xaml-services/xarray-markup-extension.md).)</span></span>  
  
 <span data-ttu-id="3c5d9-240">如果属性的类型是集合，则推断的集合类型不需要在标记中指定为对象元素。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-240">If the type of a property is a collection, then the inferred collection type does not need to be specified in the markup as an object element.</span></span> <span data-ttu-id="3c5d9-241">相反，打算成为集合中的项的元素被指定为属性元素的一个或多个子元素。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-241">Instead, the elements that are intended to become the items in the collection are specified as one or more child elements of the property element.</span></span> <span data-ttu-id="3c5d9-242">每个此类项在加载期间计算到对象，并通过调用隐含集合`Add`的方法添加到集合中。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-242">Each such item is evaluated to an object during loading and added to the collection by calling the `Add` method of the implied collection.</span></span> <span data-ttu-id="3c5d9-243">例如， 的<xref:System.Windows.Style.Triggers%2A><xref:System.Windows.Style>属性采用专用集合类型<xref:System.Windows.TriggerCollection>， 实现<xref:System.Collections.IList>。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-243">For example, the <xref:System.Windows.Style.Triggers%2A> property of <xref:System.Windows.Style> takes the specialized collection type <xref:System.Windows.TriggerCollection>, which implements <xref:System.Collections.IList>.</span></span> <span data-ttu-id="3c5d9-244">不必实例化标记中<xref:System.Windows.TriggerCollection>的对象元素。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-244">It is not necessary to instantiate a <xref:System.Windows.TriggerCollection> object element in the markup.</span></span> <span data-ttu-id="3c5d9-245"><xref:System.Windows.Trigger>相反，您将一个或多个项指定为`Style.Triggers`属性元素中的元素，其中<xref:System.Windows.Trigger>（或派生类）是强烈键入和隐式<xref:System.Windows.TriggerCollection>中的项类型所需的类型。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-245">Instead, you specify one or more <xref:System.Windows.Trigger> items as elements within the `Style.Triggers` property element, where <xref:System.Windows.Trigger> (or a derived class) is the type expected as the item type for the strongly typed and implicit <xref:System.Windows.TriggerCollection>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxPECollection](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#syntaxpecollection)]  
  
 <span data-ttu-id="3c5d9-246">属性可以是集合类型，也可以是该类型和派生类型的 XAML 内容属性，本主题的下一部分将对此进行讨论。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-246">A property may be both a collection type and the XAML content property for that type and derived types, which is discussed in the next section of this topic.</span></span>  
  
 <span data-ttu-id="3c5d9-247">隐式集合元素在逻辑树表示形式中创建成员，即使它不作为元素出现在标记中。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-247">An implicit collection element creates a member in the logical tree representation, even though it does not appear in the markup as an element.</span></span> <span data-ttu-id="3c5d9-248">通常，父类型的构造函数对其属性之一的集合执行实例化，并且最初空集合将成为对象树的一部分。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-248">Usually the constructor of the parent type performs the instantiation for the collection that is one of its properties, and the initially empty collection becomes part of the object tree.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="3c5d9-249">泛型列表和字典接口<xref:System.Collections.Generic.IList%601>（<xref:System.Collections.Generic.IDictionary%602>和 ） 不支持用于集合检测。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-249">The generic list and dictionary interfaces (<xref:System.Collections.Generic.IList%601> and <xref:System.Collections.Generic.IDictionary%602>) are not supported for collection detection.</span></span> <span data-ttu-id="3c5d9-250">但是，您可以将<xref:System.Collections.Generic.List%601>类用作基类，因为它直接实现<xref:System.Collections.IList>，或者<xref:System.Collections.Generic.Dictionary%602>作为基类实现，因为它直接实现。 <xref:System.Collections.IDictionary></span><span class="sxs-lookup"><span data-stu-id="3c5d9-250">However, you can use the <xref:System.Collections.Generic.List%601> class as a base class, because it implements <xref:System.Collections.IList> directly, or <xref:System.Collections.Generic.Dictionary%602> as a base class, because it implements <xref:System.Collections.IDictionary> directly.</span></span>  
  
 <span data-ttu-id="3c5d9-251">在集合类型的 .NET 参考页中，在 XAML 语法部分中偶尔会将此语法与集合对象元素的故意省略记录称为隐式集合语法。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-251">In the .NET Reference pages for collection types, this syntax with the deliberate omission of the object element for a collection is occasionally noted in the XAML syntax sections as Implicit Collection Syntax.</span></span>  
  
 <span data-ttu-id="3c5d9-252">除根元素外，作为另一个元素的子元素嵌套的 XAML 文件中的每个对象元素实际上是一个元素，它是以下一种情况之一或两种情况：其父元素的隐式集合属性的成员，或指定父元素 XAML 内容属性值的元素（XAML 内容属性将在下一节中讨论）。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-252">With the exception of the root element, every object element in a XAML file that is nested as a child element of another element is really an element that is one or both of the following cases: a member of an implicit collection property of its parent element, or an element that specifies the value of the XAML content property for the parent element (XAML content properties will be discussed in an upcoming section).</span></span> <span data-ttu-id="3c5d9-253">换句话说，标记页中的父元素和子元素的关系实际上是根上的单个对象，根下方的每个对象元素要么是提供父项属性值的单个实例，要么是集合中的项之一，也是父级的集合类型属性值。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-253">In other words, the relationship of parent elements and child elements in a markup page is really a single object at the root, and every object element beneath the root is either a single instance that provides a property value of the parent, or one of the items within a collection that is also a collection-type property value of the parent.</span></span> <span data-ttu-id="3c5d9-254">这种单根概念在 XML 中很常见，并且在加载 XAML（如<xref:System.Windows.Markup.XamlReader.Load%2A>） 的 API 行为中经常被强化。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-254">This single-root concept is common with XML, and is frequently reinforced in the behavior of APIs that load XAML such as <xref:System.Windows.Markup.XamlReader.Load%2A>.</span></span>  
  
 <span data-ttu-id="3c5d9-255">下面的示例是显式指定的集合的对象元素 （<xref:System.Windows.Media.GradientStopCollection>的语法。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-255">The following example is a syntax with the object element for a collection (<xref:System.Windows.Media.GradientStopCollection>) specified explicitly.</span></span>  
  
```xaml  
<LinearGradientBrush>  
  <LinearGradientBrush.GradientStops>  
    <GradientStopCollection>  
      <GradientStop Offset="0.0" Color="Red" />  
      <GradientStop Offset="1.0" Color="Blue" />  
    </GradientStopCollection>  
  </LinearGradientBrush.GradientStops>  
</LinearGradientBrush>  
```  
  
 <span data-ttu-id="3c5d9-256">请注意，并不总是可以显式声明集合。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-256">Note that it is not always possible to explicitly declare the collection.</span></span> <span data-ttu-id="3c5d9-257">例如，尝试在前面显示<xref:System.Windows.TriggerCollection><xref:System.Windows.Style.Triggers%2A>的示例中显式声明将失败。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-257">For instance, attempting to declare <xref:System.Windows.TriggerCollection> explicitly in the previously shown <xref:System.Windows.Style.Triggers%2A> example would fail.</span></span> <span data-ttu-id="3c5d9-258">显式声明集合要求集合类必须支持无参数构造函数，并且<xref:System.Windows.TriggerCollection>没有无参数构造函数。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-258">Explicitly declaring the collection requires that the collection class must support a parameterless constructor, and <xref:System.Windows.TriggerCollection> does not have a parameterless constructor.</span></span>  
  
<a name="xaml_content_properties"></a>
## <a name="xaml-content-properties"></a><span data-ttu-id="3c5d9-259">XAML 内容属性</span><span class="sxs-lookup"><span data-stu-id="3c5d9-259">XAML Content Properties</span></span>  
 <span data-ttu-id="3c5d9-260">XAML 内容语法是仅在指定<xref:System.Windows.Markup.ContentPropertyAttribute>作为类声明的一部分的类上启用的语法。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-260">XAML content syntax is a syntax that is only enabled on classes that specify the <xref:System.Windows.Markup.ContentPropertyAttribute> as part of their class declaration.</span></span> <span data-ttu-id="3c5d9-261">引用<xref:System.Windows.Markup.ContentPropertyAttribute>作为该类型元素（包括派生类）的内容属性的属性名称。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-261">The <xref:System.Windows.Markup.ContentPropertyAttribute> references the property name that is the content property for that type of element (including derived classes).</span></span> <span data-ttu-id="3c5d9-262">当 XAML 处理器处理时，对象元素的打开和关闭标记之间找到的任何子元素或内部文本都将分配为该对象的 XAML 内容属性的值。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-262">When processed by a XAML processor, any child elements or inner text that are found between the opening and closing tags of the object element will be assigned to be the value of the XAML content property for that object.</span></span> <span data-ttu-id="3c5d9-263">允许为内容属性指定显式属性元素，但此用法通常不显示在 .NET 引用中的 XAML 语法部分中。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-263">You are permitted to specify explicit property elements for the content property, but this usage is not generally shown in the XAML syntax sections in the .NET reference.</span></span> <span data-ttu-id="3c5d9-264">显式/详细技术偶尔对标记清晰度或标记样式具有价值，但内容属性通常旨在简化标记，以便可以直接嵌套与父子关系且直观相关的元素。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-264">The explicit/verbose technique has occasional value for markup clarity or as a matter of markup style, but usually the intent of a content property is to streamline the markup so that elements that are intuitively related as parent-child can be nested directly.</span></span> <span data-ttu-id="3c5d9-265">根据严格的 XAML 语言定义，元素上其他属性的属性元素标记不会指定为"内容";因此，根据严格的 XAML 语言定义，元素的属性元素标记不会指定为"内容";它们以前在 XAML 解析器的处理顺序中处理，不被视为"内容"。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-265">Property element tags for other properties on an element are not assigned as "content" per a strict XAML language definition; they are processed previously in the XAML parser's processing order and are not considered to be "content".</span></span>  
  
### <a name="xaml-content-property-values-must-be-contiguous"></a><span data-ttu-id="3c5d9-266">XAML 内容属性值必须是连续的</span><span class="sxs-lookup"><span data-stu-id="3c5d9-266">XAML Content Property Values Must Be Contiguous</span></span>  
 <span data-ttu-id="3c5d9-267">XAML 内容属性的值必须完全放在该对象元素上的任何其他属性元素之前或完全之后。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-267">The value of a XAML content property must be given either entirely before or entirely after any other property elements on that object element.</span></span> <span data-ttu-id="3c5d9-268">无论 XAML 内容属性的值指定为字符串，还是指定为一个或多个对象，都是如此。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-268">This is true whether the value of a XAML content property is specified as a string, or as one or more objects.</span></span> <span data-ttu-id="3c5d9-269">例如，以下标记不解析：</span><span class="sxs-lookup"><span data-stu-id="3c5d9-269">For example, the following markup does not parse:</span></span>  
  
```xaml  
<Button>I am a
  <Button.Background>Blue</Button.Background>  
  blue button</Button>  
```  
  
 <span data-ttu-id="3c5d9-270">这是非法的，主要是因为如果使用属性元素语法对内容属性显式进行此语法，则内容属性将设置两次：</span><span class="sxs-lookup"><span data-stu-id="3c5d9-270">This is illegal essentially because if this syntax were made explicit by using property element syntax for the content property, then the content property would be set twice:</span></span>  
  
```xaml  
<Button>  
  <Button.Content>I am a </Button.Content>  
  <Button.Background>Blue</Button.Background>  
  <Button.Content> blue button</Button.Content>  
</Button>  
```  
  
 <span data-ttu-id="3c5d9-271">同样非法的示例是，如果内容属性是集合，并且子元素与属性元素交织在一起：</span><span class="sxs-lookup"><span data-stu-id="3c5d9-271">A similarly illegal example is if the content property is a collection, and child elements are interspersed with property elements:</span></span>  
  
```xaml  
<StackPanel>  
  <Button>This example</Button>  
  <StackPanel.Resources>  
    <SolidColorBrush x:Key="BlueBrush" Color="Blue"/>  
  </StackPanel.Resources>  
  <Button>... is illegal XAML</Button>  
</StackPanel>  
```  
  
<a name="content_properties_and_collection_syntax_combined"></a>
## <a name="content-properties-and-collection-syntax-combined"></a><span data-ttu-id="3c5d9-272">内容属性和集合语法组合</span><span class="sxs-lookup"><span data-stu-id="3c5d9-272">Content Properties and Collection Syntax Combined</span></span>  
 <span data-ttu-id="3c5d9-273">为了接受多个对象元素作为内容，内容属性的类型必须特别为集合类型。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-273">In order to accept more than a single object element as content, the type of the content property must specifically be a collection type.</span></span> <span data-ttu-id="3c5d9-274">与集合类型的属性元素语法类似，XAML 处理器必须标识集合类型的类型。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-274">Similar to property element syntax for collection types, a XAML processor must identify types that are collection types.</span></span> <span data-ttu-id="3c5d9-275">如果元素具有 XAML 内容属性，并且 XAML 内容属性的类型是集合，则隐含集合类型不需要在标记中指定为对象元素，并且不需要将 XAML 内容属性指定为属性元素。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-275">If an element has a XAML content property and the type of the XAML content property is a collection, then the implied collection type does not need to be specified in the markup as an object element and the XAML content property does not need to be specified as a property element.</span></span> <span data-ttu-id="3c5d9-276">因此，标记中的明显内容模型现在可以将多个子元素指定为内容。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-276">Therefore the apparent content model in the markup can now have more than one child element assigned as the content.</span></span> <span data-ttu-id="3c5d9-277">以下是<xref:System.Windows.Controls.Panel>派生类的内容语法。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-277">The following is content syntax for a <xref:System.Windows.Controls.Panel> derived class.</span></span> <span data-ttu-id="3c5d9-278">所有<xref:System.Windows.Controls.Panel>派生类都建立 XAML 内容属性<xref:System.Windows.Controls.Panel.Children%2A>，这需要 类型的<xref:System.Windows.Controls.UIElementCollection>值 。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-278">All <xref:System.Windows.Controls.Panel> derived classes establish the XAML content property to be <xref:System.Windows.Controls.Panel.Children%2A>, which requires a value of type <xref:System.Windows.Controls.UIElementCollection>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxContent](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page5.xaml#syntaxcontent)]  
  
 <span data-ttu-id="3c5d9-279">请注意，标记中既不需要<xref:System.Windows.Controls.Panel.Children%2A>属性元素，也<xref:System.Windows.Controls.UIElementCollection>不需要 元素的元素。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-279">Note that neither the property element for <xref:System.Windows.Controls.Panel.Children%2A> nor the element for the <xref:System.Windows.Controls.UIElementCollection> is required in the markup.</span></span> <span data-ttu-id="3c5d9-280">这是 XAML 的设计功能，因此，在不影响属性元素标记或集合对象的情况下，[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]可以更直观地将定义 定义的 元素表示为具有直接父子元素关系的嵌套元素树。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-280">This is a design feature of XAML so that recursively contained elements that define a [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] are more intuitively represented as a tree of nested elements with immediate parent-child element relationships, without intervening property element tags or collection objects.</span></span> <span data-ttu-id="3c5d9-281">事实上，<xref:System.Windows.Controls.UIElementCollection>无法在标记中显式指定为对象元素。设计。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-281">In fact, <xref:System.Windows.Controls.UIElementCollection> cannot be specified explicitly in markup as an object element, by design.</span></span> <span data-ttu-id="3c5d9-282">因为它的唯一用途是作为隐式集合，<xref:System.Windows.Controls.UIElementCollection>因此不会公开公共无参数构造函数，因此不能实例化为对象元素。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-282">Because its only intended use is as an implicit collection, <xref:System.Windows.Controls.UIElementCollection> does not expose a public parameterless constructor and thus cannot be instantiated as an object element.</span></span>  
  
### <a name="mixing-property-elements-and-object-elements-in-an-object-with-a-content-property"></a><span data-ttu-id="3c5d9-283">将对象中的属性元素和对象元素与内容属性混合</span><span class="sxs-lookup"><span data-stu-id="3c5d9-283">Mixing Property Elements and Object Elements in an Object with a Content Property</span></span>  
 <span data-ttu-id="3c5d9-284">XAML 规范声明 XAML 处理器可以强制用于填充对象元素中的 XAML 内容属性的对象元素必须是连续的，并且不能混合。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-284">The XAML specification declares that a XAML processor can enforce that object elements that are used to fill the XAML content property within an object element must be contiguous, and must not be mixed.</span></span> <span data-ttu-id="3c5d9-285">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML 处理器强制执行了对混合属性元素和内容的限制。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-285">This restriction against mixing property elements and content is enforced by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML processors.</span></span>  
  
 <span data-ttu-id="3c5d9-286">可以将子对象元素作为对象元素中的第一个直接标记。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-286">You can have a child object element as the first immediate markup within an object element.</span></span> <span data-ttu-id="3c5d9-287">然后，您可以引入属性元素。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-287">Then you can introduce property elements.</span></span> <span data-ttu-id="3c5d9-288">或者，您可以指定一个或多个属性元素，然后指定内容，然后指定更多属性元素。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-288">Or, you can specify one or more property elements, then content, then more property elements.</span></span> <span data-ttu-id="3c5d9-289">但是，一旦属性元素遵循内容，您就不能引入任何进一步的内容，您只能添加属性元素。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-289">But once a property element follows content, you cannot introduce any further content, you can only add property elements.</span></span>  
  
 <span data-ttu-id="3c5d9-290">此内容/属性元素顺序要求不适用于用作内容的内部文本。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-290">This content / property element order requirement does not apply to inner text used as content.</span></span> <span data-ttu-id="3c5d9-291">但是，保持内部文本连续仍然是一种良好的标记样式，因为如果属性元素与内部文本交织在一起，则很难在标记中直观地检测到显著的空白。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-291">However, it is still a good markup style to keep inner text contiguous, because significant white space will be difficult to detect visually in the markup if property elements are interspersed with inner text.</span></span>  
  
<a name="xaml_namespaces"></a>
## <a name="xaml-namespaces"></a><span data-ttu-id="3c5d9-292">XAML 命名空间</span><span class="sxs-lookup"><span data-stu-id="3c5d9-292">XAML Namespaces</span></span>  
 <span data-ttu-id="3c5d9-293">前面的语法示例均未指定 XAML 命名空间，而不是默认的 XAML 命名空间。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-293">None of the preceding syntax examples specified a XAML namespace other than the default XAML namespace.</span></span> <span data-ttu-id="3c5d9-294">在典型的[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]应用程序中，默认 XAML 命名空间指定为[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]命名空间。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-294">In typical [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, the default XAML namespace is specified to be the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] namespace.</span></span> <span data-ttu-id="3c5d9-295">您可以指定默认 XAML 命名空间以外的 XAML 命名空间，并且仍然使用类似的语法。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-295">You can specify XAML namespaces other than the default XAML namespace and still use similar syntax.</span></span> <span data-ttu-id="3c5d9-296">但是，在命名在默认 XAML 命名空间中无法访问的类的任何地方，该类名称必须前面加上映射到相应 CLR 命名空间的 XAML 命名空间的前缀。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-296">But then, anywhere where a class is named that is not accessible within the default XAML namespace, that class name must be preceded with the prefix of the XAML namespace as mapped to the corresponding CLR namespace.</span></span> <span data-ttu-id="3c5d9-297">例如，`<custom:Example/>`对象元素语法用于实例化`Example`类的实例，其中包含该类的 CLR 命名空间（可能还有包含支持类型的外部程序集信息）以前映射到`custom`前缀。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-297">For example, `<custom:Example/>` is object element syntax to instantiate an instance of the `Example` class, where the CLR namespace containing that class (and possibly the external assembly information that contains backing types) was previously mapped to the `custom` prefix.</span></span>  
  
 <span data-ttu-id="3c5d9-298">有关 XAML 命名空间的详细信息，请参阅[WPF XAML 的 XAML 命名空间和命名空间映射](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-298">For more information about XAML namespaces, see [XAML Namespaces and Namespace Mapping for WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span></span>  
  
<a name="markup_extensions"></a>
## <a name="markup-extensions"></a><span data-ttu-id="3c5d9-299">标记扩展</span><span class="sxs-lookup"><span data-stu-id="3c5d9-299">Markup Extensions</span></span>  
 <span data-ttu-id="3c5d9-300">XAML 定义了标记扩展编程实体，该实体允许从字符串属性值或对象元素的正常 XAML 处理器处理中转义，并将处理延迟到备份类。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-300">XAML defines a markup extension programming entity that enables an escape from the normal XAML processor handling of string attribute values or object elements, and defers the processing to a backing class.</span></span> <span data-ttu-id="3c5d9-301">使用属性语法时标识 XAML 处理器的标记扩展的字符是首角大括号 （*），后跟关闭大括号 （*） 以外的任何字符。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-301">The character that identifies a markup extension to a XAML processor when using attribute syntax is the opening curly brace ({), followed by any character other than a closing curly brace (}).</span></span> <span data-ttu-id="3c5d9-302">开头大括号后的第一个字符串必须引用提供特定扩展行为的类，如果该子字符串是真实类名称的一部分，则引用可能会省略子字符串"扩展"。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-302">The first string following the opening curly brace must reference the class that provides the particular extension behavior, where the reference may omit the substring "Extension" if that substring is part of the true class name.</span></span> <span data-ttu-id="3c5d9-303">此后，可能会出现单个空格，然后每个后续字符都用作扩展实现的输入，直到遇到关闭的大括号。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-303">Thereafter, a single space may appear, and then each succeeding character is used as input by the extension implementation, up until the closing curly brace is encountered.</span></span>  
  
 <span data-ttu-id="3c5d9-304">.NET XAML 实现使用<xref:System.Windows.Markup.MarkupExtension>抽象类作为其他[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]框架或技术支持的所有标记扩展的基础。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-304">The .NET XAML implementation uses the <xref:System.Windows.Markup.MarkupExtension> abstract class as the basis for all of the markup extensions supported by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] as well as other frameworks or technologies.</span></span> <span data-ttu-id="3c5d9-305">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]专门实现的标记扩展通常旨在提供引用其他现有对象的方法，或对将在运行时计算的对象进行延迟引用。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-305">The markup extensions that [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] specifically implements are often intended to provide a means to reference other existing objects, or to make deferred references to objects that will be evaluated at run time.</span></span> <span data-ttu-id="3c5d9-306">例如，通过指定`{Binding}`标记扩展代替特定属性通常采用的值来完成简单的 WPF 数据绑定。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-306">For example, a simple WPF data binding is accomplished by specifying the `{Binding}` markup extension in place of the value that a particular property would ordinarily take.</span></span> <span data-ttu-id="3c5d9-307">许多 WPF 标记扩展为无法进行属性语法的属性启用属性语法。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-307">Many of the WPF markup extensions enable an attribute syntax for properties where an attribute syntax would not otherwise be possible.</span></span> <span data-ttu-id="3c5d9-308">例如，<xref:System.Windows.Style>对象是一种相对复杂的类型，包含嵌套的对象和属性系列。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-308">For example, a <xref:System.Windows.Style> object is a relatively complex type that contains a nested series of objects and properties.</span></span> <span data-ttu-id="3c5d9-309">WPF 中的样式通常定义为<xref:System.Windows.ResourceDictionary>中的资源，然后通过请求资源的两个 WPF 标记扩展之一引用。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-309">Styles in WPF are typically defined as a resource in a <xref:System.Windows.ResourceDictionary>, and then referenced through one of the two WPF markup extensions that request a resource.</span></span> <span data-ttu-id="3c5d9-310">标记扩展将属性值的计算延迟到资源查找，并启用在属性语法中提供<xref:System.Windows.FrameworkElement.Style%2A>属性的值，采用类型<xref:System.Windows.Style>，如以下示例所示：</span><span class="sxs-lookup"><span data-stu-id="3c5d9-310">The markup extension defers the evaluation of the property value to a resource lookup and enables providing the value of the <xref:System.Windows.FrameworkElement.Style%2A> property, taking type <xref:System.Windows.Style>, in attribute syntax as in the following example:</span></span>  
  
 `<Button Style="{StaticResource MyStyle}">My button</Button>`  
  
 <span data-ttu-id="3c5d9-311">此处，`StaticResource`标识提供标记<xref:System.Windows.StaticResourceExtension>扩展实现的类。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-311">Here, `StaticResource` identifies the <xref:System.Windows.StaticResourceExtension> class providing the markup extension implementation.</span></span> <span data-ttu-id="3c5d9-312">下一个`MyStyle`字符串用作非默认<xref:System.Windows.StaticResourceExtension>构造函数的输入，其中从扩展字符串获取的参数声明请求<xref:System.Windows.ResourceKey>的 。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-312">The next string `MyStyle` is used as the input for the non-default <xref:System.Windows.StaticResourceExtension> constructor, where the parameter as taken from the extension string declares the requested <xref:System.Windows.ResourceKey>.</span></span> <span data-ttu-id="3c5d9-313">`MyStyle`应为<xref:System.Windows.Style>定义为资源的[x：键](../../../desktop-wpf/xaml-services/xkey-directive.md)值。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-313">`MyStyle` is expected to be the [x:Key](../../../desktop-wpf/xaml-services/xkey-directive.md) value of a <xref:System.Windows.Style> defined as a resource.</span></span> <span data-ttu-id="3c5d9-314">[静态资源标记扩展](staticresource-markup-extension.md)使用请求使用资源在加载时通过静态资源查找逻辑<xref:System.Windows.Style>提供属性值。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-314">The [StaticResource Markup Extension](staticresource-markup-extension.md) usage requests that the resource be used to provide the <xref:System.Windows.Style> property value through static resource lookup logic at load time.</span></span>  
  
 <span data-ttu-id="3c5d9-315">有关标记扩展的详细信息，请参阅[标记扩展和 WPF XAML](markup-extensions-and-wpf-xaml.md)。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-315">For more information about markup extensions, see [Markup Extensions and WPF XAML](markup-extensions-and-wpf-xaml.md).</span></span> <span data-ttu-id="3c5d9-316">有关在常规 .NET XAML 实现中启用的标记扩展和其他 XAML 编程功能的引用，请参阅[XAML 命名空间 （x：）语言功能](../../../desktop-wpf/xaml-services/namespace-language-features.md).</span><span class="sxs-lookup"><span data-stu-id="3c5d9-316">For a reference of markup extensions and other XAML programming features enabled in the general .NET XAML implementation, see [XAML Namespace (x:) Language Features](../../../desktop-wpf/xaml-services/namespace-language-features.md).</span></span> <span data-ttu-id="3c5d9-317">有关特定于 WPF 的标记扩展，请参阅[WPF XAML 扩展](wpf-xaml-extensions.md)。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-317">For WPF-specific markup extensions, see [WPF XAML Extensions](wpf-xaml-extensions.md).</span></span>  
  
<a name="attached_properties"></a>
## <a name="attached-properties"></a><span data-ttu-id="3c5d9-318">附加属性</span><span class="sxs-lookup"><span data-stu-id="3c5d9-318">Attached Properties</span></span>  
 <span data-ttu-id="3c5d9-319">附加属性是在 XAML 中引入的编程概念，根据该概念，属性可以由特定类型拥有和定义，但设置为任何元素的属性或属性元素。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-319">Attached properties are a programming concept introduced in XAML whereby properties can be owned and defined by a particular type, but set as attributes or property elements on any element.</span></span> <span data-ttu-id="3c5d9-320">附加属性的主要方案是使标记结构中的子元素能够将信息报告给父元素，而无需跨所有元素进行广泛共享的对象模型。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-320">The primary scenario that attached properties are intended for is to enable child elements in a markup structure to report information to a parent element without requiring an extensively shared object model across all elements.</span></span> <span data-ttu-id="3c5d9-321">相反，父元素可以使用附加属性向子元素报告信息。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-321">Conversely, attached properties can be used by parent elements to report information to child elements.</span></span> <span data-ttu-id="3c5d9-322">有关附加属性的用途以及如何创建自己的附加属性的详细信息，请参阅[附加属性概述](attached-properties-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-322">For more information on the purpose of attached properties and how to create your own attached properties, see [Attached Properties Overview](attached-properties-overview.md).</span></span>  
  
 <span data-ttu-id="3c5d9-323">附加属性使用表面上类似于属性元素语法的语法，因为您还指定了*typeName*。*属性名称*组合。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-323">Attached properties use a syntax that superficially resembles property element syntax, in that you also specify a *typeName*.*propertyName* combination.</span></span> <span data-ttu-id="3c5d9-324">有两个重要的差异：</span><span class="sxs-lookup"><span data-stu-id="3c5d9-324">There are two important differences:</span></span>  
  
- <span data-ttu-id="3c5d9-325">您可以使用*类型名称*。*属性名称*组合，即使通过属性语法设置附加属性也是如此。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-325">You can use the *typeName*.*propertyName* combination even when setting an attached property through attribute syntax.</span></span> <span data-ttu-id="3c5d9-326">附加属性是唯一限定属性名称是属性语法中的要求。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-326">Attached properties are the only case where qualifying the property name is a requirement in an attribute syntax.</span></span>  
  
- <span data-ttu-id="3c5d9-327">还可以对附加属性使用属性元素语法。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-327">You can also use property element syntax for attached properties.</span></span> <span data-ttu-id="3c5d9-328">但是，对于典型的属性元素语法，指定的*类型Name*是包含属性元素的对象元素。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-328">However, for typical property element syntax, the *typeName* you specify is the object element that contains the property element.</span></span> <span data-ttu-id="3c5d9-329">如果引用附加属性，则*typeName*是定义附加属性的类，而不是包含的对象元素。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-329">If you are referring to an attached property, then the *typeName* is the class that defines the attached property, not the containing object element.</span></span>  
  
<a name="attached_events"></a>
## <a name="attached-events"></a><span data-ttu-id="3c5d9-330">附加事件</span><span class="sxs-lookup"><span data-stu-id="3c5d9-330">Attached Events</span></span>  
 <span data-ttu-id="3c5d9-331">附加事件是在 XAML 中引入的另一个编程概念，其中事件可以由特定类型定义，但处理程序可以附加到任何对象元素上。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-331">Attached events are another programming concept introduced in XAML where events can be defined by a specific type, but handlers may be attached on any object element.</span></span> <span data-ttu-id="3c5d9-332">在 WOF 实现中，定义附加事件的类型通常是定义服务的静态类型，有时这些附加事件由公开服务类型的路由事件别名公开。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-332">In the WOF implementation, often the type that defines an attached event is a static type that defines a service, and sometimes those attached events are exposed by a routed event alias in types that expose the service.</span></span> <span data-ttu-id="3c5d9-333">附加事件的处理程序通过属性语法指定。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-333">Handlers for attached events are specified through attribute syntax.</span></span> <span data-ttu-id="3c5d9-334">与附加事件一样，附加事件的属性语法将展开，以允许*typeName*。*事件名称*用法，其中*类型名称*是为附加的事件`Add`基础结构`Remove`提供和事件处理程序访问器的类，*事件名称*是事件名称。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-334">As with attached events, the attribute syntax is expanded for attached events to allow a *typeName*.*eventName* usage, where *typeName* is the class that provides `Add` and `Remove` event handler accessors for the attached event infrastructure, and *eventName* is the event name.</span></span>  
  
<a name="anatomy_of_a_xaml_page_root_element"></a>
## <a name="anatomy-of-a-xaml-root-element"></a><span data-ttu-id="3c5d9-335">XAML 根元素的剖析</span><span class="sxs-lookup"><span data-stu-id="3c5d9-335">Anatomy of a XAML Root Element</span></span>  
 <span data-ttu-id="3c5d9-336">下表显示了分解的典型 XAML 根元素，显示了根元素的特定属性：</span><span class="sxs-lookup"><span data-stu-id="3c5d9-336">The following table shows a typical XAML root element broken down, showing the specific attributes of a root element:</span></span>  
  
|||  
|-|-|  
|`<Page`|<span data-ttu-id="3c5d9-337">打开根元素的对象元素</span><span class="sxs-lookup"><span data-stu-id="3c5d9-337">Opening object element of the root element</span></span>|  
|`xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"`|<span data-ttu-id="3c5d9-338">默认 （[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]） XAML 命名空间</span><span class="sxs-lookup"><span data-stu-id="3c5d9-338">The default ([!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]) XAML namespace</span></span>|  
|`xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"`|<span data-ttu-id="3c5d9-339">XAML 语言 XAML 命名空间</span><span class="sxs-lookup"><span data-stu-id="3c5d9-339">The XAML language XAML namespace</span></span>|  
|`x:Class="ExampleNamespace.ExampleCode"`|<span data-ttu-id="3c5d9-340">将标记连接到为部分类定义的任何代码后面的任何部分类声明</span><span class="sxs-lookup"><span data-stu-id="3c5d9-340">The partial class declaration that connects markup to any code-behind defined for the partial class</span></span>|  
|`>`|<span data-ttu-id="3c5d9-341">根对象元素的结束。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-341">End of object element for the root.</span></span> <span data-ttu-id="3c5d9-342">对象尚未关闭，因为元素包含子元素</span><span class="sxs-lookup"><span data-stu-id="3c5d9-342">Object is not closed yet because the element contains child elements</span></span>|  
  
<a name="optional_and_nonrecommended_xaml_usages"></a>
## <a name="optional-and-nonrecommended-xaml-usages"></a><span data-ttu-id="3c5d9-343">可选和非推荐的 XAML 用法</span><span class="sxs-lookup"><span data-stu-id="3c5d9-343">Optional and Nonrecommended XAML Usages</span></span>  
 <span data-ttu-id="3c5d9-344">以下各节介绍 XAML 处理器在技术上支持的 XAML 用法，但会产生详细性或其他美学问题，干扰在开发包含 XAML 源的应用程序时保持人类可读的 XAML 文件。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-344">The following sections describe XAML usages that are technically supported by XAML processors, but that produce verbosity or other aesthetic issues that interfere with XAML files remaining human-readable when you develop applications that contain XAML sources.</span></span>  
  
### <a name="optional-property-element-usages"></a><span data-ttu-id="3c5d9-345">可选属性元素用法</span><span class="sxs-lookup"><span data-stu-id="3c5d9-345">Optional Property Element Usages</span></span>  
 <span data-ttu-id="3c5d9-346">可选属性元素用法包括显式写入 XAML 处理器认为隐式的元素内容属性。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-346">Optional property element usages include explicitly writing out element content properties that the XAML processor considers implicit.</span></span> <span data-ttu-id="3c5d9-347">例如，当您声明 的内容时<xref:System.Windows.Controls.Menu>，可以选择显式声明 集合<xref:System.Windows.Controls.ItemsControl.Items%2A><xref:System.Windows.Controls.Menu>为`<Menu.Items>`属性元素标记，并将每个<xref:System.Windows.Controls.MenuItem>集合放在`<Menu.Items>`中，而不是使用隐式 XAML 处理器行为，所有<xref:System.Windows.Controls.Menu>子元素的所有子元素都必须是<xref:System.Windows.Controls.MenuItem>和 放置在<xref:System.Windows.Controls.ItemsControl.Items%2A>集合中。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-347">For example, when you declare the contents of a <xref:System.Windows.Controls.Menu>, you could choose to explicitly declare the <xref:System.Windows.Controls.ItemsControl.Items%2A> collection of the <xref:System.Windows.Controls.Menu> as a `<Menu.Items>` property element tag, and place each <xref:System.Windows.Controls.MenuItem> within `<Menu.Items>`, rather than using the implicit XAML processor behavior that all child elements of a <xref:System.Windows.Controls.Menu> must be a <xref:System.Windows.Controls.MenuItem> and are placed in the <xref:System.Windows.Controls.ItemsControl.Items%2A> collection.</span></span> <span data-ttu-id="3c5d9-348">有时，可选用法有助于直观地阐明标记中表示的对象结构。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-348">Sometimes the optional usages can help to visually clarify the object structure as represented in the markup.</span></span> <span data-ttu-id="3c5d9-349">或者有时显式属性元素使用可以避免在技术上起作用但视觉上令人困惑的标记，例如属性值中的嵌套标记扩展。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-349">Or sometimes an explicit property element usage can avoid markup that is technically functional but visually confusing, such as nested markup extensions within an attribute value.</span></span>  
  
### <a name="full-typenamemembername-qualified-attributes"></a><span data-ttu-id="3c5d9-350">全类型名称.成员名称限定属性</span><span class="sxs-lookup"><span data-stu-id="3c5d9-350">Full typeName.memberName Qualified Attributes</span></span>  
 <span data-ttu-id="3c5d9-351">*类型名称*。属性*的 iName*窗体实际上比路由事件案例更通用。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-351">The *typeName*.*memberName* form for an attribute actually works more universally than just the routed event case.</span></span> <span data-ttu-id="3c5d9-352">但在其他情况下，形式是多余的，你应该避免它，如果仅仅是标记风格和可读性的原因。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-352">But in other situations that form is superfluous and you should avoid it, if only for reasons of markup style and readability.</span></span> <span data-ttu-id="3c5d9-353">在下面的示例中，对<xref:System.Windows.Controls.Control.Background%2A>该属性的三个引用中的每一个都完全等效：</span><span class="sxs-lookup"><span data-stu-id="3c5d9-353">In the following example, each of the three references to the <xref:System.Windows.Controls.Control.Background%2A> attribute are completely equivalent:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#TypeNameProp](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#typenameprop)]  
  
 <span data-ttu-id="3c5d9-354">`Button.Background`工作，因为 该<xref:System.Windows.Controls.Button>属性的限定查找成功（<xref:System.Windows.Controls.Control.Background%2A>从 Control 继承），并且<xref:System.Windows.Controls.Button>是对象元素或基类的类。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-354">`Button.Background` works because the qualified lookup for that property on <xref:System.Windows.Controls.Button> is successful (<xref:System.Windows.Controls.Control.Background%2A> was inherited from Control) and <xref:System.Windows.Controls.Button> is the class of the object element or a base class.</span></span> <span data-ttu-id="3c5d9-355">`Control.Background`工作，<xref:System.Windows.Controls.Control>因为类实际上定义<xref:System.Windows.Controls.Control.Background%2A>，是<xref:System.Windows.Controls.Control>一个<xref:System.Windows.Controls.Button>基类。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-355">`Control.Background` works because the <xref:System.Windows.Controls.Control> class actually defines <xref:System.Windows.Controls.Control.Background%2A> and <xref:System.Windows.Controls.Control> is a <xref:System.Windows.Controls.Button> base class.</span></span>  
  
 <span data-ttu-id="3c5d9-356">但是，以下*类型名称*。*成员名称*窗体示例不起作用，因此显示注释：</span><span class="sxs-lookup"><span data-stu-id="3c5d9-356">However, the following *typeName*.*memberName* form example does not work and is thus shown commented:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#TypeNameBadProp](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#typenamebadprop)]  
  
 <span data-ttu-id="3c5d9-357"><xref:System.Windows.Controls.Label>是另一派生类，<xref:System.Windows.Controls.Control>如果您在`Label.Background`<xref:System.Windows.Controls.Label>对象元素中指定，则此用法将起作用。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-357"><xref:System.Windows.Controls.Label> is another derived class of <xref:System.Windows.Controls.Control>, and if you had specified `Label.Background` within a <xref:System.Windows.Controls.Label> object element, this usage would have worked.</span></span> <span data-ttu-id="3c5d9-358">但是，由于<xref:System.Windows.Controls.Label>不是 的类或基类<xref:System.Windows.Controls.Button>，因此指定的 XAML 处理器行为是作为附加`Label.Background`属性进行处理。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-358">However, because <xref:System.Windows.Controls.Label> is not the class or base class of <xref:System.Windows.Controls.Button>, the specified XAML processor behavior is to then process `Label.Background` as an attached property.</span></span> <span data-ttu-id="3c5d9-359">`Label.Background`不是可用的附加属性，并且此用法将失败。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-359">`Label.Background` is not an available attached property, and this usage fails.</span></span>  
  
### <a name="basetypenamemembername-property-elements"></a><span data-ttu-id="3c5d9-360">基类型名称.成员名称属性元素</span><span class="sxs-lookup"><span data-stu-id="3c5d9-360">baseTypeName.memberName Property Elements</span></span>  
 <span data-ttu-id="3c5d9-361">以类似的方式与*类型名称*。*成员名称*窗体适用于属性语法，*基类型名称*。*成员名称*语法适用于属性元素语法。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-361">In an analogous way to how the *typeName*.*memberName* form works for attribute syntax, a *baseTypeName*.*memberName* syntax works for property element syntax.</span></span> <span data-ttu-id="3c5d9-362">例如，以下语法有效：</span><span class="sxs-lookup"><span data-stu-id="3c5d9-362">For instance, the following syntax works:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#GoofyPE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofype)]  
  
 <span data-ttu-id="3c5d9-363">此处，即使属性元素包含在 中`Control.Background``Button`，属性元素也给出为</span><span class="sxs-lookup"><span data-stu-id="3c5d9-363">Here, the property element was given as `Control.Background` even though the property element was contained in `Button`.</span></span>  
  
 <span data-ttu-id="3c5d9-364">但就像*类型名称*。*属性的成员名称*窗体，*基本类型名称*。*成员名称*在标记中是不好的样式，您应该避免它。</span><span class="sxs-lookup"><span data-stu-id="3c5d9-364">But just like *typeName*.*memberName* form for attributes, *baseTypeName*.*memberName* is poor style in markup, and you should avoid it.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="3c5d9-365">另请参阅</span><span class="sxs-lookup"><span data-stu-id="3c5d9-365">See also</span></span>

- [<span data-ttu-id="3c5d9-366">XAML 概述 (WPF)</span><span class="sxs-lookup"><span data-stu-id="3c5d9-366">XAML Overview (WPF)</span></span>](../../../desktop-wpf/fundamentals/xaml.md)
- [<span data-ttu-id="3c5d9-367">XAML 命名空间 (x:)语言功能</span><span class="sxs-lookup"><span data-stu-id="3c5d9-367">XAML Namespace (x:) Language Features</span></span>](../../../desktop-wpf/xaml-services/namespace-language-features.md)
- [<span data-ttu-id="3c5d9-368">WPF XAML 扩展</span><span class="sxs-lookup"><span data-stu-id="3c5d9-368">WPF XAML Extensions</span></span>](wpf-xaml-extensions.md)
- [<span data-ttu-id="3c5d9-369">依赖项属性概述</span><span class="sxs-lookup"><span data-stu-id="3c5d9-369">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="3c5d9-370">TypeConverters 和 XAML</span><span class="sxs-lookup"><span data-stu-id="3c5d9-370">TypeConverters and XAML</span></span>](typeconverters-and-xaml.md)
- [<span data-ttu-id="3c5d9-371">XAML 及 WPF 的自定义类</span><span class="sxs-lookup"><span data-stu-id="3c5d9-371">XAML and Custom Classes for WPF</span></span>](xaml-and-custom-classes-for-wpf.md)
