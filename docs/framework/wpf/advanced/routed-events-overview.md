---
title: 路由事件概述
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- attached events [WPF]
- grouped button set [WPF]
- routed events [WPF]
- events [WPF], routed
- tunneling [WPF]
- events [WPF], attached
- routing strategies for events [WPF]
- button set [WPF], grouped
- bubbling [WPF]
ms.assetid: 1a2189ae-13b4-45b0-b12c-8de2e49c29d2
ms.openlocfilehash: a6baf073e25635f0a6dd666d681d8bc641128ea0
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/23/2019
ms.locfileid: "61982344"
---
# <a name="routed-events-overview"></a><span data-ttu-id="e5cf2-102">路由事件概述</span><span class="sxs-lookup"><span data-stu-id="e5cf2-102">Routed Events Overview</span></span>
<span data-ttu-id="e5cf2-103">本主题描述 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 中路由事件的概念。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-103">This topic describes the concept of routed events in [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)].</span></span> <span data-ttu-id="e5cf2-104">本主题定义路由事件术语、描述路由事件如何通过元素树来路由、概述如何处理路由事件，并介绍如何创建你自己的自定义路由事件。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-104">The topic defines routed events terminology, describes how routed events are routed through a tree of elements, summarizes how you handle routed events, and introduces how to create your own custom routed events.</span></span>
  
<a name="prerequisites"></a>   
## <a name="prerequisites"></a><span data-ttu-id="e5cf2-105">系统必备</span><span class="sxs-lookup"><span data-stu-id="e5cf2-105">Prerequisites</span></span>  
 <span data-ttu-id="e5cf2-106">本主题假定你对如下内容有基本了解：[!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)]、面向对象的编程以及如何将 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 元素之间的关系概念化为树。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-106">This topic assumes that you have basic knowledge of the [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] and object-oriented programming, as well as the concept of how the relationships between [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] elements can be conceptualized as a tree.</span></span> <span data-ttu-id="e5cf2-107">若要理解本主题中的示例，你还应当了解 [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] 并知道如何编写非常基本的 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 应用程序或页。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-107">In order to follow the examples in this topic, you should also understand [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] and know how to write very basic [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications or pages.</span></span> <span data-ttu-id="e5cf2-108">有关详细信息，请参见[演练：我第一个 WPF 桌面应用程序](../getting-started/walkthrough-my-first-wpf-desktop-application.md)并[XAML 概述 (WPF)](xaml-overview-wpf.md)。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-108">For more information, see [Walkthrough: My first WPF desktop application](../getting-started/walkthrough-my-first-wpf-desktop-application.md) and [XAML Overview (WPF)](xaml-overview-wpf.md).</span></span>  
  
<a name="routing"></a>   
## <a name="what-is-a-routed-event"></a><span data-ttu-id="e5cf2-109">什么是路由事件？</span><span class="sxs-lookup"><span data-stu-id="e5cf2-109">What Is a Routed Event?</span></span>  
 <span data-ttu-id="e5cf2-110">可以从功能或实现的角度来理解路由事件。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-110">You can think about routed events either from a functional or implementation perspective.</span></span> <span data-ttu-id="e5cf2-111">此处对这两种定义均进行了说明，因为有的用户认为前者更有用，有的用户认为后者更有用。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-111">Both definitions are presented here, because some people find one or the other definition more useful.</span></span>  
  
 <span data-ttu-id="e5cf2-112">功能定义：路由的事件是事件的一种可以调用处理程序在元素树中，多个侦听器，而不是事件的只是事件的在引发事件的对象上。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-112">Functional definition: A routed event is a type of event that can invoke handlers on multiple listeners in an element tree, rather than just on the object that raised the event.</span></span>  
  
 <span data-ttu-id="e5cf2-113">实现定义：路由的事件是[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]由的实例提供支持的事件<xref:System.Windows.RoutedEvent>类，并由处理[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]事件系统。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-113">Implementation definition: A routed event is a [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event that is backed by an instance of the <xref:System.Windows.RoutedEvent> class and is processed by the [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] event system.</span></span>  
  
 <span data-ttu-id="e5cf2-114">典型的 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 应用程序中包含许多元素。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-114">A typical [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] application contains many elements.</span></span> <span data-ttu-id="e5cf2-115">无论这些元素是在代码中创建还是在 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 中声明，它们存在于彼此关联的元素树关系中。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-115">Whether created in code or declared in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], these elements exist in an element tree relationship to each other.</span></span> <span data-ttu-id="e5cf2-116">根据事件的定义，事件路由可以按两种方向之一传播，但是通常会在元素树中从源元素向上“浮升”，直到它到达元素树的根（通常是页面或窗口）。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-116">The event route can travel in one of two directions depending on the event definition, but generally the route travels from the source element and then "bubbles" upward through the element tree until it reaches the element tree root (typically a page or a window).</span></span> <span data-ttu-id="e5cf2-117">如果你以前用过 DHTML 对象模型，则可能会熟悉这个浮升概念。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-117">This bubbling concept might be familiar to you if you have worked with the DHTML object model previously.</span></span>  
  
 <span data-ttu-id="e5cf2-118">请思考下面的简单元素树：</span><span class="sxs-lookup"><span data-stu-id="e5cf2-118">Consider the following simple element tree:</span></span>  
  
 [!code-xaml[EventOvwSupport#GroupButton](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml#groupbutton)]  
  
 <span data-ttu-id="e5cf2-119">此元素树生成类似如下的内容：</span><span class="sxs-lookup"><span data-stu-id="e5cf2-119">This element tree produces something like the following:</span></span>  
  
 <span data-ttu-id="e5cf2-120">![“是”、“否”和“取消”按钮](./media/routedevent-ovw-1.gif "RoutedEvent_ovw_1")</span><span class="sxs-lookup"><span data-stu-id="e5cf2-120">![Yes, No, and Cancel buttons](./media/routedevent-ovw-1.gif "RoutedEvent_ovw_1")</span></span>  
  
 <span data-ttu-id="e5cf2-121">在此简化的元素树中，源<xref:System.Windows.Controls.Primitives.ButtonBase.Click>事件是之一<xref:System.Windows.Controls.Button>元素，而所<xref:System.Windows.Controls.Button>单击的是有机会处理事件的第一个元素。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-121">In this simplified element tree, the source of a <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event is one of the <xref:System.Windows.Controls.Button> elements, and whichever <xref:System.Windows.Controls.Button> was clicked is the first element that has the opportunity to handle the event.</span></span> <span data-ttu-id="e5cf2-122">但是，如果没有处理程序附加到<xref:System.Windows.Controls.Button>处理的事件，则该事件将向上冒泡到<xref:System.Windows.Controls.Button>在元素树中，这是父<xref:System.Windows.Controls.StackPanel>。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-122">But if no handler attached to the <xref:System.Windows.Controls.Button> acts on the event, then the event will bubble upwards to the <xref:System.Windows.Controls.Button> parent in the element tree, which is the <xref:System.Windows.Controls.StackPanel>.</span></span> <span data-ttu-id="e5cf2-123">可能的事件冒泡到<xref:System.Windows.Controls.Border>，然后会到达元素树 （未显示） 的页面根。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-123">Potentially, the event bubbles to <xref:System.Windows.Controls.Border>, and then beyond to the page root of the element tree (not shown).</span></span>  
  
 <span data-ttu-id="e5cf2-124">换而言之，此事件路由<xref:System.Windows.Controls.Primitives.ButtonBase.Click>事件：</span><span class="sxs-lookup"><span data-stu-id="e5cf2-124">In other words, the event route for this <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event is:</span></span>  
  
 <span data-ttu-id="e5cf2-125">Button-->StackPanel-->Border-->...</span><span class="sxs-lookup"><span data-stu-id="e5cf2-125">Button-->StackPanel-->Border-->...</span></span>  
  
### <a name="top-level-scenarios-for-routed-events"></a><span data-ttu-id="e5cf2-126">路由事件的顶级方案</span><span class="sxs-lookup"><span data-stu-id="e5cf2-126">Top-level Scenarios for Routed Events</span></span>  
 <span data-ttu-id="e5cf2-127">下面简要概述了需运用路由事件的方案，以及为什么典型的 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 事件不适合这些方案：</span><span class="sxs-lookup"><span data-stu-id="e5cf2-127">The following is a brief summary of the scenarios that motivated the routed event concept, and why a typical [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event was not adequate for these scenarios:</span></span>  
  
 <span data-ttu-id="e5cf2-128">**控件的撰写和封装：** 中的各个控件[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]具有丰富内容模型。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-128">**Control composition and encapsulation:** Various controls in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] have a rich content model.</span></span> <span data-ttu-id="e5cf2-129">例如，可以将内部的图像<xref:System.Windows.Controls.Button>，这会有效地扩展按钮的可视化树。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-129">For example, you can place an image inside of a <xref:System.Windows.Controls.Button>, which effectively extends the visual tree of the button.</span></span> <span data-ttu-id="e5cf2-130">但是，所添加的图像不得中断命中测试行为，会使按钮响应<xref:System.Windows.Controls.Primitives.ButtonBase.Click>其内容，即使在用户单击的像素在技术上的图像的一部分。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-130">However, the added image must not break the hit-testing behavior that causes a button to respond to a <xref:System.Windows.Controls.Primitives.ButtonBase.Click> of its content, even if the user clicks on pixels that are technically part of the image.</span></span>  
  
 <span data-ttu-id="e5cf2-131">**单一处理程序附加点：** 在[!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)]，您将不得不多次的同一处理程序附加到处理可能从多个元素引发的事件。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-131">**Singular handler attachment points:** In [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)], you would have to attach the same handler multiple times to process events that could be raised from multiple elements.</span></span> <span data-ttu-id="e5cf2-132">借助路由事件，可以只附加该处理程序一次（如上例中所示），并在必要时使用处理程序逻辑来确定该事件的源位置。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-132">Routed events enable you to attach that handler only once, as was shown in the previous example, and use handler logic to determine where the event came from if necessary.</span></span> <span data-ttu-id="e5cf2-133">例如，这可以是前面显示的 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 的处理程序：</span><span class="sxs-lookup"><span data-stu-id="e5cf2-133">For instance, this might be the handler for the previously shown [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]:</span></span>  
  
 [!code-csharp[EventOvwSupport#GroupButtonCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml.cs#groupbuttoncodebehind)]
 [!code-vb[EventOvwSupport#GroupButtonCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/default.xaml.vb#groupbuttoncodebehind)]  
  
 <span data-ttu-id="e5cf2-134">**类处理方式：** 路由事件允许由类定义一个静态处理程序。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-134">**Class handling:** Routed events permit a static handler that is defined by the class.</span></span> <span data-ttu-id="e5cf2-135">此类处理程序能够抢在任何附加的实例处理程序之前处理事件。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-135">This class handler has the opportunity to handle an event before any attached instance handlers can.</span></span>  
  
 <span data-ttu-id="e5cf2-136">**引用事件，而不反射：** 某些代码和标记技术需要采用某种方式来标识特定事件。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-136">**Referencing an event without reflection:** Certain code and markup techniques require a way to identify a specific event.</span></span> <span data-ttu-id="e5cf2-137">路由的事件创建<xref:System.Windows.RoutedEvent>字段作为标识符，它提供一种可靠的事件标识技术，不需要静态或运行时反射。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-137">A routed event creates a <xref:System.Windows.RoutedEvent> field as an identifier, which provides a robust event identification technique that does not require static or run-time reflection.</span></span>  
  
### <a name="how-routed-events-are-implemented"></a><span data-ttu-id="e5cf2-138">路由事件的实现方式</span><span class="sxs-lookup"><span data-stu-id="e5cf2-138">How Routed Events Are Implemented</span></span>  
 <span data-ttu-id="e5cf2-139">路由的事件是[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]由的实例提供支持的事件<xref:System.Windows.RoutedEvent>类，并使用注册[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]事件系统。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-139">A routed event is a [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event that is backed by an instance of the <xref:System.Windows.RoutedEvent> class and registered with the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] event system.</span></span> <span data-ttu-id="e5cf2-140"><xref:System.Windows.RoutedEvent>从注册中获取的实例通常保留为`public` `static` `readonly`字段成员的类的注册，并因此"拥有"路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-140">The <xref:System.Windows.RoutedEvent> instance obtained from registration is typically retained as a `public` `static` `readonly` field member of the class that registers and thus "owns" the routed event.</span></span> <span data-ttu-id="e5cf2-141">与同名 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 事件（有时称为“包装器”事件）的连接是通过替代 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 事件的 `add` 和 `remove` 实现来完成的。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-141">The connection to the identically named [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event (which is sometimes termed the "wrapper" event) is accomplished by overriding the `add` and `remove` implementations for the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event.</span></span> <span data-ttu-id="e5cf2-142">通常，`add` 和 `remove` 保留为隐式默认值，该默认值使用特定于语言的相应事件语法来添加和删除该事件的处理程序。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-142">Ordinarily, the `add` and `remove` are left as an implicit default that uses the appropriate language-specific event syntax for adding and removing handlers of that event.</span></span> <span data-ttu-id="e5cf2-143">路由的事件支持和连接机制是从概念上讲类似于依赖项属性的方式[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]支持的属性<xref:System.Windows.DependencyProperty>类，并使用注册[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]属性系统。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-143">The routed event backing and connection mechanism is conceptually similar to how a dependency property is a [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] property that is backed by the <xref:System.Windows.DependencyProperty> class and registered with the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system.</span></span>  
  
 <span data-ttu-id="e5cf2-144">下面的示例演示了自定义的声明`Tap`路由的事件，包括注册和公开<xref:System.Windows.RoutedEvent>标识符字段，并`add`并`remove`实现`Tap` [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]事件。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-144">The following example shows the declaration for a custom `Tap` routed event, including the registration and exposure of the <xref:System.Windows.RoutedEvent> identifier field and the `add` and `remove` implementations for the `Tap` [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event.</span></span>  
  
 [!code-csharp[RoutedEventCustom#AddRemoveHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventCustom/CSharp/SDKSampleLibrary/class1.cs#addremovehandler)]
 [!code-vb[RoutedEventCustom#AddRemoveHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventCustom/VB/SDKSampleLibrary/Class1.vb#addremovehandler)]  
  
### <a name="routed-event-handlers-and-xaml"></a><span data-ttu-id="e5cf2-145">路由事件处理程序和 XAML</span><span class="sxs-lookup"><span data-stu-id="e5cf2-145">Routed Event Handlers and XAML</span></span>  
 <span data-ttu-id="e5cf2-146">若要使用 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 为事件添加处理程序，可将该事件的名称声明为用作事件侦听器的元素的属性。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-146">To add a handler for an event using [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], you declare the event name as an attribute on the element that is an event listener.</span></span> <span data-ttu-id="e5cf2-147">该属性的值是所实现的处理程序方法的名称，该方法必须存在于代码隐藏文件的分部类中。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-147">The value of the attribute is the name of your implemented handler method, which must exist in the partial class of the code-behind file.</span></span>  
  
 [!code-xaml[EventOvwSupport#SimplestSyntax](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml#simplestsyntax)]  
  
 <span data-ttu-id="e5cf2-148">用来添加标准 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 事件处理程序的 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 语法与用来添加路由事件处理程序的语法相同，因为实际上是向底层具有路由事件实现的 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 事件包装器添加处理程序。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-148">The [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] syntax for adding standard [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event handlers is the same for adding routed event handlers, because you are really adding handlers to the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event wrapper, which has a routed event implementation underneath.</span></span> <span data-ttu-id="e5cf2-149">有关在 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 中添加事件处理程序的详细信息，请参阅 [XAML 概述 (WPF)](xaml-overview-wpf.md)。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-149">For more information about adding event handlers in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], see [XAML Overview (WPF)](xaml-overview-wpf.md).</span></span>  
  
<a name="routing_strategies"></a>   
## <a name="routing-strategies"></a><span data-ttu-id="e5cf2-150">路由策略</span><span class="sxs-lookup"><span data-stu-id="e5cf2-150">Routing Strategies</span></span>  
 <span data-ttu-id="e5cf2-151">路由事件使用以下三种路由策略之一：</span><span class="sxs-lookup"><span data-stu-id="e5cf2-151">Routed events use one of three routing strategies:</span></span>  
  
- <span data-ttu-id="e5cf2-152">**浮升：** 调用事件源的事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-152">**Bubbling:** Event handlers on the event source are invoked.</span></span> <span data-ttu-id="e5cf2-153">路由事件随后会路由到后续的父级元素，直到到达元素树的根。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-153">The routed event then routes to successive parent elements until reaching the element tree root.</span></span> <span data-ttu-id="e5cf2-154">大多数路由事件都使用浮升路由策略。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-154">Most routed events use the bubbling routing strategy.</span></span> <span data-ttu-id="e5cf2-155">浮升路由事件通常用于报告来自不同控件或其他 UI 元素的输入或状态变化。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-155">Bubbling routed events are generally used to report input or state changes from distinct controls or other UI elements.</span></span>  
  
- <span data-ttu-id="e5cf2-156">**直接：** 仅源元素本身才有机会调用处理程序来响应。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-156">**Direct:** Only the source element itself is given the opportunity to invoke handlers in response.</span></span> <span data-ttu-id="e5cf2-157">这与 [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] 用于事件的“路由”相似。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-157">This is analogous to the "routing" that [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] uses for events.</span></span> <span data-ttu-id="e5cf2-158">但是，与标准不同[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]事件，直接路由的事件支持类处理 （下一节中介绍类处理） 和可由<xref:System.Windows.EventSetter>和<xref:System.Windows.EventTrigger>。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-158">However, unlike a standard [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event, direct routed events support class handling (class handling is explained in an upcoming section) and can be used by <xref:System.Windows.EventSetter> and <xref:System.Windows.EventTrigger>.</span></span>  
  
- <span data-ttu-id="e5cf2-159">**隧道：** 最初，调用元素树的根处的事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-159">**Tunneling:** Initially, event handlers at the element tree root are invoked.</span></span> <span data-ttu-id="e5cf2-160">随后，路由事件将朝着路由事件的源节点元素（即引发路由事件的元素）方向，沿路由线路传播到后续的子元素。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-160">The routed event then travels a route through successive child elements along the route, towards the node element that is the routed event source (the element that raised the routed event).</span></span> <span data-ttu-id="e5cf2-161">合成控件的过程中通常会使用或处理隧道路由事件，通过这种方式，可以有意地禁止复合部件中的事件，或者将其替换为特定于整个控件的事件。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-161">Tunneling routed events are often used or handled as part of the compositing for a control, such that events from composite parts can be deliberately suppressed or replaced by events that are specific to the complete control.</span></span> <span data-ttu-id="e5cf2-162">在 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中提供的输入事件通常是以隧道/浮升对实现的。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-162">Input events provided in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] often come implemented as a tunneling/bubbling pair.</span></span> <span data-ttu-id="e5cf2-163">隧道事件有时又称作预览事件，这是由该对所使用的命名约定决定的。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-163">Tunneling events are also sometimes referred to as Preview events, because of a naming convention that is used for the pairs.</span></span>  
  
<a name="why_use"></a>   
## <a name="why-use-routed-events"></a><span data-ttu-id="e5cf2-164">为什么使用路由事件？</span><span class="sxs-lookup"><span data-stu-id="e5cf2-164">Why Use Routed Events?</span></span>  
 <span data-ttu-id="e5cf2-165">作为应用程序开发人员，你不需要始终了解或关注要处理的事件是否作为路由事件实现。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-165">As an application developer, you do not always need to know or care that the event you are handling is implemented as a routed event.</span></span> <span data-ttu-id="e5cf2-166">路由事件具有特殊的行为，但是，如果在引发该行为的元素上处理事件，则该行为通常会不可见。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-166">Routed events have special behavior, but that behavior is largely invisible if you are handling an event on the element where it is raised.</span></span>  
  
 <span data-ttu-id="e5cf2-167">如果使用以下任一建议方案，路由事件的功能将得到充分发挥：在公用根处定义公用处理程序、合成自己的控件或者定义自己的自定义控件类。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-167">Where routed events become powerful is if you use any of the suggested scenarios: defining common handlers at a common root, compositing your own control, or defining your own custom control class.</span></span>  
  
 <span data-ttu-id="e5cf2-168">路由事件侦听器和路由事件源不必在其层次结构中共享公用事件。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-168">Routed event listeners and routed event sources do not need to share a common event in their hierarchy.</span></span> <span data-ttu-id="e5cf2-169">任何<xref:System.Windows.UIElement>或<xref:System.Windows.ContentElement>可以是任一路由事件的事件侦听器。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-169">Any <xref:System.Windows.UIElement> or <xref:System.Windows.ContentElement> can be an event listener for any routed event.</span></span> <span data-ttu-id="e5cf2-170">因此，可以将有效的 [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] 集中可用的全套路由事件用作概念“接口”，应用程序中的不同元素通过这个接口来交换事件信息。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-170">Therefore, you can use the full set of routed events available throughout the working [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] set as a conceptual "interface" whereby disparate elements in the application can exchange event information.</span></span> <span data-ttu-id="e5cf2-171">路由事件的这个“接口”概念特别适用于输入事件。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-171">This "interface" concept for routed events is particularly applicable for input events.</span></span>  
  
 <span data-ttu-id="e5cf2-172">路由事件还可以用于通过元素树进行通信，因为事件的事件数据会保留到路由中的每个元素中。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-172">Routed events can also be used to communicate through the element tree, because the event data for the event is perpetuated to each element in the route.</span></span> <span data-ttu-id="e5cf2-173">一个元素可以更改事件数据中的某些内容，该更改将用于路由中的下一个元素。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-173">One element could change something in the event data, and that change would be available to the next element in the route.</span></span>  
  
 <span data-ttu-id="e5cf2-174">之所以将任何给定的 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 事件作为路由事件实现（而不是作为标准 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 事件实现），除了路由方面的原因，还有两个其他原因。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-174">Other than the routing aspect, there are two other reasons that any given [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] event might be implemented as a routed event instead of a standard [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event.</span></span> <span data-ttu-id="e5cf2-175">如果要实现自己的事件，则可能也需要考虑这些原则：</span><span class="sxs-lookup"><span data-stu-id="e5cf2-175">If you are implementing your own events, you might also consider these principles:</span></span>  
  
- <span data-ttu-id="e5cf2-176">某些[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]样式和模板化功能，如<xref:System.Windows.EventSetter>和<xref:System.Windows.EventTrigger>需要被引用的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-176">Certain [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] styling and templating features such as <xref:System.Windows.EventSetter> and <xref:System.Windows.EventTrigger> require the referenced event to be a routed event.</span></span> <span data-ttu-id="e5cf2-177">前面提到的事件标识符方案就是这样的。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-177">This is the event identifier scenario mentioned earlier.</span></span>  
  
- <span data-ttu-id="e5cf2-178">路由事件支持类处理机制，类可以通过该机制来指定静态方法，这些静态方法能够在任何已注册的实例处理程序访问路由事件之前，处理这些路由事件。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-178">Routed events support a class handling mechanism whereby the class can specify static methods that have the opportunity to handle routed events before any registered instance handlers can access them.</span></span> <span data-ttu-id="e5cf2-179">这在控件设计中非常有用，因为类可以强制执行事件驱动的类行为，以防它们在处理实例上的事件时被意外禁止。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-179">This is very useful in control design, because your class can enforce event-driven class behaviors that cannot be accidentally suppressed by handling an event on an instance.</span></span>  
  
 <span data-ttu-id="e5cf2-180">本主题将用单独的章节来讨论上述每个因素。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-180">Each of the above considerations is discussed in a separate section of this topic.</span></span>  
  
<a name="event_handing"></a>   
## <a name="adding-and-implementing-an-event-handler-for-a-routed-event"></a><span data-ttu-id="e5cf2-181">为路由事件添加和实现事件处理程序</span><span class="sxs-lookup"><span data-stu-id="e5cf2-181">Adding and Implementing an Event Handler for a Routed Event</span></span>  
 <span data-ttu-id="e5cf2-182">若要在 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 中添加事件处理程序，只需将事件名称作为属性添加到元素中，并将属性值设置为用来实现相应委托的事件处理程序的名称，如下面的示例中所示。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-182">To add an event handler in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], you simply add the event name to an element as an attribute and set the attribute value as the name of the event handler that implements an appropriate delegate, as in the following example.</span></span>  
  
 [!code-xaml[EventOvwSupport#SimplestSyntax](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml#simplestsyntax)]  
  
 <span data-ttu-id="e5cf2-183">`b1SetColor` 包含用于处理的代码实现的处理程序的名称<xref:System.Windows.Controls.Primitives.ButtonBase.Click>事件。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-183">`b1SetColor` is the name of the implemented handler that contains the code that handles the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span> <span data-ttu-id="e5cf2-184">`b1SetColor` 必须具有相同的签名<xref:System.Windows.RoutedEventHandler>委托，委托是事件处理程序委托的<xref:System.Windows.Controls.Primitives.ButtonBase.Click>事件。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-184">`b1SetColor` must have the same signature as the <xref:System.Windows.RoutedEventHandler> delegate, which is the event handler delegate for the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span> <span data-ttu-id="e5cf2-185">所有路由事件处理程序委托的第一个参数都指定要向其中添加事件处理程序的元素，第二个参数指定事件的数据。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-185">The first parameter of all routed event handler delegates specifies the element to which the event handler is added, and the second parameter specifies the data for the event.</span></span>  
  
[!code-csharp[EventOvwSupport#SimpleHandlerA](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml.cs#simplehandlera)]
[!code-vb[EventOvwSupport#SimpleHandlerA](~/samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/default.xaml.vb#simplehandlera)]  
  
 <span data-ttu-id="e5cf2-186"><xref:System.Windows.RoutedEventHandler> 是基本的路由的事件处理程序委托。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-186"><xref:System.Windows.RoutedEventHandler> is the basic routed event handler delegate.</span></span> <span data-ttu-id="e5cf2-187">对于针对某些控件或方案的专用路由事件，要用于路由事件处理程序的委托还可能会变得更加专用化，以便可以传输专用的事件数据。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-187">For routed events that are specialized for certain controls or scenarios, the delegates to use for the routed event handlers also might become more specialized, so that they can transmit specialized event data.</span></span> <span data-ttu-id="e5cf2-188">例如，在常见的输入方案中，可能需要处理<xref:System.Windows.UIElement.DragEnter>路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-188">For instance, in a common input scenario, you might handle a <xref:System.Windows.UIElement.DragEnter> routed event.</span></span> <span data-ttu-id="e5cf2-189">您的处理程序应实现<xref:System.Windows.DragEventHandler>委托。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-189">Your handler should implement the <xref:System.Windows.DragEventHandler> delegate.</span></span> <span data-ttu-id="e5cf2-190">通过使用更具体的委托，可以处理<xref:System.Windows.DragEventArgs>中的处理程序和读取<xref:System.Windows.DragEventArgs.Data%2A>属性，其中包含拖动操作的剪贴板有效负载。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-190">By using the most specific delegate, you can process the <xref:System.Windows.DragEventArgs> in the handler and read the <xref:System.Windows.DragEventArgs.Data%2A> property, which contains the clipboard payload of the drag operation.</span></span>  
  
 <span data-ttu-id="e5cf2-191">有关如何使用 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 向元素中添加事件处理程序的完整示例，请参阅[处理路由事件](how-to-handle-a-routed-event.md)。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-191">For a complete example of how to add an event handler to an element using [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], see [Handle a Routed Event](how-to-handle-a-routed-event.md).</span></span>  
  
 <span data-ttu-id="e5cf2-192">在用代码创建的应用程序中为路由事件添加处理程序非常简单。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-192">Adding a handler for a routed event in an application that is created in code is straightforward.</span></span> <span data-ttu-id="e5cf2-193">路由的事件处理程序始终可通过一个帮助器方法添加<xref:System.Windows.UIElement.AddHandler%2A>(它是现有支持进行调用的相同方法`add`。)但是，现有的 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 路由事件通常借助于支持机制来实现 `add` 和 `remove` 逻辑，这些实现允许使用特定于语言的事件语法来添加路由事件的处理程序，特定于语言的事件语法比 Helper 方法更直观。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-193">Routed event handlers can always be added through a helper method <xref:System.Windows.UIElement.AddHandler%2A> (which is the same method that the existing backing calls for `add`.) However, existing [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] routed events generally have backing implementations of `add` and `remove` logic that allow the handlers for routed events to be added by a language-specific event syntax, which is more intuitive syntax than the helper method.</span></span> <span data-ttu-id="e5cf2-194">下面是 Helper 方法的示例用法：</span><span class="sxs-lookup"><span data-stu-id="e5cf2-194">The following is an example usage of the helper method:</span></span>  
  
 [!code-csharp[EventOvwSupport#AddHandlerCode](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml.cs#addhandlercode)]
 [!code-vb[EventOvwSupport#AddHandlerCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/default.xaml.vb#addhandlercode)]  
  
 <span data-ttu-id="e5cf2-195">下面的示例说明C#运算符 （Visual Basic 原因是其处理的取消引用具有略有不同的运算符语法） 的语法：</span><span class="sxs-lookup"><span data-stu-id="e5cf2-195">The next example shows the C# operator syntax (Visual Basic has slightly different operator syntax because of its handling of dereferencing):</span></span>  
  
 [!code-csharp[EventOvwSupport#AddHandlerPlusEquals](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml.cs#addhandlerplusequals)]
 [!code-vb[EventOvwSupport#AddHandlerPlusEquals](~/samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/default.xaml.vb#addhandlerplusequals)]  
  
 <span data-ttu-id="e5cf2-196">有关如何在代码中添加事件处理程序的示例，请参阅[使用代码添加事件处理程序](how-to-add-an-event-handler-using-code.md)。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-196">For an example of how to add an event handler in code, see [Add an Event Handler Using Code](how-to-add-an-event-handler-using-code.md).</span></span>  
  
 <span data-ttu-id="e5cf2-197">如果使用的 Visual Basic，您还可以使用`Handles`关键字作为处理程序声明的一部分添加处理程序。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-197">If you are using Visual Basic, you can also use the `Handles` keyword to add handlers as part of the handler declarations.</span></span> <span data-ttu-id="e5cf2-198">有关详细信息，请参阅 [Visual Basic 和 WPF 事件处理](visual-basic-and-wpf-event-handling.md)。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-198">For more information, see [Visual Basic and WPF Event Handling](visual-basic-and-wpf-event-handling.md).</span></span>  
  
<a name="concept_handled"></a>   
### <a name="the-concept-of-handled"></a><span data-ttu-id="e5cf2-199">“已处理”概念</span><span class="sxs-lookup"><span data-stu-id="e5cf2-199">The Concept of Handled</span></span>  
 <span data-ttu-id="e5cf2-200">所有路由的事件都共享一个公共事件数据基类， <xref:System.Windows.RoutedEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-200">All routed events share a common event data base class, <xref:System.Windows.RoutedEventArgs>.</span></span> <span data-ttu-id="e5cf2-201"><xref:System.Windows.RoutedEventArgs> 定义<xref:System.Windows.RoutedEventArgs.Handled%2A>属性，它采用一个布尔值。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-201"><xref:System.Windows.RoutedEventArgs> defines the <xref:System.Windows.RoutedEventArgs.Handled%2A> property, which takes a Boolean value.</span></span> <span data-ttu-id="e5cf2-202">目的<xref:System.Windows.RoutedEventArgs.Handled%2A>属性是启用的路由将为该路由的事件标记任何事件处理程序*处理*，通过设置的值<xref:System.Windows.RoutedEventArgs.Handled%2A>到`true`。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-202">The purpose of the <xref:System.Windows.RoutedEventArgs.Handled%2A> property is to enable any event handler along the route to mark the routed event as *handled*, by setting the value of <xref:System.Windows.RoutedEventArgs.Handled%2A> to `true`.</span></span> <span data-ttu-id="e5cf2-203">处理程序在路由上的某个元素处对共享事件数据进行处理之后，这些数据将再次报告给路由上的每个侦听器。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-203">After being processed by the handler at one element along the route, the shared event data is again reported to each listener along the route.</span></span>  
  
 <span data-ttu-id="e5cf2-204">值<xref:System.Windows.RoutedEventArgs.Handled%2A>影响如何路由的事件的报告或处理传输时进一步路由。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-204">The value of <xref:System.Windows.RoutedEventArgs.Handled%2A> affects how a routed event is reported or processed as it travels further along the route.</span></span> <span data-ttu-id="e5cf2-205">如果<xref:System.Windows.RoutedEventArgs.Handled%2A>是`true`在事件路由的事件，则侦听该路由事件在其他元素上的处理程序的数据通常不会再调用为该特定事件实例。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-205">If <xref:System.Windows.RoutedEventArgs.Handled%2A> is `true` in the event data for a routed event, then handlers that listen for that routed event on other elements are generally no longer invoked for that particular event instance.</span></span> <span data-ttu-id="e5cf2-206">这条规则对以下两类处理程序均适用：在 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 中附加的处理程序；由特定于语言的事件处理程序附加语法（如 `+=` 或 `Handles`）添加的处理程序。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-206">This is true both for handlers attached in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] and for handlers added by language-specific event handler attachment syntaxes such as `+=` or `Handles`.</span></span> <span data-ttu-id="e5cf2-207">对于最常见的处理程序方案，事件标记为已处理通过设置<xref:System.Windows.RoutedEventArgs.Handled%2A>到`true`将"停止"路由隧道路由或浮升路由，以及可由类处理程序处理的路由中的某个位置的任何事件。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-207">For most common handler scenarios, marking an event as handled by setting <xref:System.Windows.RoutedEventArgs.Handled%2A> to `true` will "stop" routing for either a tunneling route or a bubbling route, and also for any event that is handled at a point in the route by a class handler.</span></span>  
  
 <span data-ttu-id="e5cf2-208">但是，没有"handledEventsToo"机制，侦听器仍可运行处理程序响应路由事件在其中<xref:System.Windows.RoutedEventArgs.Handled%2A>是`true`事件数据中。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-208">However, there is a "handledEventsToo" mechanism whereby listeners can still run handlers in response to routed events where <xref:System.Windows.RoutedEventArgs.Handled%2A> is `true` in the event data.</span></span> <span data-ttu-id="e5cf2-209">换言之，将事件数据标记为“已处理”并不会真的停止事件路由。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-209">In other words, the event route is not truly stopped by marking the event data as handled.</span></span> <span data-ttu-id="e5cf2-210">在代码中，或在只能使用 handledEventsToo 机制<xref:System.Windows.EventSetter>:</span><span class="sxs-lookup"><span data-stu-id="e5cf2-210">You can only use the handledEventsToo mechanism in code, or in an <xref:System.Windows.EventSetter>:</span></span>  
  
- <span data-ttu-id="e5cf2-211">在代码中，而不是使用常规的工作方式的特定于语言的事件语法[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]事件，调用[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]方法<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>来添加处理程序。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-211">In code, instead of using a language-specific event syntax that works for general [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] events, call the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] method <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> to add your handler.</span></span> <span data-ttu-id="e5cf2-212">请将 `handledEventsToo` 的值指定为 `true`。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-212">Specify the value of `handledEventsToo` as `true`.</span></span>  
  
- <span data-ttu-id="e5cf2-213">在中<xref:System.Windows.EventSetter>，将<xref:System.Windows.EventSetter.HandledEventsToo%2A>属性不存在`true`。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-213">In an <xref:System.Windows.EventSetter>, set the <xref:System.Windows.EventSetter.HandledEventsToo%2A> attribute to be `true`.</span></span>  
  
 <span data-ttu-id="e5cf2-214">除了行为的<xref:System.Windows.RoutedEventArgs.Handled%2A>路由事件，这一概念在生成状态<xref:System.Windows.RoutedEventArgs.Handled%2A>牵涉到将应用程序设计和编写事件处理程序代码的方式。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-214">In addition to the behavior that <xref:System.Windows.RoutedEventArgs.Handled%2A> state produces in routed events, the concept of <xref:System.Windows.RoutedEventArgs.Handled%2A> has implications for how you should design your application and write the event handler code.</span></span> <span data-ttu-id="e5cf2-215">从概念上讲<xref:System.Windows.RoutedEventArgs.Handled%2A>作为路由事件公开的简单协议。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-215">You can conceptualize <xref:System.Windows.RoutedEventArgs.Handled%2A> as being a simple protocol that is exposed by routed events.</span></span> <span data-ttu-id="e5cf2-216">具体使用此协议负责，但如何进行概念设计的值<xref:System.Windows.RoutedEventArgs.Handled%2A>应使用如下所示：</span><span class="sxs-lookup"><span data-stu-id="e5cf2-216">Exactly how you use this protocol is up to you, but the conceptual design for how the value of <xref:System.Windows.RoutedEventArgs.Handled%2A> is intended to be used is as follows:</span></span>  
  
- <span data-ttu-id="e5cf2-217">如果路由事件标记为“已处理”，则它不必由该路由中的其他元素再次处理。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-217">If a routed event is marked as handled, then it does not need to be handled again by other elements along that route.</span></span>  
  
- <span data-ttu-id="e5cf2-218">如果路由的事件未标记为已处理，则路由中前面的其他侦听器已选择不进行注册处理程序或已注册的选择不操作事件数据和设置的处理程序<xref:System.Windows.RoutedEventArgs.Handled%2A>到`true`。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-218">If a routed event is not marked as handled, then other listeners that were earlier along the route have chosen either not to register a handler, or the handlers that were registered chose not to manipulate the event data and set <xref:System.Windows.RoutedEventArgs.Handled%2A> to `true`.</span></span> <span data-ttu-id="e5cf2-219">（或者，当前侦听器很可能是路由中的第一个点。）当前侦听器上的处理程序现在有三个可能的操作过程：</span><span class="sxs-lookup"><span data-stu-id="e5cf2-219">(Or, it is of course possible that the current listener is the first point in the route.) Handlers on the current listener now have three possible courses of action:</span></span>  
  
    - <span data-ttu-id="e5cf2-220">不执行任何操作；该事件保持未处理状态，该事件将路由到下一个侦听器。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-220">Take no action at all; the event remains unhandled, and the event routes to the next listener.</span></span>  
  
    - <span data-ttu-id="e5cf2-221">执行代码以响应该事件，但是所执行的操作被视为不足以保证将事件标记为“已处理”。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-221">Execute code in response to the event, but make the determination that the action taken was not substantial enough to warrant marking the event as handled.</span></span> <span data-ttu-id="e5cf2-222">该事件将路由到下一个侦听器。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-222">The event routes to the next listener.</span></span>  
  
    - <span data-ttu-id="e5cf2-223">执行代码以响应该事件。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-223">Execute code in response to the event.</span></span> <span data-ttu-id="e5cf2-224">在传递到处理程序的事件数据中将该事件标记为“已处理”，因为所执行的操作被视为不足以保证将该事件标记为“已处理”。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-224">Mark the event as handled in the event data passed to the handler, because the action taken was deemed substantial enough to warrant marking as handled.</span></span> <span data-ttu-id="e5cf2-225">该事件仍将路由到下一个侦听器，但<xref:System.Windows.RoutedEventArgs.Handled%2A> = `true`在其事件数据，因此，只有`handledEventsToo`侦听器都有机会进一步调用处理程序。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-225">The event still routes to the next listener, but with <xref:System.Windows.RoutedEventArgs.Handled%2A>=`true` in its event data, so only `handledEventsToo` listeners have the opportunity to invoke further handlers.</span></span>  
  
 <span data-ttu-id="e5cf2-226">此概念设计通过前面所述的路由行为得到增强： 会更加困难 （尽管仍可以在代码或样式） 来调用即使路由前面的处理程序已设置路由事件附加处理程序<xref:System.Windows.RoutedEventArgs.Handled%2A>到`true`。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-226">This conceptual design is reinforced by the routing behavior mentioned earlier: it is more difficult (although still possible in code or styles) to attach handlers for routed events that are invoked even if a previous handler along the route has already set <xref:System.Windows.RoutedEventArgs.Handled%2A> to `true`.</span></span>  
  
 <span data-ttu-id="e5cf2-227">有关详细信息<xref:System.Windows.RoutedEventArgs.Handled%2A>、 的类处理路由事件和有关时建议适当的标记作为路由的事件<xref:System.Windows.RoutedEventArgs.Handled%2A>，请参阅[路由事件标记为已处理，和类处理](marking-routed-events-as-handled-and-class-handling.md)。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-227">For more information about <xref:System.Windows.RoutedEventArgs.Handled%2A>, class handling of routed events, and recommendations about when it is appropriate to mark a routed event as <xref:System.Windows.RoutedEventArgs.Handled%2A>, see [Marking Routed Events as Handled, and Class Handling](marking-routed-events-as-handled-and-class-handling.md).</span></span>  
  
 <span data-ttu-id="e5cf2-228">在应用程序中，相当常见的做法是只针对引发浮升路由事件的对象来处理该事件，而根本不考虑事件的路由特征。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-228">In applications, it is quite common to just handle a bubbling routed event on the object that raised it, and not be concerned with the event's routing characteristics at all.</span></span> <span data-ttu-id="e5cf2-229">但是，在事件数据中将路由事件标记为“已处理”仍是一个不错的做法，因为这样可以防止元素树中位置更高的元素也对同一个路由事件附加了处理程序而出现意外的副作用。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-229">However, it is still a good practice to mark the routed event as handled in the event data, to prevent unanticipated side effects just in case an element that is further up the element tree also has a handler attached for that same routed event.</span></span>  
  
<a name="class_handlers"></a>   
## <a name="class-handlers"></a><span data-ttu-id="e5cf2-230">类处理程序</span><span class="sxs-lookup"><span data-stu-id="e5cf2-230">Class Handlers</span></span>  
 <span data-ttu-id="e5cf2-231">如果定义派生的类以某种方式从<xref:System.Windows.DependencyObject>，还可以定义并附加路由事件是您的类声明或继承事件成员的类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-231">If you are defining a class that derives in some way from <xref:System.Windows.DependencyObject>, you can also define and attach a class handler for a routed event that is a declared or inherited event member of your class.</span></span> <span data-ttu-id="e5cf2-232">每当路由事件到达其路由中的元素实例时，都会先调用类处理程序，然后再调用附加到该类某个实例的任何实例侦听器处理程序。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-232">Class handlers are invoked before any instance listener handlers that are attached to an instance of that class, whenever a routed event reaches an element instance in its route.</span></span>  
  
 <span data-ttu-id="e5cf2-233">有些 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 控件对某些路由事件具有固有的类处理。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-233">Some [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] controls have inherent class handling for certain routed events.</span></span> <span data-ttu-id="e5cf2-234">路由事件可能看起来从未引发过，但实际上正对其进行类处理，如果使用某些技术，路由事件还是可以由实例处理程序进行处理。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-234">This might give the outward appearance that the routed event is not ever raised, but in reality it is being class handled, and the routed event can potentially still be handled by your instance handlers if you use certain techniques.</span></span> <span data-ttu-id="e5cf2-235">此外，许多基类和控件会公开可用来替代类处理行为的虚拟方法。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-235">Also, many base classes and controls expose virtual methods that can be used to override class handling behavior.</span></span> <span data-ttu-id="e5cf2-236">若要深入了解如何解决不需要的类处理以及如何在自定义类中定义自己的类处理，请参阅[将路由事件标记为“已处理”和类处理](marking-routed-events-as-handled-and-class-handling.md)。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-236">For more information both on how to work around undesired class handling and on defining your own class handling in a custom class, see [Marking Routed Events as Handled, and Class Handling](marking-routed-events-as-handled-and-class-handling.md).</span></span>  
  
<a name="attached_events"></a>   
## <a name="attached-events-in-wpf"></a><span data-ttu-id="e5cf2-237">WPF 中的附加事件</span><span class="sxs-lookup"><span data-stu-id="e5cf2-237">Attached Events in WPF</span></span>  
 <span data-ttu-id="e5cf2-238">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 语言还定义了一个名为附加事件的特殊类型的事件。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-238">The [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] language also defines a special type of event called an *attached event*.</span></span> <span data-ttu-id="e5cf2-239">使用附加事件，可以将特定事件的处理程序添加到任意元素中。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-239">An attached event enables you to add a handler for a particular event to an arbitrary element.</span></span> <span data-ttu-id="e5cf2-240">处理事件的元素不必定义或继承附加事件，可能引发事件的对象和用来处理实例的目标也都不必将该事件定义为类成员，或将其作为类成员来“拥有”。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-240">The element handling the event need not define or inherit the attached event, and neither the object potentially raising the event nor the destination handling instance must define or otherwise "own" that event as a class member.</span></span>  
  
 <span data-ttu-id="e5cf2-241">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 输入系统广泛使用附加事件。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-241">The [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] input system uses attached events extensively.</span></span> <span data-ttu-id="e5cf2-242">但是，几乎所有的附加事件都是通过基本元素转发的。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-242">However, nearly all of these attached events are forwarded through base elements.</span></span> <span data-ttu-id="e5cf2-243">输入事件随后会显示为作为基本元素类成员的等效非附加路由事件。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-243">The input events then appear as equivalent non-attached routed events that are members of the base element class.</span></span> <span data-ttu-id="e5cf2-244">例如，基础附加事件<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>可以更方便地处理针对任何给定<xref:System.Windows.UIElement>通过使用<xref:System.Windows.UIElement.MouseDown>上的<xref:System.Windows.UIElement>而不是可以处理附加的事件语法中[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]或代码。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-244">For instance, the underlying attached event <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> can more easily be handled on any given <xref:System.Windows.UIElement> by using <xref:System.Windows.UIElement.MouseDown> on that <xref:System.Windows.UIElement> rather than dealing with attached event syntax either in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] or code.</span></span>  
  
 <span data-ttu-id="e5cf2-245">有关 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中附加事件的详细信息，请参阅[附加事件概述](attached-events-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-245">For more information about attached events in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], see [Attached Events Overview](attached-events-overview.md).</span></span>  
  
<a name="Qualifying_Event_Names_in_XAML_for_Anticipated_Routing"></a>   
## <a name="qualified-event-names-in-xaml"></a><span data-ttu-id="e5cf2-246">XAML 中的限定事件名称</span><span class="sxs-lookup"><span data-stu-id="e5cf2-246">Qualified Event Names in XAML</span></span>  
 <span data-ttu-id="e5cf2-247">为子元素所引发的路由事件附加处理程序是另一个语法用法，它与 typename.eventname 附加事件语法相似，但它并非严格意义上的附加事件用法。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-247">Another syntax usage that resembles *typename*.*eventname* attached event syntax but is not strictly speaking an attached event usage is when you attach handlers for routed events that are raised by child elements.</span></span> <span data-ttu-id="e5cf2-248">可以向公用父级附加处理程序以利用事件路由，即使公用父级可能没有作为成员的相关路由事件，也是如此。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-248">You attach the handlers to a common parent, to take advantage of event routing, even though the common parent might not have the relevant routed event as a member.</span></span> <span data-ttu-id="e5cf2-249">请再次思考下面的示例：</span><span class="sxs-lookup"><span data-stu-id="e5cf2-249">Consider this example again:</span></span>  
  
 [!code-xaml[EventOvwSupport#GroupButton](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml#groupbutton)]  
  
 <span data-ttu-id="e5cf2-250">在这里，添加了处理程序的父元素侦听器是<xref:System.Windows.Controls.StackPanel>。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-250">Here, the parent element listener where the handler is added is a <xref:System.Windows.Controls.StackPanel>.</span></span> <span data-ttu-id="e5cf2-251">但是，它添加声明时，将通过引发的路由事件处理程序<xref:System.Windows.Controls.Button>类 (<xref:System.Windows.Controls.Primitives.ButtonBase>实际上，但是可以由<xref:System.Windows.Controls.Button>通过继承)。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-251">However, it is adding a handler for a routed event that was declared and will be raised by the <xref:System.Windows.Controls.Button> class (<xref:System.Windows.Controls.Primitives.ButtonBase> actually, but available to <xref:System.Windows.Controls.Button> through inheritance).</span></span> <span data-ttu-id="e5cf2-252"><xref:System.Windows.Controls.Button> "拥有"该事件，但是路由的事件系统允许处理程序附加到任何任何路由事件<xref:System.Windows.UIElement>或<xref:System.Windows.ContentElement>实例侦听器，否则无法附加侦听器[!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)]事件。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-252"><xref:System.Windows.Controls.Button> "owns" the event, but the routed event system permits handlers for any routed event to be attached to any <xref:System.Windows.UIElement> or <xref:System.Windows.ContentElement> instance listener that could otherwise attach listeners for a [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] event.</span></span> <span data-ttu-id="e5cf2-253">对于这些限定的事件特性名来说，默认的 xmlns 命名空间通常是默认的 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] xmlns 命名空间，但是还可以为自定义路由事件指定带有前缀的命名空间。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-253">The default xmlns namespace for these qualified event attribute names is typically the default [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] xmlns namespace, but you can also specify prefixed namespaces for custom routed events.</span></span> <span data-ttu-id="e5cf2-254">有关 xmlns 的详细信息，请参阅 [WPF XAML 的 XAML 命名空间和命名空间映射](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-254">For more information about xmlns, see [XAML Namespaces and Namespace Mapping for WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span></span>  
  
<a name="how_event_processing_works"></a>   
## <a name="wpf-input-events"></a><span data-ttu-id="e5cf2-255">WPF 输入事件</span><span class="sxs-lookup"><span data-stu-id="e5cf2-255">WPF Input Events</span></span>  
 <span data-ttu-id="e5cf2-256">路由事件在 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 平台中的常见应用之一是用于事件输入。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-256">One frequent application of routed events within the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] platform is for input events.</span></span> <span data-ttu-id="e5cf2-257">在 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中，按照约定，隧道路由事件的名称以单词“Preview”开头。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-257">In [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], tunneling routed events names are prefixed with the word "Preview" by convention.</span></span> <span data-ttu-id="e5cf2-258">输入事件通常成对出现，一个是浮升事件，另一个是隧道事件。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-258">Input events often come in pairs, with one being the bubbling event and the other being the tunneling event.</span></span> <span data-ttu-id="e5cf2-259">例如，<xref:System.Windows.ContentElement.KeyDown>事件和<xref:System.Windows.ContentElement.PreviewKeyDown>事件具有相同的签名，前者是浮升输入的事件，后者是隧道输入事件。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-259">For example, the <xref:System.Windows.ContentElement.KeyDown> event and the <xref:System.Windows.ContentElement.PreviewKeyDown> event have the same signature, with the former being the bubbling input event and the latter being the tunneling input event.</span></span> <span data-ttu-id="e5cf2-260">偶尔，输入事件只有浮升版本，或者有可能只有直接路由版本。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-260">Occasionally, input events only have a bubbling version, or perhaps only a direct routed version.</span></span> <span data-ttu-id="e5cf2-261">在文档中，路由事件主题交叉引用具有备用路由策略的类似路由事件（如果存在这类路由事件），托管的引用页面中的相关部分阐明每个路由事件的路由策略。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-261">In the documentation, routed event topics cross-reference similar routed events with alternative routing strategies if such routed events exist, and sections in the managed reference pages clarify the routing strategy of each routed event.</span></span>  
  
 <span data-ttu-id="e5cf2-262">实现成对出现的 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 输入事件，使来自输入的单个用户操作（如按鼠标按钮）按顺序引发该对中的两个路由事件。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-262">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] input events that come in pairs are implemented so that a single user action from input, such as a mouse button press, will raise both routed events of the pair in sequence.</span></span> <span data-ttu-id="e5cf2-263">首先引发隧道事件并沿路由传播。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-263">First, the tunneling event is raised and travels its route.</span></span> <span data-ttu-id="e5cf2-264">然后引发浮升事件并沿路由传播。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-264">Then the bubbling event is raised and travels its route.</span></span> <span data-ttu-id="e5cf2-265">两个事件按字面意思共享相同的事件数据实例，因为<xref:System.Windows.UIElement.RaiseEvent%2A>引发浮升事件在实现类中的方法调用侦听隧道事件中的事件数据，并在新引发的事件中重用它。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-265">The two events literally share the same event data instance, because the <xref:System.Windows.UIElement.RaiseEvent%2A> method call in the implementing class that raises the bubbling event listens for the event data from the tunneling event and reuses it in the new raised event.</span></span> <span data-ttu-id="e5cf2-266">具有隧道事件处理程序的侦听器首先获得将路由事件标记为“已处理”的机会（首先是类处理程序，然后是实例处理程序）。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-266">Listeners with handlers for the tunneling event have the first opportunity to mark the routed event handled (class handlers first, then instance handlers).</span></span> <span data-ttu-id="e5cf2-267">如果隧道路由中的某个元素将路由事件标记为“已处理”，则会针对浮升事件发送已处理的事件数据，而且将不调用等效的浮升输入事件的附加典型处理程序。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-267">If an element along the tunneling route marked the routed event as handled, the already-handled event data is sent on for the bubbling event, and typical handlers attached for the equivalent bubbling input events will not be invoked.</span></span> <span data-ttu-id="e5cf2-268">已处理的浮升事件看起来好像尚未引发。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-268">To outward appearances it will be as if the handled bubbling event has not even been raised.</span></span> <span data-ttu-id="e5cf2-269">此处理行为对于控件合成非常有用，因为在此情况下你可能希望所有基于命中测试的输入事件或者所有基于焦点的输入事件都由最终的控件（而不是它的复合部件）报告。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-269">This handling behavior is useful for control compositing, where you might want all hit-test based input events or focus-based input events to be reported by your final control, rather than its composite parts.</span></span> <span data-ttu-id="e5cf2-270">作为可支持控件类的代码的一部分，最后一个控件元素靠近合成中的根，因此将有机会首先对隧道事件进行类处理，或者有机会将该路由事件“替换”为更针对控件的事件。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-270">The final control element is closer to the root in the compositing, and therefore has the opportunity to class handle the tunneling event first and perhaps to "replace" that routed event with a more control-specific event, as part of the code that backs the control class.</span></span>  
  
 <span data-ttu-id="e5cf2-271">为了说明输入事件处理的工作方式，请思考下面的输入事件示例。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-271">As an illustration of how input event processing works, consider the following input event example.</span></span> <span data-ttu-id="e5cf2-272">在下面的树插图中，`leaf element #2` 是先后发生的 `PreviewMouseDown` 事件和 `MouseDown` 事件的源。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-272">In the following tree illustration, `leaf element #2` is the source of both a `PreviewMouseDown` and then a `MouseDown` event.</span></span>  
  
 <span data-ttu-id="e5cf2-273">![事件路由示意图](./media/wcsdkcoreinputevents.png "wcsdkCoreInputEvents")</span><span class="sxs-lookup"><span data-stu-id="e5cf2-273">![Event routing diagram](./media/wcsdkcoreinputevents.png "wcsdkCoreInputEvents")</span></span>  
<span data-ttu-id="e5cf2-274">输入事件的浮升和隧道</span><span class="sxs-lookup"><span data-stu-id="e5cf2-274">Input Event Bubbling and Tunneling</span></span>  
  
 <span data-ttu-id="e5cf2-275">事件的处理顺序如下所述：</span><span class="sxs-lookup"><span data-stu-id="e5cf2-275">The order of event processing is as follows:</span></span>  
  
1. <span data-ttu-id="e5cf2-276">针对根元素处理 `PreviewMouseDown`（隧道）。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-276">`PreviewMouseDown` (tunnel) on root element.</span></span>  
  
2. <span data-ttu-id="e5cf2-277">针对中间元素 #1 处理 `PreviewMouseDown`（隧道）。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-277">`PreviewMouseDown` (tunnel) on intermediate element #1.</span></span>  
  
3. <span data-ttu-id="e5cf2-278">针对源元素 #2 处理 `PreviewMouseDown`（隧道）。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-278">`PreviewMouseDown` (tunnel) on source element #2.</span></span>  
  
4. <span data-ttu-id="e5cf2-279">针对源元素 #2 处理 `MouseDown`（浮升）。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-279">`MouseDown` (bubble) on source element #2.</span></span>  
  
5. <span data-ttu-id="e5cf2-280">针对中间元素 #1 处理 `MouseDown`（浮升）。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-280">`MouseDown` (bubble) on intermediate element #1.</span></span>  
  
6. <span data-ttu-id="e5cf2-281">针对根元素处理 `MouseDown`（浮升）。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-281">`MouseDown` (bubble) on root element.</span></span>  
  
 <span data-ttu-id="e5cf2-282">路由事件处理程序委托提供对以下两个对象的引用：引发该事件的对象以及在其中调用处理程序的对象。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-282">A routed event handler delegate provides references to two objects: the object that raised the event and the object where the handler was invoked.</span></span> <span data-ttu-id="e5cf2-283">在其中调用处理程序的对象是由 `sender` 参数报告的对象。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-283">The object where the handler was invoked is the object reported by the `sender` parameter.</span></span> <span data-ttu-id="e5cf2-284">首先引发该事件的对象报告的<xref:System.Windows.RoutedEventArgs.Source%2A>事件数据中的属性。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-284">The object where the event was first raised is reported by the <xref:System.Windows.RoutedEventArgs.Source%2A> property in the event data.</span></span> <span data-ttu-id="e5cf2-285">路由的事件仍可以引发并由同一个对象，在这种情况下处理`sender`和<xref:System.Windows.RoutedEventArgs.Source%2A>是相同的 （这是与步骤 3 和 4 中的事件处理示例列表的情况）。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-285">A routed event can still be raised and handled by the same object, in which case `sender` and <xref:System.Windows.RoutedEventArgs.Source%2A> are identical (this is the case with Steps 3 and 4 in the event processing example list).</span></span>  
  
 <span data-ttu-id="e5cf2-286">由于存在隧道和浮升，父元素接收输入的事件其中<xref:System.Windows.RoutedEventArgs.Source%2A>是一个及其子元素。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-286">Because of tunneling and bubbling, parent elements receive input events where the <xref:System.Windows.RoutedEventArgs.Source%2A> is one of their child elements.</span></span> <span data-ttu-id="e5cf2-287">必须了解源元素时，您可以通过访问来标识源元素<xref:System.Windows.RoutedEventArgs.Source%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-287">When it is important to know what the source element is, you can identify the source element by accessing the <xref:System.Windows.RoutedEventArgs.Source%2A> property.</span></span>  
  
 <span data-ttu-id="e5cf2-288">通常情况下，输入的事件标记后<xref:System.Windows.RoutedEventArgs.Handled%2A>，进一步不调用处理程序。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-288">Usually, once the input event is marked <xref:System.Windows.RoutedEventArgs.Handled%2A>, further handlers are not invoked.</span></span> <span data-ttu-id="e5cf2-289">通常，一旦调用了用来对输入事件的含义进行特定于应用程序的逻辑处理的处理程序，就应当将输入事件标记为“已处理”。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-289">Typically, you should mark input events as handled as soon as a handler is invoked that addresses your application-specific logical handling of the meaning of the input event.</span></span>  
  
 <span data-ttu-id="e5cf2-290">有关此通用声明异常<xref:System.Windows.RoutedEventArgs.Handled%2A>状态是输入的事件处理程序注册为有意忽略<xref:System.Windows.RoutedEventArgs.Handled%2A>事件数据的状态仍会调用路由。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-290">The exception to this general statement about <xref:System.Windows.RoutedEventArgs.Handled%2A> state is that input event handlers that are registered to deliberately ignore <xref:System.Windows.RoutedEventArgs.Handled%2A> state of the event data would still be invoked along either route.</span></span> <span data-ttu-id="e5cf2-291">有关详细信息，请参阅[预览事件](preview-events.md)或[将路由事件标记为“已处理”和类处理](marking-routed-events-as-handled-and-class-handling.md)。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-291">For more information, see [Preview Events](preview-events.md) or [Marking Routed Events as Handled, and Class Handling](marking-routed-events-as-handled-and-class-handling.md).</span></span>  
  
 <span data-ttu-id="e5cf2-292">通常，隧道事件和浮升事件之间的共享事件数据模型以及先引发隧道事件后引发浮升事件的顺序引发并非适用于所有的路由事件的概念。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-292">The shared event data model between tunneling and bubbling events, and the sequential raising of first tunneling then bubbling events, is not a concept that is generally true for all routed events.</span></span> <span data-ttu-id="e5cf2-293">该行为的实现取决于 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 输入设备选择引发和连接输入事件对的具体方式。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-293">That behavior is specifically implemented by how [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] input devices choose to raise and connect the input event pairs.</span></span> <span data-ttu-id="e5cf2-294">实现你自己的输入事件是一个高级方案，但是你也可以选择针对自己的输入事件遵循该模型。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-294">Implementing your own input events is an advanced scenario, but you might choose to follow that model for your own input events also.</span></span>  
  
 <span data-ttu-id="e5cf2-295">一些类选择对某些输入事件进行类处理，其目的通常是重新定义用户驱动的特定输入事件在该控件中的含义并引发新事件。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-295">Certain classes choose to class-handle certain input events, usually with the intent of redefining what a particular user-driven input event means within that control and raising a new event.</span></span> <span data-ttu-id="e5cf2-296">有关详细信息，请参阅[将路由事件标记为“已处理”和类处理](marking-routed-events-as-handled-and-class-handling.md)。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-296">For more information, see [Marking Routed Events as Handled, and Class Handling](marking-routed-events-as-handled-and-class-handling.md).</span></span>  
  
 <span data-ttu-id="e5cf2-297">有关输入以及在典型的应用程序方案中输入和事件如何交互的详细信息，请参阅[输入概述](input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-297">For more information on input and how input and events interact in typical application scenarios, see [Input Overview](input-overview.md).</span></span>  
  
<a name="events_styles"></a>   
## <a name="eventsetters-and-eventtriggers"></a><span data-ttu-id="e5cf2-298">EventSetter 和 EventTrigger</span><span class="sxs-lookup"><span data-stu-id="e5cf2-298">EventSetters and EventTriggers</span></span>  
 <span data-ttu-id="e5cf2-299">在样式中，您可以添加一些预先声明[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]事件处理的标记中的语法使用<xref:System.Windows.EventSetter>。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-299">In styles, you can include some pre-declared [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] event handling syntax in the markup by using an <xref:System.Windows.EventSetter>.</span></span> <span data-ttu-id="e5cf2-300">在应用样式时，所引用的处理程序会添加到带样式的实例中。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-300">When the style is applied, the referenced handler is added to the styled instance.</span></span> <span data-ttu-id="e5cf2-301">您可以声明<xref:System.Windows.EventSetter>仅为路由事件。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-301">You can declare an <xref:System.Windows.EventSetter> only for a routed event.</span></span> <span data-ttu-id="e5cf2-302">下面是一个示例。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-302">The following is an example.</span></span> <span data-ttu-id="e5cf2-303">请注意，此处引用的 `b1SetColor` 方法位于代码隐藏文件中。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-303">Note that the `b1SetColor` method referenced here is in a code-behind file.</span></span>  
  
 [!code-xaml[EventOvwSupport#XAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/page2.xaml#xaml2)]  
  
 <span data-ttu-id="e5cf2-304">好处是，样式有可能包含大量的其他信息，可应用到你的应用程序中任何按钮和具有<xref:System.Windows.EventSetter>属于该样式将提升甚至在标记级别的代码重用。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-304">The advantage gained here is that the style is likely to contain a great deal of other information that could apply to any button in your application, and having the <xref:System.Windows.EventSetter> be part of that style promotes code reuse even at the markup level.</span></span> <span data-ttu-id="e5cf2-305">此外，<xref:System.Windows.EventSetter>抽象化处理程序进一步从常规的应用程序和页面标记的方法名称。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-305">Also, an <xref:System.Windows.EventSetter> abstracts method names for handlers one step further away from the general application and page markup.</span></span>  
  
 <span data-ttu-id="e5cf2-306">路由的事件和动画功能组合在一起的另一个专用的语法[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]是<xref:System.Windows.EventTrigger>。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-306">Another specialized syntax that combines the routed event and animation features of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is an <xref:System.Windows.EventTrigger>.</span></span> <span data-ttu-id="e5cf2-307">如同<xref:System.Windows.EventSetter>，只有路由的事件可用于<xref:System.Windows.EventTrigger>。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-307">As with <xref:System.Windows.EventSetter>, only routed events may be used for an <xref:System.Windows.EventTrigger>.</span></span> <span data-ttu-id="e5cf2-308">通常情况下，<xref:System.Windows.EventTrigger>声明为样式的一部分，但<xref:System.Windows.EventTrigger>也可以声明的一部分在页级别的元素<xref:System.Windows.FrameworkElement.Triggers%2A>集合，或在<xref:System.Windows.Controls.ControlTemplate>。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-308">Typically, an <xref:System.Windows.EventTrigger> is declared as part of a style, but an <xref:System.Windows.EventTrigger> can also be declared on page-level elements as part of the <xref:System.Windows.FrameworkElement.Triggers%2A> collection, or in a <xref:System.Windows.Controls.ControlTemplate>.</span></span> <span data-ttu-id="e5cf2-309"><xref:System.Windows.EventTrigger> ，可指定<xref:System.Windows.Media.Animation.Storyboard>运行每当路由的事件到达其路由中的某个元素声明<xref:System.Windows.EventTrigger>该事件。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-309">An <xref:System.Windows.EventTrigger> enables you to specify a <xref:System.Windows.Media.Animation.Storyboard> that runs whenever a routed event reaches an element in its route that declares an <xref:System.Windows.EventTrigger> for that event.</span></span> <span data-ttu-id="e5cf2-310">利用<xref:System.Windows.EventTrigger>转移只需处理事件并使其启动现有情节提要是<xref:System.Windows.EventTrigger>提供更好地控制情节提要和其运行时行为。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-310">The advantage of an <xref:System.Windows.EventTrigger> over just handling the event and causing it to start an existing storyboard is that an <xref:System.Windows.EventTrigger> provides better control over the storyboard and its run-time behavior.</span></span> <span data-ttu-id="e5cf2-311">有关详细信息，请参阅[在情节提要启动之后使用事件触发器来控制情节提要](../graphics-multimedia/how-to-use-event-triggers-to-control-a-storyboard-after-it-starts.md)。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-311">For more information, see [Use Event Triggers to Control a Storyboard After It Starts](../graphics-multimedia/how-to-use-event-triggers-to-control-a-storyboard-after-it-starts.md).</span></span>  
  
<a name="more_about"></a>   
## <a name="more-about-routed-events"></a><span data-ttu-id="e5cf2-312">有关路由事件的更多信息</span><span class="sxs-lookup"><span data-stu-id="e5cf2-312">More About Routed Events</span></span>  
 <span data-ttu-id="e5cf2-313">本主题主要从以下角度讨论路由事件：描述基本概念；就如何以及何时响应各种基元素和控件中已经存在的路由事件提供指南。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-313">This topic mainly discusses routed events from the perspective of describing the basic concepts and offering guidance on how and when to respond to the routed events that are already present in the various base elements and controls.</span></span> <span data-ttu-id="e5cf2-314">但是，你可以在自定义类上创建自己的路由事件以及所有必要的支持（如专用的事件数据类和委托）。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-314">However, you can create your own routed event on your custom class along with all the necessary support, such as specialized event data classes and delegates.</span></span> <span data-ttu-id="e5cf2-315">路由的事件的所有者可以是任何类，但必须由引发并由处理路由的事件<xref:System.Windows.UIElement>或<xref:System.Windows.ContentElement>这样才可供派生类。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-315">The routed event owner can be any class, but routed events must be raised by and handled by <xref:System.Windows.UIElement> or <xref:System.Windows.ContentElement> derived classes in order to be useful.</span></span> <span data-ttu-id="e5cf2-316">有关自定义事件的详细信息，请参阅[创建自定义路由事件](how-to-create-a-custom-routed-event.md)。</span><span class="sxs-lookup"><span data-stu-id="e5cf2-316">For more information about custom events, see [Create a Custom Routed Event](how-to-create-a-custom-routed-event.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="e5cf2-317">请参阅</span><span class="sxs-lookup"><span data-stu-id="e5cf2-317">See also</span></span>

- <xref:System.Windows.EventManager>
- <xref:System.Windows.RoutedEvent>
- <xref:System.Windows.RoutedEventArgs>
- [<span data-ttu-id="e5cf2-318">将路由事件标记为“已处理”和“类处理”</span><span class="sxs-lookup"><span data-stu-id="e5cf2-318">Marking Routed Events as Handled, and Class Handling</span></span>](marking-routed-events-as-handled-and-class-handling.md)
- [<span data-ttu-id="e5cf2-319">输入概述</span><span class="sxs-lookup"><span data-stu-id="e5cf2-319">Input Overview</span></span>](input-overview.md)
- [<span data-ttu-id="e5cf2-320">命令概述</span><span class="sxs-lookup"><span data-stu-id="e5cf2-320">Commanding Overview</span></span>](commanding-overview.md)
- [<span data-ttu-id="e5cf2-321">自定义依赖属性</span><span class="sxs-lookup"><span data-stu-id="e5cf2-321">Custom Dependency Properties</span></span>](custom-dependency-properties.md)
- [<span data-ttu-id="e5cf2-322">WPF 中的树</span><span class="sxs-lookup"><span data-stu-id="e5cf2-322">Trees in WPF</span></span>](trees-in-wpf.md)
- [<span data-ttu-id="e5cf2-323">弱事件模式</span><span class="sxs-lookup"><span data-stu-id="e5cf2-323">Weak Event Patterns</span></span>](weak-event-patterns.md)
