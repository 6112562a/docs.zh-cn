---
title: TypeConverters 和 XAML
ms.date: 03/30/2017
helpviewer_keywords:
- XAML [WPF], TypeConverter class
ms.assetid: f6313e4d-e89d-497d-ac87-b43511a1ae4b
ms.openlocfilehash: 7f42bb6e4333fcb5e83ee4b95e404230424b317f
ms.sourcegitcommit: 0c48191d6d641ce88d7510e319cf38c0e35697d0
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/05/2019
ms.locfileid: "57352706"
---
# <a name="typeconverters-and-xaml"></a><span data-ttu-id="a7367-102">TypeConverters 和 XAML</span><span class="sxs-lookup"><span data-stu-id="a7367-102">TypeConverters and XAML</span></span>
<span data-ttu-id="a7367-103">本主题介绍将从字符串进行的类型转换作为常规 XAML 语言功能的用途。</span><span class="sxs-lookup"><span data-stu-id="a7367-103">This topic introduces the purpose of type conversion from string as a general XAML language feature.</span></span> <span data-ttu-id="a7367-104">在.NET Framework 中，<xref:System.ComponentModel.TypeConverter>类作为某种特定用途可以用作 XAML 特性用法中的属性值的托管自定义类的实现的一部分。</span><span class="sxs-lookup"><span data-stu-id="a7367-104">In the .NET Framework, the <xref:System.ComponentModel.TypeConverter> class serves a particular purpose as part of the implementation for a managed custom class that can be used as a property value in XAML attribute usage.</span></span> <span data-ttu-id="a7367-105">如果您编写的自定义类，并且你希望类用作 XAML 可设置属性值的实例，您可能需要应用<xref:System.ComponentModel.TypeConverterAttribute>到类，编写自定义<xref:System.ComponentModel.TypeConverter>类，或两者。</span><span class="sxs-lookup"><span data-stu-id="a7367-105">If you write a custom class, and you want instances of your class to be usable as XAML settable attribute values, you might need to apply a <xref:System.ComponentModel.TypeConverterAttribute> to your class, write a custom <xref:System.ComponentModel.TypeConverter> class, or both.</span></span>  
  

  
## <a name="type-conversion-concepts"></a><span data-ttu-id="a7367-106">类型转换概念</span><span class="sxs-lookup"><span data-stu-id="a7367-106">Type Conversion Concepts</span></span>  
  
### <a name="xaml-and-string-values"></a><span data-ttu-id="a7367-107">XAML 和字符串值</span><span class="sxs-lookup"><span data-stu-id="a7367-107">XAML and String Values</span></span>  
 <span data-ttu-id="a7367-108">在 XAML 文件中设置特性值时，该值的初始类型是纯文本形式的字符串。</span><span class="sxs-lookup"><span data-stu-id="a7367-108">When you set an attribute value in a XAML file, the initial type of that value is a string in pure text.</span></span> <span data-ttu-id="a7367-109">如甚至其他基元<xref:System.Double>最初是为 XAML 处理器的文本字符串。</span><span class="sxs-lookup"><span data-stu-id="a7367-109">Even other primitives such as <xref:System.Double> are initially text strings to a XAML processor.</span></span>  
  
 <span data-ttu-id="a7367-110">XAML 处理器需要两条信息来处理特性值。</span><span class="sxs-lookup"><span data-stu-id="a7367-110">A XAML processor needs two pieces of information in order to process an attribute value.</span></span> <span data-ttu-id="a7367-111">第一条信息是所设置的属性的值类型。</span><span class="sxs-lookup"><span data-stu-id="a7367-111">The first piece of information is the value type of the property that is being set.</span></span> <span data-ttu-id="a7367-112">定义特性值以及在 XAML 中进行处理的任何字符串都必须最终转换或解析为该类型的值。</span><span class="sxs-lookup"><span data-stu-id="a7367-112">Any string that defines an attribute value and that is processed in XAML must ultimately be converted or resolved to a value of that type.</span></span> <span data-ttu-id="a7367-113">如果值是 XAML 分析器可理解的基元（如数值），则会尝试直接转换字符串。</span><span class="sxs-lookup"><span data-stu-id="a7367-113">If the value is a primitive that is understood by the XAML parser (such as a numeric value), a direct conversion of the string is attempted.</span></span> <span data-ttu-id="a7367-114">如果值是枚举，则字符串用于检查是否存在与该枚举中的命名常量匹配的名称。</span><span class="sxs-lookup"><span data-stu-id="a7367-114">If the value is an enumeration, the string is used to check for a name match to a named constant in that enumeration.</span></span> <span data-ttu-id="a7367-115">如果值既不是分析器可理解的基元，也不是枚举，则所讨论的类型必须能够基于转换后的字符串提供类型的实例或值。</span><span class="sxs-lookup"><span data-stu-id="a7367-115">If the value is neither a parser-understood primitive nor an enumeration, then the type in question must be able to provide an instance of the type, or a value, based on a converted string.</span></span> <span data-ttu-id="a7367-116">可通过指示类型转换器类达到此目的。</span><span class="sxs-lookup"><span data-stu-id="a7367-116">This is done by indicating a type converter class.</span></span> <span data-ttu-id="a7367-117">类型转换器实际上是提供其他类的值的帮助器类，可用于的 XAML 方案和 .NET 代码中的代码调用。</span><span class="sxs-lookup"><span data-stu-id="a7367-117">The type converter is effectively a helper class for providing values of another class, both for the XAML scenario and also potentially for code calls in .NET code.</span></span>  
  
### <a name="using-existing-type-conversion-behavior-in-xaml"></a><span data-ttu-id="a7367-118">在 XAML 中使用现有的类型转换行为</span><span class="sxs-lookup"><span data-stu-id="a7367-118">Using Existing Type Conversion Behavior in XAML</span></span>  
 <span data-ttu-id="a7367-119">你可能已经在基础应用程序 XAML 中使用了类型转换行为，只是你还不知道，具体取决于你对基础 XAML 概念的熟悉程度。</span><span class="sxs-lookup"><span data-stu-id="a7367-119">Depending on your familiarity with the underlying XAML concepts, you may already be using type conversion behavior in basic application XAML without realizing it.</span></span> <span data-ttu-id="a7367-120">例如，WPF 定义成百上千个采用类型的值的属性<xref:System.Windows.Point>。</span><span class="sxs-lookup"><span data-stu-id="a7367-120">For instance, WPF defines literally hundreds of properties that take a value of type <xref:System.Windows.Point>.</span></span> <span data-ttu-id="a7367-121">一个<xref:System.Windows.Point>是描述二维坐标空间中中的坐标的值，它实际上只是具有两个重要属性：<xref:System.Windows.Point.X%2A>和<xref:System.Windows.Point.Y%2A>。</span><span class="sxs-lookup"><span data-stu-id="a7367-121">A <xref:System.Windows.Point> is a value that describes a coordinate in a two-dimensional coordinate space, and it really just has two important properties: <xref:System.Windows.Point.X%2A> and <xref:System.Windows.Point.Y%2A>.</span></span> <span data-ttu-id="a7367-122">如果在 XAML 中指定一个点，将其指定为分隔符 （通常为逗号） 的字符串之间<xref:System.Windows.Point.X%2A>和<xref:System.Windows.Point.Y%2A>你提供的值。</span><span class="sxs-lookup"><span data-stu-id="a7367-122">When you specify a point in XAML, you specify it as a string with a delimiter (typically a comma) between the <xref:System.Windows.Point.X%2A> and <xref:System.Windows.Point.Y%2A> values you provide.</span></span> <span data-ttu-id="a7367-123">例如：`<LinearGradientBrush StartPoint="0,0" EndPoint="1,1"/>`。</span><span class="sxs-lookup"><span data-stu-id="a7367-123">For example: `<LinearGradientBrush StartPoint="0,0" EndPoint="1,1"/>`.</span></span>  
  
 <span data-ttu-id="a7367-124">即使这种简单的<xref:System.Windows.Point>，而其简单的用法在 XAML 中涉及的类型转换器。</span><span class="sxs-lookup"><span data-stu-id="a7367-124">Even this simple type of <xref:System.Windows.Point> and its simple usage in XAML involve a type converter.</span></span> <span data-ttu-id="a7367-125">在这种情况下，这是类<xref:System.Windows.PointConverter>。</span><span class="sxs-lookup"><span data-stu-id="a7367-125">In this case that is the class <xref:System.Windows.PointConverter>.</span></span>  
  
 <span data-ttu-id="a7367-126">类型转换器<xref:System.Windows.Point>采用的所有属性的标记用法定义在类级别简化<xref:System.Windows.Point>。</span><span class="sxs-lookup"><span data-stu-id="a7367-126">The type converter for <xref:System.Windows.Point> defined at the class level streamlines the markup usages of all properties that take <xref:System.Windows.Point>.</span></span> <span data-ttu-id="a7367-127">如果没有类型转换器，那么对于前面显示的同一示例，将需要更冗长的标记，如下所示：</span><span class="sxs-lookup"><span data-stu-id="a7367-127">Without a type converter here, you would need the following much more verbose markup for the same example shown previously:</span></span>  

```xaml
<LinearGradientBrush>
  <LinearGradientBrush.StartPoint>
    <Point X="0" Y="0"/>
  </LinearGradientBrush.StartPoint>
  <LinearGradientBrush.EndPoint>
    <Point X="1" Y="1"/>
  </LinearGradientBrush.EndPoint>
</LinearGradientBrush>
 ```
  
 <span data-ttu-id="a7367-128">使用类型转换字符串或使用更复杂的等效语法通常是编码风格的选择。</span><span class="sxs-lookup"><span data-stu-id="a7367-128">Whether to use the type conversion string or a more verbose equivalent syntax is generally a coding style choice.</span></span> <span data-ttu-id="a7367-129">XAML 工具工作流也可能会影响值的设置方式。</span><span class="sxs-lookup"><span data-stu-id="a7367-129">Your XAML tooling workflow might also influence how values are set.</span></span> <span data-ttu-id="a7367-130">某些 XAML 工具可能会生成最复杂的标记窗体，以便更容易往返于设计器视图或其自身的序列化机制。</span><span class="sxs-lookup"><span data-stu-id="a7367-130">Some XAML tools tend to emit the most verbose form of the markup because it is easier to round-trip to designer views or its own serialization mechanism.</span></span>  
  
 <span data-ttu-id="a7367-131">现有的类型转换器可以通常会发现 WPF 和.NET Framework 类型通过检查类 （或属性） 的应用是否存在<xref:System.ComponentModel.TypeConverterAttribute>。</span><span class="sxs-lookup"><span data-stu-id="a7367-131">Existing type converters can generally be discovered on WPF and .NET Framework types by checking a class (or property) for the presence of an applied <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="a7367-132">此属性将对支持类型转换器转换类型的值的类进行命名，用于 XAML 或其他可能的用途。</span><span class="sxs-lookup"><span data-stu-id="a7367-132">This attribute will name the class that is the supporting type converter for values of that type, for XAML purposes as well as potentially other purposes.</span></span>  
  
### <a name="type-converters-and-markup-extensions"></a><span data-ttu-id="a7367-133">类型转换器和标记扩展</span><span class="sxs-lookup"><span data-stu-id="a7367-133">Type Converters and Markup Extensions</span></span>  
 <span data-ttu-id="a7367-134">标记扩展和类型转换器根据 XAML 处理器行为及其应用场景来实现正交角色。</span><span class="sxs-lookup"><span data-stu-id="a7367-134">Markup extensions and type converters fill orthogonal roles in terms of XAML processor behavior and the scenarios that they are applied to.</span></span> <span data-ttu-id="a7367-135">尽管上下文可用于标记扩展用途，但通常不会在标记扩展实现中检查属性的类型转换行为（其中标记扩展提供了一个值）。</span><span class="sxs-lookup"><span data-stu-id="a7367-135">Although context is available for markup extension usages, type conversion behavior of properties where a markup extension provides a value is generally is not checked in the markup extension implementations.</span></span> <span data-ttu-id="a7367-136">换言之，即使标记扩展返回一个文本字符串作为其 `ProvideValue` 输出，该字符串上应用于特定属性或属性值类型的类型转换行为也不会被调用。通常，标记扩展的目的是在不调用任何类型转换器的情况下，处理字符串和返回对象。</span><span class="sxs-lookup"><span data-stu-id="a7367-136">In other words, even if a markup extension returns a text string as its `ProvideValue` output, type conversion behavior on that string as applied to a specific property or property value type is not invoked, Generally, the purpose of a markup extension is to process a string and return an object without any type converter involved.</span></span>  
  
 <span data-ttu-id="a7367-137">需要标记扩展而不是类型转换器的一种常见情况是使对已存在的对象进行引用。</span><span class="sxs-lookup"><span data-stu-id="a7367-137">One common situation where a markup extension is necessary rather than a type converter is to make a reference to an object that already exists.</span></span> <span data-ttu-id="a7367-138">无状态类型转换器最多只能生成新实例，这可能并不理想。</span><span class="sxs-lookup"><span data-stu-id="a7367-138">At best, a stateless type converter could only generate a new instance, which might not be desirable.</span></span> <span data-ttu-id="a7367-139">若要深入了解标记扩展，请参阅[标记扩展和 WPF XAML](markup-extensions-and-wpf-xaml.md)。</span><span class="sxs-lookup"><span data-stu-id="a7367-139">For more information on markup extensions, see [Markup Extensions and WPF XAML](markup-extensions-and-wpf-xaml.md).</span></span>  
  
### <a name="native-type-converters"></a><span data-ttu-id="a7367-140">本机类型转换器</span><span class="sxs-lookup"><span data-stu-id="a7367-140">Native Type Converters</span></span>  
 <span data-ttu-id="a7367-141">在 XAML 分析器的 WPF 和 .NET XAML 实现中，某些特定类型具有本机类型转换处理，但在传统上可能不会将这些类型视为基元。</span><span class="sxs-lookup"><span data-stu-id="a7367-141">In the WPF and .NET Framework implementation of the XAML parser, there are certain types that have native type conversion handling, yet are not types that might conventionally be thought of as primitives.</span></span> <span data-ttu-id="a7367-142">这种类型的一个示例是 <xref:System.DateTime>。</span><span class="sxs-lookup"><span data-stu-id="a7367-142">An example of such a type is <xref:System.DateTime>.</span></span> <span data-ttu-id="a7367-143">这样做的原因基于.NET Framework 体系结构的工作原理： 类型<xref:System.DateTime>在 mscorlib，在.NET 中最基本的库中定义。</span><span class="sxs-lookup"><span data-stu-id="a7367-143">The reason for this is based on how the .NET Framework architecture works: the type <xref:System.DateTime> is defined in mscorlib, the most basic library in .NET.</span></span> <span data-ttu-id="a7367-144"><xref:System.DateTime> 不允许使用来自引入依赖关系的另一个程序集的属性特性 (<xref:System.ComponentModel.TypeConverterAttribute>来自系统) 因此不能支持通过特性的正常类型转换器发现机制。</span><span class="sxs-lookup"><span data-stu-id="a7367-144"><xref:System.DateTime> is not permitted to be attributed with an attribute that comes from another assembly that introduces a dependency (<xref:System.ComponentModel.TypeConverterAttribute> is from System) so the usual type converter discovery mechanism by attributing cannot be supported.</span></span> <span data-ttu-id="a7367-145">相反，XAML 分析器具有需要此类本机处理的类型的列表，它可通过与真正基元的处理方式类似的方式来处理这些类型。</span><span class="sxs-lookup"><span data-stu-id="a7367-145">Instead, the XAML parser has a list of types that need such native processing and processes these similarly to how the true primitives are processed.</span></span> <span data-ttu-id="a7367-146">(的情况下<xref:System.DateTime>这涉及调用<xref:System.DateTime.Parse%2A>。)</span><span class="sxs-lookup"><span data-stu-id="a7367-146">(In the case of <xref:System.DateTime> this involves a call to <xref:System.DateTime.Parse%2A>.)</span></span>  
  
<a name="Implementing_a_Type_Converter"></a>   
## <a name="implementing-a-type-converter"></a><span data-ttu-id="a7367-147">实现类型转换器</span><span class="sxs-lookup"><span data-stu-id="a7367-147">Implementing a Type Converter</span></span>  
  
### <a name="typeconverter"></a><span data-ttu-id="a7367-148">TypeConverter</span><span class="sxs-lookup"><span data-stu-id="a7367-148">TypeConverter</span></span>  
 <span data-ttu-id="a7367-149">在中<xref:System.Windows.Point>以前，给定类的示例<xref:System.Windows.PointConverter>提到过。</span><span class="sxs-lookup"><span data-stu-id="a7367-149">In the <xref:System.Windows.Point> example given previously, the class <xref:System.Windows.PointConverter> was mentioned.</span></span> <span data-ttu-id="a7367-150">适用于 XAML 的.NET 实现，用于 XAML 目的的所有类型转换器都是从基类派生的类<xref:System.ComponentModel.TypeConverter>。</span><span class="sxs-lookup"><span data-stu-id="a7367-150">For .NET implementations of XAML, all type converters that are used for XAML purposes are classes that derive from the base class <xref:System.ComponentModel.TypeConverter>.</span></span> <span data-ttu-id="a7367-151"><xref:System.ComponentModel.TypeConverter>类存在于版本的.NET Framework 出现之前的 XAML 中; 其原始用法之一是提供可视化设计器中的属性对话框的字符串转换。</span><span class="sxs-lookup"><span data-stu-id="a7367-151">The <xref:System.ComponentModel.TypeConverter> class existed in versions of .NET Framework that precede the existence of XAML; one of its original usages was to provide string conversion for property dialogs in visual designers.</span></span> <span data-ttu-id="a7367-152">为 XAML 的角色<xref:System.ComponentModel.TypeConverter>扩展以包含要启用分析字符串特性值，并可能返回到一个字符串处理特定对象属性的运行时间值的字符串到和从字符串转换类的基类为属性的序列化。</span><span class="sxs-lookup"><span data-stu-id="a7367-152">For XAML, the role of <xref:System.ComponentModel.TypeConverter> is expanded to include being the base class for to-string and from-string conversions that enable parsing a string attribute value, and possibly processing a run-time value of a particular object property back into a string for serialization as an attribute.</span></span>  
  
 <span data-ttu-id="a7367-153"><xref:System.ComponentModel.TypeConverter> 定义了四个成员与相关的转换以及从 XAML 处理用途的字符串转换为：</span><span class="sxs-lookup"><span data-stu-id="a7367-153"><xref:System.ComponentModel.TypeConverter> defines four members that are relevant for converting to and from strings for XAML processing purposes:</span></span>  
  
-   <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>  
  
-   <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A>  
  
-   <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>  
  
-   <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>  
  
 <span data-ttu-id="a7367-154">其中，最重要的方法是<xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>。</span><span class="sxs-lookup"><span data-stu-id="a7367-154">Of these, the most important method is <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>.</span></span> <span data-ttu-id="a7367-155">此方法将输入字符串转换为所需的对象类型。</span><span class="sxs-lookup"><span data-stu-id="a7367-155">This method converts the input string to the required object type.</span></span> <span data-ttu-id="a7367-156">严格地说，<xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>方法可以实现更广泛的类型转换为转换器的预期的目标类型，并因此有超出 XAML，如支持运行时的转换，但出于 XAML 目的的用途这是可以处理的代码路径<xref:System.String>很重要的输入。</span><span class="sxs-lookup"><span data-stu-id="a7367-156">Strictly speaking, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method could be implemented to convert a much wider range of types into the converter's intended destination type, and thus serve purposes that extend beyond XAML such as supporting run-time conversions, but for XAML purposes it is only the code path that can process a <xref:System.String> input that matters.</span></span>  
  
 <span data-ttu-id="a7367-157">下一步最重要的方法是<xref:System.ComponentModel.TypeConverter.ConvertTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="a7367-157">The next most important method is <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span></span> <span data-ttu-id="a7367-158">如果应用程序转换为标记表示形式 （例如，如果它已保存到 XAML 作为一个文件），<xref:System.ComponentModel.TypeConverter.ConvertTo%2A>负责生成标记表示形式。</span><span class="sxs-lookup"><span data-stu-id="a7367-158">If an application is converted to a markup representation (for instance, if it is saved to XAML as a file), <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is responsible for producing a markup representation.</span></span> <span data-ttu-id="a7367-159">在这种情况下，对 XAML 很重要的代码路径是传递`destinationType`的<xref:System.String>。</span><span class="sxs-lookup"><span data-stu-id="a7367-159">In this case, the code path that matters for XAML is when you pass a `destinationType` of <xref:System.String> .</span></span>  
  
 <span data-ttu-id="a7367-160"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> 和 <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> 是在服务查询 <xref:System.ComponentModel.TypeConverter> 实现的功能时使用的支持方法。</span><span class="sxs-lookup"><span data-stu-id="a7367-160"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> and <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> are support methods that are used when a service queries the capabilities of the <xref:System.ComponentModel.TypeConverter> implementation.</span></span> <span data-ttu-id="a7367-161">必须实现这些方法以便为转换器的等效转换方法支持的特定于类型的情况返回 `true` 。</span><span class="sxs-lookup"><span data-stu-id="a7367-161">You must implement these methods to return `true` for type-specific cases that the equivalent conversion methods of your converter support.</span></span> <span data-ttu-id="a7367-162">对于 XAML 用途，这通常意味着 <xref:System.String> 类型。</span><span class="sxs-lookup"><span data-stu-id="a7367-162">For XAML purposes, this generally means the <xref:System.String> type.</span></span>  
  
### <a name="culture-information-and-type-converters-for-xaml"></a><span data-ttu-id="a7367-163">XAML 的区域性信息和类型转换器</span><span class="sxs-lookup"><span data-stu-id="a7367-163">Culture Information and Type Converters for XAML</span></span>  
 <span data-ttu-id="a7367-164">每个<xref:System.ComponentModel.TypeConverter>实现可以有其自己的什么构成有效的字符串转换，解释，还可以使用或忽略作为参数传递的类型说明。</span><span class="sxs-lookup"><span data-stu-id="a7367-164">Each <xref:System.ComponentModel.TypeConverter> implementation can have its own interpretation of what constitutes a valid string for a conversion, and can also use or ignore the type description passed as parameters.</span></span> <span data-ttu-id="a7367-165">对于区域性和 XAML 类型转换，有一个重要的注意事项。</span><span class="sxs-lookup"><span data-stu-id="a7367-165">There is an important consideration with regard to culture and XAML type conversion.</span></span> <span data-ttu-id="a7367-166">XAML 完全支持使用可本地化的字符串作为特性值。</span><span class="sxs-lookup"><span data-stu-id="a7367-166">Using localizable strings as attribute values is entirely supported by XAML.</span></span> <span data-ttu-id="a7367-167">但不支持将该可本地化字符串用作具有特定区域性要求的类型转换器输入，因为 XAML 特性值的类型转换器包含一个必要的固定语言分析行为，该行为使用 `en-US` 区域性。</span><span class="sxs-lookup"><span data-stu-id="a7367-167">But using that localizable string as type converter input with specific culture requirements is not supported, because type converters for XAML attribute values involve a necessarily fixed-language parsing behavior, using `en-US` culture.</span></span> <span data-ttu-id="a7367-168">有关此限制的设计原因的更多信息，请查阅 XAML 语言规范 ([\[MS-XAML\]](https://go.microsoft.com/fwlink/?LinkId=114525))。</span><span class="sxs-lookup"><span data-stu-id="a7367-168">For more information on the design reasons for this restriction, you should consult the XAML language specification ([\[MS-XAML\]](https://go.microsoft.com/fwlink/?LinkId=114525)).</span></span>  
  
 <span data-ttu-id="a7367-169">区域性可能会产生问题的示例之一是，某些区域性使用逗号作为数字的小数点分隔符。</span><span class="sxs-lookup"><span data-stu-id="a7367-169">As an example where culture can be an issue, some cultures use a comma as their decimal point delimiter for numbers.</span></span> <span data-ttu-id="a7367-170">这将与许多 WPF XAML 类型转换器所具有的使用逗号作为分隔符的行为发生冲突（根据常用的 X,Y 形式等过去的先例，或逗号分隔的列表）。</span><span class="sxs-lookup"><span data-stu-id="a7367-170">This will collide with the behavior that many of the WPF XAML type converters have, which is to use a comma as a delimiter (based on historical precedents such as the common X,Y form, or comma delimited lists).</span></span> <span data-ttu-id="a7367-171">即使在周围的 XAML 中传递区域性（将 `Language` 或 `xml:lang` 设置为 `sl-SI` 区域性，以此方式使用逗号作为小数点的区域性的一个示例）也不能解决此问题。</span><span class="sxs-lookup"><span data-stu-id="a7367-171">Even passing a culture in the surrounding XAML (setting `Language` or `xml:lang` to the `sl-SI` culture, an example of a culture that uses a comma for decimal in this way) does not solve the issue.</span></span>  
  
### <a name="implementing-convertfrom"></a><span data-ttu-id="a7367-172">实现 ConvertFrom</span><span class="sxs-lookup"><span data-stu-id="a7367-172">Implementing ConvertFrom</span></span>  
 <span data-ttu-id="a7367-173">若要能够用作支持 XAML 的 <xref:System.ComponentModel.TypeConverter> 实现，该转换器的 <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> 方法必须接受字符串作为 `value` 参数。</span><span class="sxs-lookup"><span data-stu-id="a7367-173">To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method for that converter must accept a string as the `value` parameter.</span></span> <span data-ttu-id="a7367-174">如果字符串的有效格式，并可以通过转换<xref:System.ComponentModel.TypeConverter>实现中，则返回的对象必须支持强制转换为属性预期的类型。</span><span class="sxs-lookup"><span data-stu-id="a7367-174">If the string was in valid format, and can be converted by the <xref:System.ComponentModel.TypeConverter> implementation, then the returned object must support a cast to the type expected by the property.</span></span> <span data-ttu-id="a7367-175">否则， <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> 实现必须返回 `null`。</span><span class="sxs-lookup"><span data-stu-id="a7367-175">Otherwise, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation must return `null`.</span></span>  
  
 <span data-ttu-id="a7367-176">每个<xref:System.ComponentModel.TypeConverter>实现可以具有其自己的什么构成有效的字符串转换，解释，还可以使用或忽略作为参数传递的类型说明或区域性上下文。</span><span class="sxs-lookup"><span data-stu-id="a7367-176">Each <xref:System.ComponentModel.TypeConverter> implementation can have its own interpretation of what constitutes a valid string for a conversion, and can also use or ignore the type description or culture contexts passed as parameters.</span></span> <span data-ttu-id="a7367-177">但是，WPF XAML 处理可能不会在所有情况下都将值传递给类型说明上下文，还可能不会基于 `xml:lang` 传递区域性。</span><span class="sxs-lookup"><span data-stu-id="a7367-177">However, the WPF XAML processing might not pass values to the type description context in all cases, and also might not pass culture based on `xml:lang`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a7367-178">请勿使用大括号字符（尤其是 {）作为字符串格式的可能元素。</span><span class="sxs-lookup"><span data-stu-id="a7367-178">Do not use the curly brace characters, particularly {, as a possible element of your string format.</span></span> <span data-ttu-id="a7367-179">这些字符保留作为标记扩展序列的入口和出口。</span><span class="sxs-lookup"><span data-stu-id="a7367-179">These characters are reserved as the entry and exit for a markup extension sequence.</span></span>  
  
### <a name="implementing-convertto"></a><span data-ttu-id="a7367-180">实现 ConvertTo</span><span class="sxs-lookup"><span data-stu-id="a7367-180">Implementing ConvertTo</span></span>  
 <span data-ttu-id="a7367-181"><xref:System.ComponentModel.TypeConverter.ConvertTo%2A> 可能用于序列化支持。</span><span class="sxs-lookup"><span data-stu-id="a7367-181"><xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is potentially used for serialization support.</span></span> <span data-ttu-id="a7367-182">通过 <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> 为自定义类型及其类型转换器实现的序列化支持不是绝对要求。</span><span class="sxs-lookup"><span data-stu-id="a7367-182">Serialization support through <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> for your custom type and its type converter is not an absolute requirement.</span></span> <span data-ttu-id="a7367-183">但是，如果要实现控件，或使用序列化作为类的功能或设计的一部分，则应实现 <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="a7367-183">However, if you are implementing a control, or using serialization of as part of the features or design of your class, you should implement <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span></span>  
  
 <span data-ttu-id="a7367-184">若要能够用作<xref:System.ComponentModel.TypeConverter>支持 XAML，实现<xref:System.ComponentModel.TypeConverter.ConvertTo%2A>该转换器的方法必须接受的类型 （或值），它支持实例作为`value`参数。</span><span class="sxs-lookup"><span data-stu-id="a7367-184">To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> method for that converter must accept an instance of the type (or a value) being supported as the `value` parameter.</span></span> <span data-ttu-id="a7367-185">当`destinationType`参数的类型为<xref:System.String>，则返回的对象必须能够强制转换为<xref:System.String>。</span><span class="sxs-lookup"><span data-stu-id="a7367-185">When the `destinationType` parameter is the type <xref:System.String>, then the returned object must be able to be cast as <xref:System.String>.</span></span> <span data-ttu-id="a7367-186">返回字符串必须表示 `value`的序列化值。</span><span class="sxs-lookup"><span data-stu-id="a7367-186">The returned string must represent a serialized value of `value`.</span></span> <span data-ttu-id="a7367-187">理想情况下，你选择的序列化格式应能够生成相同的值，如果该字符串传递到<xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>而丢失大量信息不相同转换器的实现。</span><span class="sxs-lookup"><span data-stu-id="a7367-187">Ideally, the serialization format you choose should be capable of generating the same value if that string were passed to the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation of the same converter, without significant loss of information.</span></span>  
  
 <span data-ttu-id="a7367-188">如果值不能序列化，或转换器不支持序列化<xref:System.ComponentModel.TypeConverter.ConvertTo%2A>实现必须返回`null`，并允许在此情况下引发异常。</span><span class="sxs-lookup"><span data-stu-id="a7367-188">If the value cannot be serialized, or the converter does not support serialization, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> implementation must return `null`, and is permitted to throw an exception in this case.</span></span> <span data-ttu-id="a7367-189">如果引发了异常，则应报告无法使用该转换作为的一部分，但你<xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>实现，以便检查功能的最佳做法<xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>首先以避免异常支持。</span><span class="sxs-lookup"><span data-stu-id="a7367-189">But if you do throw exceptions, you should report the inability to use that conversion as part of your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation so that the best practice of checking with <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> first to avoid exceptions is supported.</span></span>  
  
 <span data-ttu-id="a7367-190">如果`destinationType`参数的类型不是<xref:System.String>，可以选择自己的转换器处理。</span><span class="sxs-lookup"><span data-stu-id="a7367-190">If `destinationType` parameter is not of type <xref:System.String>, you can choose your own converter handling.</span></span> <span data-ttu-id="a7367-191">通常情况下，你要恢复处理，这会在最基本的基实现<xref:System.ComponentModel.TypeConverter.ConvertTo%2A>引发特定异常。</span><span class="sxs-lookup"><span data-stu-id="a7367-191">Typically, you would revert to base implementation handling, which in the basemost <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> raises a specific exception.</span></span>  
  
### <a name="implementing-canconvertto"></a><span data-ttu-id="a7367-192">实现 CanConvertTo</span><span class="sxs-lookup"><span data-stu-id="a7367-192">Implementing CanConvertTo</span></span>  
 <span data-ttu-id="a7367-193">对于 <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> 类型的 `true` ， `destinationType` 实现应返回 <xref:System.String>，否则遵从基实现。</span><span class="sxs-lookup"><span data-stu-id="a7367-193">Your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation should return `true` for `destinationType` of type <xref:System.String>, and otherwise defer to the base implementation.</span></span>  
  
### <a name="implementing-canconvertfrom"></a><span data-ttu-id="a7367-194">实现 CanConvertFrom</span><span class="sxs-lookup"><span data-stu-id="a7367-194">Implementing CanConvertFrom</span></span>  
 <span data-ttu-id="a7367-195">对于 <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> 类型的 `true` ， `sourceType` 实现应返回 <xref:System.String>，否则遵从基实现。</span><span class="sxs-lookup"><span data-stu-id="a7367-195">Your <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> implementation should return `true` for `sourceType` of type <xref:System.String>, and otherwise defer to the base implementation.</span></span>  
  
<a name="Applying_the_TypeConverterAttribute"></a>   
## <a name="applying-the-typeconverterattribute"></a><span data-ttu-id="a7367-196">应用 TypeConverterAttribute</span><span class="sxs-lookup"><span data-stu-id="a7367-196">Applying the TypeConverterAttribute</span></span>  
 <span data-ttu-id="a7367-197">为了使你的自定义类型转换器作为使用由 XAML 处理器的自定义类的类型转换器，必须应用[!INCLUDE[TLA#tla_netframewkattr](../../../../includes/tlasharptla-netframewkattr-md.md)]<xref:System.ComponentModel.TypeConverterAttribute>向类定义。</span><span class="sxs-lookup"><span data-stu-id="a7367-197">In order for your custom type converter to be used as the acting type converter for a custom class by a XAML processor, you must apply the [!INCLUDE[TLA#tla_netframewkattr](../../../../includes/tlasharptla-netframewkattr-md.md)] <xref:System.ComponentModel.TypeConverterAttribute> to your class definition.</span></span> <span data-ttu-id="a7367-198">通过特性指定的 <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> 必须是自定义类型转换器的类型名。</span><span class="sxs-lookup"><span data-stu-id="a7367-198">The <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> that you specify through the attribute must be the type name of your custom type converter.</span></span> <span data-ttu-id="a7367-199">应用此特性后，当 XAML 处理器处理属性类型使用自定义类类型的值时，它可以输入字符串并返回对象实例。</span><span class="sxs-lookup"><span data-stu-id="a7367-199">With this attribute applied, when a XAML processor handles values where the property type uses your custom class type, it can input strings and return object instances.</span></span>  
  
 <span data-ttu-id="a7367-200">还可以基于每个属性提供类型转换器。</span><span class="sxs-lookup"><span data-stu-id="a7367-200">You can also provide a type converter on a per-property basis.</span></span> <span data-ttu-id="a7367-201">应将 [!INCLUDE[TLA#tla_netframewkattr](../../../../includes/tlasharptla-netframewkattr-md.md)] <xref:System.ComponentModel.TypeConverterAttribute> 应用于属性定义（主定义，不是它包含的 `get`/`set` 的实现），而不是将它应用于类定义。</span><span class="sxs-lookup"><span data-stu-id="a7367-201">Instead of applying a [!INCLUDE[TLA#tla_netframewkattr](../../../../includes/tlasharptla-netframewkattr-md.md)] <xref:System.ComponentModel.TypeConverterAttribute> to the class definition, apply it to a property definition (the main definition, not the `get`/`set` implementations within it).</span></span> <span data-ttu-id="a7367-202">属性的类型必须与自定义类型转换器处理的类型匹配。</span><span class="sxs-lookup"><span data-stu-id="a7367-202">The type of the property must match the type that is processed by your custom type converter.</span></span> <span data-ttu-id="a7367-203">应用此特性后，当 XAML 处理器处理该属性的值时，它可以处理输入字符串并返回对象实例。</span><span class="sxs-lookup"><span data-stu-id="a7367-203">With this attribute applied, when a XAMLprocessor handles values of that property, it can process input strings and return object instances.</span></span> <span data-ttu-id="a7367-204">每个属性类型转换器方法会特别有用，如果您选择使用 Microsoft.NET Framework 中或某些其他库其中无法控制类定义并且无法应用的属性类型<xref:System.ComponentModel.TypeConverterAttribute>存在。</span><span class="sxs-lookup"><span data-stu-id="a7367-204">The per-property type converter technique is particularly useful if you choose to use a property type from Microsoft .NET Framework or from some other library where you cannot control the class definition and cannot apply a <xref:System.ComponentModel.TypeConverterAttribute> there.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="a7367-205">请参阅</span><span class="sxs-lookup"><span data-stu-id="a7367-205">See also</span></span>
- <xref:System.ComponentModel.TypeConverter>
- [<span data-ttu-id="a7367-206">XAML 概述 (WPF)</span><span class="sxs-lookup"><span data-stu-id="a7367-206">XAML Overview (WPF)</span></span>](xaml-overview-wpf.md)
- [<span data-ttu-id="a7367-207">标记扩展和 WPF XAML</span><span class="sxs-lookup"><span data-stu-id="a7367-207">Markup Extensions and WPF XAML</span></span>](markup-extensions-and-wpf-xaml.md)
- [<span data-ttu-id="a7367-208">XAML 语法详述</span><span class="sxs-lookup"><span data-stu-id="a7367-208">XAML Syntax In Detail</span></span>](xaml-syntax-in-detail.md)
