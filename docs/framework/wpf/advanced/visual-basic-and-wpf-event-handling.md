---
title: Visual Basic 和 WPF 事件处理
ms.date: 03/30/2017
helpviewer_keywords:
- Visual Basic [WPF], event handlers
- event handlers [WPF], Visual Basic
ms.assetid: ad4eb9aa-3afc-4a71-8cf6-add3fbea54a1
ms.openlocfilehash: 8407958ec76be7e402025ece57371e67581e5291
ms.sourcegitcommit: 68653db98c5ea7744fd438710248935f70020dfb
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 08/22/2019
ms.locfileid: "69942120"
---
# <a name="visual-basic-and-wpf-event-handling"></a><span data-ttu-id="f77a9-102">Visual Basic 和 WPF 事件处理</span><span class="sxs-lookup"><span data-stu-id="f77a9-102">Visual Basic and WPF Event Handling</span></span>
<span data-ttu-id="f77a9-103">具体而言, 对于 Microsoft Visual Basic .net 语言, 可以使用特定`Handles`于语言的关键字将事件处理程序与实例关联, 而不是将事件处理程序附加到特性或<xref:System.Windows.UIElement.AddHandler%2A>使用方法。</span><span class="sxs-lookup"><span data-stu-id="f77a9-103">For the Microsoft Visual Basic .NET language specifically, you can use the language-specific `Handles` keyword to associate event handlers with instances, instead of attaching event handlers with attributes or using the <xref:System.Windows.UIElement.AddHandler%2A> method.</span></span> <span data-ttu-id="f77a9-104">但是，用于将处理程序附加到实例的 `Handles` 技术存在一些限制，因为 `Handles` 语法不支持 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 事件系统的某些特定路由事件功能。</span><span class="sxs-lookup"><span data-stu-id="f77a9-104">However, the `Handles` technique for attaching handlers to instances does have some limitations, because the `Handles` syntax cannot support some of the specific routed event features of the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] event system.</span></span>  
  
## <a name="using-handles-in-a-wpf-application"></a><span data-ttu-id="f77a9-105">在 WPF 应用程序中使用“Handles”</span><span class="sxs-lookup"><span data-stu-id="f77a9-105">Using "Handles" in a WPF Application</span></span>  
 <span data-ttu-id="f77a9-106">通过 `Handles` 连接到实例和事件的事件处理程序必须全部在实例的分部类声明中定义，此要求也适用于通过元素上的特性值进行分配的事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="f77a9-106">The event handlers that are connected to instances and events with `Handles` must all be defined within the partial class declaration of the instance, which is also a requirement for event handlers that are assigned through attribute values on elements.</span></span> <span data-ttu-id="f77a9-107">只能为`Handles` <xref:System.Windows.FrameworkContentElement.Name%2A>具有属性值 (或声明了[x:Name 指令](../../xaml-services/x-name-directive.md)) 的页上的元素指定。</span><span class="sxs-lookup"><span data-stu-id="f77a9-107">You can only specify `Handles` for an element on the page that has a <xref:System.Windows.FrameworkContentElement.Name%2A> property value (or [x:Name Directive](../../xaml-services/x-name-directive.md) declared).</span></span> <span data-ttu-id="f77a9-108">这是因为中<xref:System.Windows.FrameworkContentElement.Name%2A> [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]的会创建支持实例所必需的实例引用 *。* `Handles`语法所需的事件引用格式。</span><span class="sxs-lookup"><span data-stu-id="f77a9-108">This is because the <xref:System.Windows.FrameworkContentElement.Name%2A> in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] creates the instance reference that is necessary to support the *Instance.Event* reference format required by the `Handles` syntax.</span></span> <span data-ttu-id="f77a9-109">`Handles` 无<xref:System.Windows.FrameworkContentElement.Name%2A>需引用即可使用的唯一元素是用于定义分部类的根元素实例。</span><span class="sxs-lookup"><span data-stu-id="f77a9-109">The only element that can be used for `Handles` without a <xref:System.Windows.FrameworkContentElement.Name%2A> reference is the root-element instance that defines the partial class.</span></span>  
  
 <span data-ttu-id="f77a9-110">可以通过使用逗号分隔 `Handles` 后面的 Instance.Event 引用，向多个元素分配相同的处理程序。</span><span class="sxs-lookup"><span data-stu-id="f77a9-110">You can assign the same handler to multiple elements by separating *Instance.Event* references after `Handles` with commas.</span></span>  
  
 <span data-ttu-id="f77a9-111">可以使用 `Handles` 将多个处理程序分配给同一 Instance.Event 引用。</span><span class="sxs-lookup"><span data-stu-id="f77a9-111">You can use `Handles` to assign more than one handler to the same *Instance.Event*reference.</span></span> <span data-ttu-id="f77a9-112">请勿对 `Handles` 引用中特定处理程序的提供顺序赋予任何重要性；应假定可按任何顺序调用处理相同事件的处理程序。</span><span class="sxs-lookup"><span data-stu-id="f77a9-112">Do not assign any importance to the order in which handlers are given in the `Handles` reference; you should assume that handlers that handle the same event can be invoked in any order.</span></span>  
  
 <span data-ttu-id="f77a9-113">若要删除在声明中添加的`Handles`处理程序, 可以调用。 <xref:System.Windows.UIElement.RemoveHandler%2A></span><span class="sxs-lookup"><span data-stu-id="f77a9-113">To remove a handler that was added with `Handles` in the declaration, you can call <xref:System.Windows.UIElement.RemoveHandler%2A>.</span></span>  
  
 <span data-ttu-id="f77a9-114">如果要将处理程序附加到实例成员表中用于定义要处理的事件的实例，可使用 `Handles` 附加路由事件的处理程序。</span><span class="sxs-lookup"><span data-stu-id="f77a9-114">You can use `Handles` to attach handlers for routed events, so long as you attach handlers to instances that define the event being handled in their members tables.</span></span> <span data-ttu-id="f77a9-115">对于路由事件, 附加了`Handles`的处理程序遵循的路由规则与作为[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]特性附加的处理程序或的公共签名<xref:System.Windows.UIElement.AddHandler%2A>相同。</span><span class="sxs-lookup"><span data-stu-id="f77a9-115">For routed events, handlers that are attached with `Handles` follow the same routing rules as do handlers that are attached as [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] attributes, or with the common signature of <xref:System.Windows.UIElement.AddHandler%2A>.</span></span> <span data-ttu-id="f77a9-116">这意味着, 如果事件已标记为已处理 (事件<xref:System.Windows.RoutedEventArgs.Handled%2A>数据中的属性为`True`), 则不会调用附加`Handles`的处理程序来响应该事件实例。</span><span class="sxs-lookup"><span data-stu-id="f77a9-116">This means that if the event is already marked handled (the <xref:System.Windows.RoutedEventArgs.Handled%2A> property in the event data is `True`), then handlers attached with `Handles` are not invoked in response to that event instance.</span></span> <span data-ttu-id="f77a9-117">可通过路由中另一个元素上的实例处理程序，或通过在路由中当前元素或更早元素上进行类处理，将事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f77a9-117">The event could be marked handled by instance handlers on another element in the route, or by class handling either on the current element or earlier elements along the route.</span></span> <span data-ttu-id="f77a9-118">对于可支持成对的隧道事件/冒泡事件的输入事件，隧道路由可能已将事件对标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f77a9-118">For input events that support paired tunnel/bubble events, the tunneling route may have marked the event pair handled.</span></span> <span data-ttu-id="f77a9-119">有关路由事件的详细信息，请参阅[路由事件概述](routed-events-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="f77a9-119">For more information about routed events, see [Routed Events Overview](routed-events-overview.md).</span></span>  
  
## <a name="limitations-of-handles-for-adding-handlers"></a><span data-ttu-id="f77a9-120">添加处理程序时的“Handles”限制</span><span class="sxs-lookup"><span data-stu-id="f77a9-120">Limitations of "Handles" for Adding Handlers</span></span>  
 <span data-ttu-id="f77a9-121">`Handles` 无法引用附加事件的处理程序。</span><span class="sxs-lookup"><span data-stu-id="f77a9-121">`Handles` cannot reference handlers for attached events.</span></span> <span data-ttu-id="f77a9-122">必须对该附加事件使用 `add` 访问方法，或使用 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 中的 typename.eventname事件特性。</span><span class="sxs-lookup"><span data-stu-id="f77a9-122">You must use the `add` accessor method for that attached event, or *typename.eventname* event attributes in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].</span></span> <span data-ttu-id="f77a9-123">有关详细信息，请参阅[路由事件概述](routed-events-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="f77a9-123">For details, see [Routed Events Overview](routed-events-overview.md).</span></span>  
  
 <span data-ttu-id="f77a9-124">对于路由事件，只能使用 `Handles` 为实例成员表中存在该事件的实例分配处理程序。</span><span class="sxs-lookup"><span data-stu-id="f77a9-124">For routed events, you can only use `Handles` to assign handlers for instances where that event exists in the instance members table.</span></span> <span data-ttu-id="f77a9-125">但是，对于一般的路由事件，父元素可以是来自子元素的事件的侦听器，即使该父元素的成员表中没有此事件也是如此。</span><span class="sxs-lookup"><span data-stu-id="f77a9-125">However, with routed events in general, a parent element can be a listener for an event from child elements, even if the parent element does not have that event in its members table.</span></span> <span data-ttu-id="f77a9-126">在特性语法中，这可以通过 typename.membername 特性形式来指定，此形式限定哪种类型实际定义要处理的事件。</span><span class="sxs-lookup"><span data-stu-id="f77a9-126">In attribute syntax, you can specify this through a *typename.membername* attribute form that qualifies which type actually defines the event you want to handle.</span></span> <span data-ttu-id="f77a9-127">例如, 父代`Page` (没有`Click`定义事件) 可以通过在表单`Button.Click`中分配属性处理程序来侦听按钮单击事件。</span><span class="sxs-lookup"><span data-stu-id="f77a9-127">For instance, a parent `Page` (with no `Click` event defined) can listen for button-click events by assigning an attribute handler in the form `Button.Click`.</span></span> <span data-ttu-id="f77a9-128">但 `Handles` 不支持 typename.membername 形式，因为它必须支持与该形式冲突的 Instance.Event 形式。</span><span class="sxs-lookup"><span data-stu-id="f77a9-128">But `Handles` does not support the *typename.membername* form, because it must support a conflicting *Instance.Event* form.</span></span> <span data-ttu-id="f77a9-129">有关详细信息，请参阅[路由事件概述](routed-events-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="f77a9-129">For details, see [Routed Events Overview](routed-events-overview.md).</span></span>  
  
 <span data-ttu-id="f77a9-130">`Handles` 无法附加针对标记为已处理的事件而调用的处理程序。</span><span class="sxs-lookup"><span data-stu-id="f77a9-130">`Handles` cannot attach handlers that are invoked for events that are already marked handled.</span></span> <span data-ttu-id="f77a9-131">相反, 您必须使用代码并调用`handledEventsToo`的<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>重载。</span><span class="sxs-lookup"><span data-stu-id="f77a9-131">Instead, you must use code and call the `handledEventsToo` overload of <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="f77a9-132">在 XAML 中为`Handles`同一事件指定事件处理程序时, 请不要在 Visual Basic 代码中使用语法。</span><span class="sxs-lookup"><span data-stu-id="f77a9-132">Do not use the `Handles` syntax in Visual Basic code when you specify an event handler for the same event in XAML.</span></span> <span data-ttu-id="f77a9-133">在这种情况下，将调用事件处理程序两次。</span><span class="sxs-lookup"><span data-stu-id="f77a9-133">In this case, the event handler is called twice.</span></span>  
  
## <a name="how-wpf-implements-handles-functionality"></a><span data-ttu-id="f77a9-134">WPF 如何实现“Handles”功能</span><span class="sxs-lookup"><span data-stu-id="f77a9-134">How WPF Implements "Handles" Functionality</span></span>  
 <span data-ttu-id="f77a9-135">`Friend` `WithEvents` <xref:System.Windows.FrameworkContentElement.Name%2A> 编译页面时, 中间文件声明对页面上设置了属性 (或声明了 [x:Name](../../xaml-services/x-name-directive.md) 指令) 的每个元素的引用。 [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)]</span><span class="sxs-lookup"><span data-stu-id="f77a9-135">When a [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] page is compiled, the intermediate file declares `Friend` `WithEvents` references to every element on the page that has a <xref:System.Windows.FrameworkContentElement.Name%2A> property set (or [x:Name Directive](../../xaml-services/x-name-directive.md) declared).</span></span> <span data-ttu-id="f77a9-136">每个命名实例都可能是可通过 `Handles` 分配给处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f77a9-136">Each named instance is potentially an element that can be assigned to a handler through `Handles`.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="f77a9-137">在[!INCLUDE[TLA#tla_visualstu](../../../../includes/tlasharptla-visualstu-md.md)]中, IntelliSense 可以显示已完成的元素, 可`Handles`用于页面中的引用。</span><span class="sxs-lookup"><span data-stu-id="f77a9-137">Within [!INCLUDE[TLA#tla_visualstu](../../../../includes/tlasharptla-visualstu-md.md)], IntelliSense can show you completion for which elements are available for a `Handles` reference in a page.</span></span> <span data-ttu-id="f77a9-138">但是，这可能需要执行一个编译传递，以便中间文件可以填充所有 `Friends` 引用。</span><span class="sxs-lookup"><span data-stu-id="f77a9-138">However, this might take one compile pass so that the intermediate file can populate all the `Friends` references.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="f77a9-139">请参阅</span><span class="sxs-lookup"><span data-stu-id="f77a9-139">See also</span></span>

- <xref:System.Windows.UIElement.AddHandler%2A>
- [<span data-ttu-id="f77a9-140">将路由事件标记为“已处理”和“类处理”</span><span class="sxs-lookup"><span data-stu-id="f77a9-140">Marking Routed Events as Handled, and Class Handling</span></span>](marking-routed-events-as-handled-and-class-handling.md)
- [<span data-ttu-id="f77a9-141">路由事件概述</span><span class="sxs-lookup"><span data-stu-id="f77a9-141">Routed Events Overview</span></span>](routed-events-overview.md)
- [<span data-ttu-id="f77a9-142">XAML 概述 (WPF)</span><span class="sxs-lookup"><span data-stu-id="f77a9-142">XAML Overview (WPF)</span></span>](xaml-overview-wpf.md)
