---
title: 预览事件
ms.date: 03/30/2017
helpviewer_keywords:
- Preview events [WPF]
- suppressing events [WPF]
- events [WPF], Preview
- events [WPF], suppressing
ms.assetid: b5032308-aa9c-4d02-af11-630ecec8df7e
ms.openlocfilehash: 75165df94aa8b508ef85cf970933efb98b9d62ca
ms.sourcegitcommit: 5b6d778ebb269ee6684fb57ad69a8c28b06235b9
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/08/2019
ms.locfileid: "59211384"
---
# <a name="preview-events"></a><span data-ttu-id="cfcd1-102">预览事件</span><span class="sxs-lookup"><span data-stu-id="cfcd1-102">Preview Events</span></span>
<span data-ttu-id="cfcd1-103">预览事件，也称为隧道事件，也是路由的路由的事件，在应用程序根元素引发该事件并报告为事件数据中的源间传递的方向。</span><span class="sxs-lookup"><span data-stu-id="cfcd1-103">Preview events, also known as tunneling events, are routed events where the direction of the route travels from the application root towards the element that raised the event and is reported as the source in event data.</span></span> <span data-ttu-id="cfcd1-104">并非所有事件方案支持或要求预览事件;本主题介绍的情况下，预览事件存在，应用程序或组件应如何处理它们和在其中创建自定义组件或类中的预览事件可能是适当的情况。</span><span class="sxs-lookup"><span data-stu-id="cfcd1-104">Not all event scenarios support or require preview events; this topic describes the situations where preview events exist, how applications or components should handle them, and cases where creating preview events in custom components or classes might be appropriate.</span></span>  
  
## <a name="preview-events-and-input"></a><span data-ttu-id="cfcd1-105">预览事件和输入</span><span class="sxs-lookup"><span data-stu-id="cfcd1-105">Preview Events and Input</span></span>  
 <span data-ttu-id="cfcd1-106">在处理事件一般情况下，则应注意的预览版时将事件标记在事件中处理数据。</span><span class="sxs-lookup"><span data-stu-id="cfcd1-106">When you handle Preview events in general, be cautious about marking the events handled in the event data.</span></span> <span data-ttu-id="cfcd1-107">而不处理任何元素上的预览事件引发它 （将被报告为中的事件数据源的元素） 的元素具有不提供机会处理产生的事件元素的效果。</span><span class="sxs-lookup"><span data-stu-id="cfcd1-107">Handling a Preview event on any element other than the element that raised it (the element that is reported as the source in the event data) has the effect of not providing an element the opportunity to handle the event that it originated.</span></span> <span data-ttu-id="cfcd1-108">有时这是所需的结果，尤其是在控件的该组合中的关系中存在所涉及的元素。</span><span class="sxs-lookup"><span data-stu-id="cfcd1-108">Sometimes this is the desired result, particularly if the elements in question exist in relationships within the compositing of a control.</span></span>  
  
 <span data-ttu-id="cfcd1-109">输入事件的具体来说，预览事件也共享事件数据实例与等效的浮升事件。</span><span class="sxs-lookup"><span data-stu-id="cfcd1-109">For input events specifically, Preview events also share event data instances with the equivalent bubbling event.</span></span> <span data-ttu-id="cfcd1-110">如果使用预览事件类处理程序将处理该输入的事件标记，将不会调用浮升输入的事件的类处理程序。</span><span class="sxs-lookup"><span data-stu-id="cfcd1-110">If you use a Preview event class handler to mark the input event handled, the bubbling input event class handler will not be invoked.</span></span> <span data-ttu-id="cfcd1-111">或者，如果使用预览事件实例处理程序将处理该事件标记，浮升事件的处理程序将不通常会调用。</span><span class="sxs-lookup"><span data-stu-id="cfcd1-111">Or, if you use a Preview event instance handler to mark the event handled, handlers for the bubbling event will not typically be invoked.</span></span> <span data-ttu-id="cfcd1-112">类处理程序或实例处理程序可以注册或附加要调用即使事件被标记为已处理，但该技术不常使用的选项。</span><span class="sxs-lookup"><span data-stu-id="cfcd1-112">Class handlers or instance handlers can be registered or attached with an option to be invoked even if the event is marked handled, but that technique is not commonly used.</span></span>  
  
 <span data-ttu-id="cfcd1-113">有关类处理并将它与预览事件的详细信息请参阅[路由事件标记为已处理，和类处理](marking-routed-events-as-handled-and-class-handling.md)。</span><span class="sxs-lookup"><span data-stu-id="cfcd1-113">For more information about class handling and how it relates to Preview events see [Marking Routed Events as Handled, and Class Handling](marking-routed-events-as-handled-and-class-handling.md).</span></span>  
  
### <a name="working-around-event-suppression-by-controls"></a><span data-ttu-id="cfcd1-114">通过控件解决事件禁止问题</span><span class="sxs-lookup"><span data-stu-id="cfcd1-114">Working Around Event Suppression by Controls</span></span>  
 <span data-ttu-id="cfcd1-115">通常用于预览事件的一个方案是，对于复合控件的输入事件的处理。</span><span class="sxs-lookup"><span data-stu-id="cfcd1-115">One scenario where Preview events are commonly used is for composited control handling of input events.</span></span> <span data-ttu-id="cfcd1-116">有时，控件作者禁止显示中的某些事件可能是为了替换上携带更多信息或者指示更具体的行为的组件定义事件源自其控件。</span><span class="sxs-lookup"><span data-stu-id="cfcd1-116">Sometimes, the author of the control suppresses a certain event from originating from their control, perhaps in order to substitute a component-defined event that carries more information or implies a more specific behavior.</span></span> <span data-ttu-id="cfcd1-117">例如， [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button>取消<xref:System.Windows.UIElement.MouseLeftButtonDown>和<xref:System.Windows.UIElement.MouseRightButtonDown>引发浮升事件<xref:System.Windows.Controls.Button>或复合元素上的，以便支持捕获鼠标并引发<xref:System.Windows.Controls.Primitives.ButtonBase.Click>始终由引发的事件<xref:System.Windows.Controls.Button>本身。</span><span class="sxs-lookup"><span data-stu-id="cfcd1-117">For instance, a [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> suppresses <xref:System.Windows.UIElement.MouseLeftButtonDown> and <xref:System.Windows.UIElement.MouseRightButtonDown> bubbling events raised by the <xref:System.Windows.Controls.Button> or its composite elements in favor of capturing the mouse and raising a <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event that is always raised by the <xref:System.Windows.Controls.Button> itself.</span></span> <span data-ttu-id="cfcd1-118">事件和其数据仍继续沿路由，但由于<xref:System.Windows.Controls.Button>将标记作为事件数据<xref:System.Windows.RoutedEventArgs.Handled%2A>，仅用于明确指定它们应在处理该事件的处理程序`handledEventsToo`调用用例。</span><span class="sxs-lookup"><span data-stu-id="cfcd1-118">The event and its data still continue along the route, but because the <xref:System.Windows.Controls.Button> marks the event data as <xref:System.Windows.RoutedEventArgs.Handled%2A>, only handlers for the event that specifically indicated they should act in the `handledEventsToo` case  are invoked.</span></span>  <span data-ttu-id="cfcd1-119">如果其他元素指向你的应用程序的根目录仍想要处理控件取消事件的机会，一种替代方法是将在代码中使用的处理程序附加`handledEventsToo`指定为`true`。</span><span class="sxs-lookup"><span data-stu-id="cfcd1-119">If other elements towards the root of your application still wanted an opportunity to handle a control-suppressed event, one alternative is to attach handlers in code with `handledEventsToo` specified as `true`.</span></span> <span data-ttu-id="cfcd1-120">但通常更简单方法是更改处理输入事件的预览等效路由方向。</span><span class="sxs-lookup"><span data-stu-id="cfcd1-120">But often a simpler technique is to change the routing direction you handle to be the Preview equivalent of an input event.</span></span> <span data-ttu-id="cfcd1-121">例如，如果一个控件，将禁止<xref:System.Windows.UIElement.MouseLeftButtonDown>，请尝试将附加的处理程序<xref:System.Windows.UIElement.PreviewMouseLeftButtonDown>改为。</span><span class="sxs-lookup"><span data-stu-id="cfcd1-121">For instance, if a control suppresses <xref:System.Windows.UIElement.MouseLeftButtonDown>, try attaching a handler for <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> instead.</span></span> <span data-ttu-id="cfcd1-122">此方法仅适用于基元素输入事件如<xref:System.Windows.UIElement.MouseLeftButtonDown>。</span><span class="sxs-lookup"><span data-stu-id="cfcd1-122">This technique only works for base element input events such as <xref:System.Windows.UIElement.MouseLeftButtonDown>.</span></span> <span data-ttu-id="cfcd1-123">这些输入的事件使用隧道/冒泡对、 引发两个事件，并共享事件数据。</span><span class="sxs-lookup"><span data-stu-id="cfcd1-123">These input events use tunnel/bubble pairs, raise both events, and share the event data.</span></span>  
  
 <span data-ttu-id="cfcd1-124">上述每种方法有负面影响或限制。</span><span class="sxs-lookup"><span data-stu-id="cfcd1-124">Each of these techniques has either side effects or limitations.</span></span> <span data-ttu-id="cfcd1-125">处理预览事件的副作用是在该点处理该事件可能会禁用为能够处理浮升事件的处理程序，并因此的限制是，它通常是不标记为已处理仍在使用 Previ 时一个好办法新路由的一部分。</span><span class="sxs-lookup"><span data-stu-id="cfcd1-125">The side effect of handling the Preview event is that handling the event at that point might disable handlers that expect to handle the bubbling event, and therefore the limitation is that it is usually not a good idea to mark the event handled while it is still on the Preview part of the route.</span></span> <span data-ttu-id="cfcd1-126">限制`handledEventsToo`种方法是，不能指定`handledEventsToo`处理程序中的[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]作为属性，你必须注册事件处理程序代码中获取对该元素的对象引用，该处理程序附加后。</span><span class="sxs-lookup"><span data-stu-id="cfcd1-126">The limitation of the `handledEventsToo` technique is that you cannot specify a `handledEventsToo` handler in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] as an attribute, you must register the event handler in code after obtaining an object reference to the element where the handler is to be attached.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="cfcd1-127">请参阅</span><span class="sxs-lookup"><span data-stu-id="cfcd1-127">See also</span></span>

- [<span data-ttu-id="cfcd1-128">将路由事件标记为“已处理”和“类处理”</span><span class="sxs-lookup"><span data-stu-id="cfcd1-128">Marking Routed Events as Handled, and Class Handling</span></span>](marking-routed-events-as-handled-and-class-handling.md)
- [<span data-ttu-id="cfcd1-129">路由事件概述</span><span class="sxs-lookup"><span data-stu-id="cfcd1-129">Routed Events Overview</span></span>](routed-events-overview.md)
