---
title: WPF 体系结构
ms.date: 03/30/2017
helpviewer_keywords:
- properties [WPF], attached
- attached properties [WPF]
- architecture [WPF]
- unmanaged components [WPF]
- affinity thread [WPF]
- Storyboards [WPF]
- milcore [WPF]
- components [WPF], unmanaged
- painter's algorithm
- interfaces [WPF], INotifyPropertyChange
- CommandBindings [WPF]
- data templates [WPF]
- thread [WPF], affinity
ms.assetid: 8579c10b-76ab-4c52-9691-195ce02333c8
ms.openlocfilehash: 2fa2e039d73d079b6dacc9326c64fc2015eecc49
ms.sourcegitcommit: 4d8efe00f2e5ab42e598aff298d13b8c052d9593
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 07/16/2019
ms.locfileid: "68238486"
---
# <a name="wpf-architecture"></a><span data-ttu-id="d1fb5-102">WPF 体系结构</span><span class="sxs-lookup"><span data-stu-id="d1fb5-102">WPF Architecture</span></span>
<span data-ttu-id="d1fb5-103">本主题提供 Windows Presentation Foundation (WPF) 类层次结构的指导的教程。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-103">This topic provides a guided tour of the Windows Presentation Foundation (WPF) class hierarchy.</span></span> <span data-ttu-id="d1fb5-104">本主题涵盖了 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 的大部分主要子系统，并说明它们的交互方式。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-104">It covers most of the major subsystems of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], and describes how they interact.</span></span> <span data-ttu-id="d1fb5-105">本主题还详细介绍了 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 架构师所做的一些选择。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-105">It also details some of the choices made by the architects of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)].</span></span>  

<a name="System_Object"></a>   
## <a name="systemobject"></a><span data-ttu-id="d1fb5-106">System.Object</span><span class="sxs-lookup"><span data-stu-id="d1fb5-106">System.Object</span></span>  
 <span data-ttu-id="d1fb5-107">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 主要编程模型通过托管代码公开。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-107">The primary [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] programming model is exposed through managed code.</span></span> <span data-ttu-id="d1fb5-108">在 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 的早期设计阶段，曾有过大量关于如何界定系统的托管组件和非托管组件的争论。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-108">Early in the design phase of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] there were a number of debates about where the line should be drawn between the managed components of the system and the unmanaged ones.</span></span> <span data-ttu-id="d1fb5-109">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 提供一系列的功能，可以提高开发效率和可靠性（包括内存管理、错误处理和通用类型系统等），但这是需要付出代价的。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-109">The [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] provides a number of features that make development more productive and robust (including memory management, error handling, common type system, etc.) but they come at a cost.</span></span>  
  
 <span data-ttu-id="d1fb5-110">下图说明了 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 的主要组件。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-110">The major components of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] are illustrated in the figure below.</span></span> <span data-ttu-id="d1fb5-111">关系图的红色部分（PresentationFramework、PresentationCore 和 milcore）是 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 的主要代码部分。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-111">The red sections of the diagram (PresentationFramework, PresentationCore, and milcore) are the major code portions of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)].</span></span> <span data-ttu-id="d1fb5-112">在这些组件中，只有一个是非托管组件 - milcore。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-112">Of these, only one is an unmanaged component – milcore.</span></span> <span data-ttu-id="d1fb5-113">milcore 是以非托管代码编写的，目的是实现与 [!INCLUDE[TLA2#tla_dx](../../../../includes/tla2sharptla-dx-md.md)] 的紧密集成。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-113">Milcore is written in unmanaged code in order to enable tight integration with [!INCLUDE[TLA2#tla_dx](../../../../includes/tla2sharptla-dx-md.md)].</span></span> <span data-ttu-id="d1fb5-114">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 中的所有显示均通过 [!INCLUDE[TLA2#tla_dx](../../../../includes/tla2sharptla-dx-md.md)] 引擎完成，因此硬件和软件呈现都很高效。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-114">All display in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] is done through the [!INCLUDE[TLA2#tla_dx](../../../../includes/tla2sharptla-dx-md.md)] engine, allowing for efficient hardware and software rendering.</span></span> [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] <span data-ttu-id="d1fb5-115">还要求对内存和执行进行精细控制。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-115">also required fine control over memory and execution.</span></span> <span data-ttu-id="d1fb5-116">milcore 中的组合引擎受性能影响极大，需要放弃 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 的许多优点来提高性能。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-116">The composition engine in milcore is extremely performance sensitive, and required giving up many advantages of the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] to gain performance.</span></span>  
  
 <span data-ttu-id="d1fb5-117">![WPF 在 .NET Framework 中的位置。](./media/wpf-architect1.PNG "wpf_architect1")</span><span class="sxs-lookup"><span data-stu-id="d1fb5-117">![The position of WPF within the .NET Framework.](./media/wpf-architect1.PNG "wpf_architect1")</span></span>  
  
 <span data-ttu-id="d1fb5-118">本主题的后面部分将讨论 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 的托管和非托管部分之间的通信。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-118">Communication between the managed and unmanaged portions of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] is discussed later in this topic.</span></span> <span data-ttu-id="d1fb5-119">下面介绍托管编程模型的其余部分。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-119">The remainder of the managed programming model is described below.</span></span>  
  
<a name="System_Threading_DispatcherObject"></a>   
## <a name="systemthreadingdispatcherobject"></a><span data-ttu-id="d1fb5-120">System.Threading.DispatcherObject</span><span class="sxs-lookup"><span data-stu-id="d1fb5-120">System.Threading.DispatcherObject</span></span>  
 <span data-ttu-id="d1fb5-121">中的大多数对象[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]派生自<xref:System.Windows.Threading.DispatcherObject>，后者提供的基本构造来处理并发和线程处理。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-121">Most objects in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] derive from <xref:System.Windows.Threading.DispatcherObject>, which provides the basic constructs for dealing with concurrency and threading.</span></span> [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] <span data-ttu-id="d1fb5-122">基于调度程序实现的消息系统。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-122">is based on a messaging system implemented by the dispatcher.</span></span> <span data-ttu-id="d1fb5-123">其工作方式与常见的 [!INCLUDE[TLA#tla_win32](../../../../includes/tlasharptla-win32-md.md)] 消息泵非常类似；事实上，[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 调度程序使用 User32 消息执行跨线程调用。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-123">This works much like the familiar [!INCLUDE[TLA#tla_win32](../../../../includes/tlasharptla-win32-md.md)] message pump; in fact, the [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] dispatcher uses User32 messages for performing cross thread calls.</span></span>  
  
 <span data-ttu-id="d1fb5-124">要讨论 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 中的并发，首先必须真正理解两个核心概念 - 调度程序和线程关联。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-124">There are really two core concepts to understand when discussing concurrency in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] – the dispatcher and thread affinity.</span></span>  
  
 <span data-ttu-id="d1fb5-125">在 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 的设计阶段，目标是移动到单一线程的执行，但这不是一种与线程“关联的”模型。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-125">During the design phase of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], the goal was to move to a single thread of execution, but a non-thread "affinitized" model.</span></span> <span data-ttu-id="d1fb5-126">当一个组件使用执行线程的标识来存储某种类型的状态时，将发生线程关联。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-126">Thread affinity happens when a component uses the identity of the executing thread to store some type of state.</span></span> <span data-ttu-id="d1fb5-127">最常见的形式是使用线程本地存储 (TLS) 来存储状态。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-127">The most common form of this is to use the thread local store (TLS) to store state.</span></span> <span data-ttu-id="d1fb5-128">线程关联要求执行的每个逻辑线程仅由操作系统中的一个物理线程所拥有，这将占用大量内存。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-128">Thread affinity requires that each logical thread of execution be owned by only one physical thread in the operating system, which can become memory intensive.</span></span> <span data-ttu-id="d1fb5-129">最后，WPF 的线程处理模型通过线程关联与单一线程执行的现有 User32 线程处理模型保持同步。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-129">In the end, WPF’s threading model was kept in sync with the existing User32 threading model of single threaded execution with thread affinity.</span></span> <span data-ttu-id="d1fb5-130">主要原因是互操作性 - 类似于 [!INCLUDE[TLA2#tla_ole2.0](../../../../includes/tla2sharptla-ole2-0-md.md)] 的系统、剪贴板和 Internet Explorer 均需要单一线程关联 (STA) 执行。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-130">The primary reason for this was interoperability – systems like [!INCLUDE[TLA2#tla_ole2.0](../../../../includes/tla2sharptla-ole2-0-md.md)], the clipboard, and Internet Explorer all require single thread affinity (STA) execution.</span></span>  
  
 <span data-ttu-id="d1fb5-131">假设你具有带有 STA 线程的对象，则需要在线程之间通信并验证你是否位于正确的线程上的一种方法。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-131">Given that you have objects with STA threading, you need a way to communicate between threads, and validate that you are on the correct thread.</span></span> <span data-ttu-id="d1fb5-132">调度程序的作用就在于此。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-132">Herein lies the role of the dispatcher.</span></span> <span data-ttu-id="d1fb5-133">调度程序是一个基本的消息调度系统，具有多个按优先顺序排列的队列。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-133">The dispatcher is a basic message dispatching system, with multiple prioritized queues.</span></span> <span data-ttu-id="d1fb5-134">消息的示例包括原始输入通知（鼠标移动）、框架函数（布局）或用户命令（执行此方法）。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-134">Examples of messages include raw input notifications (mouse moved), framework functions (layout), or user commands (execute this method).</span></span> <span data-ttu-id="d1fb5-135">通过派生自<xref:System.Windows.Threading.DispatcherObject>，创建[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]对象具有 STA 行为的并将获得一个指向调度程序在创建时。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-135">By deriving from <xref:System.Windows.Threading.DispatcherObject>, you create a [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] object that has STA behavior, and will be given a pointer to a dispatcher at creation time.</span></span>  
  
<a name="System_Windows_DependencyObject"></a>   
## <a name="systemwindowsdependencyobject"></a><span data-ttu-id="d1fb5-136">System.Windows.DependencyObject</span><span class="sxs-lookup"><span data-stu-id="d1fb5-136">System.Windows.DependencyObject</span></span>  
 <span data-ttu-id="d1fb5-137">生成 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 时使用的主要体系结构原理之一是首选属性而不是方法或事件。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-137">One of the primary architectural philosophies used in building [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] was a preference for properties over methods or events.</span></span> <span data-ttu-id="d1fb5-138">属性具有声明性，可更方便地指定用途而不是操作。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-138">Properties are declarative and allow you to more easily specify intent instead of action.</span></span> <span data-ttu-id="d1fb5-139">它还支持模型驱动或数据驱动的系统，以显示用户界面内容。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-139">This also supported a model driven, or data driven, system for displaying user interface content.</span></span> <span data-ttu-id="d1fb5-140">这种理念的预期效果是创建更多可以绑定到的属性，从而更好地控制应用程序的行为。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-140">This philosophy had the intended effect of creating more properties that you could bind to, in order to better control the behavior of an application.</span></span>  
  
 <span data-ttu-id="d1fb5-141">为了更加充分地利用由属性驱动的系统，需要一个比 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 提供的功能更丰富的属性系统。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-141">In order to have more of the system driven by properties, a richer property system than what the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] provides was needed.</span></span> <span data-ttu-id="d1fb5-142">这种丰富性的一个简单示例是更改通知。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-142">A simple example of this richness is change notifications.</span></span> <span data-ttu-id="d1fb5-143">若要实现双向绑定，需要绑定的双方支持更改通知。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-143">In order to enable two way binding, you need both sides of the bind to support change notification.</span></span> <span data-ttu-id="d1fb5-144">若要使行为与属性值相关联，需要在属性值更改时收到通知。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-144">In order to have behavior tied to property values, you need to be notified when the property value changes.</span></span> <span data-ttu-id="d1fb5-145">Microsoft.NET Framework 中的一个接口， **INotifyPropertyChange**，这允许对象发布更改通知，但它是可选的。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-145">The Microsoft .NET Framework has an interface, **INotifyPropertyChange**, which allows an object to publish change notifications, however it is optional.</span></span>  
  
 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] <span data-ttu-id="d1fb5-146">提供了更丰富的属性系统，派生自<xref:System.Windows.DependencyObject>类型。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-146">provides a richer property system, derived from the <xref:System.Windows.DependencyObject> type.</span></span> <span data-ttu-id="d1fb5-147">该属性系统实际是一个“依赖”属性系统，因为它会跟踪属性表达式之间的依赖关系，并在依赖关系更改时自动重新验证属性值。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-147">The property system is truly a "dependency" property system in that it tracks dependencies between property expressions and automatically revalidates property values when dependencies change.</span></span> <span data-ttu-id="d1fb5-148">例如，如果您有一个继承的属性 (如<xref:System.Windows.Controls.Control.FontSize%2A>)，如果继承值的元素的父级发生属性更改，系统会自动更新。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-148">For example, if you have a property that inherits (like <xref:System.Windows.Controls.Control.FontSize%2A>), the system is automatically updated if the property changes on a parent of an element that inherits the value.</span></span>  
  
 <span data-ttu-id="d1fb5-149">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 属性系统的基础是属性表达式的概念。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-149">The foundation of the [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] property system is the concept of a property expression.</span></span> <span data-ttu-id="d1fb5-150">在 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 的第一个版本中，属性表达式系统是关闭的，表达式均作为框架的一部分提供。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-150">In this first release of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], the property expression system is closed, and the expressions are all provided as part of the framework.</span></span> <span data-ttu-id="d1fb5-151">表达式致使属性系统不具有数据绑定、样式调整或继承硬编码，而是由框架内后面的层来提供这些功能。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-151">Expressions are why the property system doesn’t have data binding, styling, or inheritance hard coded, but rather provided by later layers within the framework.</span></span>  
  
 <span data-ttu-id="d1fb5-152">属性系统还提供属性值的稀疏存储。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-152">The property system also provides for sparse storage of property values.</span></span> <span data-ttu-id="d1fb5-153">因为对象可能有数十个（如果达不到上百个）属性，并且大部分值处于其默认状态（被继承、由样式设置等），所以并非对象的每个实例都需要具有在其上定义的每个属性的完全权重。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-153">Because objects can have dozens (if not hundreds) of properties, and most of the values are in their default state (inherited, set by styles, etc.), not every instance of an object needs to have the full weight of every property defined on it.</span></span>  
  
 <span data-ttu-id="d1fb5-154">属性系统的最后一个新功能是附加属性的概念。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-154">The final new feature of the property system is the notion of attached properties.</span></span> [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] <span data-ttu-id="d1fb5-155">元素是基于组合和组件重用的原则生成的。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-155">elements are built on the principle of composition and component reuse.</span></span> <span data-ttu-id="d1fb5-156">它通常是这种情况，某些包含元素 (如<xref:System.Windows.Controls.Grid>布局元素) 需要在子元素来控制其行为 （如行/列信息中） 上的其他数据。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-156">It is often the case that some containing element (like a <xref:System.Windows.Controls.Grid> layout element) needs additional data on child elements to control its behavior (like the Row/Column information).</span></span> <span data-ttu-id="d1fb5-157">任何对象都可以为任何其他对象提供属性定义，而不是将所有这些属性与每个元素相关联。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-157">Instead of associating all of these properties with every element, any object is allowed to provide property definitions for any other object.</span></span> <span data-ttu-id="d1fb5-158">这与 JavaScript 中的“expando”功能相似。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-158">This is similar to the "expando" features of JavaScript.</span></span>  
  
<a name="System_Windows_Media_Visual"></a>   
## <a name="systemwindowsmediavisual"></a><span data-ttu-id="d1fb5-159">System.Windows.Media.Visual</span><span class="sxs-lookup"><span data-stu-id="d1fb5-159">System.Windows.Media.Visual</span></span>  
 <span data-ttu-id="d1fb5-160">定义一个系统后，下一步是将像素绘制到屏幕上。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-160">With a system defined, the next step is getting pixels drawn to the screen.</span></span> <span data-ttu-id="d1fb5-161"><xref:System.Windows.Media.Visual>类提供了用于每个可以选择性地包含绘制指令以及有关如何呈现这些指令 （剪裁、 转换等） 的元数据生成视觉对象的树。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-161">The <xref:System.Windows.Media.Visual> class provides for building a tree of visual objects, each optionally containing drawing instructions and metadata about how to render those instructions (clipping, transformation, etc.).</span></span> <span data-ttu-id="d1fb5-162"><xref:System.Windows.Media.Visual> 专为极其轻量且灵活，因此大部分功能没有公共 API 接触并且非常依赖受保护的回调函数。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-162"><xref:System.Windows.Media.Visual> is designed to be extremely lightweight and flexible, so most of the features have no public API exposure and rely heavily on protected callback functions.</span></span>  
  
 <span data-ttu-id="d1fb5-163"><xref:System.Windows.Media.Visual> 是真正的入口点[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]复合系统。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-163"><xref:System.Windows.Media.Visual> is really the entry point to the [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] composition system.</span></span> <span data-ttu-id="d1fb5-164"><xref:System.Windows.Media.Visual> 是的这两个子系统、 托管的 API 和非托管的 milcore 之间点。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-164"><xref:System.Windows.Media.Visual> is the point of connection between these two subsystems, the managed API and the unmanaged milcore.</span></span>  
  
 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] <span data-ttu-id="d1fb5-165">通过遍历由 milcore 管理的非托管数据结构来显示数据。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-165">displays data by traversing the unmanaged data structures managed by the milcore.</span></span> <span data-ttu-id="d1fb5-166">这些结构（称为组合节点）代表层次结构显示树，其中每个节点都有呈现指令。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-166">These structures, called composition nodes, represent a hierarchical display tree with rendering instructions at each node.</span></span> <span data-ttu-id="d1fb5-167">只能通过消息传递协议来访问此树（如下图右侧所示）。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-167">This tree, illustrated on the right hand side of the figure below, is only accessible through a messaging protocol.</span></span>  
  
 <span data-ttu-id="d1fb5-168">编程时[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]，创建<xref:System.Windows.Media.Visual>元素和派生的类型，它们在内部与此消息传递协议通过此组合树进行通信。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-168">When programming [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], you create <xref:System.Windows.Media.Visual> elements, and derived types, which internally communicate to the composition tree through this messaging protocol.</span></span> <span data-ttu-id="d1fb5-169">每个<xref:System.Windows.Media.Visual>在[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]可能会创建一个、 none、 或多个组合节点。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-169">Each <xref:System.Windows.Media.Visual> in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] may create one, none, or several composition nodes.</span></span>  
  
 <span data-ttu-id="d1fb5-170">![Windows Presentation Foundation 可视化树。](./media/wpf-architecture2.PNG "wpf_architecture2")</span><span class="sxs-lookup"><span data-stu-id="d1fb5-170">![The Windows Presentation Foundation Visual Tree.](./media/wpf-architecture2.PNG "wpf_architecture2")</span></span>  
  
 <span data-ttu-id="d1fb5-171">请注意一个非常重要的体系结构细节 - 会缓存整个可视化树和绘制指令。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-171">There is a very important architectural detail to notice here – the entire tree of visuals and drawing instructions is cached.</span></span> <span data-ttu-id="d1fb5-172">在图形方面，[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 使用一个保留的绘制系统。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-172">In graphics terms, [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] uses a retained rendering system.</span></span> <span data-ttu-id="d1fb5-173">这可以实现以高刷新率重绘系统，并且组合系统不会阻止对用户代码的回调。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-173">This enables the system to repaint at high refresh rates without the composition system blocking on callbacks to user code.</span></span> <span data-ttu-id="d1fb5-174">这有助于防止出现应用程序无响应的情况。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-174">This helps prevent the appearance of an unresponsive application.</span></span>  
  
 <span data-ttu-id="d1fb5-175">关系图中容易忽略的另一个重要细节是系统实际执行组合的方式。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-175">Another important detail that isn’t really noticeable in the diagram is how the system actually performs composition.</span></span>  
  
 <span data-ttu-id="d1fb5-176">在 User32 和 [!INCLUDE[TLA2#tla_gdi](../../../../includes/tla2sharptla-gdi-md.md)] 中，系统在一个即时模式剪裁系统上工作。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-176">In User32 and [!INCLUDE[TLA2#tla_gdi](../../../../includes/tla2sharptla-gdi-md.md)], the system works on an immediate mode clipping system.</span></span> <span data-ttu-id="d1fb5-177">当需要绘制一个组件时，系统会建立一个剪裁边界，在此边界外，不允许组件接触像素，然后会要求组件在该框中绘制像素。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-177">When a component needs to be rendered, the system establishes a clipping bounds outside of which the component isn’t allowed to touch the pixels, and then the component is asked to paint pixels in that box.</span></span> <span data-ttu-id="d1fb5-178">此系统在内存受限的系统上工作良好，因为当某些内容更改时，只需处理受影响的组件即可 - 不会由两个组件同时处理一个像素的颜色。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-178">This system works very well in memory constrained systems because when something changes you only have to touch the affected component – no two components ever contribute to the color of a single pixel.</span></span>  
  
 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] <span data-ttu-id="d1fb5-179">使用“绘画器的算法”绘制模型。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-179">uses a "painter's algorithm" painting model.</span></span> <span data-ttu-id="d1fb5-180">要求每个组件从显示内容的背面绘制到正面，而不是剪裁每个组件。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-180">This means that instead of clipping each component, each component is asked to render from the back to the front of the display.</span></span> <span data-ttu-id="d1fb5-181">这允许每个组件在先前组件的显示内容上绘制。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-181">This allows each component to paint over the previous component's display.</span></span> <span data-ttu-id="d1fb5-182">此模型的优点是可以生成部分透明的复杂形状。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-182">The advantage of this model is that you can have complex, partially transparent shapes.</span></span> <span data-ttu-id="d1fb5-183">通过使用当今的新式图形硬件，此模型的速度相对较快（创建 User32/ [!INCLUDE[TLA2#tla_gdi](../../../../includes/tla2sharptla-gdi-md.md)] 时则不然）。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-183">With today’s modern graphics hardware, this model is relatively fast (which wasn’t the case when User32/ [!INCLUDE[TLA2#tla_gdi](../../../../includes/tla2sharptla-gdi-md.md)] were created).</span></span>  
  
 <span data-ttu-id="d1fb5-184">如上所述，[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 的一个核心原理是转移到一个更具声明性且“以属性为中心”的编程模型。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-184">As mentioned previously, a core philosophy of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] is to move to a more declarative, "property centric" model of programming.</span></span> <span data-ttu-id="d1fb5-185">在可视化系统中，这体现在有意思的几个方面。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-185">In the visual system, this shows up in a couple of interesting places.</span></span>  
  
 <span data-ttu-id="d1fb5-186">首先，对于保留的模式图形系统，这实际上是从命令性 DrawLine/DrawLine 类型模型移动到面向数据的模型 new Line()/new Line()。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-186">First, if you think about the retained mode graphic system, this is really moving away from an imperative DrawLine/DrawLine type model, to a data oriented model – new Line()/new Line().</span></span> <span data-ttu-id="d1fb5-187">通过这种向数据驱动的绘制的移动，可以使用属性表达绘制指令上的复杂操作。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-187">This move to data driven rendering allows complex operations on the drawing instructions to be expressed using properties.</span></span> <span data-ttu-id="d1fb5-188">从派生类型<xref:System.Windows.Media.Drawing>实际上是呈现的对象模型。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-188">The types deriving from <xref:System.Windows.Media.Drawing> are effectively the object model for rendering.</span></span>  
  
 <span data-ttu-id="d1fb5-189">第二，如果评估动画系统，你会发现它几乎是完全声明性的。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-189">Second, if you evaluate the animation system, you'll see that it is almost completely declarative.</span></span> <span data-ttu-id="d1fb5-190">可以将动画表示为动画对象上的一组属性，无需要求开发人员计算下一个位置或下一个颜色。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-190">Instead of requiring a developer to compute the next location, or next color, you can express animations as a set of properties on an animation object.</span></span> <span data-ttu-id="d1fb5-191">这些动画可以表达开发人员或设计人员的意图（在 5 秒内将此按钮从一个位置移动到另一个位置），系统可以确定完成此任务的最高效方式。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-191">These animations can then express the intent of the developer or designer (move this button from here to there in 5 seconds), and the system can determine the most efficient way to accomplish that.</span></span>  
  
<a name="System_Windows_UIElement"></a>   
## <a name="systemwindowsuielement"></a><span data-ttu-id="d1fb5-192">System.Windows.UIElement</span><span class="sxs-lookup"><span data-stu-id="d1fb5-192">System.Windows.UIElement</span></span>  
 <span data-ttu-id="d1fb5-193"><xref:System.Windows.UIElement> 定义核心子系统，包括布局、 输入和事件。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-193"><xref:System.Windows.UIElement> defines core subsystems including Layout, Input, and Events.</span></span>  
  
 <span data-ttu-id="d1fb5-194">布局是 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 中的核心概念。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-194">Layout is a core concept in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)].</span></span> <span data-ttu-id="d1fb5-195">在许多系统中，可能有一组固定的布局模型（HTML 支持三种布局模型：流、绝对和表），也可能没有布局模型（User32 实际仅支持绝对定位）。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-195">In many systems there is either a fixed set of layout models (HTML supports three models for layout; flow, absolute, and tables) or no model for layout (User32 really only supports absolute positioning).</span></span> [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] <span data-ttu-id="d1fb5-196">先假设开发人员和设计人员需要灵活的可扩展布局模型，该模型可能是由属性值而不是命令性逻辑驱动的。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-196">started with the assumption that developers and designers wanted a flexible, extensible layout model, which could be driven by property values rather than imperative logic.</span></span> <span data-ttu-id="d1fb5-197">在<xref:System.Windows.UIElement>级别，引入布局的基本协定-阶段使用的模型的两阶段<xref:System.Windows.UIElement.Measure%2A>和<xref:System.Windows.UIElement.Arrange%2A>传递。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-197">At the <xref:System.Windows.UIElement> level, the basic contract for layout is introduced – a two phase model with <xref:System.Windows.UIElement.Measure%2A> and <xref:System.Windows.UIElement.Arrange%2A> passes.</span></span>  
  
 <span data-ttu-id="d1fb5-198"><xref:System.Windows.UIElement.Measure%2A> 允许组件确定所要采取的大小。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-198"><xref:System.Windows.UIElement.Measure%2A> allows a component to determine how much size it would like to take.</span></span> <span data-ttu-id="d1fb5-199">这是从单独阶段<xref:System.Windows.UIElement.Arrange%2A>因为有很多情况下，父元素会要求子测量若干次以确定其最佳位置和大小。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-199">This is a separate phase from <xref:System.Windows.UIElement.Arrange%2A> because there are many situations where a parent element will ask a child to measure several times to determine its optimal position and size.</span></span> <span data-ttu-id="d1fb5-200">父元素要求子元素测量这一事实体现了 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 的另一关键原则 - 调整内容大小。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-200">The fact that parent elements ask child elements to measure demonstrates another key philosophy of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] – size to content.</span></span> <span data-ttu-id="d1fb5-201">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 中的所有控件支持调整到内容自然大小的功能。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-201">All controls in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] support the ability to size to the natural size of their content.</span></span> <span data-ttu-id="d1fb5-202">这使本地化更加容易，并可实现调整内容大小时进行动态元素布局。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-202">This makes localization much easier, and allows for dynamic layout of elements as things resize.</span></span> <span data-ttu-id="d1fb5-203"><xref:System.Windows.UIElement.Arrange%2A>阶段允许父元素定位并确定每个子级的最终大小。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-203">The <xref:System.Windows.UIElement.Arrange%2A> phase allows a parent to position and determine the final size of each child.</span></span>  
  
 <span data-ttu-id="d1fb5-204">很多时间通常会花费谈论的输出一端[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]–<xref:System.Windows.Media.Visual>和相关对象。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-204">A lot of time is often spent talking about the output side of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] – <xref:System.Windows.Media.Visual> and related objects.</span></span> <span data-ttu-id="d1fb5-205">然而，在输入端也有许多创新。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-205">However there is a tremendous amount of innovation on the input side as well.</span></span> <span data-ttu-id="d1fb5-206">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 输入模型中的最基本更改也许是一致模型，借助此模型可通过系统对输入事件进行路由。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-206">Probably the most fundamental change in the input model for [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] is the consistent model by which input events are routed through the system.</span></span>  
  
 <span data-ttu-id="d1fb5-207">输入是作为内核模式设备驱动程序上的信号发出的，并通过涉及 Windows 内核和 User32 的复杂过程路由到正确的进程和线程。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-207">Input originates as a signal on a kernel mode device driver and gets routed to the correct process and thread through an intricate process involving the Windows kernel and User32.</span></span> <span data-ttu-id="d1fb5-208">与输入相对应的 User32 消息路由到 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 后，转换为 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 原始输入消息，并发送到调度程序。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-208">Once the User32 message corresponding to the input is routed to [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], it is converted into a [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] raw input message and sent to the dispatcher.</span></span> [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] <span data-ttu-id="d1fb5-209">允许将原始输入事件转换为多个实际事件，在保证传递到位的情况下在低系统级别实现类似“MouseEnter”的功能。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-209">allows for raw input events to be converted to multiple actual events, enabling features like "MouseEnter" to be implemented at a low level of the system with guaranteed delivery.</span></span>  
  
 <span data-ttu-id="d1fb5-210">每个输入事件至少会转换为两个事件 -“预览”事件和实际事件。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-210">Each input event is converted to at least two events – a "preview" event and the actual event.</span></span> <span data-ttu-id="d1fb5-211">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 中的所有事件都具有通过元素树路由的概念。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-211">All events in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] have a notion of routing through the element tree.</span></span> <span data-ttu-id="d1fb5-212">事件被称为"浮升"如果用户从目标树中向上遍历到根目录，并从根开始并遍历到目标被称为"隧道"。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-212">Events are said to "bubble" if they traverse from a target up the tree to the root, and are said to "tunnel" if they start at the root and traverse down to a target.</span></span> <span data-ttu-id="d1fb5-213">输入预览事件隧道，使树中的任何元素都有机会筛选事件或对事件采取操作。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-213">Input preview events tunnel, enabling any element in the tree an opportunity to filter or take action on the event.</span></span> <span data-ttu-id="d1fb5-214">然后，常规（非预览）事件将从目标向上浮升到根。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-214">The regular (non-preview) events then bubble from the target up to the root.</span></span>  
  
 <span data-ttu-id="d1fb5-215">隧道和浮升阶段之间的划分使键盘快捷键等功能的实现在复合环境中采用一致的方式。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-215">This split between the tunnel and bubble phase makes implementation of features like keyboard accelerators work in a consistent fashion in a composite world.</span></span> <span data-ttu-id="d1fb5-216">在 User32 中，可以通过使用一个全局表来实现键盘快捷键，该表中包含你希望支持的所有快捷键（Ctrl+N 映射到“新建”）。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-216">In User32 you would implement keyboard accelerators by having a single global table containing all the accelerators you wanted to support (Ctrl+N mapping to "New").</span></span> <span data-ttu-id="d1fb5-217">在应用程序的调度程序中，可以调用 **TranslateAccelerator**，它会探查 User32 中的输入消息，并确定是否有任何消息与已注册的快捷键匹配。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-217">In the dispatcher for your application you would call **TranslateAccelerator** which would sniff the input messages in User32 and determine if any matched a registered accelerator.</span></span> <span data-ttu-id="d1fb5-218">在 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 中，上述内容无效，因为系统是完全“可组合”的 - 任何元素都可以处理和使用任何键盘快捷键。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-218">In [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] this wouldn’t work because the system is fully "composable" – any element can handle and use any keyboard accelerator.</span></span> <span data-ttu-id="d1fb5-219">将此两阶段模型用于输入，可允许组件实现其自己的“TranslateAccelerator”。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-219">Having this two phase model for input allows components to implement their own "TranslateAccelerator".</span></span>  
  
 <span data-ttu-id="d1fb5-220">若要进一步此步骤，<xref:System.Windows.UIElement>还引入了 CommandBindings 的概念。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-220">To take this one step further, <xref:System.Windows.UIElement> also introduces the notion of CommandBindings.</span></span> <span data-ttu-id="d1fb5-221">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]命令系统允许开发人员的方式定义功能命令终结点 – 内容实现<xref:System.Windows.Input.ICommand>。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-221">The [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] command system allows developers to define functionality in terms of a command end point – something that implements <xref:System.Windows.Input.ICommand>.</span></span> <span data-ttu-id="d1fb5-222">命令绑定使元素可以定义输入笔势 (Ctrl+N) 和命令（“新建”）之间的映射。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-222">Command bindings enable an element to define a mapping between an input gesture (Ctrl+N) and a command (New).</span></span> <span data-ttu-id="d1fb5-223">输入笔势和命令定义都是可扩展的，并且可以在使用时联系到一起。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-223">Both the input gestures and command definitions are extensible, and can be wired together at usage time.</span></span> <span data-ttu-id="d1fb5-224">这使得一些操作（例如，允许最终用户自定义其要在应用程序内使用的键绑定）显得无关紧要。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-224">This makes it trivial, for example, to allow an end user to customize the key bindings that they want to use within an application.</span></span>  
  
 <span data-ttu-id="d1fb5-225">至此，本主题已重点讨论了 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 的“核心”功能 - PresentationCore 程序集中实现的功能。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-225">To this point in the topic, "core" features of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] – features implemented in the PresentationCore assembly, have been the focus.</span></span> <span data-ttu-id="d1fb5-226">生成时[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]、 明确划分基础部分 (如与布局的协定**度量值**并**排列**) 和框架部分 （例如特定的实现像布局<xref:System.Windows.Controls.Grid>) 是所需的结果。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-226">When building [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], a clean separation between foundational pieces (like the contract for layout with **Measure** and **Arrange**) and framework pieces (like the implementation of a specific layout like <xref:System.Windows.Controls.Grid>) was the desired outcome.</span></span> <span data-ttu-id="d1fb5-227">目标是提供在堆栈中处于较低位置的可扩展性点，这将允许外部开发人员在需要时创建自己的框架。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-227">The goal was to provide an extensibility point low in the stack that would allow external developers to create their own frameworks if needed.</span></span>  
  
<a name="System_Windows_FrameworkElement"></a>   
## <a name="systemwindowsframeworkelement"></a><span data-ttu-id="d1fb5-228">System.Windows.FrameworkElement</span><span class="sxs-lookup"><span data-stu-id="d1fb5-228">System.Windows.FrameworkElement</span></span>  
 <span data-ttu-id="d1fb5-229"><xref:System.Windows.FrameworkElement> 可以查看两个不同的方式。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-229"><xref:System.Windows.FrameworkElement> can be looked at in two different ways.</span></span> <span data-ttu-id="d1fb5-230">它在 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 的较低层中引入的子系统上引入一组策略和自定义项。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-230">It introduces a set of policies and customizations on the subsystems introduced in lower layers of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)].</span></span> <span data-ttu-id="d1fb5-231">它还引入了一组新的子系统。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-231">It also introduces a set of new subsystems.</span></span>  
  
 <span data-ttu-id="d1fb5-232">通过引入的主要策略<xref:System.Windows.FrameworkElement>与应用程序布局。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-232">The primary policy introduced by <xref:System.Windows.FrameworkElement> is around application layout.</span></span> <span data-ttu-id="d1fb5-233"><xref:System.Windows.FrameworkElement> 基础上引入的基本布局协定构建<xref:System.Windows.UIElement>并添加布局"插槽"可使布局作者具有一组一致的属性驱动的布局语义更方便的概念。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-233"><xref:System.Windows.FrameworkElement> builds on the basic layout contract introduced by <xref:System.Windows.UIElement> and adds the notion of a layout "slot" that makes it easier for layout authors to have a consistent set of property driven layout semantics.</span></span> <span data-ttu-id="d1fb5-234">属性，如<xref:System.Windows.FrameworkElement.HorizontalAlignment%2A>， <xref:System.Windows.FrameworkElement.VerticalAlignment%2A>， <xref:System.Windows.FrameworkElement.MinWidth%2A>，和<xref:System.Windows.FrameworkElement.Margin%2A>（若要仅举几例） 派生自的所有组件<xref:System.Windows.FrameworkElement>在布局容器内一致的行为。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-234">Properties like <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A>, <xref:System.Windows.FrameworkElement.VerticalAlignment%2A>, <xref:System.Windows.FrameworkElement.MinWidth%2A>, and <xref:System.Windows.FrameworkElement.Margin%2A> (to name a few) give all components derived from <xref:System.Windows.FrameworkElement> consistent behavior inside of layout containers.</span></span>  
  
 <span data-ttu-id="d1fb5-235"><xref:System.Windows.FrameworkElement> 此外提供了许多功能的核心层中找到更容易 API 认识[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-235"><xref:System.Windows.FrameworkElement> also provides easier API exposure to many features found in the core layers of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)].</span></span> <span data-ttu-id="d1fb5-236">例如，<xref:System.Windows.FrameworkElement>提供直接访问权限通过动画<xref:System.Windows.FrameworkElement.BeginStoryboard%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-236">For example, <xref:System.Windows.FrameworkElement> provides direct access to animation through the <xref:System.Windows.FrameworkElement.BeginStoryboard%2A> method.</span></span> <span data-ttu-id="d1fb5-237">一个<xref:System.Windows.Media.Animation.Storyboard>地针对一组属性的多个动画编写脚本。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-237">A <xref:System.Windows.Media.Animation.Storyboard> provides a way to script multiple animations against a set of properties.</span></span>  
  
 <span data-ttu-id="d1fb5-238">最重要的两点，<xref:System.Windows.FrameworkElement>引入了将数据绑定和样式。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-238">The two most critical things that <xref:System.Windows.FrameworkElement> introduces are data binding and styles.</span></span>  
  
 <span data-ttu-id="d1fb5-239">曾经使用 [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] 或 [!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)] 创建应用程序 [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] 的用户应当对 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 中的数据绑定子系统较为熟悉。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-239">The data binding subsystem in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] should be relatively familiar to anyone that has used [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] or [!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)] for creating an application [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)].</span></span> <span data-ttu-id="d1fb5-240">在上述每个系统中，可通过一种简单的方式来表达希望将给定元素中的一个或多个属性绑定到一个数据片段。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-240">In each of these systems, there is a simple way to express that you want one or more properties from a given element to be bound to a piece of data.</span></span> [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] <span data-ttu-id="d1fb5-241">完全支持属性绑定、转换和列表绑定。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-241">has full support for property binding, transformation, and list binding.</span></span>  
  
 <span data-ttu-id="d1fb5-242">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 中数据绑定的最值得关注的功能之一是引入了数据模板。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-242">One of the most interesting features of data binding in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] is the introduction of data templates.</span></span> <span data-ttu-id="d1fb5-243">利用数据模板，可以通过声明方式指定某个数据片断的可视化方式。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-243">Data templates allow you to declaratively specify how a piece of data should be visualized.</span></span> <span data-ttu-id="d1fb5-244">无需创建可绑定到数据的自定义用户界面，而是转而让数据来确定要创建的显示内容。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-244">Instead of creating a custom user interface that can be bound to data, you can instead turn the problem around and let the data determine the display that will be created.</span></span>  
  
 <span data-ttu-id="d1fb5-245">样式实际上是轻量型的数据绑定。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-245">Styling is really a lightweight form of data binding.</span></span> <span data-ttu-id="d1fb5-246">使用样式，可以将共享定义的一组属性绑定到元素的一个或多个实例。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-246">Using styling you can bind a set of properties from a shared definition to one or more instances of an element.</span></span> <span data-ttu-id="d1fb5-247">样式应用到元素通过显式引用 (通过设置<xref:System.Windows.FrameworkElement.Style%2A>属性) 或通过关联与样式来隐式[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]元素的类型。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-247">Styles get applied to an element either by explicit reference (by setting the <xref:System.Windows.FrameworkElement.Style%2A> property) or implicitly by associating a style with the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] type of the element.</span></span>  
  
<a name="System_Windows_Controls_Control"></a>   
## <a name="systemwindowscontrolscontrol"></a><span data-ttu-id="d1fb5-248">System.Windows.Controls.Control</span><span class="sxs-lookup"><span data-stu-id="d1fb5-248">System.Windows.Controls.Control</span></span>  
 <span data-ttu-id="d1fb5-249">控件的最重要功能是模板化。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-249">Control’s most significant feature is templating.</span></span> <span data-ttu-id="d1fb5-250">如果将 WPF 的组合系统视为一个保留模式绘制系统，则控件可通过模板化以一种参数化的声明性方式描述其绘制。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-250">If you think about WPF’s composition system as a retained mode rendering system, templating allows a control to describe its rendering in a parameterized, declarative manner.</span></span> <span data-ttu-id="d1fb5-251">一个<xref:System.Windows.Controls.ControlTemplate>实际上只不过是一个脚本来创建一组子元素，同时绑定到由控件提供的属性。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-251">A <xref:System.Windows.Controls.ControlTemplate> is really nothing more than a script to create a set of child elements, with bindings to properties offered by the control.</span></span>  
  
 <span data-ttu-id="d1fb5-252"><xref:System.Windows.Controls.Control> 提供了一组常用属性<xref:System.Windows.Controls.Control.Foreground%2A>， <xref:System.Windows.Controls.Control.Background%2A>， <xref:System.Windows.Controls.Control.Padding%2A>，仅举几例，模板作者可以使用自定义控件的显示。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-252"><xref:System.Windows.Controls.Control> provides a set of stock properties, <xref:System.Windows.Controls.Control.Foreground%2A>, <xref:System.Windows.Controls.Control.Background%2A>, <xref:System.Windows.Controls.Control.Padding%2A>, to name a few, which template authors can then use to customize the display of a control.</span></span> <span data-ttu-id="d1fb5-253">控件的实现提供了数据模型和交互模型。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-253">The implementation of a control provides a data model and interaction model.</span></span> <span data-ttu-id="d1fb5-254">交互模型定义了一组命令（如窗口的“关闭”），以及到输入笔势的绑定（如单击窗口右上角的红叉）。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-254">The interaction model defines a set of commands (like Close for a window) and bindings to input gestures (like clicking the red X in the upper corner of the window).</span></span> <span data-ttu-id="d1fb5-255">数据模型提供了一组属性，用于自定义交互模型或自定义显示内容（由模板确定）。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-255">The data model provides a set of properties to either customize the interaction model or customize the display (determined by the template).</span></span>  
  
 <span data-ttu-id="d1fb5-256">数据模型（属性）、交互模型（命令和事件）及显示模型（模板）之间的划分，可实现对控件的外观和行为的完全自定义。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-256">This split between the data model (properties), interaction model (commands and events), and display model (templates) enables complete customization of a control’s look and behavior.</span></span>  
  
 <span data-ttu-id="d1fb5-257">最常见的控件数据模型是内容模型。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-257">A common aspect of the data model of controls is the content model.</span></span> <span data-ttu-id="d1fb5-258">如果您看一下控件喜欢<xref:System.Windows.Controls.Button>，你将看到它有一个名为"Content"的类型属性<xref:System.Object>。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-258">If you look at a control like <xref:System.Windows.Controls.Button>, you will see that it has a property named "Content" of type <xref:System.Object>.</span></span> <span data-ttu-id="d1fb5-259">在 [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] 和 [!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)] 中，此属性通常是一个字符串 - 不过，这会限制可以在按钮中添加的内容类型。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-259">In [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] and [!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)], this property would typically be a string – however that limits the type of content you can put in a button.</span></span> <span data-ttu-id="d1fb5-260">按钮的内容可以是简单的字符串、复杂的数据对象或整个元素树。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-260">Content for a button can either be a simple string, a complex data object, or an entire element tree.</span></span> <span data-ttu-id="d1fb5-261">如果是数据对象，可以使用数据模板构造显示内容。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-261">In the case of a data object, the data template is used to construct a display.</span></span>  
  
<a name="Summary"></a>   
## <a name="summary"></a><span data-ttu-id="d1fb5-262">总结</span><span class="sxs-lookup"><span data-stu-id="d1fb5-262">Summary</span></span>  
 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] <span data-ttu-id="d1fb5-263">可创建动态的数据驱动的演示系统。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-263">is designed to allow you to create dynamic, data driven presentation systems.</span></span> <span data-ttu-id="d1fb5-264">系统的每一部分均可通过驱动行为的属性集来创建对象。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-264">Every part of the system is designed to create objects through property sets that drive behavior.</span></span> <span data-ttu-id="d1fb5-265">数据绑定是系统的基础部分，在每一层中均进行了集成。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-265">Data binding is a fundamental part of the system, and is integrated at every layer.</span></span>  
  
 <span data-ttu-id="d1fb5-266">传统的应用程序创建一个显示内容，然后绑定到某些数据。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-266">Traditional applications create a display and then bind to some data.</span></span> <span data-ttu-id="d1fb5-267">在 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 中，控件的所有内容、显示内容的所有方面都是由某种类型的数据绑定生成的。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-267">In [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], everything about the control, every aspect of the display, is generated by some type of data binding.</span></span> <span data-ttu-id="d1fb5-268">通过在按钮内部创建复合控件并将其显示内容绑定到按钮的内容属性，会显示按钮中的文本。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-268">The text found inside a button is displayed by creating a composed control inside of the button and binding its display to the button’s content property.</span></span>  
  
 <span data-ttu-id="d1fb5-269">当开始开发基于 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 的应用程序时，你应感到非常熟悉。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-269">When you begin developing [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] based applications, it should feel very familiar.</span></span> <span data-ttu-id="d1fb5-270">设置属性、使用对象和数据绑定的方式与使用 [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] 或 [!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)] 的方式极为相似。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-270">You can set properties, use objects, and data bind in much the same way that you can using [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] or [!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)].</span></span> <span data-ttu-id="d1fb5-271">如果对 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 体系结构有更深的了解，将能够创建更丰富的应用程序，这些应用程序在根本上会将数据视为应用程序的核心驱动要素。</span><span class="sxs-lookup"><span data-stu-id="d1fb5-271">With a deeper investigation into the architecture of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], you'll find that the possibility exists for creating much richer applications that fundamentally treat data as the core driver of the application.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="d1fb5-272">请参阅</span><span class="sxs-lookup"><span data-stu-id="d1fb5-272">See also</span></span>

- <xref:System.Windows.Media.Visual>
- <xref:System.Windows.UIElement>
- <xref:System.Windows.Input.ICommand>
- <xref:System.Windows.FrameworkElement>
- <xref:System.Windows.Threading.DispatcherObject>
- <xref:System.Windows.Input.CommandBinding>
- <xref:System.Windows.Controls.Control>
- [<span data-ttu-id="d1fb5-273">数据绑定概述</span><span class="sxs-lookup"><span data-stu-id="d1fb5-273">Data Binding Overview</span></span>](../data/data-binding-overview.md)
- [<span data-ttu-id="d1fb5-274">布局</span><span class="sxs-lookup"><span data-stu-id="d1fb5-274">Layout</span></span>](layout.md)
- [<span data-ttu-id="d1fb5-275">动画概述</span><span class="sxs-lookup"><span data-stu-id="d1fb5-275">Animation Overview</span></span>](../graphics-multimedia/animation-overview.md)
