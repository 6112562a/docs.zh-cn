---
title: WPF 外接程序概述
ms.date: 03/30/2017
helpviewer_keywords:
- add-ins and XAML browser applications [WPF]
- add-ins overview [WPF]
- add-ins [WPF], performance
- add-ins [WPF], benefits
- .NET Framework add-in model [WPF]
- add-ins [WPF], user interface
- add-ins and the user interface [WPF]
- add-ins [WPF], architecture
- add-ins [WPF], limitations
ms.assetid: 00b4c776-29a8-4dba-b603-280a0cdc2ade
ms.openlocfilehash: 07c33aa49e6fc8f78acd86a92cf555ae389e200c
ms.sourcegitcommit: 49af435bfdd41faf26d38c20c5b0cc07e87bea60
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 12/14/2018
ms.locfileid: "53397028"
---
# <a name="wpf-add-ins-overview"></a><span data-ttu-id="b9bcb-102">WPF 外接程序概述</span><span class="sxs-lookup"><span data-stu-id="b9bcb-102">WPF Add-Ins Overview</span></span>
<a name="Introduction"></a> <span data-ttu-id="b9bcb-103">.NET Framework 包括开发人员可用于创建支持外接程序扩展性的应用程序的外接程序模型。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-103">The .NET Framework includes an add-in model that developers can use to create applications that support add-in extensibility.</span></span> <span data-ttu-id="b9bcb-104">借助此外接程序模型，可以创建与应用程序功能集成并进行扩展的外接程序。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-104">This add-in model allows the creation of add-ins that integrate with and extend application functionality.</span></span> <span data-ttu-id="b9bcb-105">在某些情况下，应用程序还需要显示外接程序提供的用户界面。本主题介绍 WPF 增加.NET Framework 外接程序模型若要启用这些方案，它、 其优点和局限性的体系结构的内容。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-105">In some scenarios, applications also need to display user interfaces that are provided by add-ins. This topic shows how WPF augments the .NET Framework add-in model to enable these scenarios, the architecture behind it, its benefits, and its limitations.</span></span>  
  

  
<a name="Requirements"></a>   
## <a name="prerequisites"></a><span data-ttu-id="b9bcb-106">系统必备</span><span class="sxs-lookup"><span data-stu-id="b9bcb-106">Prerequisites</span></span>  
 <span data-ttu-id="b9bcb-107">熟悉.NET Framework 外接程序模型是必需的。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-107">Familiarity with the .NET Framework add-in model is required.</span></span> <span data-ttu-id="b9bcb-108">有关详细信息，请参阅[外接程序和扩展性](/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100))。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-108">For more information, see [Add-ins and Extensibility](/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100)).</span></span>  
  
<a name="AddInsOverview"></a>   
## <a name="add-ins-overview"></a><span data-ttu-id="b9bcb-109">外接程序概述</span><span class="sxs-lookup"><span data-stu-id="b9bcb-109">Add-Ins Overview</span></span>  
 <span data-ttu-id="b9bcb-110">为了需要对应用程序重新编译和重新部署才能引入新功能这一复杂过程，应用程序实现了扩展机制，使开发者（包括第一方和第三方）能够创建与应用程序集成的其他应用程序。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-110">In order to avoid the complexities of application recompilation and redeployment to incorporate new functionality, applications implement extensibility mechanisms that allow developers (both first-party and third-party) to create other applications that integrate with them.</span></span> <span data-ttu-id="b9bcb-111">支持此扩展性类型的最常见方式是，使用外接程序（也称为“加载项”和“插件”）。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-111">The most common way to support this type of extensibility is through the use of add-ins (also known as "add-ons" and "plug-ins").</span></span> <span data-ttu-id="b9bcb-112">通过外接程序公开扩展性的实际应用程序示例包括：</span><span class="sxs-lookup"><span data-stu-id="b9bcb-112">Examples of real-world applications that expose extensibility with add-ins include:</span></span>  
  
-   <span data-ttu-id="b9bcb-113">Internet Explorer 加载项。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-113">Internet Explorer add-ons.</span></span>  
  
-   <span data-ttu-id="b9bcb-114">Windows Media Player 插件。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-114">Windows Media Player plug-ins.</span></span>  
  
-   <span data-ttu-id="b9bcb-115">Visual Studio 外接程序。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-115">Visual Studio add-ins.</span></span>  
  
 <span data-ttu-id="b9bcb-116">例如，通过 Windows Media Player 外接程序模型，第三方开发人员可以实现“插件”，从而以各种方式对 Windows Media Player 进行扩展，包括为 Windows Media Player 本身不支持的媒体格式（例如 DVD、MP3）创建解码器和编码器，创建音频效果和外观。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-116">For example, the Windows Media Player add-in model allows third-party developers to implement "plug-ins" that extend Windows Media Player in a variety of ways, including creating decoders and encoders for media formats that are not supported natively by Windows Media Player (for example, DVD, MP3), audio effects, and skins.</span></span> <span data-ttu-id="b9bcb-117">尽管有一些实体和行为是所有外接程序模型共有的，但会生成每个外接程序模型以公开某个应用程序的特有功能。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-117">Each add-in model is built to expose the functionality that is unique to an application, although there are several entities and behaviors that are common to all add-in models.</span></span>  
  
 <span data-ttu-id="b9bcb-118">典型外接程序扩展性解决方案的三大实体是“协定”、“外接程序”和“主机应用程序”。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-118">The three main entities of typical add-in extensibility solutions are *contracts*, *add-ins*, and *host applications*.</span></span> <span data-ttu-id="b9bcb-119">协定会定义外接程序与主机应用程序之间的两种集成方式：</span><span class="sxs-lookup"><span data-stu-id="b9bcb-119">Contracts define how add-ins integrate with host applications in two ways:</span></span>  
  
-   <span data-ttu-id="b9bcb-120">外接程序集成主机应用程序所实现的功能。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-120">Add-ins integrate with functionality that is implemented by host applications.</span></span>  
  
-   <span data-ttu-id="b9bcb-121">主机应用程序公开供外接程序集成的功能。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-121">Host applications expose functionality for add-ins to integrate with.</span></span>  
  
 <span data-ttu-id="b9bcb-122">为了使外接程序能发挥作用，主机应用程序需要在运行时找到它们并进行加载。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-122">In order for add-ins to be used, host applications need to find them and load them at run time.</span></span> <span data-ttu-id="b9bcb-123">因此，支持外接程序的应用程序需要承担以下附加的职责：</span><span class="sxs-lookup"><span data-stu-id="b9bcb-123">Consequently, applications that support add-ins have the following additional responsibilities:</span></span>  
  
-   <span data-ttu-id="b9bcb-124">**发现**:查找遵循主机应用程序支持的协定的外接程序。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-124">**Discovery**: Finding add-ins that adhere to contracts supported by host applications.</span></span>  
  
-   <span data-ttu-id="b9bcb-125">**激活**:正在加载、 运行和建立与外接程序的通信。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-125">**Activation**: Loading, running, and establishing communication with add-ins.</span></span>  
  
-   <span data-ttu-id="b9bcb-126">**隔离**:使用应用程序域或进程建立隔离边界，保护应用程序免受潜在的安全和外接程序执行问题。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-126">**Isolation**: Using either application domains or processes to establish isolation boundaries that protect applications from potential security and execution problems with add-ins.</span></span>  
  
-   <span data-ttu-id="b9bcb-127">**通信**:允许加载项和主机应用程序彼此通信跨隔离边界，通过调用方法并传递数据。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-127">**Communication**: Allowing add-ins and host applications to communicate with each other across isolation boundaries by calling methods and passing data.</span></span>  
  
-   <span data-ttu-id="b9bcb-128">**生存期管理**:加载和卸载应用程序域和进程以干净、 可预测的方式 (请参阅[应用程序域](../../../../docs/framework/app-domains/application-domains.md))。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-128">**Lifetime Management**: Loading and unloading application domains and processes in a clean, predictable manner (see [Application Domains](../../../../docs/framework/app-domains/application-domains.md)).</span></span>  
  
-   <span data-ttu-id="b9bcb-129">**版本控制**:确保，主机应用程序和外接程序仍可进行通信时创建的新版本。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-129">**Versioning**: Ensuring that host applications and add-ins can still communicate when new versions of either are created.</span></span>  
  
 <span data-ttu-id="b9bcb-130">总之，开发一个可靠的外接程序模型不是一项简单的任务。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-130">Ultimately, developing a robust add-in model is a non-trivial undertaking.</span></span> <span data-ttu-id="b9bcb-131">出于此原因，.NET Framework 构建外接程序模型提供一种基础结构。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-131">For this reason, the .NET Framework provides an infrastructure for building add-in models.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b9bcb-132">有关外接程序的更多详细信息，请参阅[外接程序和扩展性](/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100))。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-132">For more detailed information on add-ins, see [Add-ins and Extensibility](/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100)).</span></span>  
  
<a name="NETFrameworkAddInModelOverview"></a>   
## <a name="net-framework-add-in-model-overview"></a><span data-ttu-id="b9bcb-133">.NET Framework 外接程序模型概述</span><span class="sxs-lookup"><span data-stu-id="b9bcb-133">.NET Framework Add-In Model Overview</span></span>  
 <span data-ttu-id="b9bcb-134">在中找到.NET Framework 外接程序模型，<xref:System.AddIn>命名空间包含一组旨在简化开发外接程序扩展性的类型。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-134">The .NET Framework add-in model, found in the <xref:System.AddIn> namespace, contains a set of types that are designed to simplify the development of add-in extensibility.</span></span> <span data-ttu-id="b9bcb-135">.NET Framework 外接程序模型的基本单元是*协定*、 用于定义如何主机应用程序和外接程序与彼此通信。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-135">The fundamental unit of the .NET Framework add-in model is the *contract*, which defines how a host application and an add-in communicate with each other.</span></span> <span data-ttu-id="b9bcb-136">会使用特定于主机应用程序的协定*视图*向主机应用程序公开协定。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-136">A contract is exposed to a host application using a host-application-specific *view* of the contract.</span></span> <span data-ttu-id="b9bcb-137">同样，向外接程序公开特定于外接程序的协定*视图*。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-137">Likewise, an add-in-specific *view* of the contract is exposed to the add-in.</span></span> <span data-ttu-id="b9bcb-138">使用*适配器*，主机应用程序和外接程序可以在它们各自的协定视图之间进行通信。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-138">An *adapter* is used to allow a host application and an add-in to communicate between their respective views of the contract.</span></span> <span data-ttu-id="b9bcb-139">协定、视图和适配器称为管道段，一组相关的管道段组成一条*管道*。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-139">Contracts, views, and adapters are referred to as segments, and a set of related segments constitutes a *pipeline*.</span></span> <span data-ttu-id="b9bcb-140">管道是在其.NET Framework 外接程序模型支持发现、 激活、 安全隔离、 执行隔离 （使用应用程序域和进程）、 通信、 生存期管理和版本控制的基础。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-140">Pipelines are the foundation upon which the .NET Framework add-in model supports discovery, activation, security isolation, execution isolation (using both application domains and processes), communication, lifetime management, and versioning.</span></span>  
  
 <span data-ttu-id="b9bcb-141">所有这些支持使得开发人员能够生成与主机应用程序的功能相集成的外接程序。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-141">The sum of this support allows developers to build add-ins that integrate with the functionality of a host application.</span></span> <span data-ttu-id="b9bcb-142">但是，某些情况下需要主机应用程序显示用户界面提供的外接程序。由于.NET Framework 中的每个演示文稿技术都有其自己的模型用于实现用户界面，.NET Framework 外接程序模型不支持任何特定的显示技术。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-142">However, some scenarios require host applications to display user interfaces provided by add-ins. Because each presentation technology in the .NET Framework has its own model for implementing user interfaces, the .NET Framework add-in model does not support any particular presentation technology.</span></span> <span data-ttu-id="b9bcb-143">相反，WPF 扩展模型外, 接程序的 UI 支持.NET Framework 外接程序。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-143">Instead, WPF extends the .NET Framework add-in model with UI support for add-ins.</span></span>  
  
<a name="WPFAddInModel"></a>   
## <a name="wpf-add-ins"></a><span data-ttu-id="b9bcb-144">WPF 外接程序</span><span class="sxs-lookup"><span data-stu-id="b9bcb-144">WPF Add-Ins</span></span>  
 <span data-ttu-id="b9bcb-145">WPF 中，与.NET Framework 外接程序模型，结合使用，可处理各种要求主机应用程序显示外接程序从用户界面的方案。具体而言，处理这些情况由 WPF 使用以下两种编程模型：</span><span class="sxs-lookup"><span data-stu-id="b9bcb-145">WPF, in conjunction with the .NET Framework add-in model, allows you to address a wide variety of scenarios that require host applications to display user interfaces from add-ins. In particular, these scenarios are addressed by WPF with the following two programming models:</span></span>  
  
1.  <span data-ttu-id="b9bcb-146">**外接程序返回 UI**。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-146">**The add-in returns a UI**.</span></span> <span data-ttu-id="b9bcb-147">外接程序返回 UI 到主机应用程序通过方法调用，如协定所定义的。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-147">An add-in returns a UI to the host application via a method call, as defined by the contract.</span></span> <span data-ttu-id="b9bcb-148">此方案可用于以下情况：</span><span class="sxs-lookup"><span data-stu-id="b9bcb-148">This scenario is used in the following cases:</span></span>  
  
    -   <span data-ttu-id="b9bcb-149">返回的外接程序的 UI 的外观取决于数据或条件可仅在运行时，例如动态生成的报告。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-149">The appearance of a UI that is returned by an add-in is dependent on either data or conditions that exist only at run time, such as dynamically generated reports.</span></span>  
  
    -   <span data-ttu-id="b9bcb-150">为服务提供的外接程序的 UI 与从外接程序可以使用的主机应用程序的 UI。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-150">The UI for services provided by an add-in differs from the UI of the host applications that can use the add-in.</span></span>  
  
    -   <span data-ttu-id="b9bcb-151">外接程序主要执行某项服务的主机应用程序，并向主机应用程序的 ui 报告状态。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-151">The add-in primarily performs a service for the host application, and reports status to the host application with a UI.</span></span>  
  
2.  <span data-ttu-id="b9bcb-152">**外接程序为 UI**。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-152">**The add-in is a UI**.</span></span> <span data-ttu-id="b9bcb-153">外接程序是一个 UI，如协定所定义的。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-153">An add-in is a UI, as defined by the contract.</span></span> <span data-ttu-id="b9bcb-154">此方案可用于以下情况：</span><span class="sxs-lookup"><span data-stu-id="b9bcb-154">This scenario is used in the following cases:</span></span>  
  
    -   <span data-ttu-id="b9bcb-155">外接程序提供的服务都需要显示，例如广告。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-155">An add-in doesn't provide services other than being displayed, such as an advertisement.</span></span>  
  
    -   <span data-ttu-id="b9bcb-156">服务提供的外接程序的 UI 是普遍适用于所有主机应用程序可以使用该外接程序，如计算器或颜色选取器。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-156">The UI for services provided by an add-in is common to all host applications that can use that add-in, such as a calculator or color picker.</span></span>  
  
 <span data-ttu-id="b9bcb-157">这些方案需要，可以主机应用程序和外接程序应用程序域之间传递 UI 对象。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-157">These scenarios require that UI objects can be passed between host application and add-in application domains.</span></span> <span data-ttu-id="b9bcb-158">自.NET Framework 外接程序模型依赖于远程处理应用程序域之间进行通信，它们之间传递的对象必须可远程处理。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-158">Since the .NET Framework add-in model relies on remoting to communicate between application domains, the objects that are passed between them must be remotable.</span></span>  
  
 <span data-ttu-id="b9bcb-159">可远程处理的对象是某个类的实例，并执行以下一个或多个任务：</span><span class="sxs-lookup"><span data-stu-id="b9bcb-159">A remotable object is an instance of a class that does one or more of the following:</span></span>  
  
-   <span data-ttu-id="b9bcb-160">派生自<xref:System.MarshalByRefObject>类。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-160">Derives from the <xref:System.MarshalByRefObject> class.</span></span>  
  
-   <span data-ttu-id="b9bcb-161">实现 <xref:System.Runtime.Serialization.ISerializable> 接口。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-161">Implements the <xref:System.Runtime.Serialization.ISerializable> interface.</span></span>  
  
-   <span data-ttu-id="b9bcb-162">具有<xref:System.SerializableAttribute>应用属性。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-162">Has the <xref:System.SerializableAttribute> attribute applied.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b9bcb-163">有关创建可远程处理.NET Framework 对象的详细信息，请参阅[使对象可远程处理](https://msdn.microsoft.com/library/01197253-3f13-43b7-894d-9683e431192a)。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-163">For more information regarding the creation of remotable .NET Framework objects, see [Making Objects Remotable](https://msdn.microsoft.com/library/01197253-3f13-43b7-894d-9683e431192a).</span></span>  
  
 <span data-ttu-id="b9bcb-164">WPF UI 类型不可远程处理。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-164">The WPF UI types are not remotable.</span></span> <span data-ttu-id="b9bcb-165">若要解决此问题，WPF 扩展了.NET Framework 外接程序模型以启用 WPF UI 的外接程序创建要显示从主机应用程序。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-165">To solve the problem, WPF extends the .NET Framework add-in model to enable WPF UI created by add-ins to be displayed from host applications.</span></span> <span data-ttu-id="b9bcb-166">通过两种类型的 wpf 提供此支持：<xref:System.AddIn.Contract.INativeHandleContract>接口和实现的两个静态方法<xref:System.AddIn.Pipeline.FrameworkElementAdapters>类：<xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A>和<xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A>。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-166">This support is provided by WPF by two types: the <xref:System.AddIn.Contract.INativeHandleContract> interface and two static methods implemented by the <xref:System.AddIn.Pipeline.FrameworkElementAdapters> class: <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A> and <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A>.</span></span> <span data-ttu-id="b9bcb-167">从较高层面来看，这些类型和方法按以下方式使用：</span><span class="sxs-lookup"><span data-stu-id="b9bcb-167">At a high level, these types and methods are used in the following manner:</span></span>  
  
1.  <span data-ttu-id="b9bcb-168">WPF 要求由外接程序提供的用户界面是直接或间接派生的类<xref:System.Windows.FrameworkElement>，如形状、 控件、 用户控件、 布局面板和页面。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-168">WPF requires that user interfaces provided by add-ins are classes that derive directly or indirectly from <xref:System.Windows.FrameworkElement>, such as shapes, controls, user controls, layout panels, and pages.</span></span>  
  
2.  <span data-ttu-id="b9bcb-169">无论协定声明，将外接程序与主机应用程序之间传递 UI，它必须声明为<xref:System.AddIn.Contract.INativeHandleContract>(不<xref:System.Windows.FrameworkElement>);<xref:System.AddIn.Contract.INativeHandleContract>是外接程序用户界面，可跨隔离边界传递的可远程处理表示形式。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-169">Wherever the contract declares that a UI will be passed between the add-in and the host application, it must be declared as an <xref:System.AddIn.Contract.INativeHandleContract> (not a <xref:System.Windows.FrameworkElement>); <xref:System.AddIn.Contract.INativeHandleContract> is a remotable representation of the add-in UI that can be passed across isolation boundaries.</span></span>  
  
3.  <span data-ttu-id="b9bcb-170">然后再从外接程序的应用程序域中，传递<xref:System.Windows.FrameworkElement>打包为<xref:System.AddIn.Contract.INativeHandleContract>通过调用<xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A>。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-170">Before being passed from the add-in's application domain, a <xref:System.Windows.FrameworkElement> is packaged as an <xref:System.AddIn.Contract.INativeHandleContract> by calling <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A>.</span></span>  
  
4.  <span data-ttu-id="b9bcb-171">之后传递到主机应用程序的应用程序域<xref:System.AddIn.Contract.INativeHandleContract>必须重新打包为<xref:System.Windows.FrameworkElement>通过调用<xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A>。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-171">After being passed to the host application's application domain, the <xref:System.AddIn.Contract.INativeHandleContract> must be repackaged as a <xref:System.Windows.FrameworkElement> by calling <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A>.</span></span>  
  
 <span data-ttu-id="b9bcb-172">如何<xref:System.AddIn.Contract.INativeHandleContract>， <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A>，和<xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A>使用取决于特定方案。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-172">How <xref:System.AddIn.Contract.INativeHandleContract>, <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A>, and <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A> are used depends on the specific scenario.</span></span> <span data-ttu-id="b9bcb-173">下面几节介绍每个编程模型的详细信息。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-173">The following sections provide details for each programming model.</span></span>  
  
<a name="ReturnUIFromAddInContract"></a>   
## <a name="add-in-returns-a-user-interface"></a><span data-ttu-id="b9bcb-174">外接程序返回用户界面</span><span class="sxs-lookup"><span data-stu-id="b9bcb-174">Add-In Returns a User Interface</span></span>  
 <span data-ttu-id="b9bcb-175">有关外接程序返回到主机应用程序的 UI，需要以下项：</span><span class="sxs-lookup"><span data-stu-id="b9bcb-175">For an add-in to return a UI to a host application, the following are required:</span></span>  
  
1.  <span data-ttu-id="b9bcb-176">主机应用程序、 外接程序和管道必须创建，如.NET Framework 中所述[外接程序和扩展性](/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100))文档。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-176">The host application, add-in, and pipeline must be created, as described by the .NET Framework [Add-ins and Extensibility](/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100)) documentation.</span></span>  
  
2.  <span data-ttu-id="b9bcb-177">协定必须实现<xref:System.AddIn.Contract.IContract>并返回一个用户界面，该协定必须声明具有类型的返回值的方法<xref:System.AddIn.Contract.INativeHandleContract>。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-177">The contract must implement <xref:System.AddIn.Contract.IContract> and, to return a UI, the contract must declare a method with a return value of type <xref:System.AddIn.Contract.INativeHandleContract>.</span></span>  
  
3.  <span data-ttu-id="b9bcb-178">外接程序与主机应用程序之间传递 UI 必须直接或间接派生自<xref:System.Windows.FrameworkElement>。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-178">The UI that is passed between the add-in and the host application must directly or indirectly derive from <xref:System.Windows.FrameworkElement>.</span></span>  
  
4.  <span data-ttu-id="b9bcb-179">必须从转换返回的外接程序的 UI<xref:System.Windows.FrameworkElement>到<xref:System.AddIn.Contract.INativeHandleContract>之前跨越隔离边界。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-179">The UI that is returned by the add-in must be converted from a <xref:System.Windows.FrameworkElement> to an <xref:System.AddIn.Contract.INativeHandleContract> before crossing the isolation boundary.</span></span>  
  
5.  <span data-ttu-id="b9bcb-180">必须从转换返回 UI<xref:System.AddIn.Contract.INativeHandleContract>到<xref:System.Windows.FrameworkElement>后跨越隔离边界。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-180">The UI that is returned must be converted from an <xref:System.AddIn.Contract.INativeHandleContract> to a <xref:System.Windows.FrameworkElement> after crossing the isolation boundary.</span></span>  
  
6.  <span data-ttu-id="b9bcb-181">主机应用程序显示返回<xref:System.Windows.FrameworkElement>。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-181">The host application displays the returned <xref:System.Windows.FrameworkElement>.</span></span>  
  
 <span data-ttu-id="b9bcb-182">有关演示如何实现返回 UI 的外接程序示例，请参阅[创建外接程序返回 UI](../../../../docs/framework/wpf/app-development/how-to-create-an-add-in-that-returns-a-ui.md)。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-182">For an example that demonstrates how to implement an add-in that returns a UI, see [Create an Add-In That Returns a UI](../../../../docs/framework/wpf/app-development/how-to-create-an-add-in-that-returns-a-ui.md).</span></span>  
  
<a name="AddInIsAUI"></a>   
## <a name="add-in-is-a-user-interface"></a><span data-ttu-id="b9bcb-183">外接程序为用户界面</span><span class="sxs-lookup"><span data-stu-id="b9bcb-183">Add-In Is a User Interface</span></span>  
 <span data-ttu-id="b9bcb-184">当外接程序是一个 UI 时，具备以下条件：</span><span class="sxs-lookup"><span data-stu-id="b9bcb-184">When an add-in is a UI, the following are required:</span></span>  
  
1.  <span data-ttu-id="b9bcb-185">主机应用程序、 外接程序和管道必须创建，如.NET Framework 中所述[外接程序和扩展性](/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100))文档。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-185">The host application, add-in, and pipeline must be created, as described by the .NET Framework [Add-ins and Extensibility](/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100)) documentation.</span></span>  
  
2.  <span data-ttu-id="b9bcb-186">外接程序的协定接口必须实现<xref:System.AddIn.Contract.INativeHandleContract>。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-186">The contract interface for the add-in must implement <xref:System.AddIn.Contract.INativeHandleContract>.</span></span>  
  
3.  <span data-ttu-id="b9bcb-187">传递到主机应用程序的外接程序必须直接或间接派生自<xref:System.Windows.FrameworkElement>。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-187">The add-in that is passed to the host application must directly or indirectly derive from <xref:System.Windows.FrameworkElement>.</span></span>  
  
4.  <span data-ttu-id="b9bcb-188">外接程序必须从转换<xref:System.Windows.FrameworkElement>到<xref:System.AddIn.Contract.INativeHandleContract>之前跨越隔离边界。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-188">The add-in must be converted from a <xref:System.Windows.FrameworkElement> to an <xref:System.AddIn.Contract.INativeHandleContract> before crossing the isolation boundary.</span></span>  
  
5.  <span data-ttu-id="b9bcb-189">外接程序必须从转换<xref:System.AddIn.Contract.INativeHandleContract>到<xref:System.Windows.FrameworkElement>后跨越隔离边界。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-189">The add-in must be converted from an <xref:System.AddIn.Contract.INativeHandleContract> to a <xref:System.Windows.FrameworkElement> after crossing the isolation boundary.</span></span>  
  
6.  <span data-ttu-id="b9bcb-190">主机应用程序显示返回<xref:System.Windows.FrameworkElement>。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-190">The host application displays the returned <xref:System.Windows.FrameworkElement>.</span></span>  
  
 <span data-ttu-id="b9bcb-191">有关演示如何实现作为 ui 的外接程序示例，请参阅[外接程序，它是创建 UI](../../../../docs/framework/wpf/app-development/how-to-create-an-add-in-that-is-a-ui.md)。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-191">For an example that demonstrates how to implement an add-in that is a UI, see [Create an Add-In That Is a UI](../../../../docs/framework/wpf/app-development/how-to-create-an-add-in-that-is-a-ui.md).</span></span>  
  
<a name="ReturningMultipleUIsFromAnAddIn"></a>   
## <a name="returning-multiple-uis-from-an-add-in"></a><span data-ttu-id="b9bcb-192">从外接程序返回多个 UI</span><span class="sxs-lookup"><span data-stu-id="b9bcb-192">Returning Multiple UIs from an Add-In</span></span>  
 <span data-ttu-id="b9bcb-193">外接程序通常提供多个主机应用程序显示用户界面。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-193">Add-ins often provide multiple user interfaces for host applications to display.</span></span> <span data-ttu-id="b9bcb-194">例如，考虑为用户界面还提供状态信息到主机应用程序，也可用作 UI 的外接程序。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-194">For example, consider an add-in that is a UI that also provides status information to the host application, also as a UI.</span></span> <span data-ttu-id="b9bcb-195">此类外接程序可以通过结合使用[外接程序返回用户界面](#ReturnUIFromAddInContract)和[外接程序为用户界面](#AddInIsAUI)模型中的技术来实现。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-195">An add-in like this can be implemented by using a combination of techniques from both the [Add-In Returns a User Interface](#ReturnUIFromAddInContract) and [Add-In Is a User Interface](#AddInIsAUI) models.</span></span>  
  
<a name="AddInsAndXBAPs"></a>   
## <a name="add-ins-and-xaml-browser-applications"></a><span data-ttu-id="b9bcb-196">外接程序和 XAML 浏览器应用程序</span><span class="sxs-lookup"><span data-stu-id="b9bcb-196">Add-Ins and XAML Browser Applications</span></span>  
 <span data-ttu-id="b9bcb-197">到目前为止，示例中的主机应用程序都安装为独立应用程序。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-197">In the examples so far, the host application has been an installed standalone application.</span></span> <span data-ttu-id="b9bcb-198">但是，如果满足以下附加的生成和实现要求，[!INCLUDE[TLA#tla_xbap#plural](../../../../includes/tlasharptla-xbapsharpplural-md.md)] 也可以承载外接程序：</span><span class="sxs-lookup"><span data-stu-id="b9bcb-198">But [!INCLUDE[TLA#tla_xbap#plural](../../../../includes/tlasharptla-xbapsharpplural-md.md)] can also host add-ins, albeit with the following additional build and implementation requirements:</span></span>  
  
-   <span data-ttu-id="b9bcb-199">必须专门配置 [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] 应用程序清单，以便将管道（文件夹和程序集）和外接程序程序集下载到客户端计算机上的 [!INCLUDE[TLA#tla_clickonce](../../../../includes/tlasharptla-clickonce-md.md)] 应用程序缓存中 [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] 所在的文件夹中。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-199">The [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] application manifest must be configured specially to download the pipeline (folders and assemblies) and add-in assembly to the [!INCLUDE[TLA#tla_clickonce](../../../../includes/tlasharptla-clickonce-md.md)] application cache on the client machine, in the same folder as the [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)].</span></span>  
  
-   <span data-ttu-id="b9bcb-200">用于发现和加载外接程序的 [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] 代码必须将 [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] 的 [!INCLUDE[TLA2#tla_clickonce](../../../../includes/tla2sharptla-clickonce-md.md)] 应用程序缓存用作管道和外接程序位置。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-200">The [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] code to discover and load add-ins must use the [!INCLUDE[TLA2#tla_clickonce](../../../../includes/tla2sharptla-clickonce-md.md)] application cache for the [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] as the pipeline and add-in location.</span></span>  
  
-   <span data-ttu-id="b9bcb-201">如果外接程序引用位于源站点的松散文件，则 [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] 必须将外接程序加载到专门的安全上下文中；在由 [!INCLUDE[TLA2#tla_xbap#plural](../../../../includes/tla2sharptla-xbapsharpplural-md.md)] 承载时，外接程序只能引用位于主机应用程序源站点的松散文件。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-201">The [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] must load the add-in into a special security context if the add-in references loose files that are located at the site of origin; when hosted by [!INCLUDE[TLA2#tla_xbap#plural](../../../../includes/tla2sharptla-xbapsharpplural-md.md)], add-ins can only reference loose files that are located at the host application's site of origin.</span></span>  
  
 <span data-ttu-id="b9bcb-202">下面几个小节将详细介绍这些任务。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-202">These tasks are described in detail in the following subsections.</span></span>  
  
### <a name="configuring-the-pipeline-and-add-in-for-clickonce-deployment"></a><span data-ttu-id="b9bcb-203">配置用于 ClickOnce 部署的管道和外接程序</span><span class="sxs-lookup"><span data-stu-id="b9bcb-203">Configuring the Pipeline and Add-In for ClickOnce Deployment</span></span>  
 [!INCLUDE[TLA2#tla_xbap#plural](../../../../includes/tla2sharptla-xbapsharpplural-md.md)] <span data-ttu-id="b9bcb-204">将下载到 [!INCLUDE[TLA2#tla_clickonce](../../../../includes/tla2sharptla-clickonce-md.md)] 部署缓存中的安全文件夹并从该文件夹运行。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-204">are downloaded to and run from a safe folder in the [!INCLUDE[TLA2#tla_clickonce](../../../../includes/tla2sharptla-clickonce-md.md)] deployment cache.</span></span> <span data-ttu-id="b9bcb-205">为了使 [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] 能够承载外接程序，还必须将管道和外接程序程序集下载到该安全文件夹。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-205">In order for an [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] to host an add-in, the pipeline and add-in assembly must also be downloaded to the safe folder.</span></span> <span data-ttu-id="b9bcb-206">为此，需要将应用程序清单配置为包含要下载的管道和外接程序程序集。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-206">To achieve this, you need to configure the application manifest to include both the pipeline and add-in assembly for download.</span></span> <span data-ttu-id="b9bcb-207">这在 [!INCLUDE[TLA2#tla_visualstu](../../../../includes/tla2sharptla-visualstu-md.md)] 中最容易实现，但为使 [!INCLUDE[TLA2#tla_visualstu](../../../../includes/tla2sharptla-visualstu-md.md)] 检测到管道程序集，管道和外接程序程序集需要位于宿主 [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] 项目的根文件夹中。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-207">This is most easily done in [!INCLUDE[TLA2#tla_visualstu](../../../../includes/tla2sharptla-visualstu-md.md)], although the pipeline and add-in assembly needs to be in the host [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] project's root folder in order for [!INCLUDE[TLA2#tla_visualstu](../../../../includes/tla2sharptla-visualstu-md.md)] to detect the pipeline assemblies.</span></span>  
  
 <span data-ttu-id="b9bcb-208">因此，第一步是通过设置每个管道程序集和外接程序程序集项目的生成输出，向 [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] 项目的根文件夹生成管道和外接程序程序集。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-208">Consequently, the first step is to build the pipeline and add-in assembly to the [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] project's root by setting the build output of each pipeline assembly and add-in assembly projects.</span></span> <span data-ttu-id="b9bcb-209">下表显示管道程序集项目和外接程序程序集项目的生成输出路径，这些路径位于与宿主 [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] 项目相同的解决方案和根文件夹中。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-209">The following table shows the build output paths for pipeline assembly projects and add-in assembly project that are in the same solution and root folder as the host [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] project.</span></span>  
  
 <span data-ttu-id="b9bcb-210">表 1:XBAP 承载的管道程序集生成输出路径</span><span class="sxs-lookup"><span data-stu-id="b9bcb-210">Table 1: Build Output Paths for the Pipeline Assemblies That Are Hosted by an XBAP</span></span>  
  
|<span data-ttu-id="b9bcb-211">管道程序集项目</span><span class="sxs-lookup"><span data-stu-id="b9bcb-211">Pipeline assembly project</span></span>|<span data-ttu-id="b9bcb-212">生成输出路径</span><span class="sxs-lookup"><span data-stu-id="b9bcb-212">Build output path</span></span>|  
|-------------------------------|-----------------------|  
|<span data-ttu-id="b9bcb-213">协定</span><span class="sxs-lookup"><span data-stu-id="b9bcb-213">Contract</span></span>|`..\HostXBAP\Contracts\`|  
|<span data-ttu-id="b9bcb-214">加载项视图</span><span class="sxs-lookup"><span data-stu-id="b9bcb-214">Add-In View</span></span>|`..\HostXBAP\AddInViews\`|  
|<span data-ttu-id="b9bcb-215">加载项方适配器</span><span class="sxs-lookup"><span data-stu-id="b9bcb-215">Add-In-Side Adapter</span></span>|`..\HostXBAP\AddInSideAdapters\`|  
|<span data-ttu-id="b9bcb-216">宿主端适配器</span><span class="sxs-lookup"><span data-stu-id="b9bcb-216">Host-Side Adapter</span></span>|`..\HostXBAP\HostSideAdapters\`|  
|<span data-ttu-id="b9bcb-217">外接程序</span><span class="sxs-lookup"><span data-stu-id="b9bcb-217">Add-In</span></span>|`..\HostXBAP\AddIns\WPFAddIn1`|  
  
 <span data-ttu-id="b9bcb-218">下一步是通过在 [!INCLUDE[TLA2#tla_visualstu](../../../../includes/tla2sharptla-visualstu-md.md)] 中执行以下操作，将管道程序集和外接程序程序集指定为 [!INCLUDE[TLA2#tla_xbap#plural](../../../../includes/tla2sharptla-xbapsharpplural-md.md)] 内容文件：</span><span class="sxs-lookup"><span data-stu-id="b9bcb-218">The next step is to specify the pipeline assemblies and add-in assembly as the [!INCLUDE[TLA2#tla_xbap#plural](../../../../includes/tla2sharptla-xbapsharpplural-md.md)] content files in [!INCLUDE[TLA2#tla_visualstu](../../../../includes/tla2sharptla-visualstu-md.md)] by doing the following:</span></span>  
  
1.  <span data-ttu-id="b9bcb-219">通过在“解决方案资源管理器”中右键单击每个管道文件夹，然后选择“包括在项目中”，将管道和外接程序程序集包括在项目中。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-219">Including the pipeline and add-in assembly in the project by right-clicking each pipeline folder in Solution Explorer and choosing **Include In Project**.</span></span>  
  
2.  <span data-ttu-id="b9bcb-220">在“属性”窗口中，将每个管道程序集和外接程序程序集的“生成操作”都设置为“内容”。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-220">Setting the **Build Action** of each pipeline assembly and add-in assembly to **Content** from the **Properties** window.</span></span>  
  
 <span data-ttu-id="b9bcb-221">最后一步是配置应用程序清单，以包含要下载的管道程序集文件和外接程序程序集文件。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-221">The final step is to configure the application manifest to include the pipeline assembly files and add-in assembly file for download.</span></span> <span data-ttu-id="b9bcb-222">这些文件应位于 [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] 应用程序所占用的 [!INCLUDE[TLA2#tla_clickonce](../../../../includes/tla2sharptla-clickonce-md.md)] 缓存的根文件夹下的文件夹中。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-222">The files should be located in folders at the root of the folder in the [!INCLUDE[TLA2#tla_clickonce](../../../../includes/tla2sharptla-clickonce-md.md)] cache that the [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] application occupies.</span></span> <span data-ttu-id="b9bcb-223">通过执行以下操作，可以在 [!INCLUDE[TLA2#tla_visualstu](../../../../includes/tla2sharptla-visualstu-md.md)] 中实现该配置：</span><span class="sxs-lookup"><span data-stu-id="b9bcb-223">The configuration can be achieved in [!INCLUDE[TLA2#tla_visualstu](../../../../includes/tla2sharptla-visualstu-md.md)] by doing the following:</span></span>  
  
1.  <span data-ttu-id="b9bcb-224">右键单击 [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] 项目，依次单击“属性”、“发布”，然后单击“应用程序文件”按钮。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-224">Right-click the [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] project, click **Properties**, click **Publish**, and then click the **Application Files** button.</span></span>  
  
2.  <span data-ttu-id="b9bcb-225">在“应用程序文件”对话框中，将每个管道和外接程序 DLL 的“发布状态”都设置为“包括(自动)”，并将每个管道和外接程序 DLL 的“下载组”都设置为“(必需)”。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-225">In the **Application Files** dialog, set the **Publish Status** of each pipeline and add-in DLL to **Include (Auto)**, and set the **Download Group** for each pipeline and add-in DLL to **(Required)**.</span></span>  
  
### <a name="using-the-pipeline-and-add-in-from-the-application-base"></a><span data-ttu-id="b9bcb-226">从应用程序基使用管道和外接程序</span><span class="sxs-lookup"><span data-stu-id="b9bcb-226">Using the Pipeline and Add-In from the Application Base</span></span>  
 <span data-ttu-id="b9bcb-227">为 [!INCLUDE[TLA2#tla_clickonce](../../../../includes/tla2sharptla-clickonce-md.md)] 部署配置管道和外接程序时，它们将下载到 [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] 所在的 [!INCLUDE[TLA2#tla_clickonce](../../../../includes/tla2sharptla-clickonce-md.md)] 缓存文件夹中。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-227">When the pipeline and add-in are configured for [!INCLUDE[TLA2#tla_clickonce](../../../../includes/tla2sharptla-clickonce-md.md)] deployment, they are downloaded to the same [!INCLUDE[TLA2#tla_clickonce](../../../../includes/tla2sharptla-clickonce-md.md)] cache folder as the [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)].</span></span> <span data-ttu-id="b9bcb-228">若要从 [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] 中使用管道和外接程序，[!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] 代码必须从应用程序基获取它们。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-228">To use the pipeline and add-in from the [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)], the [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] code must get them from the application base.</span></span> <span data-ttu-id="b9bcb-229">各种视频类型和模型使用的管道和外接程序的.NET Framework 外接程序的成员对于此方案提供特殊支持。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-229">The various types and members of the .NET Framework add-in model for using pipelines and add-ins provide special support for this scenario.</span></span> <span data-ttu-id="b9bcb-230">首先，路径由<xref:System.AddIn.Hosting.PipelineStoreLocation.ApplicationBase>枚举值。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-230">Firstly, the path is identified by the <xref:System.AddIn.Hosting.PipelineStoreLocation.ApplicationBase> enumeration value.</span></span> <span data-ttu-id="b9bcb-231">将此值用于使用管道的相关外接程序成员的重载，这些成员包括：</span><span class="sxs-lookup"><span data-stu-id="b9bcb-231">You use this value with overloads of the pertinent add-in members for using pipelines that include the following:</span></span>  
  
-   <xref:System.AddIn.Hosting.AddInStore.FindAddIns%28System.Type%2CSystem.AddIn.Hosting.PipelineStoreLocation%29?displayProperty=nameWithType>  
  
-   <xref:System.AddIn.Hosting.AddInStore.FindAddIns%28System.Type%2CSystem.AddIn.Hosting.PipelineStoreLocation%2CSystem.String%5B%5D%29?displayProperty=nameWithType>  
  
-   <xref:System.AddIn.Hosting.AddInStore.Rebuild%28System.AddIn.Hosting.PipelineStoreLocation%29?displayProperty=nameWithType>  
  
-   <xref:System.AddIn.Hosting.AddInStore.Update%28System.AddIn.Hosting.PipelineStoreLocation%29?displayProperty=nameWithType>  
  
### <a name="accessing-the-hosts-site-of-origin"></a><span data-ttu-id="b9bcb-232">访问宿主的源站点</span><span class="sxs-lookup"><span data-stu-id="b9bcb-232">Accessing the Host's Site of Origin</span></span>  
 <span data-ttu-id="b9bcb-233">为确保外接程序可以引用源站点的文件，必须使用等效于主机应用程序的安全隔离来加载外接程序。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-233">To ensure that an add-in can reference files from the site of origin, the add-in must be loaded with security isolation that is equivalent to the host application.</span></span> <span data-ttu-id="b9bcb-234">此安全级别由<xref:System.AddIn.Hosting.AddInSecurityLevel.Host?displayProperty=nameWithType>枚举值，并传递给<xref:System.AddIn.Hosting.AddInToken.Activate%2A>方法激活外接程序时。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-234">This security level is identified by the <xref:System.AddIn.Hosting.AddInSecurityLevel.Host?displayProperty=nameWithType> enumeration value, and passed to the <xref:System.AddIn.Hosting.AddInToken.Activate%2A> method when an add-in is activated.</span></span>  
  
<a name="WPFAddInModelArchitecture"></a>   
## <a name="wpf-add-in-architecture"></a><span data-ttu-id="b9bcb-235">WPF 外接程序体系结构</span><span class="sxs-lookup"><span data-stu-id="b9bcb-235">WPF Add-In Architecture</span></span>  
 <span data-ttu-id="b9bcb-236">在最高级别，如我们所见，WPF 使.NET Framework 外接程序来实现用户界面 (的直接或间接派生<xref:System.Windows.FrameworkElement>) 使用<xref:System.AddIn.Contract.INativeHandleContract>，<xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A>和<xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A>。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-236">At the highest level, as we've seen, WPF enables .NET Framework add-ins to implement user interfaces (that derive directly or indirectly from <xref:System.Windows.FrameworkElement>) using <xref:System.AddIn.Contract.INativeHandleContract>, <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A> and <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A>.</span></span> <span data-ttu-id="b9bcb-237">结果是，所以宿主应用程序将返回<xref:System.Windows.FrameworkElement>UI 中显示主机应用程序中。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-237">The result is that the host application is returned a <xref:System.Windows.FrameworkElement> that is displayed from UI in the host application.</span></span>  
  
 <span data-ttu-id="b9bcb-238">对于简单 UI 外接程序的方案，这是开发人员需要尽可能详细。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-238">For simple UI add-in scenarios, this is as much detail as a developer needs.</span></span> <span data-ttu-id="b9bcb-239">对于更复杂的方案，特别是那些尝试使用其他 WPF 服务，如布局、 资源和数据绑定，更深入的了解 WPF 如何扩展模型的 UI 支持.NET Framework 外接程序的需要了解它的好处和限制。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-239">For more complex scenarios, particularly those that try to utilize additional WPF services such as layout, resources, and data binding, more detailed knowledge of how WPF extends the .NET Framework add-in model with UI support is required to understand its benefits and limitations.</span></span>  
  
 <span data-ttu-id="b9bcb-240">从根本上说，WPF 未通过 UI 从外接程序的宿主应用程序;相反，WPF 将传递的 Win32 窗口句柄的 ui 使用 WPF 互操作性。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-240">Fundamentally, WPF doesn't pass a UI from an add-in to a host application; instead, WPF passes the Win32 window handle for the UI by using WPF interoperability.</span></span> <span data-ttu-id="b9bcb-241">在这种情况下，当从外接程序的 UI 传递到主机应用程序时，将发生以下情况：</span><span class="sxs-lookup"><span data-stu-id="b9bcb-241">As such, when a UI from an add-in is passed to a host application, the following occurs:</span></span>  
  
-   <span data-ttu-id="b9bcb-242">在外接程序端，WPF 主机应用程序将显示的 ui 获取窗口句柄。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-242">On the add-in side, WPF acquires a window handle for the UI that will be displayed by the host application.</span></span> <span data-ttu-id="b9bcb-243">由派生的内部 WPF 类封装窗口句柄<xref:System.Windows.Interop.HwndSource>并实现<xref:System.AddIn.Contract.INativeHandleContract>。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-243">The window handle is encapsulated by an internal WPF class that derives from <xref:System.Windows.Interop.HwndSource> and implements <xref:System.AddIn.Contract.INativeHandleContract>.</span></span> <span data-ttu-id="b9bcb-244">此类的实例返回的<xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A>和从外接程序的应用程序域封至主机应用程序的应用程序域。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-244">An instance of this class is returned by <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A> and is marshaled from the add-in's application domain to the host application's application domain.</span></span>  
  
-   <span data-ttu-id="b9bcb-245">在主机应用程序端，WPF 会重新打包<xref:System.Windows.Interop.HwndSource>作为内部 WPF 类派生自<xref:System.Windows.Interop.HwndHost>，并在使用<xref:System.AddIn.Contract.INativeHandleContract>。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-245">On the host application side, WPF repackages the <xref:System.Windows.Interop.HwndSource> as an internal WPF class that derives from <xref:System.Windows.Interop.HwndHost> and consumes <xref:System.AddIn.Contract.INativeHandleContract>.</span></span> <span data-ttu-id="b9bcb-246">此类的实例返回的<xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A>到主机应用程序。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-246">An instance of this class is returned by <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A> to the host application.</span></span>  
  
 <span data-ttu-id="b9bcb-247"><xref:System.Windows.Interop.HwndHost> 存在能够显示用户界面，标识的窗口句柄，从 WPF 用户界面。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-247"><xref:System.Windows.Interop.HwndHost> exists to display user interfaces, identified by window handles, from WPF user interfaces.</span></span> <span data-ttu-id="b9bcb-248">有关详细信息，请参阅 [WPF 和 Win32 互操作](../../../../docs/framework/wpf/advanced/wpf-and-win32-interoperation.md)。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-248">For more information, see [WPF and Win32 Interoperation](../../../../docs/framework/wpf/advanced/wpf-and-win32-interoperation.md).</span></span>  
  
 <span data-ttu-id="b9bcb-249">总之， <xref:System.AddIn.Contract.INativeHandleContract>， <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A>，并<xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A>存在的目的在于允许传递从外接程序的宿主应用程序中，通过封装了一个 WPF UI 的窗口句柄<xref:System.Windows.Interop.HwndHost>和显示主机应用程序的 UI。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-249">In summary, <xref:System.AddIn.Contract.INativeHandleContract>, <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A>, and <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A> exist to allow the window handle for a WPF UI to be passed from an add-in to a host application, where it is encapsulated by a <xref:System.Windows.Interop.HwndHost> and displayed the host application's UI.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b9bcb-250">由于主机应用程序获取<xref:System.Windows.Interop.HwndHost>，主机应用程序无法将返回的对象转换<xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A>实现的类型它是通过外接程序 (例如， <xref:System.Windows.Controls.UserControl>)。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-250">Because the host application gets an <xref:System.Windows.Interop.HwndHost>, the host application cannot convert the object that is returned by <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A> to the type it is implemented as by the add-in (for example, a <xref:System.Windows.Controls.UserControl>).</span></span>  
  
 <span data-ttu-id="b9bcb-251">按其性质<xref:System.Windows.Interop.HwndHost>有某些限制，会影响主机应用程序可以使用它们。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-251">By its nature, <xref:System.Windows.Interop.HwndHost> has certain limitations that affect how host applications can use them.</span></span> <span data-ttu-id="b9bcb-252">但是，扩展了 WPF<xref:System.Windows.Interop.HwndHost>具备多个功能的外接程序方案。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-252">However, WPF extends <xref:System.Windows.Interop.HwndHost> with several capabilities for add-in scenarios.</span></span> <span data-ttu-id="b9bcb-253">下面介绍这些优点和限制。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-253">These benefits and limitations are described below.</span></span>  
  
<a name="WPFAddInModelBenefits"></a>   
## <a name="wpf-add-in-benefits"></a><span data-ttu-id="b9bcb-254">WPF 外接程序的优点</span><span class="sxs-lookup"><span data-stu-id="b9bcb-254">WPF Add-In Benefits</span></span>  
 <span data-ttu-id="b9bcb-255">由于 WPF 外接程序用户界面显示从主机应用程序使用的内部类派生自<xref:System.Windows.Interop.HwndHost>，这些用户界面的功能受到<xref:System.Windows.Interop.HwndHost>方面布局，如 WPF UI 服务呈现、 数据绑定、 样式、 模板和资源。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-255">Because WPF add-in user interfaces are displayed from host applications using an internal class that derives from <xref:System.Windows.Interop.HwndHost>, those user interfaces are constrained by the capabilities of <xref:System.Windows.Interop.HwndHost> with respect to WPF UI services such as layout, rendering, data binding, styles, templates, and resources.</span></span> <span data-ttu-id="b9bcb-256">但是，WPF 扩展了其内部<xref:System.Windows.Interop.HwndHost>子类的附加功能，包括以下：</span><span class="sxs-lookup"><span data-stu-id="b9bcb-256">However, WPF augments its internal <xref:System.Windows.Interop.HwndHost> subclass with additional capabilities that include the following:</span></span>  
  
-   <span data-ttu-id="b9bcb-257">主机应用程序的 UI 和外接程序的 UI 之间按 tab 键。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-257">Tabbing between a host application's UI and an add-in's UI.</span></span> <span data-ttu-id="b9bcb-258">请注意，"外接程序是一个用户界面"编程模型需要外接程序端适配器重写<xref:System.AddIn.Pipeline.ContractBase.QueryContract%2A>使 tab 键切换功能，无论外接程序是完全信任还是部分受信任的。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-258">Note that the "add-in is a UI" programming model requires the add-in-side adapter to override <xref:System.AddIn.Pipeline.ContractBase.QueryContract%2A> to enable tabbing, whether the add-in is fully trusted or partially trusted.</span></span>  
  
-   <span data-ttu-id="b9bcb-259">接受从主机应用程序的用户界面显示的外接程序用户界面的可访问性要求。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-259">Honoring accessibility requirements for add-in user interfaces that are displayed from host application user interfaces.</span></span>  
  
-   <span data-ttu-id="b9bcb-260">使 WPF 应用程序能够在多个应用程序域方案中安全地运行。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-260">Enabling WPF applications to run safely in multiple application domain scenarios.</span></span>  
  
-   <span data-ttu-id="b9bcb-261">防止非法访问外接程序用户界面窗口句柄时使用安全隔离 （即，部分信任安全沙盒） 运行外接程序。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-261">Preventing illegal access to add-in UI window handles when add-ins run with security isolation (that is, a partial-trust security sandbox).</span></span> <span data-ttu-id="b9bcb-262">调用<xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A>以确保此安全性：</span><span class="sxs-lookup"><span data-stu-id="b9bcb-262">Calling <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A> ensures this security:</span></span>  
  
    -   <span data-ttu-id="b9bcb-263">对于"外接程序返回 UI"编程模型的一个外接程序的 UI 跨隔离边界传递的窗口句柄的唯一方法是调用<xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A>。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-263">For the "add-in returns a UI" programming model, the only way to pass the window handle for an add-in UI across the isolation boundary is to call <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A>.</span></span>  
  
    -   <span data-ttu-id="b9bcb-264">对于"外接程序是一个用户界面"的编程模型，重写<xref:System.AddIn.Pipeline.ContractBase.QueryContract%2A>上的外接程序端适配器和调用<xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A>（如上述示例中所示） 是必需的因为调用外接程序端适配器`QueryContract`实现主机端适配器。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-264">For the "add-in is a UI" programming model, overriding <xref:System.AddIn.Pipeline.ContractBase.QueryContract%2A> on the add-in-side adapter and calling <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A> (as shown in the preceding examples) is required, as is calling the add-in-side adapter's `QueryContract` implementation from the host-side adapter.</span></span>  
  
-   <span data-ttu-id="b9bcb-265">提供多个应用程序域执行保护。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-265">Providing multiple application domain execution protection.</span></span> <span data-ttu-id="b9bcb-266">由于应用程序域的限制，因此即使存在隔离边界，外接程序应用程序域中引发的未经处理的异常也会导致整个应用程序出现故障。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-266">Due to limitations with application domains, unhandled exceptions that are thrown in add-in application domains cause the entire application to crash, even though the isolation boundary exists.</span></span> <span data-ttu-id="b9bcb-267">但是，WPF 和.NET Framework 外接程序模型提供简单的方法要解决此问题并提高应用程序的稳定性。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-267">However, WPF and the .NET Framework add-in model provide a simple way to work around this problem and improve application stability.</span></span> <span data-ttu-id="b9bcb-268">WPF 外接程序显示的 UI 创建<xref:System.Windows.Threading.Dispatcher>的线程的应用程序域在上运行，如果主机应用程序是一个 WPF 应用程序。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-268">A WPF add-in that displays a UI creates a <xref:System.Windows.Threading.Dispatcher> for the thread that the application domain runs on, if the host application is a WPF application.</span></span> <span data-ttu-id="b9bcb-269">你可以检测到处理应用程序域中发生的所有未处理的异常<xref:System.Windows.Threading.Dispatcher.UnhandledException>WPF 外接程序的事件<xref:System.Windows.Threading.Dispatcher>。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-269">You can detect all unhandled exceptions that occur in the application domain by handling the <xref:System.Windows.Threading.Dispatcher.UnhandledException> event of the WPF add-in's <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="b9bcb-270">可以获取<xref:System.Windows.Threading.Dispatcher>从<xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-270">You can get the <xref:System.Windows.Threading.Dispatcher> from the <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A> property.</span></span>  
  
<a name="WPFAddInModelLimitations"></a>   
## <a name="wpf-add-in-limitations"></a><span data-ttu-id="b9bcb-271">WPF 外接程序限制</span><span class="sxs-lookup"><span data-stu-id="b9bcb-271">WPF Add-In Limitations</span></span>  
 <span data-ttu-id="b9bcb-272">WPF 将添加到由提供的默认行为的优点之外<xref:System.Windows.Interop.HwndSource>， <xref:System.Windows.Interop.HwndHost>，和窗口句柄，也有限制从主机应用程序显示的外接程序用户界面：</span><span class="sxs-lookup"><span data-stu-id="b9bcb-272">Beyond the benefits that WPF adds to the default behaviors supplied by <xref:System.Windows.Interop.HwndSource>, <xref:System.Windows.Interop.HwndHost>, and window handles, there are also limitations for add-in user interfaces that are displayed from host applications:</span></span>  
  
-   <span data-ttu-id="b9bcb-273">从主机应用程序中显示的外接程序用户界面不遵从主机应用程序的剪辑行为。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-273">Add-in user interfaces displayed from a host application do not respect the host application's clipping behavior.</span></span>  
  
-   <span data-ttu-id="b9bcb-274">互操作性方案中的“空域”概念也适用于外接程序（请参阅[技术区概述](../../../../docs/framework/wpf/advanced/technology-regions-overview.md)）。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-274">The concept of *airspace* in interoperability scenarios also applies to add-ins (see [Technology Regions Overview](../../../../docs/framework/wpf/advanced/technology-regions-overview.md)).</span></span>  
  
-   <span data-ttu-id="b9bcb-275">主机应用程序的 UI 服务，如资源继承、 数据绑定和命令，不会自动提供外接程序用户界面。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-275">A host application's UI services, such as resource inheritance, data binding, and commanding, are not automatically available to add-in user interfaces.</span></span> <span data-ttu-id="b9bcb-276">若要向外接程序提供这些服务，需要更新管道。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-276">To provide these services to the add-in, you need to update the pipeline.</span></span>  
  
-   <span data-ttu-id="b9bcb-277">不能旋转、 缩放、 倾斜，或不受转换一个外接程序的 UI (请参阅[转换概述](../../../../docs/framework/wpf/graphics-multimedia/transforms-overview.md))。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-277">An add-in UI cannot be rotated, scaled, skewed, or otherwise affected by a transformation (see [Transforms Overview](../../../../docs/framework/wpf/graphics-multimedia/transforms-overview.md)).</span></span>  
  
-   <span data-ttu-id="b9bcb-278">通过绘制从操作呈现的外接程序用户界面中的内容<xref:System.Drawing>命名空间可以包含 alpha 值混合处理。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-278">Content inside add-in user interfaces that is rendered by drawing operations from the <xref:System.Drawing> namespace can include alpha blending.</span></span> <span data-ttu-id="b9bcb-279">但是，加载项 UI 和主机应用程序 UI，其中包含它必须是 100%不透明的;换而言之，`Opacity`上的属性必须设置为 1。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-279">However, both an add-in UI and the host application UI that contains it must be 100% opaque; in other words, the `Opacity` property on both must be set to 1.</span></span>  
  
-   <span data-ttu-id="b9bcb-280">如果<xref:System.Windows.Window.AllowsTransparency%2A>窗口包含一个外接程序的 UI 在主机应用程序中的属性设置为`true`外, 接程序是不可见。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-280">If the <xref:System.Windows.Window.AllowsTransparency%2A> property of a window in the host application that contains an add-in UI is set to `true`, the add-in is invisible.</span></span> <span data-ttu-id="b9bcb-281">即使外接程序用户界面是 100%不透明，这是如此 (即，`Opacity`属性具有值为 1)。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-281">This is true even if the add-in UI is 100% opaque (that is, the `Opacity` property has a value of 1).</span></span>  
  
-   <span data-ttu-id="b9bcb-282">加载项 UI 必须出现在同一顶级窗口中的其他 WPF 元素之上。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-282">An add-in UI must appear on top of other WPF elements in the same top-level window.</span></span>  
  
-   <span data-ttu-id="b9bcb-283">可以使用呈现外接程序的 UI 的任何部分<xref:System.Windows.Media.VisualBrush>。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-283">No portion of an add-in's UI can be rendered using a <xref:System.Windows.Media.VisualBrush>.</span></span> <span data-ttu-id="b9bcb-284">相反外, 接程序可能需要生成用户界面中，若要创建位图，可传递到主机应用程序使用通过协定所定义的方法的快照。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-284">Instead, the add-in may take a snapshot of the generated UI to create a bitmap that can be passed to the host application using methods defined by the contract.</span></span>  
  
-   <span data-ttu-id="b9bcb-285">不能从播放媒体文件<xref:System.Windows.Controls.MediaElement>外接程序 UI 中。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-285">Media files cannot be played from a <xref:System.Windows.Controls.MediaElement> in an add-in UI.</span></span>  
  
-   <span data-ttu-id="b9bcb-286">生成外接程序用户界面的鼠标事件则既不接收，也不引发主机应用程序，并`IsMouseOver`主机应用程序 UI 的属性的值为`false`。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-286">Mouse events generated for the add-in UI are neither received nor raised by the host application, and the `IsMouseOver` property for host application UI has a value of `false`.</span></span>  
  
-   <span data-ttu-id="b9bcb-287">当外接程序 UI 中的控件焦点`GotFocus`和`LostFocus`事件是既没有接收到不会引发主机应用程序。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-287">When focus shifts between controls in an add-in UI, the `GotFocus` and `LostFocus` events are neither received nor raised by the host application.</span></span>  
  
-   <span data-ttu-id="b9bcb-288">包含一个外接程序的 UI 的主机应用程序的部分将显示为空白时打印。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-288">The portion of a host application that contains an add-in UI appears white when printed.</span></span>  
  
-   <span data-ttu-id="b9bcb-289">所有调度程序 (请参阅<xref:System.Windows.Threading.Dispatcher>) 由外接程序创建 UI 必须手动关闭所有者外接程序卸载之前如果主机应用程序继续执行。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-289">All dispatchers (see <xref:System.Windows.Threading.Dispatcher>) created by the add-in UI must be shut down manually before the owner add-in is unloaded if the host application continues execution.</span></span> <span data-ttu-id="b9bcb-290">协定可以实现允许主机应用程序外接程序卸载之前通知外接程序，从而允许外接程序用户界面关闭自己的调度程序的方法。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-290">The contract can implement methods that allow the host application to signal the add-in before the add-in is unloaded, thereby allowing the add-in UI to shut down its dispatchers.</span></span>  
  
-   <span data-ttu-id="b9bcb-291">如果加载项 UI<xref:System.Windows.Controls.InkCanvas>或包含<xref:System.Windows.Controls.InkCanvas>，不能卸载外接程序。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-291">If an add-in UI is an <xref:System.Windows.Controls.InkCanvas> or contains an <xref:System.Windows.Controls.InkCanvas>, you cannot unload the add-in.</span></span>  
  
<a name="PerformanceOptimization"></a>   
## <a name="performance-optimization"></a><span data-ttu-id="b9bcb-292">性能优化</span><span class="sxs-lookup"><span data-stu-id="b9bcb-292">Performance Optimization</span></span>  
 <span data-ttu-id="b9bcb-293">默认情况下，当使用多个应用程序域时，每个应用程序所需的各种.NET Framework 程序集是所有加载到该应用程序的域。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-293">By default, when multiple application domains are used, the various .NET Framework assemblies required by each application are all loaded into that application's domain.</span></span> <span data-ttu-id="b9bcb-294">因此，创建新应用程序域和在应用程序域中启动应用程序所需的时间可能会影响性能。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-294">As a result, the time required for creating new application domains and starting applications in them might affect performance.</span></span> <span data-ttu-id="b9bcb-295">但是，.NET Framework 提供了一种方法，从而减少启动时间即指示应用程序在应用程序域之间共享程序集，如果他们已加载。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-295">However, the .NET Framework provides a way for you to reduce start times by instructing applications to share assemblies across application domains if they are already loaded.</span></span> <span data-ttu-id="b9bcb-296">执行此操作通过使用<xref:System.LoaderOptimizationAttribute>属性，必须应用于入口点方法 (`Main`)。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-296">You do this by using the <xref:System.LoaderOptimizationAttribute> attribute, which must be applied to the entry point method (`Main`).</span></span> <span data-ttu-id="b9bcb-297">这种情况下，只能使用代码来实现应用程序定义（请参阅[应用程序管理概述](../../../../docs/framework/wpf/app-development/application-management-overview.md)）。</span><span class="sxs-lookup"><span data-stu-id="b9bcb-297">In this case, you must use only code to implement your application definition (see [Application Management Overview](../../../../docs/framework/wpf/app-development/application-management-overview.md)).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="b9bcb-298">请参阅</span><span class="sxs-lookup"><span data-stu-id="b9bcb-298">See Also</span></span>  
 <xref:System.LoaderOptimizationAttribute>  
 <span data-ttu-id="b9bcb-299">[外接程序和扩展性](/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100))</span><span class="sxs-lookup"><span data-stu-id="b9bcb-299">[Add-ins and Extensibility](/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100))</span></span>  
 [<span data-ttu-id="b9bcb-300">应用程序域</span><span class="sxs-lookup"><span data-stu-id="b9bcb-300">Application Domains</span></span>](../../../../docs/framework/app-domains/application-domains.md)  
 [<span data-ttu-id="b9bcb-301">.NET framework 远程处理概述</span><span class="sxs-lookup"><span data-stu-id="b9bcb-301">.NET Framework Remoting Overview</span></span>](https://msdn.microsoft.com/library/eccb1d31-0a22-417a-97fd-f4f1f3aa4462)  
 [<span data-ttu-id="b9bcb-302">使对象可远程处理</span><span class="sxs-lookup"><span data-stu-id="b9bcb-302">Making Objects Remotable</span></span>](https://msdn.microsoft.com/library/01197253-3f13-43b7-894d-9683e431192a)  
 [<span data-ttu-id="b9bcb-303">帮助主题</span><span class="sxs-lookup"><span data-stu-id="b9bcb-303">How-to Topics</span></span>](../../../../docs/framework/wpf/app-development/how-to-topics.md)
