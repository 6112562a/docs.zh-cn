---
title: Windows Communication Foundation 基础概念
ms.date: 03/30/2017
helpviewer_keywords:
- WCF [WCF], concepts
- concepts [WCF]
- fundamentals [WCF]
- Windows Communication Foundation [WCF], concepts
ms.assetid: 3e7e0afd-7913-499d-bafb-eac7caacbc7a
ms.openlocfilehash: 8aceb94de4ed879834fd9ba833083c54ba1b4174
ms.sourcegitcommit: 127343afce8422bfa944c8b0c4ecc8f79f653255
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 06/25/2019
ms.locfileid: "67348350"
---
# <a name="fundamental-windows-communication-foundation-concepts"></a><span data-ttu-id="6cc90-102">Windows Communication Foundation 基础概念</span><span class="sxs-lookup"><span data-stu-id="6cc90-102">Fundamental Windows Communication Foundation Concepts</span></span>

<span data-ttu-id="6cc90-103">本文档提供 Windows Communication Foundation (WCF) 体系结构的高级视图。</span><span class="sxs-lookup"><span data-stu-id="6cc90-103">This document provides a high-level view of the Windows Communication Foundation (WCF) architecture.</span></span> <span data-ttu-id="6cc90-104">本文档旨在解释关键概念以及这些概念之间的关系。</span><span class="sxs-lookup"><span data-stu-id="6cc90-104">It is intended to explain key concepts and how they fit together.</span></span> <span data-ttu-id="6cc90-105">有关创建 WCF 服务和客户端的最简单版本的教程，请参阅[入门教程](../../../docs/framework/wcf/getting-started-tutorial.md)。</span><span class="sxs-lookup"><span data-stu-id="6cc90-105">For a tutorial on creating the simplest version of a WCF service and client, see [Getting Started Tutorial](../../../docs/framework/wcf/getting-started-tutorial.md).</span></span> <span data-ttu-id="6cc90-106">若要了解 WCF 编程，请参阅[基本 WCF 编程](../../../docs/framework/wcf/basic-wcf-programming.md)。</span><span class="sxs-lookup"><span data-stu-id="6cc90-106">To learn WCF programming, see [Basic WCF Programming](../../../docs/framework/wcf/basic-wcf-programming.md).</span></span>

## <a name="wcf-fundamentals"></a><span data-ttu-id="6cc90-107">WCF 基础知识</span><span class="sxs-lookup"><span data-stu-id="6cc90-107">WCF Fundamentals</span></span>

<span data-ttu-id="6cc90-108">WCF 是用于创建服务和客户端之间发送消息的系统运行时和一组 Api。</span><span class="sxs-lookup"><span data-stu-id="6cc90-108">WCF is a runtime and a set of APIs for creating systems that send messages between services and clients.</span></span> <span data-ttu-id="6cc90-109">它使用相同的基础结构和 API 来创建应用程序，这些应用程序可与同一计算机系统上或驻留在另一家公司内并通过 Internet 访问的系统上的其他应用程序进行通信。</span><span class="sxs-lookup"><span data-stu-id="6cc90-109">The same infrastructure and APIs are used to create applications that communicate with other applications on the same computer system or on a system that resides in another company and is accessed over the Internet.</span></span>

### <a name="messaging-and-endpoints"></a><span data-ttu-id="6cc90-110">消息和终结点</span><span class="sxs-lookup"><span data-stu-id="6cc90-110">Messaging and Endpoints</span></span>

<span data-ttu-id="6cc90-111">WCF 基于可以建模为一条消息 （例如，HTTP 请求或消息队列 (也称为 MSMQ) 消息） 可以表示以统一的方式在编程模型的基于消息的通信，以及任何概念。</span><span class="sxs-lookup"><span data-stu-id="6cc90-111">WCF is based on the notion of message-based communication, and anything that can be modeled as a message (for example, an HTTP request or a Message Queuing (also known as MSMQ) message) can be represented in a uniform way in the programming model.</span></span> <span data-ttu-id="6cc90-112">这样，就可以在不同传输机制间提供一个统一的 API。</span><span class="sxs-lookup"><span data-stu-id="6cc90-112">This enables a unified API across different transport mechanisms.</span></span>

<span data-ttu-id="6cc90-113">模型区分_客户端_，这是应用程序启动的通信，并_服务_，这是应用程序，等待客户端与它们进行通信并做出响应，通信。</span><span class="sxs-lookup"><span data-stu-id="6cc90-113">The model distinguishes between _clients_, which are applications that initiate communication, and _services_, which are applications that wait for clients to communicate with them and respond to that communication.</span></span> <span data-ttu-id="6cc90-114">单个应用程序既可以充当客户端，也可以充当服务。</span><span class="sxs-lookup"><span data-stu-id="6cc90-114">A single application can act as both a client and a service.</span></span> <span data-ttu-id="6cc90-115">有关示例，请参阅[双工服务](../../../docs/framework/wcf/feature-details/duplex-services.md)并[对等网络](../../../docs/framework/wcf/feature-details/peer-to-peer-networking.md)。</span><span class="sxs-lookup"><span data-stu-id="6cc90-115">For examples, see [Duplex Services](../../../docs/framework/wcf/feature-details/duplex-services.md) and [Peer-to-Peer Networking](../../../docs/framework/wcf/feature-details/peer-to-peer-networking.md).</span></span>

<span data-ttu-id="6cc90-116">消息在终结点之间发送。</span><span class="sxs-lookup"><span data-stu-id="6cc90-116">Messages are sent between endpoints.</span></span> <span data-ttu-id="6cc90-117">_终结点_是发送或接收消息的位置 （或两者），并且它们定义消息交换所需的所有信息。</span><span class="sxs-lookup"><span data-stu-id="6cc90-117">_Endpoints_ are places where messages are sent or received (or both), and they define all the information required for the message exchange.</span></span> <span data-ttu-id="6cc90-118">服务公开一个或多个应用程序终结点（以及零个或更多个基础结构终结点），而客户端生成一个与服务的其中一个终结点兼容的终结点。</span><span class="sxs-lookup"><span data-stu-id="6cc90-118">A service exposes one or more application endpoints (as well as zero or more infrastructure endpoints), and the client generates an endpoint that is compatible with one of the service's endpoints.</span></span>

<span data-ttu-id="6cc90-119">_终结点_描述基于标准的方式，应发送消息的位置、 如何应发送它们，以及消息应如下所示。</span><span class="sxs-lookup"><span data-stu-id="6cc90-119">An _endpoint_ describes in a standard-based way where messages should be sent, how they should be sent, and what the messages should look like.</span></span> <span data-ttu-id="6cc90-120">服务可以公开此信息作为客户端可以处理以生成适当的 WCF 客户端和通信的元数据_堆栈_。</span><span class="sxs-lookup"><span data-stu-id="6cc90-120">A service can expose this information as metadata that clients can process to generate appropriate WCF clients and communication _stacks_.</span></span>

### <a name="communication-protocols"></a><span data-ttu-id="6cc90-121">通信协议</span><span class="sxs-lookup"><span data-stu-id="6cc90-121">Communication Protocols</span></span>

<span data-ttu-id="6cc90-122">一个必需的通信堆栈的元素是_传输协议_。</span><span class="sxs-lookup"><span data-stu-id="6cc90-122">One required element of the communication stack is the _transport protocol_.</span></span> <span data-ttu-id="6cc90-123">可以使用常用传输协议（如 HTTP 和 TCP）通过 Intranet 和 Internet 发送消息。</span><span class="sxs-lookup"><span data-stu-id="6cc90-123">Messages can be sent over intranets and the Internet using common transports, such as HTTP and TCP.</span></span> <span data-ttu-id="6cc90-124">也可以使用其他支持与消息队列应用程序和对等网络网格上的节点进行通信的传输协议。</span><span class="sxs-lookup"><span data-stu-id="6cc90-124">Other transports are included that support communication with Message Queuing applications and nodes on a Peer Networking mesh.</span></span> <span data-ttu-id="6cc90-125">可以使用 WCF 的内置扩展点添加更多传输机制。</span><span class="sxs-lookup"><span data-stu-id="6cc90-125">More transport mechanisms can be added using the built-in extension points of WCF.</span></span>

<span data-ttu-id="6cc90-126">通信堆栈中的另一个必要元素是指定如何对任意给定消息进行格式化的编码。</span><span class="sxs-lookup"><span data-stu-id="6cc90-126">Another required element in the communication stack is the encoding that specifies how any given message is formatted.</span></span> <span data-ttu-id="6cc90-127">WCF 提供了以下编码：</span><span class="sxs-lookup"><span data-stu-id="6cc90-127">WCF provides the following encodings:</span></span>

- <span data-ttu-id="6cc90-128">文本编码，一种可互操作的编码。</span><span class="sxs-lookup"><span data-stu-id="6cc90-128">Text encoding, an interoperable encoding.</span></span>

- <span data-ttu-id="6cc90-129">消息传输优化机制 (MTOM) 编码，该编码是一种可互操作的方法，用于高效地将非结构化二进制数据发送到服务或从服务接收这些数据。</span><span class="sxs-lookup"><span data-stu-id="6cc90-129">Message Transmission Optimization Mechanism (MTOM) encoding, which is an interoperable way for efficiently sending unstructured binary data to and from a service.</span></span>

- <span data-ttu-id="6cc90-130">用于实现高效传输的二进制编码。</span><span class="sxs-lookup"><span data-stu-id="6cc90-130">Binary encoding for efficient transfer.</span></span>

<span data-ttu-id="6cc90-131">可以使用 WCF 的内置扩展点添加更多编码机制 （例如，压缩编码）。</span><span class="sxs-lookup"><span data-stu-id="6cc90-131">More encoding mechanisms (for example, a compression encoding) can be added using the built-in extension points of WCF.</span></span>

### <a name="message-patterns"></a><span data-ttu-id="6cc90-132">消息模式</span><span class="sxs-lookup"><span data-stu-id="6cc90-132">Message Patterns</span></span>

<span data-ttu-id="6cc90-133">WCF 支持多种消息模式，包括请求-答复、 单向和双工通信。</span><span class="sxs-lookup"><span data-stu-id="6cc90-133">WCF supports several messaging patterns, including request-reply, one-way, and duplex communication.</span></span> <span data-ttu-id="6cc90-134">不同传输协议支持不同的消息模式，因而会影响它们所支持的交互类型。</span><span class="sxs-lookup"><span data-stu-id="6cc90-134">Different transports support different messaging patterns, and thus affect the types of interactions that they support.</span></span> <span data-ttu-id="6cc90-135">WCF Api 和运行时还帮助您安全可靠地发送消息。</span><span class="sxs-lookup"><span data-stu-id="6cc90-135">The WCF APIs and runtime also help you to send messages securely and reliably.</span></span>

## <a name="wcf-terms"></a><span data-ttu-id="6cc90-136">WCF 术语</span><span class="sxs-lookup"><span data-stu-id="6cc90-136">WCF Terms</span></span>

<span data-ttu-id="6cc90-137">其他概念和 WCF 文档中使用的术语包括：</span><span class="sxs-lookup"><span data-stu-id="6cc90-137">Other concepts and terms used in the WCF documentation include the following:</span></span>

<span data-ttu-id="6cc90-138">**消息**</span><span class="sxs-lookup"><span data-stu-id="6cc90-138">**Message**</span></span>  
 <span data-ttu-id="6cc90-139">消息是一个独立的数据单元，它可能由几个部分组成，包括消息正文和消息头。</span><span class="sxs-lookup"><span data-stu-id="6cc90-139">A self-contained unit of data that can consist of several parts, including a body and headers.</span></span>

<span data-ttu-id="6cc90-140">**服务**</span><span class="sxs-lookup"><span data-stu-id="6cc90-140">**Service**</span></span>  
 <span data-ttu-id="6cc90-141">服务是一个构造，它公开一个或多个终结点，其中每个终结点都公开一个或多个服务操作。</span><span class="sxs-lookup"><span data-stu-id="6cc90-141">A construct that exposes one or more endpoints, with each endpoint exposing one or more service operations.</span></span>

<span data-ttu-id="6cc90-142">**终结点**</span><span class="sxs-lookup"><span data-stu-id="6cc90-142">**Endpoint**</span></span>  
 <span data-ttu-id="6cc90-143">终结点是用来发送或接收消息（或同时执行这两种操作）的构造。</span><span class="sxs-lookup"><span data-stu-id="6cc90-143">A construct at which messages are sent or received (or both).</span></span> <span data-ttu-id="6cc90-144">包含该定义，可以将消息发送，介绍如何应发送消息，通信机制 （绑定） 的规范的位置 （地址） 和一组可以发送或接收的消息的定义 （或两者）描述可以发送哪些消息的位置 （服务协定）。</span><span class="sxs-lookup"><span data-stu-id="6cc90-144">It comprises a location (an address) that defines where messages can be sent, a specification of the communication mechanism (a binding) that describes how messages should be sent, and a definition for a set of messages that can be sent or received (or both) at that location (a service contract) that describes what message can be sent.</span></span>

<span data-ttu-id="6cc90-145">WCF 服务作为终结点集合向外界公开。</span><span class="sxs-lookup"><span data-stu-id="6cc90-145">A WCF service is exposed to the world as a collection of endpoints.</span></span>

<span data-ttu-id="6cc90-146">**应用程序终结点**</span><span class="sxs-lookup"><span data-stu-id="6cc90-146">**Application endpoint**</span></span>  
 <span data-ttu-id="6cc90-147">一个终结点，由应用程序公开并对应于该应用程序实现的服务协定。</span><span class="sxs-lookup"><span data-stu-id="6cc90-147">An endpoint exposed by the application and that corresponds to a service contract implemented by the application.</span></span>

<span data-ttu-id="6cc90-148">**基础结构终结点**</span><span class="sxs-lookup"><span data-stu-id="6cc90-148">**Infrastructure endpoint**</span></span>  
 <span data-ttu-id="6cc90-149">一个终结点，由基础结构公开，以便实现与服务协定无关的服务需要或提供的功能。</span><span class="sxs-lookup"><span data-stu-id="6cc90-149">An endpoint that is exposed by the infrastructure to facilitate functionality that is needed or provided by the service that does not relate to a service contract.</span></span> <span data-ttu-id="6cc90-150">例如，服务可能拥有一个提供元数据信息的基础结构终结点。</span><span class="sxs-lookup"><span data-stu-id="6cc90-150">For example, a service might have an infrastructure endpoint that provides metadata information.</span></span>

<span data-ttu-id="6cc90-151">**地址**</span><span class="sxs-lookup"><span data-stu-id="6cc90-151">**Address**</span></span>  
 <span data-ttu-id="6cc90-152">地址用于指定接收消息的位置。</span><span class="sxs-lookup"><span data-stu-id="6cc90-152">Specifies the location where messages are received.</span></span> <span data-ttu-id="6cc90-153">地址以统一资源标识符 (URI) 的形式指定。</span><span class="sxs-lookup"><span data-stu-id="6cc90-153">It is specified as a Uniform Resource Identifier (URI).</span></span> <span data-ttu-id="6cc90-154">URI 架构部分指定用于到达地址的传输机制，如 HTTP 和 TCP。</span><span class="sxs-lookup"><span data-stu-id="6cc90-154">The URI schema part names the transport mechanism to use to reach the address, such as HTTP and TCP.</span></span> <span data-ttu-id="6cc90-155">URI 的层次结构部分包含一个唯一的位置，其格式取决于传输机制。</span><span class="sxs-lookup"><span data-stu-id="6cc90-155">The hierarchical part of the URI contains a unique location whose format is dependent on the transport mechanism.</span></span>

<span data-ttu-id="6cc90-156">使用终结点地址可以为服务中的每个终结点创建唯一的终结点地址，或者在某些条件下在终结点之间共享一个地址。</span><span class="sxs-lookup"><span data-stu-id="6cc90-156">The endpoint address enables you to create unique endpoint addresses for each endpoint in a service or, under certain conditions, to share an address across endpoints.</span></span> <span data-ttu-id="6cc90-157">下面的示例演示了一个将 HTTPS 协议和一个非默认端口结合使用的地址：</span><span class="sxs-lookup"><span data-stu-id="6cc90-157">The following example shows an address using the HTTPS protocol with a non-default port:</span></span>

```
HTTPS://cohowinery:8005/ServiceModelSamples/CalculatorService
```

<span data-ttu-id="6cc90-158">**绑定**</span><span class="sxs-lookup"><span data-stu-id="6cc90-158">**Binding**</span></span>  
 <span data-ttu-id="6cc90-159">绑定定义终结点与外界进行通信的方式。</span><span class="sxs-lookup"><span data-stu-id="6cc90-159">Defines how an endpoint communicates to the world.</span></span> <span data-ttu-id="6cc90-160">它由一组称为绑定元素的要素构造而成，这些元素“堆叠”在一起以形成通信基础结构。</span><span class="sxs-lookup"><span data-stu-id="6cc90-160">It is constructed of a set of components called binding elements that "stack" one on top of the other to create the communication infrastructure.</span></span> <span data-ttu-id="6cc90-161">绑定最起码应定义传输协议（如 HTTP 或 TCP）和所使用的编码（如文本或二进制）。</span><span class="sxs-lookup"><span data-stu-id="6cc90-161">At the very least, a binding defines the transport (such as HTTP or TCP) and the encoding being used (such as text or binary).</span></span> <span data-ttu-id="6cc90-162">绑定可以包含指定详细信息（例如，用于保护消息的安全机制或终结点所使用的消息模式）的绑定元素。</span><span class="sxs-lookup"><span data-stu-id="6cc90-162">A binding can contain binding elements that specify details like the security mechanisms used to secure messages, or the message pattern used by an endpoint.</span></span> <span data-ttu-id="6cc90-163">有关详细信息，请参阅[配置服务](../../../docs/framework/wcf/configuring-services.md)。</span><span class="sxs-lookup"><span data-stu-id="6cc90-163">For more information, see [Configuring Services](../../../docs/framework/wcf/configuring-services.md).</span></span>

<span data-ttu-id="6cc90-164">**绑定元素**</span><span class="sxs-lookup"><span data-stu-id="6cc90-164">**Binding element**</span></span>  
 <span data-ttu-id="6cc90-165">绑定元素表示绑定的特定部分，如传输协议、编码、基础结构级协议（如 WS-ReliableMessaging）的实现以及通信堆栈的其他任何要素。</span><span class="sxs-lookup"><span data-stu-id="6cc90-165">Represents a particular piece of the binding, such as a transport, an encoding, an implementation of an infrastructure-level protocol (such as WS-ReliableMessaging), or any other component of the communication stack.</span></span>

<span data-ttu-id="6cc90-166">**行为**</span><span class="sxs-lookup"><span data-stu-id="6cc90-166">**Behaviors**</span></span>  
 <span data-ttu-id="6cc90-167">行为是控制服务、终结点、特定操作或客户端的各个运行时方面的要素。</span><span class="sxs-lookup"><span data-stu-id="6cc90-167">A component that controls various run-time aspects of a service, an endpoint, a particular operation, or a client.</span></span> <span data-ttu-id="6cc90-168">行为按照范围进行分组：常见行为在全局范围内影响所有终结点，服务行为仅影响与服务相关的方面，终结点行为仅影响与终结点相关的属性，操作级行为影响特定操作。</span><span class="sxs-lookup"><span data-stu-id="6cc90-168">Behaviors are grouped according to scope: common behaviors affect all endpoints globally, service behaviors affect only service-related aspects, endpoint behaviors affect only endpoint-related properties, and operation-level behaviors affect particular operations.</span></span> <span data-ttu-id="6cc90-169">例如，有一种服务行为是遏制，它指定当过多的消息可能超出服务的处理能力时，服务应该如何反应。</span><span class="sxs-lookup"><span data-stu-id="6cc90-169">For example, one service behavior is throttling, which specifies how a service reacts when an excess of messages threaten to overwhelm its handling capabilities.</span></span> <span data-ttu-id="6cc90-170">另一方面，终结点行为仅控制与终结点相关的方面，如查找安全凭据的方式和位置。</span><span class="sxs-lookup"><span data-stu-id="6cc90-170">An endpoint behavior, on the other hand, controls only aspects that are relevant to endpoints, such as how and where to find a security credential.</span></span>

<span data-ttu-id="6cc90-171">**系统提供的绑定**</span><span class="sxs-lookup"><span data-stu-id="6cc90-171">**System-provided bindings**</span></span>  
 <span data-ttu-id="6cc90-172">WCF 包含许多系统提供的绑定。</span><span class="sxs-lookup"><span data-stu-id="6cc90-172">WCF includes a number of system-provided bindings.</span></span> <span data-ttu-id="6cc90-173">这些绑定是针对特定方案进行优化的绑定元素的集合。</span><span class="sxs-lookup"><span data-stu-id="6cc90-173">These are collections of binding elements that are optimized for specific scenarios.</span></span> <span data-ttu-id="6cc90-174">例如，<xref:System.ServiceModel.WSHttpBinding>专为与实现各种 WS-服务互操作性\*规范。</span><span class="sxs-lookup"><span data-stu-id="6cc90-174">For example, the <xref:System.ServiceModel.WSHttpBinding> is designed for interoperability with services that implement various WS-\* specifications.</span></span> <span data-ttu-id="6cc90-175">通过仅提供那些可以正确应用于特定方案的选项，这些预定义的绑定可以节省时间。</span><span class="sxs-lookup"><span data-stu-id="6cc90-175">These predefined bindings save time by presenting only those options that can be correctly applied to the specific scenario.</span></span> <span data-ttu-id="6cc90-176">如果预定义的绑定不能满足你的需求，则可以创建你自己的自定义绑定。</span><span class="sxs-lookup"><span data-stu-id="6cc90-176">If a predefined binding does not meet your requirements, you can create your own custom binding.</span></span>

<span data-ttu-id="6cc90-177">**配置与编码**</span><span class="sxs-lookup"><span data-stu-id="6cc90-177">**Configuration versus coding**</span></span>  
 <span data-ttu-id="6cc90-178">可以通过代码编写、配置或将两者结合在一起对应用程序进行控制。</span><span class="sxs-lookup"><span data-stu-id="6cc90-178">Control of an application can be done either through coding, through configuration, or through a combination of both.</span></span> <span data-ttu-id="6cc90-179">配置的优点在于，它使非开发人员（如网络管理员）可以在代码编写完成后直接对客户端和服务参数进行设置，而不必重新进行编译。</span><span class="sxs-lookup"><span data-stu-id="6cc90-179">Configuration has the advantage of allowing someone other than the developer (for example, a network administrator) to set client and service parameters after the code is written and without having to recompile.</span></span> <span data-ttu-id="6cc90-180">使用配置不仅可以设置值（如终结点地址），还可以通过添加终结点、绑定和行为来实施进一步的控制。</span><span class="sxs-lookup"><span data-stu-id="6cc90-180">Configuration not only enables you to set values like endpoint addresses, but also allows further control by enabling you to add endpoints, bindings, and behaviors.</span></span> <span data-ttu-id="6cc90-181">通过代码编写，开发人员可以保持对服务或客户端的所有组件的严格控制，而且可以对通过配置完成的所有设置进行检查，并根据需要通过代码进行重写。</span><span class="sxs-lookup"><span data-stu-id="6cc90-181">Coding allows the developer to retain strict control over all components of the service or client, and any settings done through the configuration can be inspected and if needed overridden by the code.</span></span>

<span data-ttu-id="6cc90-182">**服务操作**</span><span class="sxs-lookup"><span data-stu-id="6cc90-182">**Service operation**</span></span>  
 <span data-ttu-id="6cc90-183">服务操作是在服务的代码中定义的过程，用于实现某种操作的功能。</span><span class="sxs-lookup"><span data-stu-id="6cc90-183">A procedure defined in a service's code that implements the functionality for an operation.</span></span> <span data-ttu-id="6cc90-184">此操作作为 WCF 客户端上的方法向客户端公开。</span><span class="sxs-lookup"><span data-stu-id="6cc90-184">This operation is exposed to clients as methods on a WCF client.</span></span> <span data-ttu-id="6cc90-185">该方法可以返回一个值，并可采用数量可选的自变量，或是不采用任何自变量且不返回任何响应。</span><span class="sxs-lookup"><span data-stu-id="6cc90-185">The method can return a value, and can take an optional number of arguments, or take no arguments, and return no response.</span></span> <span data-ttu-id="6cc90-186">例如，一个实现简单的“Hello”的操作可以用作客户端存在通知，并可以开始一系列操作。</span><span class="sxs-lookup"><span data-stu-id="6cc90-186">For example, an operation that functions as a simple "Hello" can be used as a notification of a client's presence and to begin a series of operations.</span></span>

<span data-ttu-id="6cc90-187">**服务协定**</span><span class="sxs-lookup"><span data-stu-id="6cc90-187">**Service contract**</span></span>  
 <span data-ttu-id="6cc90-188">服务协定将多个相关的操作联系在一起，组成单个功能单元。</span><span class="sxs-lookup"><span data-stu-id="6cc90-188">Ties together multiple related operations into a single functional unit.</span></span> <span data-ttu-id="6cc90-189">协定可以定义服务级设置，如服务的命名空间、对应的回调协定以及其他此类设置。</span><span class="sxs-lookup"><span data-stu-id="6cc90-189">The contract can define service-level settings, such as the namespace of the service, a corresponding callback contract, and other such settings.</span></span> <span data-ttu-id="6cc90-190">在大多数情况下，协定的定义方法是用所选的编程语言创建一个接口，然后将 <xref:System.ServiceModel.ServiceContractAttribute> 属性应用于该接口。</span><span class="sxs-lookup"><span data-stu-id="6cc90-190">In most cases, the contract is defined by creating an interface in the programming language of your choice and applying the <xref:System.ServiceModel.ServiceContractAttribute> attribute to the interface.</span></span> <span data-ttu-id="6cc90-191">通过实现该接口，可生成实际的服务代码。</span><span class="sxs-lookup"><span data-stu-id="6cc90-191">The actual service code results by implementing the interface.</span></span>

<span data-ttu-id="6cc90-192">**操作协定**</span><span class="sxs-lookup"><span data-stu-id="6cc90-192">**Operation contract**</span></span>  
 <span data-ttu-id="6cc90-193">操作协定定义参数和操作的返回类型。</span><span class="sxs-lookup"><span data-stu-id="6cc90-193">An operation contract defines the parameters and return type of an operation.</span></span> <span data-ttu-id="6cc90-194">在创建定义服务协定的接口时，可以通过将 <xref:System.ServiceModel.OperationContractAttribute> 属性应用于协定中包含的每个方法定义来表示一个操作协定。</span><span class="sxs-lookup"><span data-stu-id="6cc90-194">When creating an interface that defines the service contract, you signify an operation contract by applying the <xref:System.ServiceModel.OperationContractAttribute> attribute to each method definition that is part of the contract.</span></span> <span data-ttu-id="6cc90-195">可以将操作建模为采用单个消息作为参数并返回单个消息，或者建模为采用一组类型作为参数并返回一个类型。</span><span class="sxs-lookup"><span data-stu-id="6cc90-195">The operations can be modeled as taking a single message and returning a single message, or as taking a set of types and returning a type.</span></span> <span data-ttu-id="6cc90-196">在后一种情况下，系统将确定需要为该操作交换的消息的格式。</span><span class="sxs-lookup"><span data-stu-id="6cc90-196">In the latter case, the system will determine the format for the messages that need to be exchanged for that operation.</span></span>

<span data-ttu-id="6cc90-197">**消息协定**</span><span class="sxs-lookup"><span data-stu-id="6cc90-197">**Message contract**</span></span>  
 <span data-ttu-id="6cc90-198">消息协定描述消息的格式。</span><span class="sxs-lookup"><span data-stu-id="6cc90-198">Describes the format of a message.</span></span> <span data-ttu-id="6cc90-199">例如，它会声明消息元素应包含在消息头中还是包含在消息正文中，应该对消息的何种元素应用何种级别的安全性，等等。</span><span class="sxs-lookup"><span data-stu-id="6cc90-199">For example, it declares whether message elements should go in headers versus the body, what level of security should be applied to what elements of the message, and so on.</span></span>

<span data-ttu-id="6cc90-200">**错误协定**</span><span class="sxs-lookup"><span data-stu-id="6cc90-200">**Fault contract**</span></span>  
 <span data-ttu-id="6cc90-201">可以将错误协定与服务操作进行关联，以指示可能返回到调用方的错误。</span><span class="sxs-lookup"><span data-stu-id="6cc90-201">Can be associated with a service operation to denote errors that can be returned to the caller.</span></span> <span data-ttu-id="6cc90-202">一个操作可以具有零个或更多个与其相关联的错误。</span><span class="sxs-lookup"><span data-stu-id="6cc90-202">An operation can have zero or more faults associated with it.</span></span> <span data-ttu-id="6cc90-203">这些错误是在编程模型中作为异常建模的 SOAP 错误。</span><span class="sxs-lookup"><span data-stu-id="6cc90-203">These errors are SOAP faults that are modeled as exceptions in the programming model.</span></span>

<span data-ttu-id="6cc90-204">**数据协定**</span><span class="sxs-lookup"><span data-stu-id="6cc90-204">**Data contract**</span></span>  
 <span data-ttu-id="6cc90-205">服务使用的数据类型必须在元数据中进行描述，</span><span class="sxs-lookup"><span data-stu-id="6cc90-205">The descriptions in metadata of the data types that a service uses.</span></span> <span data-ttu-id="6cc90-206">以使其他各方可以与该服务进行交互操作。</span><span class="sxs-lookup"><span data-stu-id="6cc90-206">This enables others to interoperate with the service.</span></span> <span data-ttu-id="6cc90-207">数据类型可以在消息的任何部分使用（例如，作为参数或返回类型）。</span><span class="sxs-lookup"><span data-stu-id="6cc90-207">The data types can be used in any part of a message, for example, as parameters or return types.</span></span> <span data-ttu-id="6cc90-208">如果服务仅使用简单类型，则无需显式使用数据协定。</span><span class="sxs-lookup"><span data-stu-id="6cc90-208">If the service is using only simple types, there is no need to explicitly use data contracts.</span></span>

<span data-ttu-id="6cc90-209">**承载**</span><span class="sxs-lookup"><span data-stu-id="6cc90-209">**Hosting**</span></span>  
 <span data-ttu-id="6cc90-210">服务必须承载于某个进程中。</span><span class="sxs-lookup"><span data-stu-id="6cc90-210">A service must be hosted in some process.</span></span> <span data-ttu-id="6cc90-211">一个_主机_是控制服务的生存期的应用程序。</span><span class="sxs-lookup"><span data-stu-id="6cc90-211">A _host_ is an application that controls the lifetime of the service.</span></span> <span data-ttu-id="6cc90-212">服务可以是自承载的，也可以由现有的宿主进程进行管理。</span><span class="sxs-lookup"><span data-stu-id="6cc90-212">Services can be self-hosted or managed by an existing hosting process.</span></span>

<span data-ttu-id="6cc90-213">**自承载的服务**</span><span class="sxs-lookup"><span data-stu-id="6cc90-213">**Self-hosted service**</span></span>  
 <span data-ttu-id="6cc90-214">自承载服务是在开发人员创建的进程应用程序中运行的服务。</span><span class="sxs-lookup"><span data-stu-id="6cc90-214">A service that runs within a process application that the developer created.</span></span> <span data-ttu-id="6cc90-215">开发人员控制服务的生存期、设置服务的属性、打开服务（这会将服务设置为侦听模式）以及关闭服务。</span><span class="sxs-lookup"><span data-stu-id="6cc90-215">The developer controls its lifetime, sets the properties of the service, opens the service (which sets it into a listening mode), and closes the service.</span></span>

<span data-ttu-id="6cc90-216">**承载进程**</span><span class="sxs-lookup"><span data-stu-id="6cc90-216">**Hosting process**</span></span>  
 <span data-ttu-id="6cc90-217">托管进程是专为承载服务而设计的应用程序。</span><span class="sxs-lookup"><span data-stu-id="6cc90-217">An application that is designed to host services.</span></span> <span data-ttu-id="6cc90-218">这些宿主进程包括 Internet 信息服务 (IIS)、Windows 激活服务 (WAS) 和 Windows 服务。</span><span class="sxs-lookup"><span data-stu-id="6cc90-218">These include Internet Information Services (IIS), Windows Activation Services (WAS), and Windows Services.</span></span> <span data-ttu-id="6cc90-219">在这些宿主方案中，由宿主控制服务的生存期。</span><span class="sxs-lookup"><span data-stu-id="6cc90-219">In these hosted scenarios, the host controls the lifetime of the service.</span></span> <span data-ttu-id="6cc90-220">例如，使用 IIS 可以设置包含服务程序集和配置文件的虚拟目录。</span><span class="sxs-lookup"><span data-stu-id="6cc90-220">For example, using IIS you can set up a virtual directory that contains the service assembly and configuration file.</span></span> <span data-ttu-id="6cc90-221">在收到消息时，IIS 将启动服务并控制服务的生存期。</span><span class="sxs-lookup"><span data-stu-id="6cc90-221">When a message is received, IIS starts the service and controls its lifetime.</span></span>

<span data-ttu-id="6cc90-222">**实例化**</span><span class="sxs-lookup"><span data-stu-id="6cc90-222">**Instancing**</span></span>  
 <span data-ttu-id="6cc90-223">每个服务都具有一个实例化模型。</span><span class="sxs-lookup"><span data-stu-id="6cc90-223">A service has an instancing model.</span></span> <span data-ttu-id="6cc90-224">有三种实例化模型：“单个”，在这种模型中，由单个 CLR 对象为所有客户端提供服务；“每个调用”，在这种模型中，将创建一个新的 CLR 对象来处理每个客户端调用；“每个会话”，在这种模型中，将创建一组 CLR 对象，并且为每个独立的会话使用一个对象。</span><span class="sxs-lookup"><span data-stu-id="6cc90-224">There are three instancing models: "single," in which a single CLR object services all the clients; "per call," in which a new CLR object is created to handle each client call; and "per session," in which a set of CLR objects is created, one for each separate session.</span></span> <span data-ttu-id="6cc90-225">实例化模型的选择取决于应用程序需求和服务的预期使用模式。</span><span class="sxs-lookup"><span data-stu-id="6cc90-225">The choice of an instancing model depends on the application requirements and the expected usage pattern of the service.</span></span>

<span data-ttu-id="6cc90-226">**客户端应用程序**</span><span class="sxs-lookup"><span data-stu-id="6cc90-226">**Client application**</span></span>  
 <span data-ttu-id="6cc90-227">客户端应用程序是与一个或多个终结点交换消息的程序。</span><span class="sxs-lookup"><span data-stu-id="6cc90-227">A program that exchanges messages with one or more endpoints.</span></span> <span data-ttu-id="6cc90-228">客户端应用程序可通过创建 WCF 客户端的实例和调用该 WCF 客户端的方法来启动。</span><span class="sxs-lookup"><span data-stu-id="6cc90-228">The client application begins by creating an instance of a WCF client and calling methods of the WCF client.</span></span> <span data-ttu-id="6cc90-229">需要注意的是，单个应用程序既可以充当客户端，也可以充当服务。</span><span class="sxs-lookup"><span data-stu-id="6cc90-229">It is important to note that a single application can be both a client and a service.</span></span>

<span data-ttu-id="6cc90-230">**频道**</span><span class="sxs-lookup"><span data-stu-id="6cc90-230">**Channel**</span></span>  
 <span data-ttu-id="6cc90-231">通道是绑定元素的具体实现。</span><span class="sxs-lookup"><span data-stu-id="6cc90-231">A concrete implementation of a binding element.</span></span> <span data-ttu-id="6cc90-232">绑定表示配置，而通道是与该配置相关联的实现。</span><span class="sxs-lookup"><span data-stu-id="6cc90-232">The binding represents the configuration, and the channel is the implementation associated with that configuration.</span></span> <span data-ttu-id="6cc90-233">因此，每个绑定元素都有一个相关联的通道。</span><span class="sxs-lookup"><span data-stu-id="6cc90-233">Therefore, there is a channel associated with each binding element.</span></span> <span data-ttu-id="6cc90-234">通道堆叠在一起以形成绑定的具体实现：通道堆栈。</span><span class="sxs-lookup"><span data-stu-id="6cc90-234">Channels stack on top of each other to create the concrete implementation of the binding: the channel stack.</span></span>

<span data-ttu-id="6cc90-235">**WCF 客户端**</span><span class="sxs-lookup"><span data-stu-id="6cc90-235">**WCF client**</span></span>  
 <span data-ttu-id="6cc90-236">服务操作作为方法公开的客户端应用程序构造 (如 Visual Basic 或 Visual 你选择的编程语言在.NET Framework 中C#)。</span><span class="sxs-lookup"><span data-stu-id="6cc90-236">A client-application construct that exposes the service operations as methods (in the .NET Framework programming language of your choice, such as Visual Basic or Visual C#).</span></span> <span data-ttu-id="6cc90-237">任何应用程序都可以承载 WCF 客户端，包括承载服务的应用程序。</span><span class="sxs-lookup"><span data-stu-id="6cc90-237">Any application can host a WCF client, including an application that hosts a service.</span></span> <span data-ttu-id="6cc90-238">因此，可以创建一个包含其他服务的 WCF 客户端的服务。</span><span class="sxs-lookup"><span data-stu-id="6cc90-238">Therefore, it is possible to create a service that includes WCF clients of other services.</span></span>

<span data-ttu-id="6cc90-239">可以通过使用自动生成 WCF 客户端[ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)并指向正在运行的服务发布的元数据。</span><span class="sxs-lookup"><span data-stu-id="6cc90-239">A WCF client can be automatically generated by using the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) and pointing it at a running service that publishes metadata.</span></span>

<span data-ttu-id="6cc90-240">**元数据**</span><span class="sxs-lookup"><span data-stu-id="6cc90-240">**Metadata**</span></span>  
 <span data-ttu-id="6cc90-241">服务的元数据描述服务的各种特征，外部实体需要了解这些特征以便与该服务进行通信。</span><span class="sxs-lookup"><span data-stu-id="6cc90-241">In a service, describes the characteristics of the service that an external entity needs to understand to communicate with the service.</span></span> <span data-ttu-id="6cc90-242">元数据可供[ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)生成 WCF 客户端和客户端应用程序可用于与服务交互的伴随配置。</span><span class="sxs-lookup"><span data-stu-id="6cc90-242">Metadata can be consumed by the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) to generate a WCF client and accompanying configuration that a client application can use to interact with the service.</span></span>

<span data-ttu-id="6cc90-243">服务所公开的元数据包括 XML 架构文档（用于定义服务的数据协定）和 WSDL 文档（用于描述服务的方法）。</span><span class="sxs-lookup"><span data-stu-id="6cc90-243">The metadata exposed by the service includes XML schema documents, which define the data contract of the service, and WSDL documents, which describe the methods of the service.</span></span>

<span data-ttu-id="6cc90-244">启用元数据后，WCF 可通过检查服务及其终结点来自动生成服务的元数据。</span><span class="sxs-lookup"><span data-stu-id="6cc90-244">When enabled, metadata for the service is automatically generated by WCF by inspecting the service and its endpoints.</span></span> <span data-ttu-id="6cc90-245">若要发布服务的元数据，必须显式启用元数据行为。</span><span class="sxs-lookup"><span data-stu-id="6cc90-245">To publish metadata from a service, you must explicitly enable the metadata behavior.</span></span>

<span data-ttu-id="6cc90-246">**安全性**</span><span class="sxs-lookup"><span data-stu-id="6cc90-246">**Security**</span></span>  
 <span data-ttu-id="6cc90-247">在 WCF 中，包括保密性 （加密的消息，以防止窃听）、 完整性 （用于检测消息篡改行为的方法）、 身份验证 （用于验证服务器和客户端方法） 和授权 （控制的访问权限资源）。</span><span class="sxs-lookup"><span data-stu-id="6cc90-247">In WCF, includes confidentiality (encryption of messages to prevent eavesdropping), integrity (the means for detection of tampering with the message), authentication (the means for validation of servers and clients), and authorization (the control of access to resources).</span></span> <span data-ttu-id="6cc90-248">提供这些功能通过任一利用现有安全机制，如 TLS over HTTP (也称为 HTTPS)，或通过实现一个或多个各种 WS-\*安全规范。</span><span class="sxs-lookup"><span data-stu-id="6cc90-248">These functions are provided by either leveraging existing security mechanisms, such as TLS over HTTP (also known as HTTPS), or by implementing one or more of the various WS-\* security specifications.</span></span>

<span data-ttu-id="6cc90-249">**传输安全模式**</span><span class="sxs-lookup"><span data-stu-id="6cc90-249">**Transport security mode**</span></span>  
 <span data-ttu-id="6cc90-250">传输安全模式指定由传输层机制（如 HTTPS）提供保密性、完整性和身份验证。</span><span class="sxs-lookup"><span data-stu-id="6cc90-250">Specifies that confidentiality, integrity, and authentication are provided by the transport layer mechanisms (such as HTTPS).</span></span> <span data-ttu-id="6cc90-251">在使用像 HTTPS 这样的传输协议时，此模式的优点在于性能出色，而且由于它在 Internet 上非常流行，因此很容易理解。</span><span class="sxs-lookup"><span data-stu-id="6cc90-251">When using a transport like HTTPS, this mode has the advantage of being efficient in its performance, and well understood because of its prevalence on the Internet.</span></span> <span data-ttu-id="6cc90-252">其缺点在于，这种安全分别应用于通信路径中的每个跃点，这使得通信容易遭受“中间人”攻击。</span><span class="sxs-lookup"><span data-stu-id="6cc90-252">The disadvantage is that this kind of security is applied separately on each hop in the communication path, making the communication susceptible to a "man in the middle" attack.</span></span>

<span data-ttu-id="6cc90-253">**消息安全模式**</span><span class="sxs-lookup"><span data-stu-id="6cc90-253">**Message security mode**</span></span>  
 <span data-ttu-id="6cc90-254">指定安全提供通过实现一个或多个安全规范，如规范名为[Web 服务安全：SOAP 消息安全](https://go.microsoft.com/fwlink/?LinkId=94684)。</span><span class="sxs-lookup"><span data-stu-id="6cc90-254">Specifies that security is provided by implementing one or more of the security specifications, such as the specification named [Web Services Security: SOAP Message Security](https://go.microsoft.com/fwlink/?LinkId=94684).</span></span> <span data-ttu-id="6cc90-255">每个消息都包含必要的安全机制，用于在消息传输过程中保证安全，并使接收方能够检测到篡改和对消息进行解密。</span><span class="sxs-lookup"><span data-stu-id="6cc90-255">Each message contains the necessary mechanisms to provide security during its transit, and to enable the receivers to detect tampering and to decrypt the messages.</span></span> <span data-ttu-id="6cc90-256">从这种意义上说，安全信息包装在每个消息中，从而提供了跨多个跃点的端到端安全。</span><span class="sxs-lookup"><span data-stu-id="6cc90-256">In this sense, the security is encapsulated within every message, providing end-to-end security across multiple hops.</span></span> <span data-ttu-id="6cc90-257">由于安全信息成为消息的一部分，还有可能包含多种凭据并显示消息 (这些称为_声明_)。</span><span class="sxs-lookup"><span data-stu-id="6cc90-257">Because security information becomes part of the message, it is also possible to include multiple kinds of credentials with the message (these are referred to as _claims_).</span></span> <span data-ttu-id="6cc90-258">这种方法还具有这样一个优点，即消息可以通过任意传输协议（包括在其起点和目标之间的多个传输协议）安全地传送。</span><span class="sxs-lookup"><span data-stu-id="6cc90-258">This approach also has the advantage of enabling the message to travel securely over any transport, including multiple transports between its origin and destination.</span></span> <span data-ttu-id="6cc90-259">这种方法的缺点在于所使用的加密机制较为复杂，使性能受到影响。</span><span class="sxs-lookup"><span data-stu-id="6cc90-259">The disadvantage of this approach is the complexity of the cryptographic mechanisms employed, resulting in performance implications.</span></span>

<span data-ttu-id="6cc90-260">**带有消息凭据安全传输**</span><span class="sxs-lookup"><span data-stu-id="6cc90-260">**Transport with message credential security mode**</span></span>  
 <span data-ttu-id="6cc90-261">此模式指定使用传输层来提供消息的保密性、身份验证和完整性，并且每个消息都可以包含消息接收方所要求的多个凭据（声明）。</span><span class="sxs-lookup"><span data-stu-id="6cc90-261">Specifies the use of the transport layer to provide confidentiality, authentication, and integrity of the messages, while each of the messages can contain multiple credentials (claims) required by the receivers of the message.</span></span>

<span data-ttu-id="6cc90-262">**WS-\***</span><span class="sxs-lookup"><span data-stu-id="6cc90-262">**WS-\***</span></span>  
 <span data-ttu-id="6cc90-263">一组不断增加的、在 WCF 中实现的 Web 服务 (WS) 规范（如 WS-Security、WS-ReliableMessaging 等）的简写。</span><span class="sxs-lookup"><span data-stu-id="6cc90-263">Shorthand for the growing set of Web Service (WS) specifications, such as WS-Security, WS-ReliableMessaging, and so on, that are implemented in WCF.</span></span>

## <a name="see-also"></a><span data-ttu-id="6cc90-264">请参阅</span><span class="sxs-lookup"><span data-stu-id="6cc90-264">See also</span></span>

- [<span data-ttu-id="6cc90-265">什么是 Windows Communication Foundation</span><span class="sxs-lookup"><span data-stu-id="6cc90-265">What Is Windows Communication Foundation</span></span>](../../../docs/framework/wcf/whats-wcf.md)
- [<span data-ttu-id="6cc90-266">Windows Communication Foundation 体系结构</span><span class="sxs-lookup"><span data-stu-id="6cc90-266">Windows Communication Foundation Architecture</span></span>](../../../docs/framework/wcf/architecture.md)
