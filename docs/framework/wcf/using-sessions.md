---
title: 使用会话
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- sessions [WCF]
ms.assetid: 864ba12f-3331-4359-a359-6d6d387f1035
ms.openlocfilehash: fc7b86f3f2c2c6276681c324dbe9a390fdfdafd4
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/23/2019
ms.locfileid: "61791451"
---
# <a name="using-sessions"></a><span data-ttu-id="2b203-102">使用会话</span><span class="sxs-lookup"><span data-stu-id="2b203-102">Using Sessions</span></span>
<span data-ttu-id="2b203-103">在 Windows Communication Foundation (WCF) 应用程序中*会话*将一组消息关联起来形成对话。</span><span class="sxs-lookup"><span data-stu-id="2b203-103">In Windows Communication Foundation (WCF) applications, a *session* correlates a group of messages into a conversation.</span></span> <span data-ttu-id="2b203-104">WCF 会话是中提供的会话对象不同[!INCLUDE[vstecasp](../../../includes/vstecasp-md.md)]应用程序，支持不同的行为，并且以不同的方式进行控制。</span><span class="sxs-lookup"><span data-stu-id="2b203-104">WCF sessions are different than the session object available in [!INCLUDE[vstecasp](../../../includes/vstecasp-md.md)] applications, support different behaviors, and are controlled in different ways.</span></span> <span data-ttu-id="2b203-105">本主题介绍在 WCF 中的会话启用的功能的应用程序以及如何使用它们。</span><span class="sxs-lookup"><span data-stu-id="2b203-105">This topic describes the features that sessions enable in WCF applications and how to use them.</span></span>  
  
## <a name="sessions-in-windows-communication-foundation-applications"></a><span data-ttu-id="2b203-106">Windows Communication Foundation 应用程序中的会话</span><span class="sxs-lookup"><span data-stu-id="2b203-106">Sessions in Windows Communication Foundation Applications</span></span>  
 <span data-ttu-id="2b203-107">当某个服务协定指定它需要会话时，该协定会指定所有调用（即，支持调用的基础消息交换）必须是同一对话的一部分。</span><span class="sxs-lookup"><span data-stu-id="2b203-107">When a service contract specifies that it requires a session, that contract is specifying that all calls (that is, the underlying message exchanges that support the calls) must be part of the same conversation.</span></span> <span data-ttu-id="2b203-108">如果某个协定指定它允许使用会话但不要求使用会话，则客户端可以进行连接，并选择建立会话或不建立会话。</span><span class="sxs-lookup"><span data-stu-id="2b203-108">If a contract specifies that it allows sessions but does not require one, clients can connect and either establish a session or not establish a session.</span></span> <span data-ttu-id="2b203-109">如果会话结束，然后在同一个通道上发送消息，将会引发异常。</span><span class="sxs-lookup"><span data-stu-id="2b203-109">If the session ends and a message is sent through the same channel an exception is thrown.</span></span>  
  
 <span data-ttu-id="2b203-110">WCF 会话具有下列主要概念性功能：</span><span class="sxs-lookup"><span data-stu-id="2b203-110">WCF sessions have the following main conceptual features:</span></span>  
  
- <span data-ttu-id="2b203-111">它们由调用应用程序（WCF 客户端）显式启动和终止。</span><span class="sxs-lookup"><span data-stu-id="2b203-111">They are explicitly initiated and terminated by the calling application (the WCF client).</span></span>  
  
- <span data-ttu-id="2b203-112">会话期间传递的消息按照接收消息的顺序进行处理。</span><span class="sxs-lookup"><span data-stu-id="2b203-112">Messages delivered during a session are processed in the order in which they are received.</span></span>  
  
- <span data-ttu-id="2b203-113">会话将一组消息相互关联，从而形成对话。</span><span class="sxs-lookup"><span data-stu-id="2b203-113">Sessions correlate a group of messages into a conversation.</span></span> <span data-ttu-id="2b203-114">可以有不同类型的关联。</span><span class="sxs-lookup"><span data-stu-id="2b203-114">Different types of correlation are possible.</span></span> <span data-ttu-id="2b203-115">例如，一个基于会话的通道可能会根据共享网络连接来关联消息，而另一个基于会话的通道可能会根据消息正文中的共享标记来关联消息。</span><span class="sxs-lookup"><span data-stu-id="2b203-115">For instance, one session-based channel may correlate messages based on a shared network connection while another session-based channel may correlate messages based on a shared tag in the message body.</span></span> <span data-ttu-id="2b203-116">可以从会话派生的功能取决于关联的性质。</span><span class="sxs-lookup"><span data-stu-id="2b203-116">The features that can be derived from the session depend on the nature of the correlation.</span></span>  
  
- <span data-ttu-id="2b203-117">没有与 WCF 会话相关联的常规数据存储。</span><span class="sxs-lookup"><span data-stu-id="2b203-117">There is no general data store associated with a WCF session.</span></span>  
  
 <span data-ttu-id="2b203-118">如果你熟悉<xref:System.Web.SessionState.HttpSessionState?displayProperty=nameWithType>类中[!INCLUDE[vstecasp](../../../includes/vstecasp-md.md)]它提供应用程序和功能，您可能注意到该类型的会话和 WCF 会话之间的以下差异：</span><span class="sxs-lookup"><span data-stu-id="2b203-118">If you are familiar with the <xref:System.Web.SessionState.HttpSessionState?displayProperty=nameWithType> class in [!INCLUDE[vstecasp](../../../includes/vstecasp-md.md)] applications and the functionality it provides, you might notice the following differences between that kind of session and WCF sessions:</span></span>  
  
- [!INCLUDE[vstecasp](../../../includes/vstecasp-md.md)] <span data-ttu-id="2b203-119">会话总是由服务器启动。</span><span class="sxs-lookup"><span data-stu-id="2b203-119">sessions are always server-initiated.</span></span>  
  
- [!INCLUDE[vstecasp](../../../includes/vstecasp-md.md)] <span data-ttu-id="2b203-120">会话原本是无序的。</span><span class="sxs-lookup"><span data-stu-id="2b203-120">sessions are implicitly unordered.</span></span>  
  
- [!INCLUDE[vstecasp](../../../includes/vstecasp-md.md)] <span data-ttu-id="2b203-121">会话提供了一种跨请求的常规数据存储机制。</span><span class="sxs-lookup"><span data-stu-id="2b203-121">sessions provide a general data storage mechanism across requests.</span></span>  
  
 <span data-ttu-id="2b203-122">本主题描述：</span><span class="sxs-lookup"><span data-stu-id="2b203-122">This topic describes:</span></span>  
  
- <span data-ttu-id="2b203-123">在服务模型层中使用基于会话的绑定时的默认执行行为。</span><span class="sxs-lookup"><span data-stu-id="2b203-123">The default execution behavior when using session-based bindings in the service model layer.</span></span>  
  
- <span data-ttu-id="2b203-124">WCF 基于会话的、 由系统提供绑定提供的功能类型。</span><span class="sxs-lookup"><span data-stu-id="2b203-124">The types of features that the WCF session-based, system-provided bindings provide.</span></span>  
  
- <span data-ttu-id="2b203-125">如何创建声明会话要求的协定。</span><span class="sxs-lookup"><span data-stu-id="2b203-125">How to create a contract that declares a session requirement.</span></span>  
  
- <span data-ttu-id="2b203-126">如何了解和控制会话的创建和终止以及会话与服务实例的关系。</span><span class="sxs-lookup"><span data-stu-id="2b203-126">How to understand and control the creation and termination of the session and the relationship of the session to the service instance.</span></span>  
  
## <a name="default-execution-behavior-using-sessions"></a><span data-ttu-id="2b203-127">使用会话的默认执行行为</span><span class="sxs-lookup"><span data-stu-id="2b203-127">Default Execution Behavior Using Sessions</span></span>  
 <span data-ttu-id="2b203-128">尝试启动会话的绑定称为基于会话的  绑定。</span><span class="sxs-lookup"><span data-stu-id="2b203-128">A binding that attempts to initiate a session is called a *session-based* binding.</span></span> <span data-ttu-id="2b203-129">通过将服务协定接口（或类）上的 <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> 属性设置为 <xref:System.ServiceModel.SessionMode?displayProperty=nameWithType> 枚举值之一，服务协定指定它们要求、允许或拒绝基于会话的绑定。</span><span class="sxs-lookup"><span data-stu-id="2b203-129">Service contracts specify that they require, permit, or refuse session-based bindings by setting the <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> property on the service contract interface (or class) to one of the <xref:System.ServiceModel.SessionMode?displayProperty=nameWithType> enumeration values.</span></span> <span data-ttu-id="2b203-130">默认情况下，此属性的值是<xref:System.ServiceModel.SessionMode.Allowed>，这意味着，如果客户端与 WCF 服务实现使用基于会话的绑定，该服务将建立并使用提供的会话。</span><span class="sxs-lookup"><span data-stu-id="2b203-130">By default, the value of this property is <xref:System.ServiceModel.SessionMode.Allowed>, which means that if a client uses a session-based binding with a WCF service implementation, the service establishes and uses the session provided.</span></span>  
  
 <span data-ttu-id="2b203-131">在 WCF 服务接受客户端会话后，默认情况下启用以下功能：</span><span class="sxs-lookup"><span data-stu-id="2b203-131">When a WCF service accepts a client session, the following features are enabled by default:</span></span>  
  
1. <span data-ttu-id="2b203-132">WCF 客户端对象之间的所有调用都由同一个服务实例都处理。</span><span class="sxs-lookup"><span data-stu-id="2b203-132">All calls between a WCF client object are handled by the same service instance.</span></span>  
  
2. <span data-ttu-id="2b203-133">不同的基于会话的绑定还会提供其他功能。</span><span class="sxs-lookup"><span data-stu-id="2b203-133">Different session-based bindings provide additional features.</span></span>  
  
## <a name="system-provided-session-types"></a><span data-ttu-id="2b203-134">系统提供的会话类型</span><span class="sxs-lookup"><span data-stu-id="2b203-134">System-Provided Session Types</span></span>  
 <span data-ttu-id="2b203-135">基于会话的绑定支持服务实例与特定会话的默认关联。</span><span class="sxs-lookup"><span data-stu-id="2b203-135">A session-based binding supports the default association of a service instance with a particular session.</span></span> <span data-ttu-id="2b203-136">但是，除了启用前面介绍的基于会话的实例化控制之外，不同的基于会话的绑定还支持不同的功能。</span><span class="sxs-lookup"><span data-stu-id="2b203-136">However, different session-based bindings support different features in addition to enabling the session-based instancing control previously described.</span></span>  
  
 <span data-ttu-id="2b203-137">WCF 提供了以下类型的基于会话的应用程序的行为：</span><span class="sxs-lookup"><span data-stu-id="2b203-137">WCF provides the following types of session-based application behavior:</span></span>  
  
- <span data-ttu-id="2b203-138"><xref:System.ServiceModel.Channels.SecurityBindingElement?displayProperty=nameWithType> 支持基于安全的会话，其中，两个通信端采用统一的安全对话。</span><span class="sxs-lookup"><span data-stu-id="2b203-138">The <xref:System.ServiceModel.Channels.SecurityBindingElement?displayProperty=nameWithType> supports security-based sessions, in which both ends of communication have agreed upon a specific secure conversation.</span></span> <span data-ttu-id="2b203-139">有关详细信息，请参阅[Securing Services](../../../docs/framework/wcf/securing-services.md)。</span><span class="sxs-lookup"><span data-stu-id="2b203-139">For more information, see [Securing Services](../../../docs/framework/wcf/securing-services.md).</span></span> <span data-ttu-id="2b203-140">例如， <xref:System.ServiceModel.WSHttpBinding?displayProperty=nameWithType> 绑定（包含对安全会话和可靠会话的支持）默认情况下只使用对消息进行加密和数字签名的安全会话。</span><span class="sxs-lookup"><span data-stu-id="2b203-140">For example, the <xref:System.ServiceModel.WSHttpBinding?displayProperty=nameWithType> binding, which contains support for both security sessions and reliable sessions, by default uses only a secure session that encrypts and digitally signs messages.</span></span>  
  
- <span data-ttu-id="2b203-141"><xref:System.ServiceModel.NetTcpBinding?displayProperty=nameWithType> 绑定支持基于 TCP/IP 的会话，以确保所有消息都由套接字级别的连接进行关联。</span><span class="sxs-lookup"><span data-stu-id="2b203-141">The <xref:System.ServiceModel.NetTcpBinding?displayProperty=nameWithType> binding supports TCP/IP-based sessions to ensure that all messages are correlated by the connection at the socket level.</span></span>  
  
- <span data-ttu-id="2b203-142"><xref:System.ServiceModel.Channels.ReliableSessionBindingElement?displayProperty=nameWithType> 元素实现 WS-ReliableMessaging 规范，并提供对可靠会话的支持。在可靠会话中，可以配置消息以按顺序传递并且只传递一次，从而使消息在对话期间即使经过多个节点也可以确保收到。</span><span class="sxs-lookup"><span data-stu-id="2b203-142">The <xref:System.ServiceModel.Channels.ReliableSessionBindingElement?displayProperty=nameWithType> element, which implements the WS-ReliableMessaging specification, provides support for reliable sessions in which messages can be configured to be delivered in order and exactly once, ensuring messages are received even when messages travel across multiple nodes during the conversation.</span></span> <span data-ttu-id="2b203-143">有关详细信息，请参阅[可靠会话](../../../docs/framework/wcf/feature-details/reliable-sessions.md)。</span><span class="sxs-lookup"><span data-stu-id="2b203-143">For more information, see [Reliable Sessions](../../../docs/framework/wcf/feature-details/reliable-sessions.md).</span></span>  
  
- <span data-ttu-id="2b203-144"><xref:System.ServiceModel.NetMsmqBinding?displayProperty=nameWithType> 绑定提供 MSMQ 数据报会话。</span><span class="sxs-lookup"><span data-stu-id="2b203-144">The <xref:System.ServiceModel.NetMsmqBinding?displayProperty=nameWithType> binding provides MSMQ datagram sessions.</span></span> <span data-ttu-id="2b203-145">有关详细信息，请参阅[WCF 中的队列](../../../docs/framework/wcf/feature-details/queues-in-wcf.md)。</span><span class="sxs-lookup"><span data-stu-id="2b203-145">For more information, see [Queues in WCF](../../../docs/framework/wcf/feature-details/queues-in-wcf.md).</span></span>  
  
 <span data-ttu-id="2b203-146">设置 <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A> 属性并不指定协定需要的会话类型，而只是指定协定需要一个会话。</span><span class="sxs-lookup"><span data-stu-id="2b203-146">Setting the <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A> property does not specify the type of session the contract requires, only that it requires one.</span></span>  
  
## <a name="creating-a-contract-that-requires-a-session"></a><span data-ttu-id="2b203-147">创建一个需要会话的协定</span><span class="sxs-lookup"><span data-stu-id="2b203-147">Creating a Contract That Requires a Session</span></span>  
 <span data-ttu-id="2b203-148">创建需要会话的协定的原则是，必须在同一会话内执行服务协定声明的所有操作组，并且必须按顺序传递消息。</span><span class="sxs-lookup"><span data-stu-id="2b203-148">Creating a contract that requires a session states that the group of operations that the service contract declares must all be executed within the same session and that messages must be delivered in order.</span></span> <span data-ttu-id="2b203-149">若要断言服务协定需要的会话支持级别，请将服务协定接口或类上的 <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> 属性设置为 <xref:System.ServiceModel.SessionMode?displayProperty=nameWithType> 枚举的值以指定协定是否：</span><span class="sxs-lookup"><span data-stu-id="2b203-149">To assert the level of session support that a service contract requires, set the <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> property on your service contract interface or class to the value of the <xref:System.ServiceModel.SessionMode?displayProperty=nameWithType> enumeration to specify whether the contract:</span></span>  
  
- <span data-ttu-id="2b203-150">需要会话。</span><span class="sxs-lookup"><span data-stu-id="2b203-150">Requires a session.</span></span>  
  
- <span data-ttu-id="2b203-151">允许客户端建立会话。</span><span class="sxs-lookup"><span data-stu-id="2b203-151">Allows a client to establish a session.</span></span>  
  
- <span data-ttu-id="2b203-152">禁止会话。</span><span class="sxs-lookup"><span data-stu-id="2b203-152">Prohibits a session.</span></span>  
  
 <span data-ttu-id="2b203-153">但是，设置 <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A> 属性并不指定协定需要的基于会话的行为的类型。</span><span class="sxs-lookup"><span data-stu-id="2b203-153">Setting the <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A> property does not, however, specify the type of session-based behavior the contract requires.</span></span> <span data-ttu-id="2b203-154">它指示 WCF 在确认在运行时，为该服务不，不是，请或可以建立的会话配置绑定 （用于创建通信通道） 实现服务时。</span><span class="sxs-lookup"><span data-stu-id="2b203-154">It instructs WCF to confirm at runtime that the configured binding (which creates the communication channel) for the service does, does not, or can establish a session when implementing a service.</span></span> <span data-ttu-id="2b203-155">同样，绑定可以使用它选择的任何类型的基于会话的行为（安全、传输、可靠或某种组合）来满足该要求。</span><span class="sxs-lookup"><span data-stu-id="2b203-155">Again, the binding can satisfy that requirement with any type of session-based behavior it chooses—security, transport, reliable, or some combination.</span></span> <span data-ttu-id="2b203-156">具体的行为取决于选择的 <xref:System.ServiceModel.SessionMode?displayProperty=nameWithType> 值。</span><span class="sxs-lookup"><span data-stu-id="2b203-156">The exact behavior depends on the <xref:System.ServiceModel.SessionMode?displayProperty=nameWithType> value selected.</span></span> <span data-ttu-id="2b203-157">如果为服务配置的绑定不符合 <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A>的值，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="2b203-157">If the configured binding of the service does not conform to the value of <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A>, an exception is thrown.</span></span> <span data-ttu-id="2b203-158">绑定及其创建的支持会话的通道可认为是基于会话的。</span><span class="sxs-lookup"><span data-stu-id="2b203-158">Bindings and the channels they create that support sessions are said to be session-based.</span></span>  
  
 <span data-ttu-id="2b203-159">下面的服务协定指定 `ICalculatorSession` 中的所有操作必须在会话中进行交换。</span><span class="sxs-lookup"><span data-stu-id="2b203-159">The following service contract specifies that all operations in the `ICalculatorSession` must be exchanged within a session.</span></span> <span data-ttu-id="2b203-160">除了 `Equals` 方法之外，任何操作都不会向调用方返回值。</span><span class="sxs-lookup"><span data-stu-id="2b203-160">None of the operations returns a value to the caller except the `Equals` method.</span></span> <span data-ttu-id="2b203-161">但是， `Equals` 方法不使用参数，因此，在已将其中的数据传递到其他操作的会话内部只可以返回非零值。</span><span class="sxs-lookup"><span data-stu-id="2b203-161">However, the `Equals` method takes no parameters and, therefore, can only return a non-zero value inside a session in which data has already been passed to the other operations.</span></span> <span data-ttu-id="2b203-162">此协定需要会话正常工作。</span><span class="sxs-lookup"><span data-stu-id="2b203-162">This contract requires a session to function properly.</span></span> <span data-ttu-id="2b203-163">如果没有与特定客户端相关联的会话，则服务实例无法知道此客户端前面已经发送了哪些数据。</span><span class="sxs-lookup"><span data-stu-id="2b203-163">Without a session associated with a specific client, the service instance has no way of knowing what previous data this client has sent.</span></span>  
  
 [!code-csharp[S_Service_Session#1](../../../samples/snippets/csharp/VS_Snippets_CFX/s_service_session/cs/service.cs#1)]
 [!code-vb[S_Service_Session#1](../../../samples/snippets/visualbasic/VS_Snippets_CFX/s_service_session/vb/service.vb#1)]  
  
 <span data-ttu-id="2b203-164">如果服务允许会话，则当客户端启动一个会话时将建立并使用该会话；否则，不建立会话。</span><span class="sxs-lookup"><span data-stu-id="2b203-164">If a service allows a session, then a session is established and used if the client initiates one; otherwise, no session is established.</span></span>  
  
## <a name="sessions-and-service-instances"></a><span data-ttu-id="2b203-165">会话和服务实例</span><span class="sxs-lookup"><span data-stu-id="2b203-165">Sessions and Service Instances</span></span>  
 <span data-ttu-id="2b203-166">如果使用默认实例化 WCF 中的行为，WCF 客户端对象之间的所有调用由同一个服务实例都处理。</span><span class="sxs-lookup"><span data-stu-id="2b203-166">If you use the default instancing behavior in WCF, all calls between a WCF client object are handled by the same service instance.</span></span> <span data-ttu-id="2b203-167">因此，在应用程序级别上，可以将会话视为启用与本地调用行为相似的应用程序行为。</span><span class="sxs-lookup"><span data-stu-id="2b203-167">Therefore, at the application level, you can think of a session as enabling application behavior similar to local call behavior.</span></span> <span data-ttu-id="2b203-168">例如，在创建本地对象时：</span><span class="sxs-lookup"><span data-stu-id="2b203-168">For example, when you create a local object:</span></span>  
  
- <span data-ttu-id="2b203-169">调用构造函数。</span><span class="sxs-lookup"><span data-stu-id="2b203-169">A constructor is called.</span></span>  
  
- <span data-ttu-id="2b203-170">对 WCF 客户端对象引用所做的所有后续调用由同一个对象实例处理。</span><span class="sxs-lookup"><span data-stu-id="2b203-170">All subsequent calls made to the WCF client object reference are processed by the same object instance.</span></span>  
  
- <span data-ttu-id="2b203-171">在销毁对象引用时调用析构函数。</span><span class="sxs-lookup"><span data-stu-id="2b203-171">A destructor is called when the object reference is destroyed.</span></span>  
  
 <span data-ttu-id="2b203-172">只要使用默认的服务实例行为，会话就会在客户端和服务之间启用一个相似的行为。</span><span class="sxs-lookup"><span data-stu-id="2b203-172">Sessions enable a similar behavior between clients and services as long as the default service instance behavior is used.</span></span> <span data-ttu-id="2b203-173">如果服务协定需要或支持会话，则通过设置 <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> 和 <xref:System.ServiceModel.OperationContractAttribute.IsTerminating%2A> 属性，可以将一个或多个协定操作标记为启动或终止会话。</span><span class="sxs-lookup"><span data-stu-id="2b203-173">If a service contract requires or supports sessions, one or more contract operations can be marked as initiating or terminating a session by setting the <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> and <xref:System.ServiceModel.OperationContractAttribute.IsTerminating%2A> properties.</span></span>  
  
 <span data-ttu-id="2b203-174">启动操作 是必须作为新会话的第一个操作而调用的操作。</span><span class="sxs-lookup"><span data-stu-id="2b203-174">*Initiating operations* are those that must be called as the first operation of a new session.</span></span> <span data-ttu-id="2b203-175">只有在已调用至少一个启动操作之后才可以调用非启动操作。</span><span class="sxs-lookup"><span data-stu-id="2b203-175">Non-initiating operations can be called only after at least one initiating operation has been called.</span></span> <span data-ttu-id="2b203-176">因此，可以通过声明一个启动操作来为服务创建某种会话构造函数，启动操作应设计为从与服务实例的开始相对应的客户端接收输入。</span><span class="sxs-lookup"><span data-stu-id="2b203-176">You can therefore create a kind of session constructor for your service by declaring initiating operations designed to take input from clients appropriate to the beginning of the service instance.</span></span> <span data-ttu-id="2b203-177">（状态与会话相关联，但是，不与服务对象相关联。）</span><span class="sxs-lookup"><span data-stu-id="2b203-177">(The state is associated with the session, however, and not the service object.)</span></span>  
  
 <span data-ttu-id="2b203-178">相反，终止操作是必须作为现有会话中的最后消息而调用的操作。</span><span class="sxs-lookup"><span data-stu-id="2b203-178">*Terminating operations*, conversely, are those that must be called as the last message in an existing session.</span></span> <span data-ttu-id="2b203-179">默认情况下，在关闭与服务相关联的会话之后，WCF 会回收服务对象及其上下文。</span><span class="sxs-lookup"><span data-stu-id="2b203-179">In the default case, WCF recycles the service object and its context after the session with which the service was associated is closed.</span></span> <span data-ttu-id="2b203-180">因此，可以通过声明终止操作来创建某种析构函数，终止操作应设计为执行与服务实例的结束相对应的函数。</span><span class="sxs-lookup"><span data-stu-id="2b203-180">You can, therefore, create a kind of destructor by declaring terminating operations designed to perform a function appropriate to the end of the service instance.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2b203-181">尽管默认的行为与本地构造函数和析构函数有相似之处，但仅仅是相似。</span><span class="sxs-lookup"><span data-stu-id="2b203-181">Although the default behavior bears a resemblance to local constructors and destructors, it is only a resemblance.</span></span> <span data-ttu-id="2b203-182">任何 WCF 服务操作可以启动或终止操作，或同时在这两者。</span><span class="sxs-lookup"><span data-stu-id="2b203-182">Any WCF service operation can be an initiating or terminating operation, or both at the same time.</span></span> <span data-ttu-id="2b203-183">另外，在默认情况下，可以按任意顺序调用启动操作任意次数；一旦建立会话并与实例相关联后，便不会再创建其他会话，除非显式控制服务实例的生存期（通过操作 <xref:System.ServiceModel.InstanceContext?displayProperty=nameWithType> 对象）。</span><span class="sxs-lookup"><span data-stu-id="2b203-183">In addition, in the default case, initiating operations can be called any number of times in any order; no additional sessions are created once the session is established and associated with an instance unless you explicitly control the lifetime of the service instance (by manipulating the <xref:System.ServiceModel.InstanceContext?displayProperty=nameWithType> object).</span></span> <span data-ttu-id="2b203-184">最后，状态与会话相关联，而不是与服务对象相关联。</span><span class="sxs-lookup"><span data-stu-id="2b203-184">Finally, the state is associated with the session and not the service object.</span></span>  
  
 <span data-ttu-id="2b203-185">例如，`ICalculatorSession`前面的示例中使用的协定需要 WCF 客户端对象第一次调用`Clear`操作之前执行其他任何操作，此 WCF 客户端对象的会话应该终止时它会调用`Equals`操作。</span><span class="sxs-lookup"><span data-stu-id="2b203-185">For example, the `ICalculatorSession` contract used in the preceding example requires that the WCF client object first call the `Clear` operation prior to any other operation and that the session with this WCF client object should terminate when it calls the `Equals` operation.</span></span> <span data-ttu-id="2b203-186">下面的代码示例演示强制执行这些要求的协定。</span><span class="sxs-lookup"><span data-stu-id="2b203-186">The following code example shows a contract that enforces these requirements.</span></span> <span data-ttu-id="2b203-187">必须首先调用`Clear` 来启动会话，并且会话在调用 `Equals` 时结束。</span><span class="sxs-lookup"><span data-stu-id="2b203-187">`Clear` must be called first to initiate a session, and that session ends when `Equals` is called.</span></span>  
  
 [!code-csharp[SCA.IsInitiatingIsTerminating#1](../../../samples/snippets/csharp/VS_Snippets_CFX/sca.isinitiatingisterminating/cs/service.cs#1)]
 [!code-vb[SCA.IsInitiatingIsTerminating#1](../../../samples/snippets/visualbasic/VS_Snippets_CFX/sca.isinitiatingisterminating/vb/service.vb#1)]  
  
 <span data-ttu-id="2b203-188">服务不会启动与客户端的会话。</span><span class="sxs-lookup"><span data-stu-id="2b203-188">Services do not start sessions with clients.</span></span> <span data-ttu-id="2b203-189">在 WCF 客户端应用程序，基于会话的通道的生存期和会话本身的生存期之间存在直接的关系。</span><span class="sxs-lookup"><span data-stu-id="2b203-189">In WCF client applications, a direct relationship exists between the lifetime of the session-based channel and the lifetime of the session itself.</span></span> <span data-ttu-id="2b203-190">因此，客户端可通过创建新的基于会话的通道来创建新会话，并通过正常关闭基于会话的通道来关闭现有的会话。</span><span class="sxs-lookup"><span data-stu-id="2b203-190">As such, clients create new sessions by creating new session-based channels and tear down existing sessions by closing session-based channels gracefully.</span></span> <span data-ttu-id="2b203-191">客户端通过调用以下项目之一来启动与服务终结点的会话：</span><span class="sxs-lookup"><span data-stu-id="2b203-191">A client starts a session with a service endpoint by calling one of the following:</span></span>  
  
- <span data-ttu-id="2b203-192">通过调用<xref:System.ServiceModel.ICommunicationObject.Open%2A?displayProperty=nameWithType> 返回的通道上的 <xref:System.ServiceModel.ChannelFactory%601.CreateChannel%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="2b203-192"><xref:System.ServiceModel.ICommunicationObject.Open%2A?displayProperty=nameWithType> on the channel returned by a call to <xref:System.ServiceModel.ChannelFactory%601.CreateChannel%2A?displayProperty=nameWithType>.</span></span>  
  
- <span data-ttu-id="2b203-193"><xref:System.ServiceModel.ClientBase%601.Open%2A?displayProperty=nameWithType> 生成的 WCF 客户端对象上[ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)。</span><span class="sxs-lookup"><span data-stu-id="2b203-193"><xref:System.ServiceModel.ClientBase%601.Open%2A?displayProperty=nameWithType> on the WCF client object generated by the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md).</span></span>  
  
- <span data-ttu-id="2b203-194">任一类型的 WCF 客户端对象上的启动操作 （默认情况下，所有操作都会都启动）。</span><span class="sxs-lookup"><span data-stu-id="2b203-194">An initiating operation on either type of WCF client object (by default, all operations are initiating).</span></span> <span data-ttu-id="2b203-195">当调用的第一个操作时，WCF 客户端对象自动打开通道并启动会话。</span><span class="sxs-lookup"><span data-stu-id="2b203-195">When the first operation is called, the WCF client object automatically opens the channel and initiates a session.</span></span>  
  
 <span data-ttu-id="2b203-196">通常，客户端通过调用以下项目之一来结束与服务终结点的会话：</span><span class="sxs-lookup"><span data-stu-id="2b203-196">Typically a client ends a session with a service endpoint by calling one of the following:</span></span>  
  
- <span data-ttu-id="2b203-197">通过调用<xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType> 返回的通道上的 <xref:System.ServiceModel.ChannelFactory%601.CreateChannel%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="2b203-197"><xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType> on the channel returned by a call to <xref:System.ServiceModel.ChannelFactory%601.CreateChannel%2A?displayProperty=nameWithType>.</span></span>  
  
- <span data-ttu-id="2b203-198"><xref:System.ServiceModel.ClientBase%601.Close%2A?displayProperty=nameWithType> 在由 Svcutil.exe 生成的 WCF 客户端对象。</span><span class="sxs-lookup"><span data-stu-id="2b203-198"><xref:System.ServiceModel.ClientBase%601.Close%2A?displayProperty=nameWithType> on the WCF client object generated by Svcutil.exe.</span></span>  
  
- <span data-ttu-id="2b203-199">任一类型的 WCF 客户端对象上的终止操作 （默认情况下，不终止任何操作; 协定必须显式指定的终止操作）。</span><span class="sxs-lookup"><span data-stu-id="2b203-199">A terminating operation on either type of WCF client object (by default, no operations are terminating; the contract must explicitly specify a terminating operation).</span></span> <span data-ttu-id="2b203-200">当调用的第一个操作时，WCF 客户端对象自动打开通道并启动会话。</span><span class="sxs-lookup"><span data-stu-id="2b203-200">When the first operation is called, the WCF client object automatically opens the channel and initiates a session.</span></span>  
  
 <span data-ttu-id="2b203-201">相关示例，请参阅[如何：创建 Service That Requires Sessions](../../../docs/framework/wcf/feature-details/how-to-create-a-service-that-requires-sessions.md)并将[Default Service Behavior](../../../docs/framework/wcf/samples/default-service-behavior.md)并[Instancing](../../../docs/framework/wcf/samples/instancing.md)示例。</span><span class="sxs-lookup"><span data-stu-id="2b203-201">For examples, see [How to: Create a Service That Requires Sessions](../../../docs/framework/wcf/feature-details/how-to-create-a-service-that-requires-sessions.md) as well as the [Default Service Behavior](../../../docs/framework/wcf/samples/default-service-behavior.md) and [Instancing](../../../docs/framework/wcf/samples/instancing.md) samples.</span></span>  
  
 <span data-ttu-id="2b203-202">有关客户端和会话的详细信息，请参阅[使用 WCF 客户端访问服务](../../../docs/framework/wcf/feature-details/accessing-services-using-a-client.md)。</span><span class="sxs-lookup"><span data-stu-id="2b203-202">For more information about clients and sessions, see [Accessing Services Using a WCF Client](../../../docs/framework/wcf/feature-details/accessing-services-using-a-client.md).</span></span>  
  
## <a name="sessions-interact-with-instancecontext-settings"></a><span data-ttu-id="2b203-203">会话与 InstanceContext 设置进行交互</span><span class="sxs-lookup"><span data-stu-id="2b203-203">Sessions Interact with InstanceContext Settings</span></span>  
 <span data-ttu-id="2b203-204">协定中的 <xref:System.ServiceModel.SessionMode> 枚举与 <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> 属性之间存在交互，该属性可控制通道和特定服务对象之间的关联。</span><span class="sxs-lookup"><span data-stu-id="2b203-204">There is an interaction between the <xref:System.ServiceModel.SessionMode> enumeration in a contract and the <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> property, which controls the association between channels and specific service objects.</span></span> <span data-ttu-id="2b203-205">有关详细信息，请参阅[会话、 实例存储功能和并发](../../../docs/framework/wcf/feature-details/sessions-instancing-and-concurrency.md)。</span><span class="sxs-lookup"><span data-stu-id="2b203-205">For more information, see [Sessions, Instancing, and Concurrency](../../../docs/framework/wcf/feature-details/sessions-instancing-and-concurrency.md).</span></span>  
  
### <a name="sharing-instancecontext-objects"></a><span data-ttu-id="2b203-206">共享 InstanceContext 对象</span><span class="sxs-lookup"><span data-stu-id="2b203-206">Sharing InstanceContext Objects</span></span>  
 <span data-ttu-id="2b203-207">通过自己执行关联，您还可以控制将哪个基于会话的通道或调用与哪个 <xref:System.ServiceModel.InstanceContext> 对象相关联。</span><span class="sxs-lookup"><span data-stu-id="2b203-207">You can also control which session-based channel or call is associated with which <xref:System.ServiceModel.InstanceContext> object by performing that association yourself.</span></span> 
  
## <a name="sessions-and-streaming"></a><span data-ttu-id="2b203-208">会话和流</span><span class="sxs-lookup"><span data-stu-id="2b203-208">Sessions and Streaming</span></span>  
 <span data-ttu-id="2b203-209">如果有大量要传输的数据，在 WCF 中的流传输模式是缓冲和处理其完整的内存中的消息的默认行为可行的替代方法。</span><span class="sxs-lookup"><span data-stu-id="2b203-209">When you have a large amount of data to transfer, the streaming transfer mode in WCF is a feasible alternative to the default behavior of buffering and processing messages in memory in their entirety.</span></span> <span data-ttu-id="2b203-210">在流与基于会话的绑定一起调用时可能会产生意外行为。</span><span class="sxs-lookup"><span data-stu-id="2b203-210">You may get unexpected behavior when streaming calls with a session-based binding.</span></span> <span data-ttu-id="2b203-211">可通过单一通道（数据报通道）执行所有流调用，该通道不支持会话，即使将正在使用的绑定配置为使用会话也是如此。</span><span class="sxs-lookup"><span data-stu-id="2b203-211">All streaming calls are made through a single channel (the datagram channel) that does not support sessions even if the binding being used is configured to use sessions.</span></span> <span data-ttu-id="2b203-212">如果多个客户端通过基于会话的绑定对相同的服务对象进行流调用，并且将服务对象的并发模式设置为 single，同时将其实例上下文模式设置为 `PerSession`，则所用的调用必须经过数据报通道，因此一次只处理一个调用。</span><span class="sxs-lookup"><span data-stu-id="2b203-212">If multiple clients make streaming calls to the same service object over a session-based binding, and the service object's concurrency mode is set to single and its instance context mode is set to `PerSession`, all calls must go through the datagram channel and so only one call is processed at a time.</span></span> <span data-ttu-id="2b203-213">一个或多个客户端因此可能会超时。通过将服务对象的 `InstanceContextMode` 设置为 `PerCall` 或者将 Concurrency 设置为 multiple，可以解决此问题。</span><span class="sxs-lookup"><span data-stu-id="2b203-213">One or more clients may then time out. You can work around this issue by either setting the service object's `InstanceContextMode` to `PerCall` or Concurrency to multiple.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2b203-214">MaxConcurrentSessions 在此情况下不会产生任何影响，因为只有一个“会话”可用。</span><span class="sxs-lookup"><span data-stu-id="2b203-214">MaxConcurrentSessions have no effect in this case because there is only one "session" available.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="2b203-215">请参阅</span><span class="sxs-lookup"><span data-stu-id="2b203-215">See also</span></span>

- <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A>
- <xref:System.ServiceModel.OperationContractAttribute.IsTerminating%2A>
