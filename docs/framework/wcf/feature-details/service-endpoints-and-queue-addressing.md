---
title: 服务终结点和队列寻址
ms.date: 03/30/2017
ms.assetid: 7d2d59d7-f08b-44ed-bd31-913908b83d97
ms.openlocfilehash: 7b4eca1519eeb1ed6357b625a3253105ece2b8ad
ms.sourcegitcommit: 0069cb3de8eed4e92b2195d29e5769a76111acdd
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/16/2019
ms.locfileid: "56332515"
---
# <a name="service-endpoints-and-queue-addressing"></a><span data-ttu-id="3fab5-102">服务终结点和队列寻址</span><span class="sxs-lookup"><span data-stu-id="3fab5-102">Service Endpoints and Queue Addressing</span></span>
<span data-ttu-id="3fab5-103">本主题讨论客户端如何对从队列中读取的服务进行寻址以及服务终结点如何映射到队列。</span><span class="sxs-lookup"><span data-stu-id="3fab5-103">This topic discusses how clients address services that read from queues and how service endpoints map to queues.</span></span> <span data-ttu-id="3fab5-104">请注意下, 图显示经典 Windows Communication Foundation (WCF) 排队应用程序部署。</span><span class="sxs-lookup"><span data-stu-id="3fab5-104">As a reminder, the following illustration shows the classic Windows Communication Foundation (WCF) queued application deployment.</span></span>  
  
 <span data-ttu-id="3fab5-105">![排队应用程序关系图](../../../../docs/framework/wcf/feature-details/media/distributed-queue-figure.jpg "分布式队列图")</span><span class="sxs-lookup"><span data-stu-id="3fab5-105">![Queued Application Diagram](../../../../docs/framework/wcf/feature-details/media/distributed-queue-figure.jpg "Distributed-Queue-Figure")</span></span>  
  
 <span data-ttu-id="3fab5-106">客户端为了将消息发送到服务，需要确定该消息在目标队列中的地址。</span><span class="sxs-lookup"><span data-stu-id="3fab5-106">For the client to send the message to the service, the client addresses the message to the Target Queue.</span></span> <span data-ttu-id="3fab5-107">服务为了从队列中读取消息，需要在目标队列中设置它的侦听地址。</span><span class="sxs-lookup"><span data-stu-id="3fab5-107">For the service to read messages from the queue, it sets its listen address to the Target Queue.</span></span> <span data-ttu-id="3fab5-108">在 WCF 中寻址是基于统一资源标识符 URI 而消息队列 (MSMQ) 队列名称不是基于 URI 的。</span><span class="sxs-lookup"><span data-stu-id="3fab5-108">Addressing in WCF is Uniform Resource Identifier (URI)-based while Message Queuing (MSMQ) queue names are not URI-based.</span></span> <span data-ttu-id="3fab5-109">因此，它是必须了解如何使用 WCF MSMQ 中创建的队列进行寻址。</span><span class="sxs-lookup"><span data-stu-id="3fab5-109">It is therefore essential to understand how to address queues created in MSMQ using WCF.</span></span>  
  
## <a name="msmq-addressing"></a><span data-ttu-id="3fab5-110">MSMQ 寻址</span><span class="sxs-lookup"><span data-stu-id="3fab5-110">MSMQ Addressing</span></span>  
 <span data-ttu-id="3fab5-111">MSMQ 使用路径和格式名来标识队列。</span><span class="sxs-lookup"><span data-stu-id="3fab5-111">MSMQ uses paths and format names to identify a queue.</span></span> <span data-ttu-id="3fab5-112">路径指定一个主机名称和一个 `QueueName`。</span><span class="sxs-lookup"><span data-stu-id="3fab5-112">Paths specify a host name and a `QueueName`.</span></span> <span data-ttu-id="3fab5-113">可以根据需要在主机名称和 `Private$` 之间添加一个 `QueueName`，以指示不是在 Active Directory 目录服务中发布的专用队列。</span><span class="sxs-lookup"><span data-stu-id="3fab5-113">Optionally, there can be a `Private$` between the host name and the `QueueName` to indicate a private queue that is not published in the Active Directory directory service.</span></span>  
  
 <span data-ttu-id="3fab5-114">路径名称映射到"FormatNames"以确定地址，包括路由和队列管理器传输协议的其他方面。</span><span class="sxs-lookup"><span data-stu-id="3fab5-114">Path names are mapped to "FormatNames" to determine additional aspects of the address, including routing and queue manager transfer protocol.</span></span> <span data-ttu-id="3fab5-115">队列管理器支持两种传输协议：本机 MSMQ 协议和 SOAP 可靠消息协议 (SRMP)。</span><span class="sxs-lookup"><span data-stu-id="3fab5-115">The Queue Manager supports two transfer protocols: native MSMQ protocol and SOAP Reliable Messaging Protocol (SRMP).</span></span>  
  
 <span data-ttu-id="3fab5-116">有关 MSMQ 路径和格式名称的详细信息，请参阅[有关消息队列](https://go.microsoft.com/fwlink/?LinkId=94837)。</span><span class="sxs-lookup"><span data-stu-id="3fab5-116">For more information about MSMQ path and format names, see [About Message Queuing](https://go.microsoft.com/fwlink/?LinkId=94837).</span></span>  
  
## <a name="netmsmqbinding-and-service-addressing"></a><span data-ttu-id="3fab5-117">NetMsmqBinding 和服务寻址</span><span class="sxs-lookup"><span data-stu-id="3fab5-117">NetMsmqBinding and Service Addressing</span></span>  
 <span data-ttu-id="3fab5-118">在将消息发送到服务中的目标地址时，将根据用于通信的传输协议选择 URI 中的方案。</span><span class="sxs-lookup"><span data-stu-id="3fab5-118">When addressing a message to a service, the scheme in the URI is chosen based on the transport used for communication.</span></span> <span data-ttu-id="3fab5-119">WCF 中的每个传输协议具有唯一的方案。</span><span class="sxs-lookup"><span data-stu-id="3fab5-119">Each transport in WCF has a unique scheme.</span></span> <span data-ttu-id="3fab5-120">此方案必须反映用于通信的传输协议的性质。</span><span class="sxs-lookup"><span data-stu-id="3fab5-120">The scheme must reflect the nature of transport used for communication.</span></span> <span data-ttu-id="3fab5-121">例如，net.tcp、net.pipe、HTTP 等等。</span><span class="sxs-lookup"><span data-stu-id="3fab5-121">For example, net.tcp, net.pipe, HTTP, and so on.</span></span>  
  
 <span data-ttu-id="3fab5-122">MSMQ 排队传输协议中 WCF 公开 net.msmq 方案。</span><span class="sxs-lookup"><span data-stu-id="3fab5-122">The MSMQ queued transport in WCF exposes a net.msmq scheme.</span></span> <span data-ttu-id="3fab5-123">使用 net.msmq 方案寻址的任何消息都使用 MSMQ 排队传输协议通道上的 `NetMsmqBinding` 发送。</span><span class="sxs-lookup"><span data-stu-id="3fab5-123">Any message addressed using the net.msmq scheme is sent using the `NetMsmqBinding` over the MSMQ queued transport channel.</span></span>  
  
 <span data-ttu-id="3fab5-124">WCF 中的队列寻址基于以下模式：</span><span class="sxs-lookup"><span data-stu-id="3fab5-124">The addressing of a queue in WCF is based on the following pattern:</span></span>  
  
 <span data-ttu-id="3fab5-125">net.msmq: / / \<*主机名*> / [private /] \<*队列名称*></span><span class="sxs-lookup"><span data-stu-id="3fab5-125">net.msmq: // \<*host-name*> / [private/] \<*queue-name*></span></span>  
  
 <span data-ttu-id="3fab5-126">其中：</span><span class="sxs-lookup"><span data-stu-id="3fab5-126">where:</span></span>  
  
-   <span data-ttu-id="3fab5-127">\<*主机名*> 是承载目标队列的计算机的名称。</span><span class="sxs-lookup"><span data-stu-id="3fab5-127">\<*host-name*> is the name of the machine that hosts the Target Queue.</span></span>  
  
-   <span data-ttu-id="3fab5-128">[private] 可选。</span><span class="sxs-lookup"><span data-stu-id="3fab5-128">[private] is optional.</span></span> <span data-ttu-id="3fab5-129">它在对作为专用队列的目标队列寻址时使用。</span><span class="sxs-lookup"><span data-stu-id="3fab5-129">It is used when addressing a Target Queue that is a private queue.</span></span> <span data-ttu-id="3fab5-130">若要对公共队列寻址，不能指定 private。</span><span class="sxs-lookup"><span data-stu-id="3fab5-130">To address a public queue, you must not specify private.</span></span> <span data-ttu-id="3fab5-131">请注意，与 MSMQ 路径不同中已有不包含"$"WCF URI 形式。</span><span class="sxs-lookup"><span data-stu-id="3fab5-131">Note that, unlike MSMQ paths, there is no "$" in the WCF URI form.</span></span>  
  
-   <span data-ttu-id="3fab5-132">\<*队列名称*> 是队列的名称。</span><span class="sxs-lookup"><span data-stu-id="3fab5-132">\<*queue-name*> is the name of the queue.</span></span> <span data-ttu-id="3fab5-133">队列名还可以引用子队列。</span><span class="sxs-lookup"><span data-stu-id="3fab5-133">The queue name can also refer to a subqueue.</span></span> <span data-ttu-id="3fab5-134">因此， \<*队列名称*> = \<*队列名称*> [;*子队列名*]。</span><span class="sxs-lookup"><span data-stu-id="3fab5-134">Thus, \<*queue-name*> = \<*name-of-queue*>[;*sub-queue-name*].</span></span>  
  
 <span data-ttu-id="3fab5-135">示例 1:若要解决的专用队列 PurchaseOrders 对计算机 abc atadatum.com 上承载，则 URI 将为 net.msmq: //abc.adatum.com/private/purchaseorders。</span><span class="sxs-lookup"><span data-stu-id="3fab5-135">Example1: To address a private queue PurchaseOrders hosted on computer abc atadatum.com, the URI would be net.msmq://abc.adatum.com/private/PurchaseOrders.</span></span>  
  
 <span data-ttu-id="3fab5-136">示例 2:若要解决的公共队列 AccountsPayable 计算机 def atadatum.com 上承载，则 URI 将为 net.msmq: //def.adatum.com/accountspayable。</span><span class="sxs-lookup"><span data-stu-id="3fab5-136">Example2: To address a public queue AccountsPayable hosted on computer def atadatum.com, the URI would be net.msmq://def.adatum.com/AccountsPayable.</span></span>  
  
 <span data-ttu-id="3fab5-137">队列地址用作侦听器从中读取消息的侦听 URI。</span><span class="sxs-lookup"><span data-stu-id="3fab5-137">The queue address is used as the Listen URI by the Listener to read messages from.</span></span> <span data-ttu-id="3fab5-138">换言之，队列地址等效于 TCP 套接字的侦听端口。</span><span class="sxs-lookup"><span data-stu-id="3fab5-138">In other words, the queue address is equivalent to the listen port of TCP socket.</span></span>  
  
 <span data-ttu-id="3fab5-139">从队列中读取消息的终结点必须使用以前在打开 ServiceHost 时指定的同一方案指定队列地址。</span><span class="sxs-lookup"><span data-stu-id="3fab5-139">An endpoint that reads from a queue must specify the address of the queue using the same scheme specified previously when opening the ServiceHost.</span></span> <span data-ttu-id="3fab5-140">有关示例，请参阅[Net MSMQ 绑定](../../../../docs/framework/wcf/samples/net-msmq-binding.md)。</span><span class="sxs-lookup"><span data-stu-id="3fab5-140">For examples, see [Net MSMQ Binding](../../../../docs/framework/wcf/samples/net-msmq-binding.md).</span></span>  
  
### <a name="multiple-contracts-in-a-queue"></a><span data-ttu-id="3fab5-141">队列中存在多个协定</span><span class="sxs-lookup"><span data-stu-id="3fab5-141">Multiple Contracts in a Queue</span></span>  
 <span data-ttu-id="3fab5-142">队列中的消息可以实现不同的协定。</span><span class="sxs-lookup"><span data-stu-id="3fab5-142">Messages in a queue can implement different contracts.</span></span> <span data-ttu-id="3fab5-143">在这种情况下，下列条件中必须有一个成立才能成功读取并处理所有消息：</span><span class="sxs-lookup"><span data-stu-id="3fab5-143">In this case, it is essential that one of the following is true to successfully read and process all messages:</span></span>  
  
-   <span data-ttu-id="3fab5-144">为服务指定一个实现所有协定的终结点。</span><span class="sxs-lookup"><span data-stu-id="3fab5-144">Specify an endpoint for a service that implements all the contracts.</span></span> <span data-ttu-id="3fab5-145">此为推荐方法。</span><span class="sxs-lookup"><span data-stu-id="3fab5-145">This is the recommended approach.</span></span>  
  
-   <span data-ttu-id="3fab5-146">指定多个具有不同协定的终结点，但要确保所有终结点都使用相同的 `NetMsmqBinding` 对象。</span><span class="sxs-lookup"><span data-stu-id="3fab5-146">Specify multiple endpoints with different contracts, but ensure that all the endpoints use the same `NetMsmqBinding` object.</span></span> <span data-ttu-id="3fab5-147">ServiceModel 中的调度逻辑使用一个消息泵，它从传输通道中读取消息以进行调度，并最终根据相应的协定将消息多路分解到不同的终结点。</span><span class="sxs-lookup"><span data-stu-id="3fab5-147">The dispatching logic in ServiceModel uses a message pump that reads messages out of the transport channel for dispatch, which eventually de-multiplexes messages based on the contract to different endpoints.</span></span> <span data-ttu-id="3fab5-148">消息泵是为侦听 URI/绑定对创建的。</span><span class="sxs-lookup"><span data-stu-id="3fab5-148">A message pump is created for a listen URI/Binding pair.</span></span> <span data-ttu-id="3fab5-149">队列地址被排队侦听器用作侦听 URI。</span><span class="sxs-lookup"><span data-stu-id="3fab5-149">The queue address is used as the Listen URI by the queued listener.</span></span> <span data-ttu-id="3fab5-150">通过让所有终结点使用相同的绑定对象，可以确保使用单个消息泵来读取消息，并且根据协定将消息多路分解到相关终结点。</span><span class="sxs-lookup"><span data-stu-id="3fab5-150">Having all the endpoints use the same binding object ensures that a single message pump is used to read the message and de-multiplex to relevant endpoints based on the contract.</span></span>  
  
### <a name="srmp-messaging"></a><span data-ttu-id="3fab5-151">SRMP 消息传递</span><span class="sxs-lookup"><span data-stu-id="3fab5-151">SRMP Messaging</span></span>  
 <span data-ttu-id="3fab5-152">如前所述，可以使用 SRMP 协议进行队列到队列的传输。</span><span class="sxs-lookup"><span data-stu-id="3fab5-152">As previously discussed, you can use the SRMP protocol for queue-to-queue transfers.</span></span> <span data-ttu-id="3fab5-153">当 HTTP 传输协议在传输队列和目标队列之间传输消息时，经常使用这一协议。</span><span class="sxs-lookup"><span data-stu-id="3fab5-153">This is commonly used when an HTTP transport transmits messages between the Transmission Queue and the Target Queue.</span></span>  
  
 <span data-ttu-id="3fab5-154">若要使用 SRMP 传输协议，请使用 net.msmq URI 方案对消息进行寻址（如前所述），并在 `QueueTransferProtocol` 的 `NetMsmqBinding` 属性中指定选择 SRMP 还是 Secured SRMP。</span><span class="sxs-lookup"><span data-stu-id="3fab5-154">To use the SRMP transfer protocol, address messages using the net.msmq URI scheme, as mentioned previously, and specify the choice of SRMP or Secured SRMP in the `QueueTransferProtocol` property of the `NetMsmqBinding`.</span></span>  
  
 <span data-ttu-id="3fab5-155">指定 `QueueTransferProtocol` 属性只具有发送的功能。</span><span class="sxs-lookup"><span data-stu-id="3fab5-155">Specifying the `QueueTransferProtocol` property is a send-only feature.</span></span> <span data-ttu-id="3fab5-156">这是客户端发出的有关要使用哪种队列传输协议的指示。</span><span class="sxs-lookup"><span data-stu-id="3fab5-156">This is an indication by the client which kind of queue transfer protocol to use.</span></span>  
  
### <a name="using-active-directory"></a><span data-ttu-id="3fab5-157">使用 Active Directory</span><span class="sxs-lookup"><span data-stu-id="3fab5-157">Using Active Directory</span></span>  
 <span data-ttu-id="3fab5-158">MSMQ 带有 Active Directory 集成支持。</span><span class="sxs-lookup"><span data-stu-id="3fab5-158">MSMQ comes with support for Active Directory integration.</span></span> <span data-ttu-id="3fab5-159">安装带有 Active Directory 集成的 MSMQ 时，计算机必须属于 Windows 域。</span><span class="sxs-lookup"><span data-stu-id="3fab5-159">When MSMQ is installed with Active Directory integration, the machine must be part of a Windows domain.</span></span> <span data-ttu-id="3fab5-160">使用 active Directory 发布供发现; 的队列此类队列称为*公用队列*。</span><span class="sxs-lookup"><span data-stu-id="3fab5-160">Active Directory is used to publish queues for discovery; such queues are called *public queues*.</span></span> <span data-ttu-id="3fab5-161">对队列进行寻址时，可以使用 Active Directory 对队列进行解析。</span><span class="sxs-lookup"><span data-stu-id="3fab5-161">When addressing a queue, the queue can be resolved using Active Directory.</span></span> <span data-ttu-id="3fab5-162">这与使用域名系统 (DNS) 解析网络名称的 IP 地址的方式相似。</span><span class="sxs-lookup"><span data-stu-id="3fab5-162">This is similar to how Domain Name System (DNS) is used to resolve the IP address of a network name.</span></span> <span data-ttu-id="3fab5-163">`UseActiveDirectory` 中的 `NetMsmqBinding` 属性是一个布尔值，该值指示排队通道是否必须使用 Active Directory 来解析队列 URI。</span><span class="sxs-lookup"><span data-stu-id="3fab5-163">The `UseActiveDirectory` property in `NetMsmqBinding` is a Boolean that indicates whether the queued channel must use Active Directory to resolve the queue URI.</span></span> <span data-ttu-id="3fab5-164">默认情况下，此属性设置为 `false`。</span><span class="sxs-lookup"><span data-stu-id="3fab5-164">By default it is set to `false`.</span></span> <span data-ttu-id="3fab5-165">如果 `UseActiveDirectory` 属性设置为 `true`，则排队通道使用 Active Directory 将 net.msmq:// URI 转换为格式名。</span><span class="sxs-lookup"><span data-stu-id="3fab5-165">If the `UseActiveDirectory` property is set to `true`, then the queued channel uses Active Directory to convert the net.msmq:// URI to format name.</span></span>  
  
 <span data-ttu-id="3fab5-166">`UseActiveDirectory` 属性仅对发送消息的客户端有意义，因为它用于在发送消息时解析队列的地址。</span><span class="sxs-lookup"><span data-stu-id="3fab5-166">The `UseActiveDirectory` property is meaningful only for the client that is sending the message because it is used to resolve the address of the queue when sending messages.</span></span>  
  
### <a name="mapping-netmsmq-uri-to-message-queuing-format-names"></a><span data-ttu-id="3fab5-167">将 net.msmq URI 映射到消息队列格式名</span><span class="sxs-lookup"><span data-stu-id="3fab5-167">Mapping net.msmq URI to Message Queuing Format Names</span></span>  
 <span data-ttu-id="3fab5-168">排队通道负责将提供给通道的 net.msmq URI 名称映射到 MSMQ 格式名。</span><span class="sxs-lookup"><span data-stu-id="3fab5-168">The queued channel handles mapping the net.msmq URI name provided to the channel to MSMQ format names.</span></span> <span data-ttu-id="3fab5-169">下表总结了用于在它们之间进行映射的规则。</span><span class="sxs-lookup"><span data-stu-id="3fab5-169">The following table summarizes the rules used to map between them.</span></span>  
  
|<span data-ttu-id="3fab5-170">基于 WCF URI 的队列地址</span><span class="sxs-lookup"><span data-stu-id="3fab5-170">WCF URI-based queue address</span></span>|<span data-ttu-id="3fab5-171">使用 Active Directory 属性</span><span class="sxs-lookup"><span data-stu-id="3fab5-171">Use Active Directory property</span></span>|<span data-ttu-id="3fab5-172">队列传输协议属性</span><span class="sxs-lookup"><span data-stu-id="3fab5-172">Queue Transfer Protocol property</span></span>|<span data-ttu-id="3fab5-173">得到的 MSMQ 格式名</span><span class="sxs-lookup"><span data-stu-id="3fab5-173">Resulting MSMQ format names</span></span>|  
|----------------------------------|-----------------------------------|--------------------------------------|---------------------------------|  
|<span data-ttu-id="3fab5-174">Net.msmq://\<machine-name>/private/abc</span><span class="sxs-lookup"><span data-stu-id="3fab5-174">Net.msmq://\<machine-name>/private/abc</span></span>|<span data-ttu-id="3fab5-175">False（默认值）</span><span class="sxs-lookup"><span data-stu-id="3fab5-175">False (default)</span></span>|<span data-ttu-id="3fab5-176">Native（默认值）</span><span class="sxs-lookup"><span data-stu-id="3fab5-176">Native (default)</span></span>|<span data-ttu-id="3fab5-177">DIRECT=OS:计算机名\private$\abc</span><span class="sxs-lookup"><span data-stu-id="3fab5-177">DIRECT=OS:machine-name\private$\abc</span></span>|  
|<span data-ttu-id="3fab5-178">Net.msmq://\<machine-name>/private/abc</span><span class="sxs-lookup"><span data-stu-id="3fab5-178">Net.msmq://\<machine-name>/private/abc</span></span>|<span data-ttu-id="3fab5-179">False</span><span class="sxs-lookup"><span data-stu-id="3fab5-179">False</span></span>|<span data-ttu-id="3fab5-180">SRMP</span><span class="sxs-lookup"><span data-stu-id="3fab5-180">SRMP</span></span>|<span data-ttu-id="3fab5-181">DIRECT=http://machine/msmq/private$/abc</span><span class="sxs-lookup"><span data-stu-id="3fab5-181">DIRECT=http://machine/msmq/private$/abc</span></span>|  
|<span data-ttu-id="3fab5-182">Net.msmq://\<machine-name>/private/abc</span><span class="sxs-lookup"><span data-stu-id="3fab5-182">Net.msmq://\<machine-name>/private/abc</span></span>|<span data-ttu-id="3fab5-183">True</span><span class="sxs-lookup"><span data-stu-id="3fab5-183">True</span></span>|<span data-ttu-id="3fab5-184">Native</span><span class="sxs-lookup"><span data-stu-id="3fab5-184">Native</span></span>|<span data-ttu-id="3fab5-185">PUBLIC=some-guid（队列的 GUID）</span><span class="sxs-lookup"><span data-stu-id="3fab5-185">PUBLIC=some-guid (the GUID of the queue)</span></span>|  
  
### <a name="reading-messages-from-the-dead-letter-queue-or-the-poison-message-queue"></a><span data-ttu-id="3fab5-186">从死信队列或病毒消息队列读取消息</span><span class="sxs-lookup"><span data-stu-id="3fab5-186">Reading Messages from the Dead-Letter Queue or the Poison-Message Queue</span></span>  
 <span data-ttu-id="3fab5-187">若要从作为目标队列子队列的病毒消息队列中读取消息，请打开具有子队列地址的 `ServiceHost`。</span><span class="sxs-lookup"><span data-stu-id="3fab5-187">To read messages from a poison-message queue that is a subqueue of the target queue, open the `ServiceHost` with the address of the subqueue.</span></span>  
  
 <span data-ttu-id="3fab5-188">示例:从本地计算机的 PurchaseOrders 专用队列的病毒消息队列中读取的服务将解决 net.msmq://localhost/private/PurchaseOrders;poison。</span><span class="sxs-lookup"><span data-stu-id="3fab5-188">Example: A service that reads from the poison-message queue of the PurchaseOrders private queue from the local machine would address net.msmq://localhost/private/PurchaseOrders;poison.</span></span>  
  
 <span data-ttu-id="3fab5-189">若要从系统的事务性死信队列中读取消息，URI 必须采用以下形式：net.msmq://localhost/system$;DeadXact。</span><span class="sxs-lookup"><span data-stu-id="3fab5-189">To read messages from a system transactional dead-letter queue, the URI must be of the form: net.msmq://localhost/system$;DeadXact.</span></span>  
  
 <span data-ttu-id="3fab5-190">若要从系统的非事务性死信队列中读取消息，URI 必须采用以下形式：net.msmq://localhost/system$;DeadLetter。</span><span class="sxs-lookup"><span data-stu-id="3fab5-190">To read messages from a system nontransactional dead-letter queue, the URI must be of the form: net.msmq://localhost/system$;DeadLetter.</span></span>  
  
 <span data-ttu-id="3fab5-191">在使用自定义死信队列时，请注意，死信队列必须驻留在本地计算机上。</span><span class="sxs-lookup"><span data-stu-id="3fab5-191">When using a custom dead-letter queue, note that the dead-letter queue must reside on the local computer.</span></span> <span data-ttu-id="3fab5-192">因此，死信队列的 URI 被限制为以下形式：</span><span class="sxs-lookup"><span data-stu-id="3fab5-192">As such, the URI for the dead-letter queue is restricted to the form:</span></span>  
  
 <span data-ttu-id="3fab5-193">net.msmq: //localhost/ [private /] \<*自定义的死信字母的队列的名称-*>。</span><span class="sxs-lookup"><span data-stu-id="3fab5-193">net.msmq: //localhost/ [private/]  \<*custom-dead-letter-queue-name*>.</span></span>  
  
 <span data-ttu-id="3fab5-194">WCF 服务将验证它接收的所有消息已都发送到它所侦听的特定队列。</span><span class="sxs-lookup"><span data-stu-id="3fab5-194">A WCF service verifies that all messages it receives were addressed to the particular queue it is listening on.</span></span> <span data-ttu-id="3fab5-195">如果消息的目标队列与它所在的队列不匹配，服务不会处理该消息。</span><span class="sxs-lookup"><span data-stu-id="3fab5-195">If the message’s destination queue does not match the queue it is found in, the service does not process the message.</span></span> <span data-ttu-id="3fab5-196">这存在一个问题：侦听死信队列的服务必须寻址，因为死信队列中的任何消息都需要传递到别处。</span><span class="sxs-lookup"><span data-stu-id="3fab5-196">This is an issue that services listening to a dead-letter queue must address because any message in the dead-letter queue was meant to be delivered elsewhere.</span></span> <span data-ttu-id="3fab5-197">若要从死信队列或病毒队列中读取消息，必须使用带有 `ServiceBehavior` 参数的 <xref:System.ServiceModel.AddressFilterMode.Any>。</span><span class="sxs-lookup"><span data-stu-id="3fab5-197">To read messages from a dead-letter queue, or from a poison queue, a `ServiceBehavior` with the <xref:System.ServiceModel.AddressFilterMode.Any> parameter must be used.</span></span> <span data-ttu-id="3fab5-198">有关示例，请参阅[死信队列](../../../../docs/framework/wcf/samples/dead-letter-queues.md)。</span><span class="sxs-lookup"><span data-stu-id="3fab5-198">For an example, see [Dead Letter Queues](../../../../docs/framework/wcf/samples/dead-letter-queues.md).</span></span>  
  
## <a name="msmqintegrationbinding-and-service-addressing"></a><span data-ttu-id="3fab5-199">MsmqIntegrationBinding 和服务寻址</span><span class="sxs-lookup"><span data-stu-id="3fab5-199">MsmqIntegrationBinding and Service Addressing</span></span>  
 <span data-ttu-id="3fab5-200">`MsmqIntegrationBinding` 用于与传统 MSMQ 应用程序进行通信。</span><span class="sxs-lookup"><span data-stu-id="3fab5-200">The `MsmqIntegrationBinding` is used for communication with traditional MSMQ applications.</span></span> <span data-ttu-id="3fab5-201">为了便于与现有 MSMQ 应用程序的互操作，WCF 支持唯一的格式名寻址。</span><span class="sxs-lookup"><span data-stu-id="3fab5-201">To ease interoperation with an existing MSMQ application, WCF supports only format name addressing.</span></span> <span data-ttu-id="3fab5-202">因此，使用此绑定发送的消息必须符合 URI 方案。</span><span class="sxs-lookup"><span data-stu-id="3fab5-202">Thus, messages sent using this binding must conform to the URI scheme:</span></span>  
  
 <span data-ttu-id="3fab5-203">msmq.formatname:\<*MSMQ-format-name*>></span><span class="sxs-lookup"><span data-stu-id="3fab5-203">msmq.formatname:\<*MSMQ-format-name*>></span></span>  
  
 <span data-ttu-id="3fab5-204">MSMQ 格式名的形式指定的中的 MSMQ[有关消息队列](https://go.microsoft.com/fwlink/?LinkId=94837)。</span><span class="sxs-lookup"><span data-stu-id="3fab5-204">The MSMQ-format-name is of the form specified by MSMQ in [About Message Queuing](https://go.microsoft.com/fwlink/?LinkId=94837).</span></span>  
  
 <span data-ttu-id="3fab5-205">请注意，当使用 `MsmqIntegrationBinding` 从队列接收消息时，只能使用直接格式名以及公共和专用格式名（需要 Active Directory 集成）。</span><span class="sxs-lookup"><span data-stu-id="3fab5-205">Note that you can only use direct format names, and public and private format names (requires Active Directory integration) when receiving messages from a queue using `MsmqIntegrationBinding`.</span></span> <span data-ttu-id="3fab5-206">但是，建议您使用直接格式名。</span><span class="sxs-lookup"><span data-stu-id="3fab5-206">However, it is advised that you use direct format names.</span></span> <span data-ttu-id="3fab5-207">例如，在 [!INCLUDE[wv](../../../../includes/wv-md.md)] 上，使用任何其他格式名都将导致错误，因为系统会尝试打开一个子队列，而该子队列只能使用直接格式名打开。</span><span class="sxs-lookup"><span data-stu-id="3fab5-207">For example, on [!INCLUDE[wv](../../../../includes/wv-md.md)], using any other format name causes an error because the system attempts to open a subqueue, which can only be opened with direct format names.</span></span>  
  
 <span data-ttu-id="3fab5-208">在使用 `MsmqIntegrationBinding` 对 SRMP 进行寻址时，不需要在直接格式名中添加 /msmq/ 来帮助 Internet 信息服务 (IIS) 进行调度。</span><span class="sxs-lookup"><span data-stu-id="3fab5-208">When addressing SRMP using `MsmqIntegrationBinding`, there is no requirement to add /msmq/ in the direct format name to help Internet Information Services (IIS) with dispatching.</span></span> <span data-ttu-id="3fab5-209">例如：Abc 使用 SRMP 协议，而不是直接对队列进行寻址时 =http://adatum.com/msmq/private$/ abc，则应使用 DIRECT =http://adatum.com/private$/ abc。</span><span class="sxs-lookup"><span data-stu-id="3fab5-209">For example: When addressing a queue abc using the SRMP protocol, instead of DIRECT=http://adatum.com/msmq/private$/abc, you should use DIRECT=http://adatum.com/private$/abc.</span></span>  
  
 <span data-ttu-id="3fab5-210">请注意，对于 `MsmqIntegrationBinding`，不能使用 net.msmq:// 寻址。</span><span class="sxs-lookup"><span data-stu-id="3fab5-210">Note that you cannot use net.msmq:// addressing with `MsmqIntegrationBinding`.</span></span> <span data-ttu-id="3fab5-211">因为`MsmqIntegrationBinding`支持自由的 MSMQ 格式名寻址，可以使用 WCF 服务使用此绑定在 MSMQ 中使用多播和通讯组列表功能。</span><span class="sxs-lookup"><span data-stu-id="3fab5-211">Because `MsmqIntegrationBinding` supports free-form MSMQ format name addressing, you can use a WCF service that uses this binding to use multicast and distribution list features in MSMQ.</span></span> <span data-ttu-id="3fab5-212">一个例外是在使用 `CustomDeadLetterQueue` 时指定 `MsmqIntegrationBinding`。</span><span class="sxs-lookup"><span data-stu-id="3fab5-212">One exception is specifying `CustomDeadLetterQueue` when using the `MsmqIntegrationBinding`.</span></span> <span data-ttu-id="3fab5-213">它必须采用 net.msmq:// 形式，这与使用 `NetMsmqBinding` 进行指定的方式相似。</span><span class="sxs-lookup"><span data-stu-id="3fab5-213">It must be of the form net.msmq://, similar to how it is specified using the `NetMsmqBinding`.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="3fab5-214">请参阅</span><span class="sxs-lookup"><span data-stu-id="3fab5-214">See also</span></span>
- [<span data-ttu-id="3fab5-215">承载排队应用程序的 Web</span><span class="sxs-lookup"><span data-stu-id="3fab5-215">Web Hosting a Queued Application</span></span>](../../../../docs/framework/wcf/feature-details/web-hosting-a-queued-application.md)
